{"version":3,"file":"35101.7e63dedc.iframe.bundle.js","mappings":";AAyGA","sources":["webpack://@posthog/frontend/./src/scenes/data-management/definition/definitionEditLogic.ts"],"sourcesContent":["import { connect, kea, key, path, props } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { beforeUnload, router } from 'kea-router'\nimport { subscriptions } from 'kea-subscriptions'\nimport api from 'lib/api'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'\nimport { capitalizeFirstLetter } from 'lib/utils'\nimport { definitionLogic, DefinitionLogicProps } from 'scenes/data-management/definition/definitionLogic'\nimport { eventDefinitionsTableLogic } from 'scenes/data-management/events/eventDefinitionsTableLogic'\nimport { propertyDefinitionsTableLogic } from 'scenes/data-management/properties/propertyDefinitionsTableLogic'\nimport { urls } from 'scenes/urls'\n\nimport { updatePropertyDefinitions } from '~/models/propertyDefinitionsModel'\nimport { tagsModel } from '~/models/tagsModel'\nimport { Definition, EventDefinition, PropertyDefinition } from '~/types'\n\nimport type { definitionEditLogicType } from './definitionEditLogicType'\n\nexport const definitionEditLogic = kea<definitionEditLogicType>([\n    path(['scenes', 'data-management', 'definition', 'definitionDetailLogic']),\n    props({} as DefinitionLogicProps),\n    key((props) => props.id || 'new'),\n    connect(({ id }: DefinitionLogicProps) => ({\n        values: [definitionLogic({ id }), ['definition', 'isEvent', 'singular']],\n        actions: [\n            definitionLogic({ id }),\n            ['setDefinition'],\n            propertyDefinitionsTableLogic,\n            ['setLocalPropertyDefinition'],\n            eventDefinitionsTableLogic,\n            ['setLocalEventDefinition'],\n            tagsModel,\n            ['loadTags'],\n        ],\n    })),\n    forms(({ actions }) => ({\n        editDefinition: {\n            defaults: {} as Definition,\n            errors: ({ name }) => ({\n                name: !name ? 'You need to set a name' : null,\n            }),\n            submit: (definition) => {\n                actions.saveDefinition(definition)\n            },\n        },\n    })),\n    loaders(({ values, actions }) => ({\n        editDefinition: [\n            {} as Definition,\n            {\n                saveDefinition: async (_, breakpoint) => {\n                    let definition = { ...values.editDefinition }\n\n                    if (values.isEvent) {\n                        // Event Definition\n                        const _event = definition as EventDefinition\n                        definition = await api.eventDefinitions.update({\n                            eventDefinitionId: _event.id,\n                            eventDefinitionData: {\n                                ..._event,\n                                owner: _event.owner?.id ?? null,\n                                verified: !!_event.verified,\n                            },\n                        })\n                    } else {\n                        // Event Property Definition\n                        const _eventProperty = definition as PropertyDefinition\n                        definition = await api.propertyDefinitions.update({\n                            propertyDefinitionId: _eventProperty.id,\n                            propertyDefinitionData: _eventProperty,\n                        })\n                        updatePropertyDefinitions({\n                            [`event/${definition.name}`]: definition as PropertyDefinition,\n                        })\n                    }\n                    breakpoint()\n\n                    lemonToast.success(`${capitalizeFirstLetter(values.singular)} saved`)\n                    // Update table values\n                    if (values.isEvent) {\n                        actions.setLocalEventDefinition(definition)\n                    } else {\n                        actions.setLocalPropertyDefinition(definition)\n                    }\n                    actions.setDefinition(definition)\n                    actions.loadTags() // reload tags in case new tags are being saved\n\n                    router.actions.push(\n                        values.isEvent ? urls.eventDefinition(definition.id) : urls.propertyDefinition(definition.id)\n                    )\n                    return definition\n                },\n            },\n        ],\n    })),\n\n    subscriptions(({ actions }) => ({\n        definition: (def) => {\n            actions.resetEditDefinition(def)\n        },\n    })),\n\n    beforeUnload(({ values, actions }) => ({\n        enabled: () => values.editDefinitionChanged,\n        message: `Leave?\\nChanges you made will be discarded.`,\n        onConfirm: () => {\n            actions.resetEditDefinition(values.definition)\n        },\n    })),\n])\n"],"names":[],"sourceRoot":""}