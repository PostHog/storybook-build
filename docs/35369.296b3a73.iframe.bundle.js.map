{"version":3,"file":"35369.296b3a73.iframe.bundle.js","mappings":";;;;;;;;AAkGA;;;;;;;;;;;;;;;;;AC1DA;;;;;;;;;;;;;;;;;;;;;;;ACiEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCA","sources":["webpack://@posthog/storybook/../../frontend/src/lib/components/VersionChecker/versionCheckerLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/components/replayActiveScreensTableLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/components/replayActiveHoursHeatMapLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/components/replayActiveUsersTableLogic.ts"],"sourcesContent":["import { actions, afterMount, kea, key, listeners, path, props, reducers, sharedListeners } from 'kea'\nimport { loaders } from 'kea-loaders'\n\nimport api from 'lib/api'\nimport { isNotNil } from 'lib/utils'\nimport {\n    SemanticVersion,\n    diffVersions,\n    highestVersion,\n    isEqualVersion,\n    parseVersion,\n    tryParseVersion,\n    versionToString,\n} from 'lib/utils/semver'\n\nimport { hogql } from '~/queries/utils'\n\nimport type { versionCheckerLogicType } from './versionCheckerLogicType'\n\n// If you would like to deprecate all posthog-js versions older than a specific version\n// (i.e. after fixing an important bug) please edit\n// https://github.com/PostHog/posthog-js/blob/main/deprecation.json\n\nconst CHECK_INTERVAL_MS = 1000 * 60 * 60 * 6 // 6 hour\n\nexport type SDKVersion = {\n    version: SemanticVersion\n    timestamp?: string\n}\n\nexport type SDKVersionWarning = {\n    latestUsedVersion: string\n    latestAvailableVersion: string\n    numVersionsBehind?: number\n    level: 'warning' | 'info' | 'error'\n}\n\nexport interface PosthogJSDeprecation {\n    deprecateBeforeVersion?: string\n    deprecateOlderThanDays?: number\n}\n\nexport interface AvailableVersions {\n    sdkVersions?: SemanticVersion[]\n    deprecation?: PosthogJSDeprecation\n}\n\nexport interface VersionCheckerLogicProps {\n    teamId: number | null\n}\n\nexport const versionCheckerLogic = kea<versionCheckerLogicType>([\n    props({ teamId: null } as VersionCheckerLogicProps),\n    key(({ teamId }) => teamId || 'no-team-id'),\n    path((key) => ['components', 'VersionChecker', 'versionCheckerLogic', key]),\n    actions({\n        setVersionWarning: (versionWarning: SDKVersionWarning | null) => ({ versionWarning }),\n        setSdkVersions: (sdkVersions: SDKVersion[]) => ({ sdkVersions }),\n    }),\n    loaders(({ values }) => ({\n        availableVersions: [\n            {} as AvailableVersions,\n            {\n                loadAvailableVersions: async (): Promise<AvailableVersions> => {\n                    // Make both requests simultaneously and don't return until both have finished, to avoid a flash\n                    // of partial results in the UI.\n                    const availableVersionsPromise: Promise<SemanticVersion[]> = fetch(\n                        'https://api.github.com/repos/posthog/posthog-js/tags'\n                    )\n                        .then((r) => r.json())\n                        .then((r) => r.map((x: any) => tryParseVersion(x.name)).filter(isNotNil))\n                    const deprecationPromise: Promise<PosthogJSDeprecation> = fetch(\n                        'https://raw.githubusercontent.com/PostHog/posthog-js/main/deprecation.json'\n                    ).then((r) => r.json())\n                    const settled = await Promise.allSettled([availableVersionsPromise, deprecationPromise])\n                    const availableVersions = settled[0].status === 'fulfilled' ? settled[0].value : []\n                    const deprecation = settled[1].status === 'fulfilled' ? settled[1].value : {}\n                    // if one or more of the requests failed, merge in the previous value if we have one\n                    return {\n                        ...values.availableVersions,\n                        sdkVersions: availableVersions,\n                        deprecation: deprecation,\n                    }\n                },\n            },\n        ],\n        usedVersions: [\n            null as SDKVersion[] | null,\n            {\n                loadUsedVersions: async () => {\n                    const query = hogql`\n                        SELECT properties.$lib_version AS lib_version, max(timestamp) AS latest_timestamp, count(lib_version) as count\n                        FROM events\n                        WHERE timestamp >= now() - INTERVAL 1 DAY \n                        AND timestamp <= now()\n                        AND properties.$lib = 'web'\n                        GROUP BY lib_version\n                        ORDER BY latest_timestamp DESC\n                        limit 10`\n\n                    const res = await api.queryHogQL(query, { refresh: 'force_blocking' })\n\n                    return (\n                        res.results\n                            ?.map((x) => {\n                                const version = tryParseVersion(x[0])\n                                if (!version) {\n                                    return null\n                                }\n                                return {\n                                    version,\n                                    timestamp: x[1],\n                                }\n                            })\n                            .filter(isNotNil) ?? null\n                    )\n                },\n            },\n        ],\n    })),\n\n    reducers({\n        lastCheckTimestamp: [\n            0,\n            { persist: true },\n            {\n                loadUsedVersionsSuccess: () => Date.now(),\n            },\n        ],\n        versionWarning: [\n            null as SDKVersionWarning | null,\n            // bumping cache key due to an incorrect tag being cached on 2024-02-12\n            { persist: true, prefix: '2024-02-12' },\n            {\n                setVersionWarning: (_, { versionWarning }) => versionWarning,\n            },\n        ],\n    }),\n\n    sharedListeners(({ values, actions }) => ({\n        checkForVersionWarning: () => {\n            if (!values.usedVersions?.length) {\n                return\n            }\n            const { deprecation, sdkVersions } = values.availableVersions\n\n            // We want the highest semantic version to be the latest used one, rather than\n            // the one with the latest timestamp, because secondary installations can spew old versions\n            const latestUsedVersion = highestVersion(values.usedVersions.map((v) => v.version))\n\n            // the latest version published on github\n            const latestAvailableVersion = sdkVersions?.[0]\n\n            // the version where, anything before this deprecated (i.e. this version is allowed, before it is not)\n            const deprecateBeforeVersion = deprecation?.deprecateBeforeVersion\n                ? parseVersion(deprecation.deprecateBeforeVersion)\n                : null\n\n            let warning: SDKVersionWarning | null = null\n\n            if (deprecateBeforeVersion) {\n                const diff = diffVersions(deprecateBeforeVersion, latestUsedVersion)\n                // if they are behind the deprecatedBeforeVersion by any amount, show an error\n                if (diff && diff.diff > 0) {\n                    warning = {\n                        latestUsedVersion: versionToString(latestUsedVersion),\n                        latestAvailableVersion: versionToString(latestAvailableVersion || deprecateBeforeVersion),\n                        level: 'error',\n                    }\n                }\n            }\n\n            if (!warning && sdkVersions && latestAvailableVersion) {\n                const diff = diffVersions(latestAvailableVersion, latestUsedVersion)\n\n                if (diff && diff.diff > 0) {\n                    // there's a difference between the latest used version and the latest available version\n\n                    let numVersionsBehind = sdkVersions.findIndex((v) => isEqualVersion(v, latestUsedVersion))\n                    if (numVersionsBehind === -1) {\n                        // if we couldn't find the versions, use the length of the list as a fallback\n                        numVersionsBehind = sdkVersions.length - 1\n                    }\n                    if (numVersionsBehind < diff.diff) {\n                        // we might have deleted versions, but if the actual diff is X then we must be at least X versions behind\n                        numVersionsBehind = diff.diff\n                    }\n\n                    let level: 'warning' | 'info' | 'error' | undefined\n                    if (diff.kind === 'major') {\n                        level = 'info' // it is desirable to be on the latest major version, but not critical\n                    } else if (diff.kind === 'minor') {\n                        level = numVersionsBehind >= 40 ? 'warning' : undefined\n                    }\n\n                    if (level === undefined && numVersionsBehind >= 50) {\n                        level = 'error'\n                    }\n\n                    // we check if there is a \"latest user version string\" to avoid returning odd data in unexpected cases\n                    if (level && !!versionToString(latestUsedVersion).trim().length) {\n                        warning = {\n                            latestUsedVersion: versionToString(latestUsedVersion),\n                            latestAvailableVersion: versionToString(latestAvailableVersion),\n                            level,\n                            numVersionsBehind,\n                        }\n                    }\n                }\n            }\n\n            actions.setVersionWarning(warning)\n        },\n    })),\n\n    listeners(({ sharedListeners }) => ({\n        loadAvailableVersionsSuccess: sharedListeners.checkForVersionWarning,\n        loadUsedVersionsSuccess: sharedListeners.checkForVersionWarning,\n    })),\n\n    afterMount(({ actions, values }) => {\n        if (values.lastCheckTimestamp < Date.now() - CHECK_INTERVAL_MS) {\n            actions.loadAvailableVersions()\n            actions.loadUsedVersions()\n        }\n    }),\n])\n","import { defaults, kea, key, path, props } from 'kea'\nimport { lazyLoaders } from 'kea-loaders'\n\nimport api from 'lib/api'\n\nimport { hogql } from '~/queries/utils'\n\nimport type { replayActiveScreensTableLogicType } from './replayActiveScreensTableLogicType'\n\nexport interface ReplayActiveScreensTableLogicProps {\n    scene?: 'templates' | 'filters' | 'replay-home'\n}\n\nexport const replayActiveScreensTableLogic = kea<replayActiveScreensTableLogicType>([\n    path(['scenes', 'session-recordings', 'components', 'replayActiveScreensTableLogic']),\n    props({} as ReplayActiveScreensTableLogicProps),\n    key((props) => props.scene || 'default'),\n    defaults({\n        countedScreens: [] as { screen: string; count: number }[],\n    }),\n    lazyLoaders(() => ({\n        countedScreens: {\n            loadCountedScreens: async (_, breakpoint): Promise<{ screen: string; count: number }[]> => {\n                const q = hogql`\n                    SELECT\n                cutQueryString(cutFragment(url)) as screen,\n                count(distinct session_id) as count\n            FROM (\n                SELECT\n                    session_id,\n                    arrayJoin(any(all_urls)) as url\n                FROM raw_session_replay_events\n                WHERE min_first_timestamp >= now() - interval 7 day\n                  AND min_first_timestamp <= now()\n                GROUP BY session_id\n                HAVING date_diff('second', min(min_first_timestamp), max(max_last_timestamp)) > 5\n            )\n            GROUP BY screen\n            ORDER BY count DESC\n            LIMIT 10\n                `\n\n                const qResponse = await api.queryHogQL(q)\n\n                breakpoint()\n\n                return (qResponse.results || []).map((row) => {\n                    return {\n                        screen: row[0] as string,\n                        count: row[1] as number,\n                    }\n                }) as { screen: string; count: number }[]\n            },\n        },\n    })),\n])\n","import { kea, key, listeners, path, props, selectors } from 'kea'\nimport { lazyLoaders } from 'kea-loaders'\nimport { router } from 'kea-router'\nimport posthog from 'posthog-js'\n\nimport api from 'lib/api'\nimport { Dayjs, now } from 'lib/dayjs'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { urls } from 'scenes/urls'\nimport { CalendarHeatMapProps } from 'scenes/web-analytics/CalendarHeatMap/CalendarHeatMap'\n\nimport { hogql } from '~/queries/utils'\nimport { ReplayTabs } from '~/types'\n\nimport type { replayActiveHoursHeatMapLogicType } from './replayActiveHoursHeatMapLogicType'\n\nexport interface ReplayActiveHoursHeatMapLogicProps {\n    // we can show this component in different contexts, and key it accordingly\n    scene?: 'templates' | 'filters' | 'replay-home'\n}\n\nconst rowLabels = ['00:00 - 04:00', '04:00 - 08:00', '08:00 - 12:00', '12:00 - 16:00', '16:00 - 20:00', '20:00 - 00:00']\n\nconst columnLabels = (now: Dayjs): string[] => [\n    now.subtract(6, 'day').format('ddd D'),\n    now.subtract(5, 'day').format('ddd D'),\n    now.subtract(4, 'day').format('ddd D'),\n    now.subtract(3, 'day').format('ddd D'),\n    now.subtract(2, 'day').format('ddd D'),\n    now.subtract(1, 'day').format('ddd D'),\n    'Today',\n]\n\n// does not need to be on the logic yet, since it's stateless for now\nexport const getOnClickTooltip = (colIndex: number, rowIndex: number | undefined): string => {\n    const day = columnLabels(now())[colIndex]\n    const timeRange = rowIndex === undefined ? undefined : rowLabels[rowIndex]\n    return `View recordings for ${day}${timeRange ? ` ${timeRange}` : ''}`\n}\n\n// does not need to be on the logic yet, since it's stateless for now\nexport const onCellClick = (colIndex: number, rowIndex: number | undefined, timezone: string): void => {\n    const daysToSubtract = 6 - colIndex\n    let startDate = now().subtract(daysToSubtract, 'day').startOf('day').utc(true)\n    let endDate = startDate.clone()\n\n    if (rowIndex !== undefined) {\n        const startHour = rowIndex * 4\n        const endHour = startHour + 4\n        startDate = startDate.hour(startHour)\n        endDate = endDate.hour(endHour)\n    } else {\n        endDate = endDate.add(1, 'day')\n    }\n\n    posthog.capture('clicked_replay_active_hours_heatmap_cell', {\n        isColumnHeader: rowIndex == undefined,\n        isIndividualCell: rowIndex != undefined,\n        timezone,\n    })\n\n    const setTimezoneWithoutChangingOtherValues = true\n    router.actions.push(\n        urls.replay(ReplayTabs.Home, {\n            // here the browser might be in a different timezone to the project\n            // but the dateTime has already been corrected so we need to set the timezone\n            // but set `true` as the second parameter\n            // this means we set the project timezone on the dayjs object\n            // without changing the values\n            date_from: startDate.tz(timezone, setTimezoneWithoutChangingOtherValues).toISOString(),\n            date_to: endDate.tz(timezone, setTimezoneWithoutChangingOtherValues).toISOString(),\n        })\n    )\n}\n\nexport const replayActiveHoursHeatMapLogic = kea<replayActiveHoursHeatMapLogicType>([\n    path(['scenes', 'session-recordings', 'components', 'replayActiveHoursHeatMapLogic']),\n    props({} as ReplayActiveHoursHeatMapLogicProps),\n    key((props) => props.scene || 'default'),\n    lazyLoaders(() => ({\n        recordingsPerHour: {\n            loadRecordingsPerHour: async (_, breakpoint): Promise<number[][]> => {\n                const q = hogql`\n                    SELECT hour_block,\n                           countIf(_toDate(mints) = today() - 6) AS \"Day -6\",\n                           countIf(_toDate(mints) = today() - 5) AS \"Day -5\",\n                           countIf(_toDate(mints) = today() - 4) AS \"Day -4\",\n                           countIf(_toDate(mints) = today() - 3) AS \"Day -3\",\n                           countIf(_toDate(mints) = today() - 2) AS \"Day -2\",\n                           countIf(_toDate(mints) = today() - 1) AS \"Day -1\",\n                           countIf(_toDate(mints) = today())     AS \"Day 0\"\n                    FROM (SELECT intDiv(toHour(mints), 4) * 4 AS real_hour_block,\n                                 mints\n                          FROM (SELECT min(min_first_timestamp) AS mints\n                                FROM raw_session_replay_events\n                                WHERE min_first_timestamp >= now() - INTERVAL 7 day\n                                  AND min_first_timestamp <= now()\n                                GROUP BY session_id\n                                having dateDiff('SECOND'\n                                     , min (min_first_timestamp)\n                                     , max (max_last_timestamp))\n                                     > 5)) AS data\n                             RIGHT JOIN (SELECT arrayJoin([0, 4, 8, 12, 16, 20]) AS hour_block) AS hours\n                                        ON data.real_hour_block = hours.hour_block\n                    GROUP BY hour_block\n                    ORDER BY hour_block`\n\n                const qResponse = await api.queryHogQL(q)\n\n                // this gives an array of arrays\n                // we're loading hours 0-4, 4-8, 8-12, 12-16, 16-20, 20-24\n                // so we get an array with 6 elements\n                // each of those has 8 values\n                // [0] is the hour block\n                // and then each of the other 7 values is the count for that day\n\n                breakpoint()\n\n                return qResponse.results as number[][]\n            },\n        },\n    })),\n    selectors(() => ({\n        calendarHeatmapProps: [\n            (s) => [s.recordingsPerHour],\n            (\n                recordingsPerHour: number[][]\n            ): Pick<CalendarHeatMapProps, 'rowLabels' | 'columnLabels' | 'processedData'> => {\n                if (!recordingsPerHour || recordingsPerHour.length === 0 || recordingsPerHour[0].length === 0) {\n                    return {\n                        rowLabels: [],\n                        columnLabels: [],\n                        processedData: {\n                            matrix: [],\n                            columnsAggregations: [],\n                            rowsAggregations: [],\n                            overallValue: 0,\n                            maxOverall: 0,\n                            minOverall: 0,\n                            maxRowAggregation: 0,\n                            minRowAggregation: 0,\n                            maxColumnAggregation: 0,\n                            minColumnAggregation: 0,\n                        },\n                    }\n                }\n\n                const dataWithoutHourBlock = recordingsPerHour.map((row) => row.slice(1))\n\n                const columnsAggregations = dataWithoutHourBlock.reduce((acc, row) => {\n                    row.forEach((value: number, index: number) => {\n                        acc[index] = (acc[index] || 0) + value\n                    })\n                    return acc\n                }, [])\n                const rowsAggregations = dataWithoutHourBlock.reduce((acc, row) => {\n                    // take each row and ignoring row[0]\n                    // gather a sum for each index in the row\n                    // so we end up with an array of numbers with length 6\n                    acc[row[0]] = (acc[row[0]] || 0) + row.reduce((a: number, b: number) => a + b, 0)\n                    return acc\n                }, [])\n                const processedData = {\n                    matrix: dataWithoutHourBlock,\n                    columnsAggregations: columnsAggregations,\n                    rowsAggregations: rowsAggregations,\n                    overallValue: columnsAggregations.reduce((a: number, b: number) => a + b, 0),\n                    maxOverall: dataWithoutHourBlock.reduce((acc, row) => {\n                        return Math.max(acc, ...row)\n                    }, 0),\n                    minOverall: dataWithoutHourBlock.reduce((acc, row) => {\n                        return Math.min(acc, ...row)\n                    }, 0),\n                    maxColumnAggregation: Math.max(...columnsAggregations),\n                    minColumnAggregation: Math.min(...columnsAggregations),\n                    maxRowAggregation: Math.max(...rowsAggregations),\n                    minRowAggregation: Math.min(...rowsAggregations),\n                }\n\n                return {\n                    rowLabels: rowLabels,\n                    columnLabels: columnLabels(now()),\n                    processedData: processedData,\n                }\n            },\n        ],\n        isClickable: [\n            (s) => [s.calendarHeatmapProps],\n            (calendarHeatmapProps) => (colIndex: number, rowIndex?: number) => {\n                const valueSource =\n                    rowIndex == undefined\n                        ? calendarHeatmapProps?.processedData.columnsAggregations\n                        : calendarHeatmapProps?.processedData.matrix[rowIndex]\n                return (valueSource[colIndex] ?? 0) > 0\n            },\n        ],\n    })),\n    listeners(() => ({\n        loadRecordingsPerHourFailed: async () => {\n            lemonToast.error('Failed to load recordings activity for heatmap')\n        },\n    })),\n])\n","import { defaults, kea, key, path, props } from 'kea'\nimport { lazyLoaders } from 'kea-loaders'\n\nimport api from 'lib/api'\n\nimport { hogql } from '~/queries/utils'\nimport { PersonType } from '~/types'\n\nimport type { replayActiveUsersTableLogicType } from './replayActiveUsersTableLogicType'\n\nexport interface ReplayActiveUsersTableLogicProps {\n    scene?: 'templates' | 'filters' | 'replay-home'\n}\n\nexport const replayActiveUsersTableLogic = kea<replayActiveUsersTableLogicType>([\n    path(['scenes', 'session-recordings', 'components', 'replayActiveUsersTableLogic']),\n    props({} as ReplayActiveUsersTableLogicProps),\n    key((props) => props.scene || 'default'),\n    defaults({\n        countedUsers: [] as { person: PersonType; count: number }[],\n    }),\n    lazyLoaders(() => ({\n        countedUsers: {\n            loadCountedUsers: async (_, breakpoint): Promise<{ person: PersonType; count: number }[]> => {\n                const q = hogql`\n                    WITH\n            -- get the session ids for any recorded sessions in the last 7 days\n            recorded_sessions AS (\n                SELECT session_id\n                FROM raw_session_replay_events\n                WHERE min_first_timestamp >= now() - interval 7 day\n                  AND min_first_timestamp <= now()\n                GROUP BY session_id\n                HAVING date_diff('second', min(min_first_timestamp), max(max_last_timestamp)) > 5\n            ),\n            -- way faster to get person props from the events table\n            -- so get the mapping of person_id/person_properties to session_id\n            -- from the events table that has the same session_id as the recorded sessions\n            session_persons AS (\n                SELECT\n                    $session_id as session_id,\n                    any(person_id) as person_id,\n                    any(person.properties) as pp\n                FROM events\n                WHERE timestamp >= now() - interval 7 day\n                  AND timestamp <= now()\n                  AND $session_id IN (SELECT session_id FROM recorded_sessions)\n                  -- including events when querying the events table is always _much_ faster,\n                  -- but we don't know what events an account will have\n                  -- so we just include the most common ones\n                  -- this won't work for everyone but then that's try with the poorly performing query\n                  -- that this replaces, so it's at least no worse ðŸ™ˆ\n                  AND event IN ('$pageview', '$screen', '$autocapture', '$feature_flag_called', '$pageleave', '$identify', '$web_vitals', '$set', 'Application Opened', 'Application Backgrounded')\n                  -- exclude anonymous users since we don't care if user \"anonymous\" watched a gajillion recordings\n                  AND (properties.$process_person_profile = true or properties.$is_identified = true)\n                GROUP BY $session_id\n            )\n            -- now we can count the distinct sessions per person\n            SELECT\n                sp.person_id,\n                sp.pp,\n                count(distinct sp.session_id) as total_count\n            FROM session_persons sp \n            WHERE sp.person_id IS NOT NULL\n            GROUP BY sp.person_id, sp.pp\n            ORDER BY total_count DESC\n            LIMIT 10\n                `\n\n                const qResponse = await api.queryHogQL(q)\n\n                breakpoint()\n\n                return (qResponse.results || []).map((row) => {\n                    return {\n                        person: { id: row[0] as string, properties: JSON.parse(row[1]) as Record<string, any> },\n                        count: row[2] as number,\n                    }\n                }) as { person: PersonType; count: number }[]\n            },\n        },\n    })),\n])\n"],"names":[],"sourceRoot":""}