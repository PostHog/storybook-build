{"version":3,"file":"91081.37e5d3eb.iframe.bundle.js","mappings":";AAgFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@posthog/storybook/../../products/llm_analytics/frontend/evaluations/evaluationMetricsLogic.ts"],"sourcesContent":["import { actions, afterMount, connect, kea, listeners, path, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\n\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\n\nimport { HogQLQuery, NodeKind, TrendsQuery } from '~/queries/schema/schema-general'\nimport { ChartDisplayType, HogQLMathType } from '~/types'\n\nimport { llmAnalyticsLogic } from '../llmAnalyticsLogic'\nimport { PASS_RATE_SUCCESS_THRESHOLD } from './components/EvaluationMetrics'\nimport type { evaluationMetricsLogicType } from './evaluationMetricsLogicType'\nimport { llmEvaluationsLogic } from './llmEvaluationsLogic'\nimport { EvaluationConfig } from './types'\n\nconst MIN_RUNS_FOR_FAILING_STATUS = 3\n\nexport interface EvaluationStats {\n    evaluation_id: string\n    runs_count: number\n    pass_count: number\n    pass_rate: number\n}\n\nexport interface SummaryMetrics {\n    total_runs: number\n    overall_pass_rate: number\n    failing_evaluations_count: number\n}\n\ntype RawStatsRow = [evaluation_id: string, runs_count: number, pass_count: number]\n\nfunction getIntervalFromDateRange(dateFrom: string | null): 'hour' | 'day' {\n    if (!dateFrom) {\n        return 'day'\n    }\n\n    // Handle \"today\" formats\n    if (dateFrom === 'dStart' || dateFrom === '-0d' || dateFrom === '-0dStart') {\n        return 'hour'\n    }\n\n    // Handle relative date strings like \"-24h\", \"-1d\", \"-7d\"\n    const match = dateFrom.match(/^-(\\d+)([hdwmy])/i)\n    if (match) {\n        const value = parseInt(match[1])\n        const unit = match[2].toLowerCase()\n        const hoursMap: Record<string, number> = { h: 1, d: 24, w: 168, m: 720, y: 8760 }\n        const hours = value * (hoursMap[unit] || 24)\n        return hours <= 24 ? 'hour' : 'day'\n    }\n\n    // Handle absolute dates\n    const duration = dayjs.duration(dayjs().diff(dayjs(dateFrom)))\n    return duration.asDays() <= 1 ? 'hour' : 'day'\n}\n\nexport const evaluationMetricsLogic = kea<evaluationMetricsLogicType>([\n    path(['products', 'llm_analytics', 'frontend', 'evaluations', 'evaluationMetricsLogic']),\n\n    connect({\n        values: [llmEvaluationsLogic, ['evaluations'], llmAnalyticsLogic, ['dateFilter']],\n        actions: [llmAnalyticsLogic, ['setDates']],\n    }),\n\n    actions({\n        refreshMetrics: true,\n    }),\n\n    loaders(({ values }) => ({\n        stats: [\n            [] as EvaluationStats[],\n            {\n                loadStats: async () => {\n                    const dateFrom = values.dateFilter.dateFrom || '-1d'\n                    const dateTo = values.dateFilter.dateTo || null\n\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: `\n                            SELECT\n                                properties.$ai_evaluation_id as evaluation_id,\n                                count() as runs_count,\n                                countIf(properties.$ai_evaluation_result = true) as pass_count\n                            FROM events\n                            WHERE event = '$ai_evaluation' AND {filters}\n                            GROUP BY evaluation_id\n                        `,\n                        filters: {\n                            dateRange: {\n                                date_from: dateFrom,\n                                date_to: dateTo,\n                            },\n                        },\n                    }\n\n                    try {\n                        const response = await api.query(query)\n\n                        return (response.results || []).map((row: RawStatsRow) => {\n                            const runs_count = row[1]\n                            const pass_count = row[2]\n                            const pass_rate = runs_count > 0 ? (pass_count / runs_count) * 100 : 0\n\n                            return {\n                                evaluation_id: row[0],\n                                runs_count,\n                                pass_count,\n                                pass_rate: Math.round(pass_rate * 10) / 10,\n                            }\n                        })\n                    } catch (error) {\n                        console.error('Failed to load stats:', error)\n                        return []\n                    }\n                },\n            },\n        ],\n    })),\n\n    selectors({\n        summaryMetrics: [\n            (s) => [s.stats],\n            (stats: EvaluationStats[]): SummaryMetrics => {\n                const total_runs = stats.reduce((sum: number, stat) => sum + stat.runs_count, 0)\n                const total_passes = stats.reduce((sum: number, stat) => sum + stat.pass_count, 0)\n                const overall_pass_rate = total_runs > 0 ? (total_passes / total_runs) * 100 : 0\n\n                const failing_count = stats.filter((stat) => {\n                    return (\n                        stat.runs_count >= MIN_RUNS_FOR_FAILING_STATUS && stat.pass_rate < PASS_RATE_SUCCESS_THRESHOLD\n                    )\n                }).length\n\n                return {\n                    total_runs,\n                    overall_pass_rate: Math.round(overall_pass_rate * 10) / 10,\n                    failing_evaluations_count: failing_count,\n                }\n            },\n        ],\n\n        evaluationsWithMetrics: [\n            (s) => [s.evaluations, s.stats],\n            (\n                evaluations: EvaluationConfig[],\n                stats: EvaluationStats[]\n            ): Array<EvaluationConfig & { stats?: EvaluationStats }> => {\n                const statsMap = new Map(stats.map((stat) => [stat.evaluation_id, stat]))\n\n                return evaluations.map((evaluation) => ({\n                    ...evaluation,\n                    stats: statsMap.get(evaluation.id),\n                }))\n            },\n        ],\n\n        chartQuery: [\n            (s) => [s.evaluations, s.dateFilter],\n            (\n                evaluations: EvaluationConfig[],\n                dateFilter: { dateFrom: string | null; dateTo: string | null }\n            ): TrendsQuery | null => {\n                const enabledEvaluations = evaluations.filter((e) => e.enabled && !e.deleted)\n\n                if (enabledEvaluations.length === 0) {\n                    return null\n                }\n\n                const dateFrom = dateFilter.dateFrom || '-7d'\n                const dateTo = dateFilter.dateTo || null\n                const interval = getIntervalFromDateRange(dateFrom)\n\n                return {\n                    kind: NodeKind.TrendsQuery,\n                    series: enabledEvaluations.slice(0, 10).map((evaluation) => ({\n                        kind: NodeKind.EventsNode,\n                        event: '$ai_evaluation',\n                        custom_name: evaluation.name,\n                        math: HogQLMathType.HogQL,\n                        math_hogql: `countIf(properties.$ai_evaluation_id = '${evaluation.id}' AND properties.$ai_evaluation_result = true) / countIf(properties.$ai_evaluation_id = '${evaluation.id}') * 100`,\n                    })),\n                    trendsFilter: {\n                        display: ChartDisplayType.ActionsLineGraph,\n                    },\n                    dateRange: {\n                        date_from: dateFrom,\n                        date_to: dateTo,\n                    },\n                    interval,\n                }\n            },\n        ],\n    }),\n\n    listeners(({ actions }) => ({\n        refreshMetrics: () => {\n            actions.loadStats()\n        },\n        setDates: () => {\n            actions.loadStats()\n        },\n    })),\n\n    afterMount(({ actions }) => {\n        actions.loadStats()\n    }),\n])\n"],"names":[],"sourceRoot":""}