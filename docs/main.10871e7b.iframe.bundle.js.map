{"version":3,"file":"main.10871e7b.iframe.bundle.js","mappings":";;;;;;;AA0JA;;AC/IA;AACA;;AC8CA;;AC8LA;AAAA;AAAA;AAAA;;;;;;;ACpMA;;AC7BA;;;;;;;;;;;AC+RA;;;;;AAgBA;AClBA;ACxOA;AC8JA;AACA;AC1IA;AASA;;;AAWA;;;;;ACpEA;;;;;AAmBA;;AAxCA;;;;;AAKA;;;;;AAkDA;;;AAoCA;;;;;;AAMA;;AA7BA;;;;AAIA;;;;;AAKA;;AAiCA;;;;;AAKA;AC3HA;;;AAoBA;;;AAIA;AAKA;;;AAGA;;AAEA;AAGA;;AAEA;AACA;;AAWA;AACA;AACA;;;;;AA+BA;;;AAIA;AAKA;;;AAGA;AACA;AAGA;AACA;AACA;;AAWA;AACA;AACA;;;;AAyBA;;;AAIA;;AAMA;;AAEA;;AAIA;;AAGA;AACA;AACA;;AAUA;AACA;AACA;;;AAwBA;;;AAIA;AAKA;;AAEA;AACA;AAGA;AACA;AACA;;AAUA;AACA;AACA;;;AA6BA;;;AAIA;AAKA;;AAEA;AACA;AAGA;AACA;AACA;;AAUA;AACA;AACA;;;AA8BA;;;AAyBA;;AAuBA;;;;AAyBA;;;;;;;AAOA;;;;AAIA;AACA;AAkBA;;;AAGA;;AAEA;;;AAGA;AAUA;;;AASA;AACA;;AAEA;;;AA6BA;;AAMA;;AAWA;;AAEA;;;;;;AAMA;;AAEA;;;;;;;;;;;;;;;;;AA0BA;AC9dA;;;;;;;;;;;ACyLA;AC/KA;;;;;;;;;;;;;;;ACjEA;;;;;;;;;;;;;;;;;;;AAoBA;;;ACOA;;;;;AAKA;AACA;AACA;;;ACQA;;;;;ACgIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAmCA;;;;AAIA;AACA;AACA;;AAEA;;AAkCA;;;;AAIA;AACA;AACA;;AAEA;;;AAmCA;;;AAGA;AACA;AACA;;;AAGA;;;;AAgDA;AACA;AACA;AACA;;AAEA","sources":["webpack://posthog/./frontend/src/lib/components/AuthorizedUrlList/authorizedUrlListLogic.ts","webpack://posthog/./frontend/src/lib/components/JSSnippet.tsx","webpack://posthog/./frontend/src/lib/components/Support/SupportForm.tsx","webpack://posthog/./frontend/src/lib/components/Support/supportLogic.ts","webpack://posthog/./frontend/src/lib/components/VersionChecker/versionCheckerLogic.ts","webpack://posthog/./frontend/src/lib/lemon-ui/LemonTextArea/LemonTextAreaMarkdown.tsx","webpack://posthog/./frontend/src/queries/examples.ts","webpack://posthog/./frontend/src/scenes/batch_exports/batchExportEditLogic.ts","webpack://posthog/./frontend/src/scenes/billing/BillingProduct.tsx","webpack://posthog/./frontend/src/scenes/billing/billingLogic.ts","webpack://posthog/./frontend/src/scenes/early-access-features/InstructionsModal.tsx","webpack://posthog/./frontend/src/scenes/experiments/ExperimentCodeSnippets.tsx","webpack://posthog/./frontend/src/scenes/feature-flags/FeatureFlagSnippets.tsx","webpack://posthog/./frontend/src/scenes/notebooks/Nodes/NotebookNodeReplayTimestamp.tsx","webpack://posthog/./frontend/src/scenes/notebooks/Notebook/SlashCommands.tsx","webpack://posthog/./frontend/src/scenes/paths/renderPaths.ts","webpack://posthog/./frontend/src/scenes/plugins/source/createDefaultPluginSource.ts","webpack://posthog/./frontend/src/scenes/session-recordings/playlist/sessionRecordingsListPropertiesLogic.ts","webpack://posthog/./frontend/src/scenes/settings/organization/VerifiedDomains/ConfigureSAMLModal.tsx","webpack://posthog/./frontend/src/scenes/surveys/surveyLogic.tsx"],"sourcesContent":["import Fuse from 'fuse.js'\nimport {\n    actions,\n    afterMount,\n    connect,\n    kea,\n    key,\n    listeners,\n    path,\n    props,\n    reducers,\n    selectors,\n    sharedListeners,\n} from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { encodeParams, urlToAction } from 'kea-router'\nimport { subscriptions } from 'kea-subscriptions'\nimport api from 'lib/api'\nimport { isDomain, isURL } from 'lib/utils'\nimport { apiHostOrigin } from 'lib/utils/apiHost'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\nimport { ToolbarParams } from '~/types'\n\nimport type { authorizedUrlListLogicType } from './authorizedUrlListLogicType'\n\nexport interface ProposeNewUrlFormType {\n    url: string\n}\n\nexport enum AuthorizedUrlListType {\n    TOOLBAR_URLS = 'TOOLBAR_URLS',\n    RECORDING_DOMAINS = 'RECORDING_DOMAINS',\n}\n\nexport const validateProposedUrl = (\n    proposedUrl: string,\n    currentUrls: string[],\n    onlyAllowDomains: boolean = false\n): string | undefined => {\n    if (!onlyAllowDomains && !isURL(proposedUrl)) {\n        return 'Please enter a valid URL'\n    }\n\n    if (onlyAllowDomains && !isDomain(proposedUrl)) {\n        return \"Please enter a valid domain (URLs with a path aren't allowed)\"\n    }\n\n    if (proposedUrl.indexOf('*') > -1 && !proposedUrl.match(/^(.*)\\*[^*]*\\.[^*]+\\.[^*]+$/)) {\n        return 'Wildcards can only be used for subdomains'\n    }\n\n    if (currentUrls.indexOf(proposedUrl) > -1) {\n        return `This ${onlyAllowDomains ? 'domains' : 'URL'} already is registered`\n    }\n\n    return\n}\n\n/** defaultIntent: whether to launch with empty intent (i.e. toolbar mode is default) */\nexport function appEditorUrl(appUrl: string, actionId?: number | null, defaultIntent?: boolean): string {\n    // See https://github.com/PostHog/posthog-js/blob/f7119c/src/extensions/toolbar.ts#L52 for where these params\n    // are passed. `appUrl` is an extra `redirect_to_site` param.\n    const params: ToolbarParams & { appUrl: string } = {\n        userIntent: defaultIntent ? undefined : actionId ? 'edit-action' : 'add-action',\n        // Make sure to pass the app url, otherwise the api_host will be used by\n        // the toolbar, which isn't correct when used behind a reverse proxy as\n        // we require e.g. SSO login to the app, which will not work when placed\n        // behind a proxy unless we register each domain with the OAuth2 client.\n        apiURL: apiHostOrigin(),\n        appUrl,\n        ...(actionId ? { actionId } : {}),\n    }\n    return '/api/user/redirect_to_site/' + encodeParams(params, '?')\n}\n\nexport const filterNotAuthorizedUrls = (urls: string[], authorizedUrls: string[]): string[] => {\n    const suggestedDomains: string[] = []\n\n    urls.forEach((url) => {\n        try {\n            const parsedUrl = new URL(url)\n            const urlWithoutPath = parsedUrl.protocol + '//' + parsedUrl.host\n            // Have we already added this domain?\n            if (suggestedDomains.indexOf(urlWithoutPath) > -1) {\n                return\n            }\n            // Is this domain already in the list of urls?\n            const exactMatch = authorizedUrls.filter((url) => url.indexOf(urlWithoutPath) > -1).length > 0\n            const wildcardMatch = !!authorizedUrls.find((url) => {\n                // Matches something like `https://*.example.com` against the urlWithoutPath\n                const regex = new RegExp(url.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'))\n                return urlWithoutPath.match(regex)\n            })\n\n            if (!exactMatch && !wildcardMatch) {\n                suggestedDomains.push(urlWithoutPath)\n            }\n        } catch (error) {\n            return\n        }\n    })\n\n    return suggestedDomains\n}\n\nexport const NEW_URL = 'https://'\n\nexport interface KeyedAppUrl {\n    url: string\n    type: 'authorized' | 'suggestion'\n    originalIndex: number\n}\n\nexport interface AuthorizedUrlListLogicProps {\n    actionId: number | null\n    type: AuthorizedUrlListType\n}\nexport const authorizedUrlListLogic = kea<authorizedUrlListLogicType>([\n    path((key) => ['lib', 'components', 'AuthorizedUrlList', 'authorizedUrlListLogic', key]),\n    key((props) => `${props.type}-${props.actionId}`),\n    props({} as AuthorizedUrlListLogicProps),\n    connect({\n        values: [teamLogic, ['currentTeam', 'currentTeamId']],\n        actions: [teamLogic, ['updateCurrentTeam']],\n    }),\n    actions(() => ({\n        setAuthorizedUrls: (authorizedUrls: string[]) => ({ authorizedUrls }),\n        addUrl: (url: string, launch?: boolean) => ({ url, launch }),\n        newUrl: true,\n        removeUrl: (index: number) => ({ index }),\n        updateUrl: (index: number, url: string) => ({ index, url }),\n        launchAtUrl: (url: string) => ({ url }),\n        setSearchTerm: (term: string) => ({ term }),\n        setEditUrlIndex: (originalIndex: number | null) => ({ originalIndex }),\n        cancelProposingUrl: true,\n    })),\n    loaders(({ values }) => ({\n        suggestions: {\n            __default: [] as string[],\n            loadSuggestions: async () => {\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: hogql`select properties.$current_url, count()\n                        from events\n                           where event = '$pageview'\n                           and timestamp >= now() - interval 3 day \n                            and timestamp <= now()\n                         group by properties.$current_url\n                         order by count() desc\n                        limit 25`,\n                }\n\n                const response = await api.query(query)\n                const result = response.results as [string, number][]\n\n                if (result && result.length === 0) {\n                    return []\n                }\n\n                const suggestedDomains = filterNotAuthorizedUrls(\n                    result.map(([url]) => url),\n                    values.authorizedUrls\n                )\n\n                return suggestedDomains.slice(0, 20)\n            },\n        },\n    })),\n    subscriptions(({ props, actions }) => ({\n        currentTeam: (currentTeam) => {\n            actions.setAuthorizedUrls(\n                (props.type === AuthorizedUrlListType.RECORDING_DOMAINS\n                    ? currentTeam.recording_domains\n                    : currentTeam.app_urls) || []\n            )\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadSuggestions()\n    }),\n    forms(({ values, actions }) => ({\n        proposedUrl: {\n            defaults: { url: '' } as ProposeNewUrlFormType,\n            errors: ({ url }) => ({\n                url: validateProposedUrl(url, values.authorizedUrls, values.onlyAllowDomains),\n            }),\n            submit: async ({ url }) => {\n                if (values.editUrlIndex !== null && values.editUrlIndex >= 0) {\n                    actions.updateUrl(values.editUrlIndex, url)\n                } else {\n                    actions.addUrl(url)\n                }\n            },\n        },\n    })),\n    reducers(() => ({\n        showProposedURLForm: [\n            false as boolean,\n            {\n                newUrl: () => true,\n                submitProposedUrlSuccess: () => false,\n                cancelProposingUrl: () => false,\n            },\n        ],\n        authorizedUrls: [\n            [] as string[],\n            {\n                setAuthorizedUrls: (_, { authorizedUrls }) => authorizedUrls,\n                addUrl: (state, { url }) => state.concat([url]),\n                updateUrl: (state, { index, url }) => Object.assign([...state], { [index]: url }),\n                removeUrl: (state, { index }) => {\n                    const newUrls = [...state]\n                    newUrls.splice(index, 1)\n                    return newUrls\n                },\n            },\n        ],\n        suggestions: [\n            [],\n            {\n                addUrl: (state, { url }) => [...state].filter((item) => url !== item),\n            },\n        ],\n        searchTerm: [\n            '',\n            {\n                setSearchTerm: (_, { term }) => term,\n            },\n        ],\n        editUrlIndex: [\n            null as number | null,\n            {\n                setEditUrlIndex: (_, { originalIndex }) => originalIndex,\n                removeUrl: (editUrlIndex, { index }) =>\n                    editUrlIndex && index < editUrlIndex\n                        ? editUrlIndex - 1\n                        : index === editUrlIndex\n                        ? null\n                        : editUrlIndex,\n                newUrl: () => -1,\n                updateUrl: () => null,\n                addUrl: () => null,\n                cancelProposingUrl: () => null,\n            },\n        ],\n    })),\n    sharedListeners(({ values, props }) => ({\n        saveUrls: async () => {\n            if (props.type === AuthorizedUrlListType.RECORDING_DOMAINS) {\n                await teamLogic.asyncActions.updateCurrentTeam({ recording_domains: values.authorizedUrls })\n            } else {\n                await teamLogic.asyncActions.updateCurrentTeam({ app_urls: values.authorizedUrls })\n            }\n        },\n    })),\n    listeners(({ sharedListeners, values, actions }) => ({\n        setEditUrlIndex: () => {\n            actions.setProposedUrlValue('url', values.urlToEdit)\n        },\n        newUrl: () => {\n            actions.setProposedUrlValue('url', NEW_URL)\n        },\n        addUrl: [\n            sharedListeners.saveUrls,\n            ({ url, launch }) => {\n                if (launch) {\n                    actions.launchAtUrl(url)\n                }\n            },\n        ],\n        removeUrl: sharedListeners.saveUrls,\n        updateUrl: sharedListeners.saveUrls,\n        launchAtUrl: ({ url }) => {\n            window.location.href = values.launchUrl(url)\n        },\n        cancelProposingUrl: () => {\n            actions.resetProposedUrl()\n        },\n        submitProposedUrlSuccess: () => {\n            actions.setEditUrlIndex(null)\n            actions.resetProposedUrl()\n        },\n    })),\n    selectors({\n        urlToEdit: [\n            (s) => [s.authorizedUrls, s.editUrlIndex],\n            (authorizedUrls, editUrlIndex) => {\n                if (editUrlIndex === null || editUrlIndex === -1) {\n                    return NEW_URL\n                }\n                return authorizedUrls[editUrlIndex]\n            },\n        ],\n        urlsKeyed: [\n            (s) => [s.authorizedUrls, s.suggestions, s.searchTerm],\n            (authorizedUrls, suggestions, searchTerm): KeyedAppUrl[] => {\n                const keyedUrls = authorizedUrls\n                    .map((url, index) => ({\n                        url,\n                        type: 'authorized',\n                        originalIndex: index,\n                    }))\n                    .concat(\n                        suggestions.map((url, index) => ({\n                            url,\n                            type: 'suggestion',\n                            originalIndex: index,\n                        }))\n                    ) as KeyedAppUrl[]\n\n                if (!searchTerm) {\n                    return keyedUrls\n                }\n\n                return new Fuse(keyedUrls, {\n                    keys: ['url'],\n                    threshold: 0.3,\n                })\n                    .search(searchTerm)\n                    .map((result) => result.item)\n            },\n        ],\n        launchUrl: [(_, p) => [p.actionId], (actionId) => (url: string) => appEditorUrl(url, actionId, !actionId)],\n        isAddUrlFormVisible: [(s) => [s.editUrlIndex], (editUrlIndex) => editUrlIndex === -1],\n        onlyAllowDomains: [(_, p) => [p.type], (type) => type === AuthorizedUrlListType.RECORDING_DOMAINS],\n    }),\n    urlToAction(({ actions }) => ({\n        [urls.toolbarLaunch()]: (_, searchParams) => {\n            if (searchParams.addNew) {\n                actions.newUrl()\n            }\n        },\n    })),\n])\n","import { useValues } from 'kea'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { apiHostOrigin } from 'lib/utils/apiHost'\nimport { teamLogic } from 'scenes/teamLogic'\n\nexport function JSSnippet(): JSX.Element {\n    const { currentTeam } = useValues(teamLogic)\n\n    return (\n        <CodeSnippet language={Language.HTML}>{`<script>\n    !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(\".\");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement(\"script\")).type=\"text/javascript\",p.async=!0,p.src=s.api_host+\"/static/array.js\",(r=t.getElementsByTagName(\"script\")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a=\"posthog\",u.people=u.people||[],u.toString=function(t){var e=\"posthog\";return\"posthog\"!==a&&(e+=\".\"+a),t||(e+=\" (stub)\"),e},u.people.toString=function(){return u.toString(1)+\".people (stub)\"},o=\"capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys onSessionId\".split(\" \"),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);\n    posthog.init('${currentTeam?.api_token}',{api_host:'${apiHostOrigin()}'})\n</script>`}</CodeSnippet>\n    )\n}\n","import {\n    LemonBanner,\n    LemonInput,\n    LemonSegmentedButton,\n    LemonSegmentedButtonOption,\n    lemonToast,\n    Link,\n} from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\nimport { useUploadFiles } from 'lib/hooks/useUploadFiles'\nimport { IconBugReport, IconFeedback, IconHelpOutline } from 'lib/lemon-ui/icons'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonFileInput } from 'lib/lemon-ui/LemonFileInput/LemonFileInput'\nimport { LemonSelect } from 'lib/lemon-ui/LemonSelect/LemonSelect'\nimport { LemonTextArea } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport posthog from 'posthog-js'\nimport { useEffect, useRef } from 'react'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { SEVERITY_LEVEL_TO_NAME, supportLogic, SupportTicketKind, TARGET_AREA_TO_NAME } from './supportLogic'\n\nconst SUPPORT_TICKET_OPTIONS: LemonSegmentedButtonOption<SupportTicketKind>[] = [\n    {\n        value: 'support',\n        label: 'Question',\n        icon: <IconHelpOutline />,\n    },\n    {\n        value: 'feedback',\n        label: 'Feedback',\n        icon: <IconFeedback />,\n    },\n    {\n        value: 'bug',\n        label: 'Bug',\n        icon: <IconBugReport />,\n    },\n]\n\nconst SUPPORT_TICKET_KIND_TO_PROMPT: Record<SupportTicketKind, string> = {\n    bug: \"What's the bug?\",\n    feedback: 'What feedback do you have?',\n    support: 'What can we help you with?',\n}\n\nexport function SupportForm(): JSX.Element | null {\n    const { sendSupportRequest } = useValues(supportLogic)\n    const { setSendSupportRequestValue } = useActions(supportLogic)\n    const { objectStorageAvailable } = useValues(preflightLogic)\n    // the support model can be shown when logged out, file upload is not offered to anonymous users\n    const { user } = useValues(userLogic)\n\n    const dropRef = useRef<HTMLDivElement>(null)\n\n    const { setFilesToUpload, filesToUpload, uploading } = useUploadFiles({\n        onUpload: (url, fileName) => {\n            setSendSupportRequestValue('message', sendSupportRequest.message + `\\n\\nAttachment \"${fileName}\": ${url}`)\n        },\n        onError: (detail) => {\n            lemonToast.error(`Error uploading image: ${detail}`)\n        },\n    })\n\n    useEffect(() => {\n        if (sendSupportRequest.kind === 'bug') {\n            setSendSupportRequestValue('severity_level', 'medium')\n        } else {\n            setSendSupportRequestValue('severity_level', 'low')\n        }\n    }, [sendSupportRequest.kind])\n\n    return (\n        <Form\n            logic={supportLogic}\n            formKey=\"sendSupportRequest\"\n            id=\"support-modal-form\"\n            enableFormOnSubmit\n            className=\"space-y-4\"\n        >\n            {!user && (\n                <>\n                    <LemonField name=\"name\" label=\"Name\">\n                        <LemonInput data-attr=\"name\" placeholder=\"Jane\" />\n                    </LemonField>\n                    <LemonField name=\"email\" label=\"Email\">\n                        <LemonInput data-attr=\"email\" placeholder=\"your@email.com\" />\n                    </LemonField>\n                </>\n            )}\n            <LemonField name=\"kind\" label=\"What type of message is this?\">\n                <LemonSegmentedButton fullWidth options={SUPPORT_TICKET_OPTIONS} />\n            </LemonField>\n            <LemonField name=\"target_area\" label=\"What area does this best relate to?\">\n                <LemonSelect\n                    fullWidth\n                    options={Object.entries(TARGET_AREA_TO_NAME).map(([key, value]) => ({\n                        label: value,\n                        value: key,\n                        'data-attr': `support-form-target-area-${key}`,\n                    }))}\n                />\n            </LemonField>\n            {posthog.getFeatureFlag('show-troubleshooting-docs-in-support-form') === 'test-replay-banner' &&\n                sendSupportRequest.target_area === 'session_replay' && (\n                    <LemonBanner type=\"info\">\n                        <>\n                            We're pretty proud of our docs. Check out these helpful links:\n                            <ul>\n                                <li>\n                                    <Link target=\"_blank\" to=\"https://posthog.com/docs/session-replay/troubleshooting\">\n                                        Session replay troubleshooting\n                                    </Link>\n                                </li>\n                                <li>\n                                    <Link\n                                        target=\"_blank\"\n                                        to=\"https://posthog.com/docs/session-replay/how-to-control-which-sessions-you-record\"\n                                    >\n                                        How to control which sessions you record\n                                    </Link>\n                                </li>\n                            </ul>\n                        </>\n                    </LemonBanner>\n                )}\n            {posthog.getFeatureFlag('show-troubleshooting-docs-in-support-form') === 'test-replay-banner' &&\n                sendSupportRequest.target_area === 'toolbar' && (\n                    <LemonBanner type=\"info\">\n                        <>\n                            We're pretty proud of our docs.{' '}\n                            <Link target=\"_blank\" to=\"https://posthog.com/docs/toolbar#troubleshooting-and-faq\">\n                                Check out this troubleshooting guide\n                            </Link>\n                        </>\n                    </LemonBanner>\n                )}\n            <LemonField name=\"severity_level\" label=\"What is the severity of this issue?\">\n                <LemonSelect\n                    fullWidth\n                    options={Object.entries(SEVERITY_LEVEL_TO_NAME).map(([key, value]) => ({\n                        label: value,\n                        value: key,\n                    }))}\n                />\n            </LemonField>\n            <span className=\"text-muted\">\n                Check out the{' '}\n                <Link target=\"_blank\" to=\"https://posthog.com/docs/support-options#severity-levels\">\n                    severity level definitions\n                </Link>\n                .\n            </span>\n            <LemonField\n                name=\"message\"\n                label={sendSupportRequest.kind ? SUPPORT_TICKET_KIND_TO_PROMPT[sendSupportRequest.kind] : 'Content'}\n            >\n                {(props) => (\n                    <div ref={dropRef} className=\"flex flex-col gap-2\">\n                        <LemonTextArea\n                            placeholder=\"Type your message here\"\n                            data-attr=\"support-form-content-input\"\n                            {...props}\n                        />\n                        {objectStorageAvailable && !!user && (\n                            <LemonFileInput\n                                accept=\"image/*\"\n                                multiple={false}\n                                alternativeDropTargetRef={dropRef}\n                                onChange={setFilesToUpload}\n                                loading={uploading}\n                                value={filesToUpload}\n                            />\n                        )}\n                    </div>\n                )}\n            </LemonField>\n        </Form>\n    )\n}\n","import { captureException } from '@sentry/react'\nimport * as Sentry from '@sentry/react'\nimport { actions, connect, kea, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { urlToAction } from 'kea-router'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'\nimport { uuid } from 'lib/utils'\nimport posthog from 'posthog-js'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { sidePanelStateLogic } from '~/layout/navigation-3000/sidepanel/sidePanelStateLogic'\nimport { Region, SidePanelTab, TeamType, UserType } from '~/types'\n\nimport type { supportLogicType } from './supportLogicType'\nimport { openSupportModal } from './SupportModal'\n\nfunction getSessionReplayLink(): string {\n    const link = posthog\n        .get_session_replay_url({ withTimestamp: true, timestampLookBack: 30 })\n        .replace(window.location.origin + '/replay/', 'http://go/session/')\n\n    return `Session: ${link} (at ${window.location.href.replace(/&supportModal=.+($|&)?/, '$1')})`\n}\n\nfunction getDjangoAdminLink(\n    user: UserType | null,\n    cloudRegion: Region | null | undefined,\n    currentTeamId: TeamType['id'] | null\n): string {\n    if (!user || !cloudRegion) {\n        return ''\n    }\n    const link = `http://go/admin${cloudRegion}/${user.email}`\n    return `Admin: ${link} (Organization: '${user.organization?.name}'; Project: ${currentTeamId}:'${user.team?.name}')`\n}\n\nfunction getSentryLink(user: UserType | null, cloudRegion: Region | null | undefined): string {\n    if (!user || !cloudRegion) {\n        return ''\n    }\n    const link = `http://go/sentry${cloudRegion}/${user.team?.id}`\n    return `Sentry: ${link}`\n}\n\nconst SUPPORT_TICKET_KIND_TO_TITLE: Record<SupportTicketKind, string> = {\n    support: 'Ask a question',\n    feedback: 'Give feedback',\n    bug: 'Report a bug',\n}\n\nexport const TARGET_AREA_TO_NAME = {\n    app_performance: 'App Performance',\n    apps: 'Apps',\n    login: 'Authentication (Login / Sign-up / Invites)',\n    billing: 'Billing',\n    onboarding: 'Onboarding',\n    cohorts: 'Cohorts',\n    data_integrity: 'Data Integrity',\n    data_management: 'Data Management',\n    data_warehouse: 'Data Warehouse',\n    ingestion: 'Event Ingestion',\n    experiments: 'A/B Testing',\n    feature_flags: 'Feature Flags',\n    analytics: 'Product Analytics (Insights, Dashboards, Annotations)',\n    session_replay: 'Session Replay (Recordings)',\n    toolbar: 'Toolbar & Heatmaps',\n    surveys: 'Surveys',\n    web_analytics: 'Web Analytics',\n    'posthog-3000': 'PostHog 3000',\n}\n\nexport const SEVERITY_LEVEL_TO_NAME = {\n    critical: 'Outage / data loss / breach',\n    high: 'Feature unavailable / Significant impact',\n    medium: 'Feature not working as expected',\n    low: 'Feature request or Question',\n}\n\nexport const SUPPORT_KIND_TO_SUBJECT = {\n    bug: 'Bug Report',\n    feedback: 'Feedback',\n    support: 'Support Ticket',\n}\n\nexport type SupportTicketTargetArea = keyof typeof TARGET_AREA_TO_NAME\nexport type SupportTicketSeverityLevel = keyof typeof SEVERITY_LEVEL_TO_NAME\nexport type SupportTicketKind = keyof typeof SUPPORT_KIND_TO_SUBJECT\n\nexport const URL_PATH_TO_TARGET_AREA: Record<string, SupportTicketTargetArea> = {\n    insights: 'analytics',\n    recordings: 'session_replay',\n    replay: 'session_replay',\n    dashboard: 'analytics',\n    feature_flags: 'feature_flags',\n    experiments: 'experiments',\n    'web-performance': 'session_replay',\n    events: 'analytics',\n    'data-management': 'data_management',\n    cohorts: 'cohorts',\n    annotations: 'analytics',\n    persons: 'data_integrity',\n    groups: 'data_integrity',\n    app: 'apps',\n    toolbar: 'session_replay',\n    warehouse: 'data_warehouse',\n    surveys: 'surveys',\n    web: 'web_analytics',\n}\n\nexport function getURLPathToTargetArea(pathname: string): SupportTicketTargetArea | null {\n    const first_part = pathname.split('/')[1]\n    return URL_PATH_TO_TARGET_AREA[first_part] ?? null\n}\n\nexport type SupportFormLogicProps = {\n    onClose?: () => void\n}\n\nexport type SupportFormFields = {\n    name: string\n    email: string\n    kind: SupportTicketKind\n    target_area: SupportTicketTargetArea | null\n    severity_level: SupportTicketSeverityLevel | null\n    message: string\n}\n\nexport const supportLogic = kea<supportLogicType>([\n    props({} as SupportFormLogicProps),\n    path(['lib', 'components', 'support', 'supportLogic']),\n    connect(() => ({\n        values: [userLogic, ['user'], preflightLogic, ['preflight'], sidePanelStateLogic, ['sidePanelAvailable']],\n        actions: [sidePanelStateLogic, ['openSidePanel', 'setSidePanelOptions']],\n    })),\n    actions(() => ({\n        closeSupportForm: true,\n        openSupportForm: (values: Partial<SupportFormFields>) => values,\n        submitZendeskTicket: (form: SupportFormFields) => form,\n        updateUrlParams: true,\n    })),\n    reducers(() => ({\n        isSupportFormOpen: [\n            false,\n            {\n                openSupportForm: () => true,\n                closeSupportForm: () => false,\n            },\n        ],\n    })),\n    forms(({ actions, values }) => ({\n        sendSupportRequest: {\n            defaults: {\n                name: '',\n                email: '',\n                kind: 'support',\n                severity_level: null,\n                target_area: null,\n                message: '',\n            } as SupportFormFields,\n            errors: ({ name, email, message, kind, target_area, severity_level }) => {\n                return {\n                    name: !values.user ? (!name ? 'Please enter your name' : '') : '',\n                    email: !values.user ? (!email ? 'Please enter your email' : '') : '',\n                    message: !message ? 'Please enter a message' : '',\n                    kind: !kind ? 'Please choose' : undefined,\n                    severity_level: !severity_level ? 'Please choose' : undefined,\n                    target_area: !target_area ? 'Please choose' : undefined,\n                }\n            },\n            submit: async (formValues) => {\n                formValues.name = values.user?.first_name ?? formValues.name ?? ''\n                formValues.email = values.user?.email ?? formValues.email ?? ''\n                actions.submitZendeskTicket(formValues)\n                actions.closeSupportForm()\n                actions.resetSendSupportRequest()\n            },\n        },\n    })),\n    selectors({\n        title: [\n            (s) => [s.sendSupportRequest ?? null],\n            (sendSupportRequest) =>\n                sendSupportRequest.kind\n                    ? SUPPORT_TICKET_KIND_TO_TITLE[sendSupportRequest.kind]\n                    : 'Leave a message with PostHog',\n        ],\n    }),\n    listeners(({ actions, props, values }) => ({\n        updateUrlParams: async () => {\n            const panelOptions = [\n                values.sendSupportRequest.kind ?? '',\n                values.sendSupportRequest.target_area ?? '',\n                values.sendSupportRequest.severity_level ?? '',\n            ].join(':')\n\n            if (panelOptions !== ':') {\n                actions.setSidePanelOptions(panelOptions)\n            }\n        },\n        openSupportForm: async ({ name, email, kind, target_area, severity_level, message }) => {\n            const area = target_area ?? getURLPathToTargetArea(window.location.pathname)\n            kind = kind ?? 'support'\n            actions.resetSendSupportRequest({\n                name: name ?? '',\n                email: email ?? '',\n                kind,\n                target_area: area,\n                severity_level: severity_level ?? null,\n                message: message ?? '',\n            })\n\n            if (values.sidePanelAvailable) {\n                const panelOptions = [kind ?? '', area ?? ''].join(':')\n                actions.openSidePanel(SidePanelTab.Support, panelOptions === ':' ? undefined : panelOptions)\n            } else {\n                openSupportModal()\n            }\n\n            actions.updateUrlParams()\n        },\n        submitZendeskTicket: async ({ name, email, kind, target_area, severity_level, message }) => {\n            const zendesk_ticket_uuid = uuid()\n            const subject =\n                SUPPORT_KIND_TO_SUBJECT[kind ?? 'support'] +\n                ': ' +\n                (target_area ? TARGET_AREA_TO_NAME[target_area] ?? `${target_area} (feature preview)` : 'General') +\n                ' (' +\n                zendesk_ticket_uuid +\n                ')'\n            const cloudRegion = preflightLogic.values.preflight?.region\n\n            const payload = {\n                request: {\n                    requester: { name: name, email: email },\n                    subject: subject,\n                    custom_fields: [\n                        {\n                            id: 22084126888475,\n                            value: severity_level,\n                        },\n                        {\n                            id: 22129191462555,\n                            value: posthog.get_distinct_id(),\n                        },\n                    ],\n                    comment: {\n                        body: (\n                            message +\n                            `\\n\\n-----` +\n                            `\\nKind: ${kind}` +\n                            `\\nTarget area: ${target_area}` +\n                            `\\nReport event: http://go/ticketByUUID/${zendesk_ticket_uuid}` +\n                            '\\n' +\n                            getSessionReplayLink() +\n                            '\\n' +\n                            getDjangoAdminLink(userLogic.values.user, cloudRegion, teamLogic.values.currentTeamId) +\n                            '\\n' +\n                            getSentryLink(userLogic.values.user, cloudRegion)\n                        ).trim(),\n                    },\n                },\n            }\n\n            try {\n                const response = await fetch('https://posthoghelp.zendesk.com/api/v2/requests.json', {\n                    method: 'POST',\n                    body: JSON.stringify(payload, undefined, 4),\n                    headers: { 'Content-Type': 'application/json' },\n                })\n                if (!response.ok) {\n                    const error = new Error(`There was an error creating the support ticket with zendesk.`)\n                    captureException(error, {\n                        extra: { response, payload },\n                    })\n                    lemonToast.error(`There was an error sending the message.`)\n                    return\n                }\n\n                const json = await response.json()\n\n                const zendesk_ticket_id = json.request.id\n                const zendesk_ticket_link = `https://posthoghelp.zendesk.com/agent/tickets/${zendesk_ticket_id}`\n                const properties = {\n                    zendesk_ticket_uuid,\n                    kind,\n                    target_area,\n                    message,\n                    zendesk_ticket_id,\n                    zendesk_ticket_link,\n                }\n                posthog.capture('support_ticket', properties)\n                Sentry.captureMessage('User submitted Zendesk ticket', {\n                    tags: {\n                        zendesk_ticket_uuid,\n                        zendesk_ticket_link,\n                        support_request_kind: kind,\n                        support_request_area: target_area,\n                        team_id: teamLogic.values.currentTeamId,\n                    },\n                    extra: properties,\n                    level: 'log',\n                })\n                lemonToast.success(\"Got the message! If we have follow-up information for you, we'll reply via email.\")\n            } catch (e) {\n                captureException(e)\n                lemonToast.error(`There was an error sending the message.`)\n            }\n        },\n\n        closeSupportForm: () => {\n            props.onClose?.()\n        },\n\n        setSendSupportRequestValue: () => {\n            actions.updateUrlParams()\n        },\n    })),\n\n    urlToAction(({ actions, values }) => ({\n        '*': (_, _search, hashParams) => {\n            if (values.isSupportFormOpen) {\n                return\n            }\n\n            const [panel, ...panelOptions] = (hashParams['panel'] ?? '').split(':')\n\n            if (panel === SidePanelTab.Support) {\n                const [kind, area, severity] = panelOptions\n\n                actions.openSupportForm({\n                    kind: Object.keys(SUPPORT_KIND_TO_SUBJECT).includes(kind) ? kind : null,\n                    target_area: Object.keys(TARGET_AREA_TO_NAME).includes(area) ? area : null,\n                    severity_level: Object.keys(SEVERITY_LEVEL_TO_NAME).includes(severity) ? severity : null,\n                })\n                return\n            }\n\n            // Legacy supportModal param\n            if ('supportModal' in hashParams) {\n                const [kind, area, severity] = (hashParams['supportModal'] || '').split(':')\n\n                actions.openSupportForm({\n                    kind: Object.keys(SUPPORT_KIND_TO_SUBJECT).includes(kind) ? kind : null,\n                    target_area: Object.keys(TARGET_AREA_TO_NAME).includes(area) ? area : null,\n                    severity_level: Object.keys(SEVERITY_LEVEL_TO_NAME).includes(severity) ? severity : null,\n                })\n            }\n        },\n    })),\n])\n","import { actions, afterMount, kea, listeners, path, reducers, sharedListeners } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\n\nimport type { versionCheckerLogicType } from './versionCheckerLogicType'\n\nconst CHECK_INTERVAL_MS = 1000 * 60 * 60 // 6 hour\n\nexport type SDKVersion = {\n    version: string\n    timestamp?: string\n}\n\nexport type SDKVersionWarning = {\n    currentVersion: string\n    latestVersion: string\n    diff: number\n    level: 'warning' | 'info' | 'error'\n}\n\nexport const versionCheckerLogic = kea<versionCheckerLogicType>([\n    path(['components', 'VersionChecker', 'versionCheckerLogic']),\n    actions({\n        setVersionWarning: (versionWarning: SDKVersionWarning | null) => ({ versionWarning }),\n    }),\n    loaders({\n        availableVersions: [\n            null as SDKVersion[] | null,\n            {\n                loadAvailableVersions: async () => {\n                    return await fetch('https://api.github.com/repos/posthog/posthog-js/tags')\n                        .then((r) => r.json())\n                        .then((r) => r.map((x: any) => ({ version: x.name.replace('v', '') })))\n                },\n            },\n        ],\n        usedVersions: [\n            null as SDKVersion[] | null,\n            {\n                loadUsedVersions: async () => {\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$lib_version AS lib_version, max(timestamp) AS latest_timestamp, count(lib_version) as count\n                                FROM events\n                                WHERE timestamp >= now() - INTERVAL 1 DAY \n                                AND timestamp <= now()\n                                AND properties.$lib = 'web'\n                                GROUP BY lib_version\n                                ORDER BY latest_timestamp DESC\n                                limit 10`,\n                    }\n\n                    const res = await api.query(query)\n\n                    return (\n                        res.results?.map((x) => ({\n                            version: x[0],\n                            timestamp: x[1],\n                        })) ?? null\n                    )\n                },\n            },\n        ],\n    }),\n\n    reducers({\n        lastCheckTimestamp: [\n            0,\n            { persist: true },\n            {\n                loadUsedVersionsSuccess: () => Date.now(),\n            },\n        ],\n        versionWarning: [\n            null as SDKVersionWarning | null,\n            // bumping cache key due to an incorrect tag being cached on 2024-02-12\n            { persist: true, prefix: '2024-02-12' },\n            {\n                setVersionWarning: (_, { versionWarning }) => versionWarning,\n            },\n        ],\n    }),\n\n    sharedListeners(({ values, actions }) => ({\n        checkForVersionWarning: () => {\n            if (!values.availableVersions?.length || !values.usedVersions?.length) {\n                return\n            }\n\n            const latestVersion = values.availableVersions[0].version\n\n            // reverse sort, hence reversed arguments to localeCompare.\n            // We want the highest semantic version to be the latest used one, rather than\n            // the one with the latest timestamp, because secondary installations can spew old versions\n            const latestUsedVersion = [...values.usedVersions].sort((a, b) =>\n                b.version.localeCompare(a.version, undefined, { numeric: true })\n            )[0].version\n\n            if (latestVersion === latestUsedVersion) {\n                actions.setVersionWarning(null)\n                return\n            }\n\n            let diff = values.availableVersions.findIndex((v) => v.version === latestUsedVersion)\n            diff = diff === -1 ? values.availableVersions.length : diff\n\n            const warning: SDKVersionWarning = {\n                currentVersion: latestUsedVersion,\n                latestVersion,\n                diff,\n                level: diff > 20 ? 'error' : diff > 10 ? 'warning' : 'info',\n            }\n\n            actions.setVersionWarning(warning)\n        },\n    })),\n\n    listeners(({ sharedListeners }) => ({\n        loadAvailableVersionsSuccess: sharedListeners.checkForVersionWarning,\n        loadUsedVersionsSuccess: sharedListeners.checkForVersionWarning,\n    })),\n\n    afterMount(({ actions, values }) => {\n        if (values.lastCheckTimestamp < Date.now() - CHECK_INTERVAL_MS) {\n            actions.loadAvailableVersions()\n            actions.loadUsedVersions()\n        }\n    }),\n])\n","import { useValues } from 'kea'\nimport { TextContent } from 'lib/components/Cards/TextCard/TextCard'\nimport { useUploadFiles } from 'lib/hooks/useUploadFiles'\nimport { IconMarkdown, IconTools } from 'lib/lemon-ui/icons'\nimport { LemonFileInput } from 'lib/lemon-ui/LemonFileInput'\nimport { LemonTabs } from 'lib/lemon-ui/LemonTabs'\nimport { LemonTextArea, LemonTextAreaProps } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { Link } from 'lib/lemon-ui/Link'\nimport { Tooltip } from 'lib/lemon-ui/Tooltip'\nimport posthog from 'posthog-js'\nimport React, { useRef, useState } from 'react'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\n\nexport const LemonTextAreaMarkdown = React.forwardRef<HTMLTextAreaElement, LemonTextAreaProps>(\n    function _LemonTextAreaMarkdown({ value, onChange, ...editAreaProps }, ref): JSX.Element {\n        const { objectStorageAvailable } = useValues(preflightLogic)\n\n        const [isPreviewShown, setIsPreviewShown] = useState(false)\n        const dropRef = useRef<HTMLDivElement>(null)\n\n        const { setFilesToUpload, filesToUpload, uploading } = useUploadFiles({\n            onUpload: (url, fileName) => {\n                onChange?.(value + `\\n\\n![${fileName}](${url})`)\n                posthog.capture('markdown image uploaded', { name: fileName })\n            },\n            onError: (detail) => {\n                posthog.capture('markdown image upload failed', { error: detail })\n                lemonToast.error(`Error uploading image: ${detail}`)\n            },\n        })\n\n        return (\n            <LemonTabs\n                activeKey={isPreviewShown ? 'preview' : 'write'}\n                onChange={(key) => setIsPreviewShown(key === 'preview')}\n                tabs={[\n                    {\n                        key: 'write',\n                        label: 'Write',\n                        content: (\n                            <div ref={dropRef} className=\"LemonTextMarkdown flex flex-col space-y-1 rounded\">\n                                <LemonTextArea\n                                    ref={ref}\n                                    {...editAreaProps}\n                                    autoFocus\n                                    value={value}\n                                    onChange={onChange}\n                                />\n                                <div className=\"text-muted inline-flex items-center space-x-1\">\n                                    <IconMarkdown className=\"text-2xl\" />\n                                    <span>Markdown formatting support</span>\n                                </div>\n                                {objectStorageAvailable ? (\n                                    <LemonFileInput\n                                        accept={'image/*'}\n                                        multiple={false}\n                                        alternativeDropTargetRef={dropRef}\n                                        onChange={setFilesToUpload}\n                                        loading={uploading}\n                                        value={filesToUpload}\n                                    />\n                                ) : (\n                                    <div className=\"text-muted inline-flex items-center space-x-1\">\n                                        <Tooltip title=\"Enable object storage to add images by dragging and dropping.\">\n                                            <IconTools className=\"text-xl mr-1\" />\n                                        </Tooltip>\n                                        <span>\n                                            Add external images using{' '}\n                                            <Link to=\"https://www.markdownguide.org/basic-syntax/#images-1\">\n                                                {' '}\n                                                Markdown image links\n                                            </Link>\n                                            .\n                                        </span>\n                                    </div>\n                                )}\n                            </div>\n                        ),\n                    },\n                    {\n                        key: 'preview',\n                        label: 'Preview',\n                        content: value ? (\n                            <TextContent text={value} className=\"LemonTextArea--preview\" />\n                        ) : (\n                            <i>Nothing to preview</i>\n                        ),\n                    },\n                ]}\n            />\n        )\n    }\n)\n","// This file contains example queries, used in storybook and in the /query interface.\nimport { defaultDataTableColumns } from '~/queries/nodes/DataTable/utils'\nimport {\n    ActionsNode,\n    DataTableNode,\n    DataVisualizationNode,\n    EventsNode,\n    EventsQuery,\n    FunnelsQuery,\n    HogQLQuery,\n    LifecycleQuery,\n    Node,\n    NodeKind,\n    PathsQuery,\n    PersonsNode,\n    RetentionQuery,\n    StickinessQuery,\n    TimeToSeeDataJSONNode,\n    TimeToSeeDataSessionsQuery,\n    TimeToSeeDataWaterfallNode,\n    TrendsQuery,\n} from '~/queries/schema'\nimport {\n    ChartDisplayType,\n    FilterLogicalOperator,\n    PropertyFilterType,\n    PropertyGroupFilter,\n    PropertyOperator,\n    StepOrderValue,\n} from '~/types'\n\nconst Events: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: defaultDataTableColumns(NodeKind.EventsQuery),\n    properties: [\n        { type: PropertyFilterType.Event, key: '$browser', operator: PropertyOperator.Exact, value: 'Chrome' },\n    ],\n    after: '-24h',\n    limit: 100,\n}\n\nconst EventsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: Events,\n}\nconst EventsTableFull: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: Events,\n}\n\nconst TotalEvents: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: ['count()'],\n}\n\nexport const TotalEventsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: TotalEvents,\n}\n\nconst PropertyFormulas: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: [\n        '1 + 2 + 3',\n        'event',\n        'person.created_at',\n        \"concat(properties['$browser'], ' ðŸ’š ', properties['$geoip_city_name']) -- Browser ðŸ’š City\",\n        \"'random string'\",\n    ],\n    limit: 100,\n}\n\nconst PropertyFormulasTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: PropertyFormulas,\n}\n\nconst EventAggregations: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: {\n        kind: NodeKind.EventsQuery,\n        select: [\n            \"concat(properties['$geoip_city_name'], ' ', 'Rocks') -- City\",\n            'event',\n            'count() + 100000 -- Inflamed total',\n            '1 + 2',\n        ],\n        orderBy: ['-count()'],\n    },\n}\n\nconst Persons: PersonsNode = {\n    kind: NodeKind.PersonsNode,\n    properties: [\n        { type: PropertyFilterType.Person, key: '$browser', operator: PropertyOperator.Exact, value: 'Chrome' },\n    ],\n}\n\nconst PersonsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    columns: defaultDataTableColumns(NodeKind.PersonsNode),\n    source: Persons,\n}\n\nconst PersonsTableFull: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    columns: defaultDataTableColumns(NodeKind.PersonsNode),\n    source: Persons,\n}\n\nconst properties: PropertyGroupFilter = {\n    type: FilterLogicalOperator.And,\n    values: [\n        {\n            type: FilterLogicalOperator.Or,\n            values: [\n                {\n                    type: PropertyFilterType.Event,\n                    key: '$current_url',\n                    operator: PropertyOperator.Exact,\n                    value: ['https://hedgebox.net/files/'],\n                },\n                {\n                    type: PropertyFilterType.Event,\n                    key: '$geoip_country_code',\n                    operator: PropertyOperator.Exact,\n                    value: ['US', 'AU'],\n                },\n            ],\n        },\n    ],\n}\n\nconst filterTestAccounts = false\nconst series: (EventsNode | ActionsNode)[] = [\n    {\n        kind: NodeKind.EventsNode,\n        name: '$pageview',\n        custom_name: 'Views',\n        event: '$pageview',\n        properties: [\n            {\n                type: PropertyFilterType.Event,\n                key: '$browser',\n                operator: PropertyOperator.Exact,\n                value: 'Chrome',\n            },\n            {\n                type: PropertyFilterType.Cohort,\n                key: 'id',\n                value: 2,\n            },\n        ],\n        limit: 100, // TODO - can't find a use for `limits` in insights/trends\n    },\n    // {\n    //     kind: NodeKind.ActionsNode,\n    //     id: 1,\n    //     name: 'Interacted with file',\n    //     custom_name: 'Interactions',\n    //     properties: [\n    //         {\n    //             type: PropertyFilterType.Event,\n    //             key: '$geoip_country_code',\n    //             operator: PropertyOperator.Exact,\n    //             value: ['US'],\n    //         },\n    //     ],\n    //     math: PropertyMathType.Average,\n    //     math_property: '$session_duration',\n    // },\n]\n\nconst InsightTrendsQuery: TrendsQuery = {\n    kind: NodeKind.TrendsQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    trendsFilter: {\n        display: ChartDisplayType.ActionsAreaGraph,\n    },\n    breakdownFilter: {\n        breakdown: '$geoip_country_code',\n        breakdown_type: 'event',\n    },\n}\n\nconst InsightFunnelsQuery: FunnelsQuery = {\n    kind: NodeKind.FunnelsQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    funnelsFilter: {\n        funnelOrderType: StepOrderValue.ORDERED,\n    },\n    breakdownFilter: {\n        breakdown: '$geoip_country_code',\n        breakdown_type: 'event',\n    },\n}\n\nconst InsightRetentionQuery: RetentionQuery = {\n    kind: NodeKind.RetentionQuery,\n    properties,\n    filterTestAccounts,\n    retentionFilter: {\n        // TODO: this should be typed as (EventsNode | ActionsNode)[] without math and properties\n        targetEntity: { type: 'events', id: '$pageview', name: '$pageview' },\n        returningEntity: { type: 'events', id: '$pageview', name: '$pageview' },\n    },\n}\n\nconst InsightPathsQuery: PathsQuery = {\n    kind: NodeKind.PathsQuery,\n    properties,\n    filterTestAccounts,\n    pathsFilter: {},\n}\n\nconst InsightStickinessQuery: StickinessQuery = {\n    kind: NodeKind.StickinessQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    stickinessFilter: {},\n}\n\nconst InsightLifecycleQuery: LifecycleQuery = {\n    kind: NodeKind.LifecycleQuery,\n    properties,\n    filterTestAccounts,\n    dateRange: {\n        date_from: '-7d',\n    },\n    series, // TODO: Visualization only supports one event or action\n}\n\nconst TimeToSeeDataSessionsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    columns: [\n        'session_id',\n        'session_start',\n        'session_end',\n        'duration_ms',\n        'team_events_last_month',\n        'events_count',\n        'interactions_count',\n        'total_interaction_time_to_see_data_ms',\n        'frustrating_interactions_count',\n        'user.email',\n    ],\n    source: {\n        kind: NodeKind.TimeToSeeDataSessionsQuery,\n    },\n}\n\nconst TimeToSeeDataSessionsJSON: TimeToSeeDataSessionsQuery = {\n    kind: NodeKind.TimeToSeeDataSessionsQuery,\n}\n\nconst TimeToSeeDataJSON: TimeToSeeDataJSONNode = {\n    kind: NodeKind.TimeToSeeDataSessionsJSONNode,\n    source: {\n        kind: NodeKind.TimeToSeeDataQuery,\n        sessionId: 'complete_me',\n        sessionStart: 'iso_date',\n        sessionEnd: 'iso_date',\n    },\n}\n\nconst TimeToSeeDataWaterfall: TimeToSeeDataWaterfallNode = {\n    kind: NodeKind.TimeToSeeDataSessionsWaterfallNode,\n    source: {\n        kind: NodeKind.TimeToSeeDataQuery,\n        sessionId: 'complete_me',\n        sessionStart: 'iso_date',\n        sessionEnd: 'iso_date',\n    },\n}\n\nconst HogQLRaw: HogQLQuery = {\n    kind: NodeKind.HogQLQuery,\n    query: `   select event,\n          person.properties.email,\n          properties.$browser,\n          count()\n     from events\n    where {filters} -- replaced with global date and property filters\n      and person.properties.email is not null\n group by event,\n          properties.$browser,\n          person.properties.email\n order by count() desc\n    limit 100`,\n    explain: true,\n    filters: {\n        dateRange: {\n            date_from: '-24h',\n        },\n    },\n}\n\nconst HogQLForDataVisualization: HogQLQuery = {\n    kind: NodeKind.HogQLQuery,\n    query: `select toDate(timestamp) as timestamp, count()\nfrom events\nwhere {filters} and timestamp <= now()\ngroup by timestamp\norder by timestamp asc\nlimit 100`,\n    explain: true,\n    filters: {\n        dateRange: {\n            date_from: '-7d',\n        },\n    },\n}\n\nconst HogQLTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: HogQLRaw,\n}\n\nconst DataVisualization: DataVisualizationNode = {\n    kind: NodeKind.DataVisualizationNode,\n    source: HogQLForDataVisualization,\n}\n\n/* a subset of examples including only those we can show all users and that don't use HogQL */\nexport const queryExamples: Record<string, Node> = {\n    Events,\n    EventsTable,\n    EventsTableFull,\n    TotalEventsTable,\n    PropertyFormulasTable,\n    EventAggregations,\n    Persons,\n    PersonsTable,\n    PersonsTableFull,\n    InsightTrendsQuery,\n    InsightFunnelsQuery,\n    InsightRetentionQuery,\n    InsightPathsQuery,\n    InsightStickinessQuery,\n    InsightLifecycleQuery,\n}\n\nexport const stringifiedQueryExamples: Record<string, string> = Object.fromEntries(\n    Object.entries(queryExamples).map(([key, node]) => [key, JSON.stringify(node)])\n)\n\nexport const examples: Record<string, Node> = {\n    ...queryExamples,\n    TimeToSeeDataSessionsTable,\n    TimeToSeeDataSessionsJSON,\n    TimeToSeeDataWaterfall,\n    TimeToSeeDataJSON,\n    HogQLRaw,\n    HogQLTable,\n    DataVisualization,\n}\n\nexport const stringifiedExamples: Record<string, string> = Object.fromEntries(\n    Object.entries(examples).map(([key, node]) => [key, JSON.stringify(node)])\n)\n","import { actions, afterMount, connect, kea, key, listeners, path, props, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { beforeUnload, router } from 'kea-router'\nimport api from 'lib/api'\nimport { Dayjs, dayjs } from 'lib/dayjs'\nimport { Scene } from 'scenes/sceneTypes'\nimport { urls } from 'scenes/urls'\n\nimport {\n    BatchExportConfiguration,\n    BatchExportDestination,\n    BatchExportDestinationBigQuery,\n    BatchExportDestinationPostgres,\n    BatchExportDestinationRedshift,\n    BatchExportDestinationS3,\n    BatchExportDestinationSnowflake,\n    Breadcrumb,\n} from '~/types'\n\nimport type { batchExportsEditLogicType } from './batchExportEditLogicType'\nimport { batchExportLogic } from './batchExportLogic'\n\nexport type BatchExportsEditLogicProps = {\n    id: string\n}\n\nexport type BatchExportConfigurationForm = Omit<\n    BatchExportConfiguration,\n    'id' | 'destination' | 'start_at' | 'end_at'\n> &\n    Partial<BatchExportDestinationPostgres['config']> &\n    Partial<BatchExportDestinationRedshift['config']> &\n    Partial<BatchExportDestinationBigQuery['config']> &\n    Partial<BatchExportDestinationS3['config']> &\n    Partial<BatchExportDestinationSnowflake['config']> & {\n        destination: 'S3' | 'Snowflake' | 'Postgres' | 'BigQuery' | 'Redshift'\n        start_at: Dayjs | null\n        end_at: Dayjs | null\n        json_config_file?: File[] | null\n    }\n\nexport const batchExportFormFields = (\n    isNew: boolean,\n    { name, destination, interval, start_at, end_at, paused, ...config }: BatchExportConfigurationForm,\n    { isPipeline }: { isPipeline?: boolean } = {}\n): Record<string, any> => {\n    // Important! All fields that are required must be checked here as it is used also to sanitise the existing\n\n    return {\n        name: !name && !isPipeline ? 'Please enter a name' : '', // In pipeline UI the name is in the top bar\n        destination: !destination ? 'Please select a destination' : '',\n        interval: !interval ? 'Please select a frequency' : '',\n        paused: '',\n        start_at: '',\n        end_at: '',\n        ...(destination === 'Postgres'\n            ? {\n                  user: isNew ? (!config.user ? 'This field is required' : '') : '',\n                  password: isNew ? (!config.password ? 'This field is required' : '') : '',\n                  host: !config.host ? 'This field is required' : '',\n                  port: !config.port ? 'This field is required' : '',\n                  database: !config.database ? 'This field is required' : '',\n                  schema: !config.schema ? 'This field is required' : '',\n                  table_name: !config.table_name ? 'This field is required' : '',\n                  has_self_signed_cert: false,\n                  exclude_events: '',\n                  include_events: '',\n              }\n            : destination === 'Redshift'\n            ? {\n                  user: isNew ? (!config.user ? 'This field is required' : '') : '',\n                  password: isNew ? (!config.password ? 'This field is required' : '') : '',\n                  host: !config.host ? 'This field is required' : '',\n                  port: !config.port ? 'This field is required' : '',\n                  database: !config.database ? 'This field is required' : '',\n                  schema: !config.schema ? 'This field is required' : '',\n                  table_name: !config.table_name ? 'This field is required' : '',\n                  properties_data_type: '',\n                  exclude_events: '',\n                  include_events: '',\n              }\n            : destination === 'S3'\n            ? {\n                  bucket_name: !config.bucket_name ? 'This field is required' : '',\n                  region: !config.region ? 'This field is required' : '',\n                  prefix: !config.prefix ? 'This field is required' : '',\n                  aws_access_key_id: isNew ? (!config.aws_access_key_id ? 'This field is required' : '') : '',\n                  aws_secret_access_key: isNew ? (!config.aws_secret_access_key ? 'This field is required' : '') : '',\n                  compression: '',\n                  encryption: '',\n                  kms_key_id: !config.kms_key_id && config.encryption == 'aws:kms' ? 'This field is required' : '',\n                  exclude_events: '',\n                  include_events: '',\n              }\n            : destination === 'BigQuery'\n            ? {\n                  json_config_file: isNew\n                      ? !config.json_config_file\n                          ? 'This field is required'\n                          : !config.project_id ||\n                            !config.private_key ||\n                            !config.private_key_id ||\n                            !config.client_email ||\n                            !config.token_uri\n                          ? 'The config file is not valid'\n                          : ''\n                      : '',\n                  dataset_id: !config.dataset_id ? 'This field is required' : '',\n                  table_id: !config.table_id ? 'This field is required' : '',\n                  exclude_events: '',\n                  include_events: '',\n                  use_json_type: '',\n              }\n            : destination === 'Snowflake'\n            ? {\n                  account: !config.account ? 'This field is required' : '',\n                  database: !config.database ? 'This field is required' : '',\n                  warehouse: !config.warehouse ? 'This field is required' : '',\n                  user: isNew ? (!config.user ? 'This field is required' : '') : '',\n                  password: isNew ? (!config.password ? 'This field is required' : '') : '',\n                  schema: !config.schema ? 'This field is required' : '',\n                  table_name: !config.table_name ? 'This field is required' : '',\n                  role: '',\n                  exclude_events: '',\n                  include_events: '',\n              }\n            : {}),\n    }\n}\n\nexport const batchExportsEditLogic = kea<batchExportsEditLogicType>([\n    props({} as BatchExportsEditLogicProps),\n    key(({ id }) => id),\n    path((key) => ['scenes', 'batch_exports', 'batchExportsEditLogic', key]),\n    connect((props: BatchExportsEditLogicProps) => ({\n        values: [batchExportLogic(props), ['batchExportConfig', 'batchExportConfigLoading']],\n        actions: [batchExportLogic(props), ['loadBatchExportConfig', 'loadBatchExportConfigSuccess']],\n    })),\n\n    actions({\n        cancelEditing: true,\n    }),\n\n    forms(({ props, actions }) => ({\n        batchExportConfigForm: {\n            defaults: {\n                name: '',\n            } as BatchExportConfigurationForm,\n            errors: (form) => batchExportFormFields(props.id === 'new', form),\n            submit: async ({ name, destination, interval, start_at, end_at, paused, ...config }) => {\n                const destinationObject: BatchExportDestination =\n                    destination === 'Postgres'\n                        ? ({\n                              type: 'Postgres',\n                              config: config,\n                          } as unknown as BatchExportDestinationPostgres)\n                        : destination === 'S3'\n                        ? ({\n                              type: 'S3',\n                              config: config,\n                          } as unknown as BatchExportDestinationS3)\n                        : destination === 'Redshift'\n                        ? ({\n                              type: 'Redshift',\n                              config: config,\n                          } as unknown as BatchExportDestinationRedshift)\n                        : destination === 'BigQuery'\n                        ? ({\n                              type: 'BigQuery',\n                              config: config,\n                          } as unknown as BatchExportDestinationBigQuery)\n                        : ({\n                              type: 'Snowflake',\n                              config: config,\n                          } as unknown as BatchExportDestinationSnowflake)\n\n                const data: Omit<BatchExportConfiguration, 'id' | 'created_at' | 'team_id'> = {\n                    paused,\n                    name,\n                    interval,\n                    start_at: start_at?.toISOString() ?? null,\n                    end_at: end_at?.toISOString() ?? null,\n                    destination: destinationObject,\n                }\n\n                const result =\n                    props.id === 'new'\n                        ? await api.batchExports.create(data)\n                        : await api.batchExports.update(props.id, data)\n\n                await new Promise((resolve) => setTimeout(resolve, 1000))\n\n                actions.resetBatchExportConfigForm()\n                router.actions.replace(urls.batchExport(result.id))\n\n                return\n            },\n        },\n    })),\n\n    listeners(({ values, props, actions }) => ({\n        cancelEditing: () => {\n            if (values.isNew) {\n                router.actions.push(urls.batchExports())\n            } else {\n                router.actions.push(urls.batchExport(props.id))\n            }\n        },\n\n        setBatchExportConfigFormValue: async ({ name, value }) => {\n            if (name[0] === 'json_config_file' && value) {\n                try {\n                    const loadedFile: string = await new Promise((resolve, reject) => {\n                        const filereader = new FileReader()\n                        filereader.onload = (e) => resolve(e.target?.result as string)\n                        filereader.onerror = (e) => reject(e)\n                        filereader.readAsText(value[0])\n                    })\n                    const jsonConfig = JSON.parse(loadedFile)\n                    actions.setBatchExportConfigFormValues({\n                        ...values.batchExportConfigForm,\n                        project_id: jsonConfig.project_id,\n                        private_key: jsonConfig.private_key,\n                        private_key_id: jsonConfig.private_key_id,\n                        client_email: jsonConfig.client_email,\n                        token_uri: jsonConfig.token_uri,\n                    })\n                } catch (e) {\n                    actions.setBatchExportConfigFormManualErrors({\n                        json_config_file: 'The config file is not valid',\n                    })\n                }\n            }\n        },\n\n        loadBatchExportConfigSuccess: ({ batchExportConfig }) => {\n            if (!batchExportConfig) {\n                return\n            }\n\n            const destination = batchExportConfig.destination.type\n\n            const transformedConfig: BatchExportConfigurationForm = {\n                ...batchExportConfig,\n                destination,\n                start_at: batchExportConfig.start_at ? dayjs(batchExportConfig.start_at) : null,\n                end_at: batchExportConfig.end_at ? dayjs(batchExportConfig.end_at) : null,\n                ...batchExportConfig.destination.config,\n            }\n\n            // Filter out any values that aren't part of our from\n\n            const validFormFields = Object.keys(batchExportFormFields(props.id === 'new', transformedConfig))\n\n            Object.keys(transformedConfig).forEach((key) => {\n                if (!validFormFields.includes(key)) {\n                    delete transformedConfig[key]\n                }\n            })\n\n            actions.resetBatchExportConfigForm(transformedConfig)\n        },\n    })),\n\n    selectors({\n        isNew: [() => [(_, props) => props], (props): boolean => props.id === 'new'],\n        breadcrumbs: [\n            (s) => [s.batchExportConfig, s.isNew],\n            (config, isNew): Breadcrumb[] => [\n                {\n                    key: Scene.BatchExports,\n                    name: 'Batch Exports',\n                    path: urls.batchExports(),\n                },\n                ...(isNew\n                    ? [\n                          {\n                              key: 'new',\n                              name: 'New',\n                          },\n                      ]\n                    : [\n                          {\n                              key: config?.id ?? 'loading',\n                              name: config?.name,\n                              path: config?.id ? urls.batchExport(config.id) : undefined,\n                          },\n                          {\n                              key: 'edit',\n                              name: 'Edit',\n                          },\n                      ]),\n            ],\n        ],\n    }),\n\n    afterMount(({ values, actions }) => {\n        if (!values.isNew) {\n            if (values.batchExportConfig) {\n                actions.loadBatchExportConfigSuccess(values.batchExportConfig)\n            } else {\n                actions.loadBatchExportConfig()\n            }\n        }\n    }),\n\n    beforeUnload(({ values }) => ({\n        enabled: () => values.batchExportConfigFormChanged,\n        message: `Leave?\\nChanges you made will be discarded.`,\n    })),\n])\n","import { LemonButton, LemonSelectOptions, LemonTable, LemonTag, Link } from '@posthog/lemon-ui'\nimport clsx from 'clsx'\nimport { useActions, useValues } from 'kea'\nimport { useResizeBreakpoints } from 'lib/hooks/useResizeObserver'\nimport {\n    IconArticle,\n    IconCheckCircleOutline,\n    IconCheckmark,\n    IconChevronRight,\n    IconExpandMore,\n    IconInfo,\n    IconPlus,\n} from 'lib/lemon-ui/icons'\nimport { LemonBanner } from 'lib/lemon-ui/LemonBanner'\nimport { More } from 'lib/lemon-ui/LemonButton/More'\nimport { Tooltip } from 'lib/lemon-ui/Tooltip'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { capitalizeFirstLetter, compactNumber } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport posthog from 'posthog-js'\nimport { getProductIcon } from 'scenes/products/Products'\n\nimport { BillingProductV2AddonType, BillingProductV2Type, BillingV2TierType } from '~/types'\n\nimport { convertLargeNumberToWords, getUpgradeProductLink, summarizeUsage } from './billing-utils'\nimport { BillingGauge } from './BillingGauge'\nimport { BillingLimitInput } from './BillingLimitInput'\nimport { billingLogic } from './billingLogic'\nimport { billingProductLogic } from './billingProductLogic'\nimport { PlanComparisonModal } from './PlanComparison'\nimport { ProductPricingModal } from './ProductPricingModal'\nimport { UnsubscribeSurveyModal } from './UnsubscribeSurveyModal'\n\nconst UNSUBSCRIBE_SURVEY_ID = '018b6e13-590c-0000-decb-c727a2b3f462'\n\nexport const getTierDescription = (\n    tiers: BillingV2TierType[],\n    i: number,\n    product: BillingProductV2Type | BillingProductV2AddonType,\n    interval: string\n): string => {\n    return i === 0\n        ? `First ${summarizeUsage(tiers[i].up_to)} ${product.unit}s / ${interval}`\n        : tiers[i].up_to\n        ? `${summarizeUsage(tiers?.[i - 1].up_to || null)} - ${summarizeUsage(tiers[i].up_to)}`\n        : `> ${summarizeUsage(tiers?.[i - 1].up_to || null)}`\n}\n\nexport const BillingProductAddon = ({ addon }: { addon: BillingProductV2AddonType }): JSX.Element => {\n    const { billing, redirectPath } = useValues(billingLogic)\n    const { isPricingModalOpen, currentAndUpgradePlans, surveyID } = useValues(billingProductLogic({ product: addon }))\n    const { toggleIsPricingModalOpen, reportSurveyShown, setSurveyResponse } = useActions(\n        billingProductLogic({ product: addon })\n    )\n    const { featureFlags } = useValues(featureFlagLogic)\n    const { setProductSpecificAlert } = useActions(billingLogic)\n\n    const productType = { plural: `${addon.unit}s`, singular: addon.unit }\n    const tierDisplayOptions: LemonSelectOptions<string> = [\n        { label: `Per ${productType.singular}`, value: 'individual' },\n    ]\n\n    if (billing?.has_active_subscription) {\n        tierDisplayOptions.push({ label: `Current bill`, value: 'total' })\n    }\n\n    const isOGPipelineAddon =\n        addon.type === 'data_pipelines' &&\n        addon.subscribed &&\n        addon.plans?.[0]?.plan_key === 'addon-20240111-og-customers'\n\n    if (isOGPipelineAddon && featureFlags['data-pipelines-notice']) {\n        setProductSpecificAlert({\n            status: 'info',\n            title: 'Welcome to the data pipelines addon!',\n            message: `We've moved data export features (and cost) here to better reflect user needs. Your overall\n                    price hasn't changed.`,\n            action: {\n                onClick: () => {\n                    posthog.capture('data pipelines notice clicked')\n                    // if they don't dismiss it now, we won't show it next time they come back\n                    posthog.capture('data pipelines notice dismissed', {\n                        $set: {\n                            dismissedDataPipelinesNotice: true,\n                        },\n                    })\n                },\n                children: 'Learn more',\n                to: 'https://posthog.com/changelog/2024#data-pipeline-add-on-launched',\n                targetBlank: true,\n            },\n            dismissKey: 'data-pipelines-notice',\n            onClose: () => {\n                posthog.capture('data pipelines notice dismissed', {\n                    $set: {\n                        dismissedDataPipelinesNotice: true,\n                    },\n                })\n            },\n        })\n    }\n    return (\n        <div className=\"bg-side rounded p-6 flex flex-col\">\n            <div className=\"flex justify-between gap-x-4\">\n                <div className=\"flex gap-x-4\">\n                    <div className=\"w-8\">{getProductIcon(addon.icon_key, 'text-2xl')}</div>\n                    <div>\n                        <div className=\"flex gap-x-2 items-center mt-0 mb-2 \">\n                            <h4 className=\"leading-5 mb-1 font-bold\">{addon.name}</h4>\n                            {addon.subscribed && (\n                                <div>\n                                    <LemonTag type=\"primary\" icon={<IconCheckmark />}>\n                                        Subscribed\n                                    </LemonTag>\n                                </div>\n                            )}\n                        </div>\n                        <p className=\"ml-0 mb-0\">{addon.description}</p>\n                        {isOGPipelineAddon && (\n                            <div className=\"mt-2\">\n                                <Link\n                                    targetBlankIcon\n                                    target=\"_blank\"\n                                    to=\"https://posthog.com/changelog/2024#data-pipeline-add-on-launched\"\n                                >\n                                    <span className=\"text-xs italic\">Why am I subscribed to this?</span>\n                                </Link>\n                            </div>\n                        )}\n                    </div>\n                </div>\n                <div className=\"ml-4 mr-4 mt-2 self-center flex gap-x-2 whitespace-nowrap\">\n                    {addon.docs_url && (\n                        <Tooltip title=\"Read the docs\">\n                            <LemonButton icon={<IconArticle />} size=\"small\" to={addon.docs_url} />\n                        </Tooltip>\n                    )}\n                    {addon.subscribed ? (\n                        <>\n                            <More\n                                overlay={\n                                    <>\n                                        <LemonButton\n                                            fullWidth\n                                            onClick={() => {\n                                                setSurveyResponse(addon.type, '$survey_response_1')\n                                                reportSurveyShown(UNSUBSCRIBE_SURVEY_ID, addon.type)\n                                            }}\n                                        >\n                                            Remove addon\n                                        </LemonButton>\n                                    </>\n                                }\n                            />\n                        </>\n                    ) : addon.included_with_main_product ? (\n                        <LemonTag type=\"completion\" icon={<IconCheckmark />}>\n                            Included with plan\n                        </LemonTag>\n                    ) : (\n                        <>\n                            <LemonButton\n                                type=\"secondary\"\n                                disableClientSideRouting\n                                onClick={() => {\n                                    toggleIsPricingModalOpen()\n                                }}\n                            >\n                                View pricing\n                            </LemonButton>\n                            <LemonButton\n                                type=\"primary\"\n                                icon={<IconPlus />}\n                                size=\"small\"\n                                to={`/api/billing-v2/activation?products=${addon.type}:${\n                                    currentAndUpgradePlans?.upgradePlan?.plan_key\n                                }${redirectPath && `&redirect_path=${redirectPath}`}`}\n                                disableClientSideRouting\n                            >\n                                Add\n                            </LemonButton>\n                        </>\n                    )}\n                </div>\n            </div>\n            <ProductPricingModal\n                modalOpen={isPricingModalOpen}\n                onClose={toggleIsPricingModalOpen}\n                product={addon}\n                planKey={\n                    addon.subscribed\n                        ? currentAndUpgradePlans?.currentPlan?.plan_key\n                        : currentAndUpgradePlans?.upgradePlan?.plan_key\n                }\n            />\n            {surveyID && <UnsubscribeSurveyModal product={addon} />}\n        </div>\n    )\n}\n\nexport const BillingProduct = ({ product }: { product: BillingProductV2Type }): JSX.Element => {\n    const { billing, redirectPath, isOnboarding, isUnlicensedDebug } = useValues(billingLogic)\n    const {\n        customLimitUsd,\n        showTierBreakdown,\n        billingGaugeItems,\n        isPricingModalOpen,\n        isPlanComparisonModalOpen,\n        currentAndUpgradePlans,\n        surveyID,\n    } = useValues(billingProductLogic({ product }))\n    const {\n        setIsEditingBillingLimit,\n        setShowTierBreakdown,\n        toggleIsPricingModalOpen,\n        toggleIsPlanComparisonModalOpen,\n        reportSurveyShown,\n        setSurveyResponse,\n    } = useActions(billingProductLogic({ product }))\n    const { reportBillingUpgradeClicked } = useActions(eventUsageLogic)\n\n    const showUpgradeCTA = !product.subscribed && !product.contact_support && product.plans?.length\n    const upgradePlan = currentAndUpgradePlans?.upgradePlan\n    const currentPlan = currentAndUpgradePlans?.currentPlan\n    const downgradePlan = currentAndUpgradePlans?.downgradePlan\n    const additionalFeaturesOnUpgradedPlan = upgradePlan\n        ? upgradePlan?.features?.filter(\n              (feature) =>\n                  !currentPlan?.features?.some((currentPlanFeature) => currentPlanFeature.name === feature.name)\n          )\n        : currentPlan?.features?.filter(\n              (feature) =>\n                  !downgradePlan?.features?.some((downgradePlanFeature) => downgradePlanFeature.name === feature.name)\n          )\n\n    const upgradeToPlanKey = upgradePlan?.plan_key\n    const currentPlanKey = currentPlan?.plan_key\n\n    const { ref, size } = useResizeBreakpoints({\n        0: 'small',\n        700: 'medium',\n    })\n\n    const addonPriceColumns = product.addons\n        // only get addons that are subscribed or were subscribed and have a projected amount\n        ?.filter((addon) => addon.subscribed || parseFloat(addon.projected_amount_usd || ''))\n        .map((addon) => ({\n            title: `${addon.name} price`,\n            dataIndex: `${addon.type}-price`,\n        }))\n\n    const tableColumns = [\n        { title: `Priced per ${product.unit}`, dataIndex: 'volume' },\n        { title: addonPriceColumns?.length > 0 ? 'Base price' : 'Price', dataIndex: 'basePrice' },\n        ...(addonPriceColumns || []),\n        { title: 'Current Usage', dataIndex: 'usage' },\n        { title: 'Total', dataIndex: 'total' },\n        { title: 'Projected Total', dataIndex: 'projectedTotal' },\n    ]\n\n    type TableTierDatum = {\n        volume: string\n        basePrice: string\n        [addonPrice: string]: string\n        usage: string\n        total: string\n        projectedTotal: string\n    }\n\n    // TODO: SUPPORT NON-TIERED PRODUCT TYPES\n    // still use the table, but the data will be different\n    const tableTierData: TableTierDatum[] | undefined =\n        product.tiers && product.tiers.length > 0\n            ? product.tiers\n                  ?.map((tier, i) => {\n                      const addonPricesForTier = product.addons?.map((addon) => ({\n                          [`${addon.type}-price`]: `${\n                              addon.tiers?.[i]?.unit_amount_usd !== '0'\n                                  ? '$' + addon.tiers?.[i]?.unit_amount_usd\n                                  : 'Free'\n                          }`,\n                      }))\n                      // take the tier.current_amount_usd and add it to the same tier level for all the addons\n                      const totalForTier =\n                          parseFloat(tier.current_amount_usd || '') +\n                          (product.addons?.reduce(\n                              (acc, addon) => acc + parseFloat(addon.tiers?.[i]?.current_amount_usd || ''),\n                              0\n                              // if there aren't any addons we get NaN from the above, so we need to default to 0\n                          ) || 0)\n                      const projectedTotalForTier =\n                          (parseFloat(tier.projected_amount_usd || '') || 0) +\n                          product.addons?.reduce(\n                              (acc, addon) => acc + (parseFloat(addon.tiers?.[i]?.projected_amount_usd || '') || 0),\n                              0\n                          )\n\n                      const tierData = {\n                          volume: product.tiers // this is silly because we know there are tiers since we check above, but typescript doesn't\n                              ? getTierDescription(product.tiers, i, product, billing?.billing_period?.interval || '')\n                              : '',\n                          basePrice: tier.unit_amount_usd !== '0' ? `$${tier.unit_amount_usd}` : 'Free',\n                          usage: compactNumber(tier.current_usage),\n                          total: `$${totalForTier.toFixed(2) || '0.00'}`,\n                          projectedTotal: `$${projectedTotalForTier.toFixed(2) || '0.00'}`,\n                      }\n                      // if there are any addon prices we need to include, put them in the table\n                      addonPricesForTier?.map((addonPrice) => {\n                          Object.assign(tierData, addonPrice)\n                      })\n                      return tierData\n                  })\n                  // Add a row at the end for the total\n                  .concat({\n                      volume: 'Total',\n                      basePrice: '',\n                      usage: '',\n                      total: `$${product.current_amount_usd || '0.00'}`,\n                      projectedTotal: `$${product.projected_amount_usd || '0.00'}`,\n                  })\n            : undefined\n\n    if (billing?.discount_percent && parseFloat(product.projected_amount_usd || '')) {\n        // If there is a discount, add a row for the total after discount if there is also a projected amount\n        tableTierData?.push({\n            volume: 'Total after discount',\n            basePrice: '',\n            usage: '',\n            total: `$${\n                (parseInt(product.current_amount_usd || '0') * (1 - billing?.discount_percent / 100)).toFixed(2) ||\n                '0.00'\n            }`,\n            projectedTotal: `$${\n                (\n                    parseInt(product.projected_amount_usd || '0') -\n                    parseInt(product.projected_amount_usd || '0') * (billing?.discount_percent / 100)\n                ).toFixed(2) || '0.00'\n            }`,\n        })\n    }\n\n    return (\n        <div\n            className={clsx('flex flex-wrap max-w-300 pb-12', {\n                'flex-col pb-4': size === 'small',\n            })}\n            ref={ref}\n        >\n            <div className=\"border border-border rounded w-full bg-bg-light\">\n                <div className=\"border-b border-border bg-mid p-4\">\n                    <div className=\"flex gap-4 items-center justify-between\">\n                        {getProductIcon(product.icon_key, 'text-2xl')}\n                        <div>\n                            <h3 className=\"font-bold mb-0\">{product.name}</h3>\n                            <div>{product.description}</div>\n                        </div>\n                        <div className=\"flex grow justify-end gap-x-2 items-center\">\n                            {product.docs_url && (\n                                <Tooltip title=\"Read the docs\">\n                                    <LemonButton\n                                        icon={<IconArticle />}\n                                        size=\"small\"\n                                        to={product.docs_url}\n                                        className=\"justify-end\"\n                                    />\n                                </Tooltip>\n                            )}\n                            {product.contact_support ? (\n                                <>\n                                    {product.subscribed && <p className=\"m-0\">Need to manage your plan?</p>}\n                                    <LemonButton\n                                        type=\"primary\"\n                                        to=\"mailto:sales@posthog.com?subject=Enterprise%20plan%20request\"\n                                    >\n                                        Get in touch\n                                    </LemonButton>\n                                </>\n                            ) : (\n                                product.subscribed && (\n                                    <More\n                                        overlay={\n                                            <>\n                                                {billing?.billing_period?.interval == 'month' && (\n                                                    <LemonButton\n                                                        fullWidth\n                                                        onClick={() => setIsEditingBillingLimit(true)}\n                                                    >\n                                                        Set billing limit\n                                                    </LemonButton>\n                                                )}\n                                                <LemonButton\n                                                    fullWidth\n                                                    to=\"https://posthog.com/docs/billing/estimating-usage-costs#how-to-reduce-your-posthog-costs\"\n                                                >\n                                                    Learn how to reduce your bill\n                                                </LemonButton>\n                                                {product.plans?.length > 0 ? (\n                                                    <LemonButton\n                                                        fullWidth\n                                                        onClick={() => {\n                                                            setSurveyResponse(product.type, '$survey_response_1')\n                                                            reportSurveyShown(UNSUBSCRIBE_SURVEY_ID, product.type)\n                                                        }}\n                                                    >\n                                                        Unsubscribe\n                                                    </LemonButton>\n                                                ) : (\n                                                    <LemonButton\n                                                        fullWidth\n                                                        to=\"mailto:sales@posthog.com?subject=Custom%20plan%20unsubscribe%20request\"\n                                                    >\n                                                        Contact support to unsubscribe\n                                                    </LemonButton>\n                                                )}\n                                            </>\n                                        }\n                                    />\n                                )\n                            )}\n                            {surveyID && <UnsubscribeSurveyModal product={product} />}\n                        </div>\n                    </div>\n                </div>\n                <div className=\"px-8\">\n                    {product.percentage_usage > 1 ? (\n                        <LemonBanner type=\"error\">\n                            You have exceeded the {customLimitUsd ? 'billing limit' : 'free tier limit'} for this\n                            product.\n                        </LemonBanner>\n                    ) : null}\n                    <div className=\"flex w-full items-center gap-x-8\">\n                        {product.contact_support && (!product.subscribed || isUnlicensedDebug) ? (\n                            <div className=\"py-8\">\n                                {!billing?.has_active_subscription && (\n                                    <p className=\"ml-0\">\n                                        Every product subsciption comes with free platform features such as{' '}\n                                        <b>Multiple projects, Integrations, Apps, and more</b>. Subscribe to one of the\n                                        products above to get instant access.\n                                    </p>\n                                )}\n                                <p className=\"m-0\">\n                                    Need additional platform and support (aka enterprise) features like <b>SAML SSO</b>,{' '}\n                                    <b>advanced permissioning</b>, and more?{' '}\n                                    <Link to=\"mailto:sales@posthog.com?subject=Enterprise%20plan%20request\">\n                                        Get in touch\n                                    </Link>{' '}\n                                    for a quick chat.\n                                </p>\n                            </div>\n                        ) : (\n                            !isOnboarding &&\n                            !isUnlicensedDebug && (\n                                <>\n                                    {product.tiered ? (\n                                        <>\n                                            {product.subscribed && (\n                                                <LemonButton\n                                                    icon={showTierBreakdown ? <IconExpandMore /> : <IconChevronRight />}\n                                                    onClick={() => setShowTierBreakdown(!showTierBreakdown)}\n                                                />\n                                            )}\n                                            <div className=\"grow\">\n                                                <BillingGauge items={billingGaugeItems} product={product} />\n                                            </div>\n                                            {product.current_amount_usd ? (\n                                                <div className=\"flex justify-end gap-8 flex-wrap items-end\">\n                                                    <Tooltip\n                                                        title={`The current ${\n                                                            billing?.discount_percent ? 'discounted ' : ''\n                                                        }amount you have been billed for this ${\n                                                            billing?.billing_period?.interval\n                                                        } so far.`}\n                                                        className=\"flex flex-col items-center\"\n                                                    >\n                                                        <div className=\"font-bold text-3xl leading-7\">\n                                                            $\n                                                            {(\n                                                                parseFloat(product.current_amount_usd || '') *\n                                                                (1 -\n                                                                    (billing?.discount_percent\n                                                                        ? billing.discount_percent / 100\n                                                                        : 0))\n                                                            ).toFixed(2) || '0.00'}\n                                                        </div>\n                                                        <span className=\"text-xs text-muted\">\n                                                            {capitalizeFirstLetter(\n                                                                billing?.billing_period?.interval || ''\n                                                            )}\n                                                            -to-date\n                                                        </span>\n                                                    </Tooltip>\n                                                    {product.tiers && (\n                                                        <Tooltip\n                                                            title={`This is roughly calculated based on your current bill${\n                                                                billing?.discount_percent\n                                                                    ? ', discounts on your account,'\n                                                                    : ''\n                                                            } and the remaining time left in this billing period.`}\n                                                            className=\"flex flex-col items-center justify-end\"\n                                                        >\n                                                            <div className=\"font-bold text-muted text-lg leading-5\">\n                                                                $\n                                                                {(\n                                                                    parseFloat(product.projected_amount_usd || '') *\n                                                                    (1 -\n                                                                        (billing?.discount_percent\n                                                                            ? billing.discount_percent / 100\n                                                                            : 0))\n                                                                ).toFixed(2) || '0.00'}\n                                                            </div>\n                                                            <span className=\"text-xs text-muted\">Projected</span>\n                                                        </Tooltip>\n                                                    )}\n                                                </div>\n                                            ) : null}\n                                        </>\n                                    ) : (\n                                        <div className=\"my-8\">\n                                            <Tooltip\n                                                title={`The current amount you will be billed for this ${billing?.billing_period?.interval}.`}\n                                                className=\"flex flex-col items-center\"\n                                            >\n                                                <div className=\"font-bold text-3xl leading-7\">\n                                                    ${product.current_amount_usd}\n                                                </div>\n                                                <span className=\"text-xs text-muted\">\n                                                    per {billing?.billing_period?.interval || 'period'}\n                                                </span>\n                                            </Tooltip>\n                                        </div>\n                                    )}\n                                </>\n                            )\n                        )}\n                    </div>\n                    {product.price_description ? (\n                        <LemonBanner type=\"info\">\n                            <span dangerouslySetInnerHTML={{ __html: product.price_description }} />\n                        </LemonBanner>\n                    ) : null}\n                    {/* Table with tiers */}\n                    {showTierBreakdown && (\n                        <div className=\"pl-16 pb-8\">\n                            {product.tiered && tableTierData ? (\n                                <>\n                                    <LemonTable\n                                        stealth\n                                        embedded\n                                        size=\"small\"\n                                        uppercaseHeader={false}\n                                        columns={tableColumns}\n                                        dataSource={tableTierData}\n                                    />\n                                    {product.type === 'feature_flags' && (\n                                        <p className=\"mt-4 ml-0 text-sm text-muted italic\">\n                                            <IconInfo className=\"mr-1\" />\n                                            Using local evaluation? Here's{' '}\n                                            <Link\n                                                to=\"https://posthog.com/docs/feature-flags/bootstrapping-and-local-evaluation#server-side-local-evaluation\"\n                                                className=\"italic\"\n                                            >\n                                                how we calculate usage\n                                            </Link>\n                                            .\n                                        </p>\n                                    )}\n                                </>\n                            ) : (\n                                <LemonTable\n                                    stealth\n                                    embedded\n                                    size=\"small\"\n                                    uppercaseHeader={false}\n                                    columns={[\n                                        { title: '', dataIndex: 'name' },\n                                        { title: 'Total', dataIndex: 'total' },\n                                    ]}\n                                    dataSource={[\n                                        {\n                                            name: product.name,\n                                            total: product.unit_amount_usd,\n                                        },\n                                    ]}\n                                />\n                            )}\n                        </div>\n                    )}\n                    {!isOnboarding && product.addons?.length > 0 && (\n                        <div className=\"pb-8\">\n                            <h4 className=\"my-4\">Addons</h4>\n                            <div className=\"gap-y-4 flex flex-col\">\n                                {product.addons.map((addon, i) => {\n                                    return <BillingProductAddon key={i} addon={addon} />\n                                })}\n                            </div>\n                        </div>\n                    )}\n                </div>\n                {(showUpgradeCTA || (isOnboarding && !product.contact_support)) && (\n                    <div\n                        data-attr={`upgrade-card-${product.type}`}\n                        className={`border-t border-border p-8 flex justify-between ${\n                            product.subscribed ? 'bg-success-highlight' : 'bg-warning-highlight'\n                        }`}\n                    >\n                        <div>\n                            <h4 className={`${product.subscribed ? 'text-success-dark' : 'text-warning-dark'}`}>\n                                You're on the {product.subscribed ? 'paid' : 'free'} plan for {product.name}.\n                            </h4>\n                            {additionalFeaturesOnUpgradedPlan?.length > 0 ? (\n                                <>\n                                    <p className=\"ml-0 max-w-200\">\n                                        {product.subscribed ? 'You now' : 'Upgrade to'} get sweet features such as:\n                                    </p>\n                                    <div>\n                                        {additionalFeaturesOnUpgradedPlan?.map((feature, i) => {\n                                            return (\n                                                i < 3 && (\n                                                    <div\n                                                        className=\"flex gap-x-2 items-center mb-2\"\n                                                        key={'additional-features-' + product.type + i}\n                                                    >\n                                                        <IconCheckCircleOutline className=\"text-success\" />\n                                                        <Tooltip key={feature.key} title={feature.description}>\n                                                            <b>{feature.name} </b>\n                                                        </Tooltip>\n                                                    </div>\n                                                )\n                                            )\n                                        })}\n                                        {!billing?.has_active_subscription && (\n                                            <div className=\"flex gap-x-2 items-center mb-2\">\n                                                <IconCheckCircleOutline className=\"text-success\" />\n                                                <Tooltip title=\"Multiple projects, Feature flags, Experiments, Integrations, Apps, and more\">\n                                                    <b>Upgraded platform features</b>\n                                                </Tooltip>\n                                            </div>\n                                        )}\n                                        <div className=\"flex gap-x-2 items-center mb-2\">\n                                            <IconCheckCircleOutline className=\"text-success\" />\n                                            {product.subscribed ? (\n                                                <b>And more</b>\n                                            ) : (\n                                                <Link onClick={toggleIsPlanComparisonModalOpen}>\n                                                    <b>And more...</b>\n                                                </Link>\n                                            )}\n                                        </div>\n                                    </div>\n                                </>\n                            ) : (\n                                <p className=\"ml-0 max-w-200\">\n                                    You've got access to all the features we offer for {product.name}.\n                                </p>\n                            )}\n                            {upgradePlan?.tiers?.[0].unit_amount_usd &&\n                                parseInt(upgradePlan?.tiers?.[0].unit_amount_usd) === 0 && (\n                                    <p className=\"ml-0 mb-0 mt-4\">\n                                        <b>\n                                            First {convertLargeNumberToWords(upgradePlan?.tiers?.[0].up_to, null)}{' '}\n                                            {product.unit}s free\n                                        </b>\n                                        , then ${upgradePlan?.tiers?.[1]?.unit_amount_usd}/{product.unit} with volume\n                                        discounts.\n                                    </p>\n                                )}\n                        </div>\n                        {!product.subscribed && (\n                            <div className=\"ml-4\">\n                                <div className=\"flex flex-wrap gap-x-2 gap-y-2\">\n                                    <LemonButton\n                                        type=\"secondary\"\n                                        onClick={toggleIsPlanComparisonModalOpen}\n                                        className=\"grow\"\n                                        center\n                                    >\n                                        Compare plans\n                                    </LemonButton>\n                                    <LemonButton\n                                        to={getUpgradeProductLink(\n                                            product,\n                                            upgradeToPlanKey || '',\n                                            redirectPath,\n                                            isOnboarding // if in onboarding, we want to include addons, otherwise don't\n                                        )}\n                                        type=\"primary\"\n                                        icon={<IconPlus />}\n                                        disableClientSideRouting\n                                        onClick={() => {\n                                            reportBillingUpgradeClicked(product.type)\n                                        }}\n                                        className=\"grow\"\n                                        center\n                                    >\n                                        Upgrade\n                                    </LemonButton>\n                                </div>\n                            </div>\n                        )}\n                        <PlanComparisonModal\n                            product={product}\n                            includeAddons={isOnboarding}\n                            modalOpen={isPlanComparisonModalOpen}\n                            onClose={toggleIsPlanComparisonModalOpen}\n                        />\n                    </div>\n                )}\n                <BillingLimitInput product={product} />\n            </div>\n            <ProductPricingModal\n                modalOpen={isPricingModalOpen}\n                onClose={toggleIsPricingModalOpen}\n                product={product}\n                planKey={product.subscribed ? currentPlanKey : upgradeToPlanKey}\n            />\n        </div>\n    )\n}\n","import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, afterMount, connect, kea, listeners, path, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { LemonBannerAction } from 'lib/lemon-ui/LemonBanner/LemonBanner'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { pluralize } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport posthog from 'posthog-js'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { BillingProductV2Type, BillingV2Type, ProductKey } from '~/types'\n\nimport type { billingLogicType } from './billingLogicType'\n\nexport const ALLOCATION_THRESHOLD_ALERT = 0.85 // Threshold to show warning of event usage near limit\nexport const ALLOCATION_THRESHOLD_BLOCK = 1.2 // Threshold to block usage\n\nexport interface BillingAlertConfig {\n    status: 'info' | 'warning' | 'error'\n    title: string\n    message?: string\n    contactSupport?: boolean\n    buttonCTA?: string\n    dismissKey?: string\n    action?: LemonBannerAction\n    pathName?: string\n    onClose?: () => void\n}\n\nconst parseBillingResponse = (data: Partial<BillingV2Type>): BillingV2Type => {\n    if (data.billing_period) {\n        data.billing_period = {\n            current_period_start: dayjs(data.billing_period.current_period_start),\n            current_period_end: dayjs(data.billing_period.current_period_end),\n            interval: data.billing_period.interval,\n        }\n    }\n\n    data.free_trial_until = data.free_trial_until ? dayjs(data.free_trial_until) : undefined\n    data.amount_off_expires_at = data.amount_off_expires_at ? dayjs(data.amount_off_expires_at) : undefined\n    // If expiration is in the middle of the current period, we let it expire at the end of the period\n    if (\n        data.amount_off_expires_at &&\n        data.billing_period &&\n        data.amount_off_expires_at.isBefore(data.billing_period.current_period_end) &&\n        data.amount_off_expires_at.isAfter(data.billing_period.current_period_start)\n    ) {\n        data.amount_off_expires_at = data.billing_period.current_period_end\n    }\n\n    return data as BillingV2Type\n}\n\nexport const billingLogic = kea<billingLogicType>([\n    path(['scenes', 'billing', 'billingLogic']),\n    actions({\n        setProductSpecificAlert: (productSpecificAlert: BillingAlertConfig | null) => ({ productSpecificAlert }),\n        setScrollToProductKey: (scrollToProductKey: ProductKey | null) => ({ scrollToProductKey }),\n        setShowLicenseDirectInput: (show: boolean) => ({ show }),\n        reportBillingAlertShown: (alertConfig: BillingAlertConfig) => ({ alertConfig }),\n        reportBillingAlertActionClicked: (alertConfig: BillingAlertConfig) => ({ alertConfig }),\n        reportBillingV2Shown: true,\n        registerInstrumentationProps: true,\n        setRedirectPath: true,\n        setIsOnboarding: true,\n    }),\n    connect({\n        values: [featureFlagLogic, ['featureFlags'], preflightLogic, ['preflight']],\n        actions: [userLogic, ['loadUser'], eventUsageLogic, ['reportProductUnsubscribed']],\n    }),\n    reducers({\n        scrollToProductKey: [\n            null as ProductKey | null,\n            {\n                setScrollToProductKey: (_, { scrollToProductKey }) => scrollToProductKey,\n            },\n        ],\n        productSpecificAlert: [\n            null as BillingAlertConfig | null,\n            {\n                setProductSpecificAlert: (_, { productSpecificAlert }) => productSpecificAlert,\n            },\n        ],\n        showLicenseDirectInput: [\n            false,\n            {\n                setShowLicenseDirectInput: (_, { show }) => show,\n            },\n        ],\n        redirectPath: [\n            '' as string,\n            {\n                setRedirectPath: () => {\n                    return window.location.pathname.includes('/onboarding')\n                        ? window.location.pathname + window.location.search\n                        : ''\n                },\n            },\n        ],\n        isOnboarding: [\n            false,\n            {\n                setIsOnboarding: () => window.location.pathname.includes('/onboarding'),\n            },\n        ],\n    }),\n    loaders(({ actions }) => ({\n        billing: [\n            null as BillingV2Type | null,\n            {\n                loadBilling: async () => {\n                    const response = await api.get('api/billing-v2')\n\n                    return parseBillingResponse(response)\n                },\n\n                updateBillingLimits: async (limits: { [key: string]: string | null }) => {\n                    const response = await api.update('api/billing-v2', { custom_limits_usd: limits })\n\n                    lemonToast.success('Billing limits updated')\n                    return parseBillingResponse(response)\n                },\n\n                deactivateProduct: async (key: string) => {\n                    const response = await api.get('api/billing-v2/deactivate?products=' + key)\n                    lemonToast.success('Product unsubscribed')\n                    actions.reportProductUnsubscribed(key)\n                    return parseBillingResponse(response)\n                },\n            },\n        ],\n        products: [\n            [] as BillingProductV2Type[],\n            {\n                loadProducts: async () => {\n                    const response = await api.get('api/billing-v2/available_products')\n                    return response\n                },\n            },\n        ],\n    })),\n    selectors({\n        upgradeLink: [(s) => [s.preflight], (): string => '/organization/billing'],\n        isUnlicensedDebug: [\n            (s) => [s.preflight, s.billing],\n            (preflight, billing): boolean => !!preflight?.is_debug && !billing?.billing_period,\n        ],\n        projectedTotalAmountUsd: [\n            (s) => [s.billing],\n            (billing: BillingV2Type): number => {\n                if (!billing) {\n                    return 0\n                }\n                let projectedTotal = 0\n                for (const product of billing.products || []) {\n                    projectedTotal += parseFloat(product.projected_amount_usd || '0')\n                }\n                return projectedTotal\n            },\n        ],\n        over20kAnnual: [\n            (s) => [s.billing, s.preflight, s.projectedTotalAmountUsd],\n            (billing, preflight, projectedTotalAmountUsd) => {\n                if (!billing || !preflight?.cloud) {\n                    return\n                }\n                if (\n                    billing.current_total_amount_usd_after_discount &&\n                    (parseFloat(billing.current_total_amount_usd_after_discount) > 1666 ||\n                        projectedTotalAmountUsd > 1666) &&\n                    billing.billing_period?.interval === 'month'\n                ) {\n                    return true\n                }\n                return\n            },\n        ],\n        isAnnualPlan: [\n            (s) => [s.billing],\n            (billing) => {\n                return billing?.billing_period?.interval === 'year'\n            },\n        ],\n        billingAlert: [\n            (s) => [s.billing, s.preflight, s.productSpecificAlert],\n            (billing, preflight, productSpecificAlert): BillingAlertConfig | undefined => {\n                if (productSpecificAlert) {\n                    return productSpecificAlert\n                }\n\n                if (!billing || !preflight?.cloud) {\n                    return\n                }\n\n                if (billing.free_trial_until && billing.free_trial_until.isAfter(dayjs())) {\n                    const remainingDays = billing.free_trial_until.diff(dayjs(), 'days')\n                    const remainingHours = billing.free_trial_until.diff(dayjs(), 'hours')\n\n                    if (remainingHours > 72) {\n                        return\n                    }\n\n                    return {\n                        status: 'info',\n                        title: `Your free trial will end in ${\n                            remainingHours < 24 ? pluralize(remainingHours, 'hour') : pluralize(remainingDays, 'day')\n                        }.`,\n                        message: `Setup billing now to ensure you don't lose access to premium features.`,\n                    }\n                }\n\n                if (billing.deactivated) {\n                    return {\n                        status: 'error',\n                        title: 'Your organization has been temporarily suspended.',\n                        message: 'Please contact support to reactivate it.',\n                        contactSupport: true,\n                    }\n                }\n\n                const productOverLimit = billing.products?.find((x: BillingProductV2Type) => {\n                    return x.percentage_usage > 1 && x.usage_key\n                })\n\n                if (productOverLimit) {\n                    return {\n                        status: 'error',\n                        title: 'Usage limit exceeded',\n                        message: `You have exceeded the usage limit for ${productOverLimit.name}. Please \n                            ${productOverLimit.subscribed ? 'increase your billing limit' : 'upgrade your plan'}\n                            or data loss may occur.`,\n                    }\n                }\n\n                const productApproachingLimit = billing.products?.find(\n                    (x) => x.percentage_usage > ALLOCATION_THRESHOLD_ALERT\n                )\n\n                if (productApproachingLimit) {\n                    return {\n                        status: 'info',\n                        title: 'You will soon hit your usage limit',\n                        message: `You have currently used ${parseFloat(\n                            (productApproachingLimit.percentage_usage * 100).toFixed(2)\n                        )}% of your ${\n                            productApproachingLimit.usage_key && productApproachingLimit.usage_key.toLowerCase()\n                        } allocation.`,\n                    }\n                }\n            },\n        ],\n    }),\n    forms(({ actions, values }) => ({\n        activateLicense: {\n            defaults: { license: '' } as { license: string },\n            errors: ({ license }) => ({\n                license: !license ? 'Please enter your license key' : undefined,\n            }),\n            submit: async ({ license }, breakpoint) => {\n                await breakpoint(500)\n                try {\n                    await api.update('api/billing-v2/license', {\n                        license,\n                    })\n\n                    // Reset the URL so we don't trigger the license submission again\n                    router.actions.replace(\n                        `/${values.isOnboarding ? 'ingestion' : 'organization'}/billing?success=true`\n                    )\n                    setTimeout(() => {\n                        window.location.reload() // Permissions, projects etc will be out of date at this point, so refresh\n                    }, 100)\n                } catch (e: any) {\n                    actions.setActivateLicenseManualErrors({\n                        license: e.detail || 'License could not be activated. Please contact support.',\n                    })\n                    throw e\n                }\n            },\n        },\n    })),\n    listeners(({ actions, values }) => ({\n        reportBillingV2Shown: () => {\n            posthog.capture('billing v2 shown')\n        },\n        reportBillingAlertShown: ({ alertConfig }) => {\n            posthog.capture('billing alert shown', {\n                ...alertConfig,\n            })\n        },\n        reportBillingAlertActionClicked: ({ alertConfig }) => {\n            posthog.capture('billing alert action clicked', {\n                ...alertConfig,\n            })\n        },\n        loadBillingSuccess: () => {\n            if (\n                router.values.location.pathname.includes('/organization/billing') &&\n                router.values.searchParams['success']\n            ) {\n                // if the activation is successful, we reload the user to get the updated billing info on the organization\n                actions.loadUser()\n                router.actions.replace('/organization/billing')\n            }\n            actions.registerInstrumentationProps()\n        },\n        registerInstrumentationProps: async (_, breakpoint) => {\n            await breakpoint(100)\n            if (posthog && values.billing) {\n                const payload = {\n                    has_billing_plan: !!values.billing.has_active_subscription,\n                    free_trial_until: values.billing.free_trial_until?.toISOString(),\n                    customer_deactivated: values.billing.deactivated,\n                    current_total_amount_usd: values.billing.current_total_amount_usd,\n                }\n                if (values.billing.custom_limits_usd) {\n                    for (const product of Object.keys(values.billing.custom_limits_usd)) {\n                        payload[`custom_limits_usd.${product}`] = values.billing.custom_limits_usd[product]\n                    }\n                }\n                if (values.billing.products) {\n                    for (const product of values.billing.products) {\n                        const type = product.type.toLowerCase()\n                        payload[`percentage_usage.${type}`] = product.percentage_usage\n                        payload[`current_amount_usd.${type}`] = product.current_amount_usd\n                        payload[`unit_amount_usd.${type}`] = product.unit_amount_usd\n                        payload[`usage_limit.${type}`] = product.usage_limit\n                        payload[`current_usage.${type}`] = product.current_usage\n                        payload[`projected_usage.${type}`] = product.projected_usage\n                        payload[`free_allocation.${type}`] = product.free_allocation\n                    }\n                }\n                if (values.billing.billing_period) {\n                    payload['billing_period_start'] = values.billing.billing_period.current_period_start\n                    payload['billing_period_end'] = values.billing.billing_period.current_period_end\n                }\n                posthog.register(payload)\n            }\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadBilling()\n    }),\n    urlToAction(({ actions }) => ({\n        // IMPORTANT: This needs to be above the \"*\" so it takes precedence\n        '/*/billing': (_params, _search, hash) => {\n            if (hash.license) {\n                actions.setShowLicenseDirectInput(true)\n                actions.setActivateLicenseValues({ license: hash.license })\n                actions.submitActivateLicense()\n            }\n            if (_search.products) {\n                const products = _search.products.split(',')\n                actions.setScrollToProductKey(products[0])\n            }\n            actions.setRedirectPath()\n            actions.setIsOnboarding()\n        },\n        '*': () => {\n            actions.setRedirectPath()\n            actions.setIsOnboarding()\n        },\n    })),\n])\n","import { LemonCollapse, LemonModal, Link } from '@posthog/lemon-ui'\nimport { useValues } from 'kea'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport EarlyAccessFeatureImage from 'public/early-access-feature-demo.png'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\n\nimport { FeatureFlagType } from '~/types'\n\ninterface InstructionsModalProps {\n    featureFlag: FeatureFlagType\n    visible: boolean\n    onClose: () => void\n}\n\nexport function InstructionsModal({ onClose, visible, featureFlag }: InstructionsModalProps): JSX.Element {\n    const { preflight } = useValues(preflightLogic)\n\n    const getCloudPanels = (): JSX.Element => (\n        <LemonCollapse\n            className=\"mt-2\"\n            defaultActiveKey=\"1\"\n            panels={[\n                {\n                    key: '1',\n                    header: 'Option 1: Widget Site App',\n                    content: (\n                        <div>\n                            Give your users a <Link to=\"https://app.posthog.com/project/apps/574\">prebuilt widget</Link>{' '}\n                            to opt-in to features\n                            <img className=\"max-h-full max-w-full mt-2.5\" src={EarlyAccessFeatureImage} />\n                        </div>\n                    ),\n                },\n                {\n                    key: '2',\n                    header: 'Option 2: Custom implementation',\n                    content: (\n                        <div>\n                            <b>Opt user in</b>\n                            <div>\n                                <FeatureEnrollInstructions featureFlag={featureFlag} />\n                            </div>\n\n                            <b>Opt user out</b>\n                            <div>\n                                <FeatureUnenrollInstructions featureFlag={featureFlag} />\n                            </div>\n\n                            <b>Retrieve Previews</b>\n                            <div>\n                                <RetrievePreviewsInstructions />\n                            </div>\n                        </div>\n                    ),\n                },\n            ]}\n        />\n    )\n\n    const getSelfHostedPanels = (): JSX.Element => (\n        <div>\n            <b>Opt user in</b>\n            <div>\n                <FeatureEnrollInstructions featureFlag={featureFlag} />\n            </div>\n\n            <b>Opt user out</b>\n            <div>\n                <FeatureUnenrollInstructions featureFlag={featureFlag} />\n            </div>\n\n            <b>Retrieve Previews</b>\n            <div>\n                <RetrievePreviewsInstructions />\n            </div>\n        </div>\n    )\n\n    const panels: JSX.Element = preflight?.cloud ? getCloudPanels() : getSelfHostedPanels()\n\n    return (\n        <LemonModal title=\"How to implement opt-in feature flags\" isOpen={visible} onClose={onClose} width={640}>\n            <div>\n                <div className=\"mb-2\">\n                    Implement manual release condition toggles to give your users the ability choose which features they\n                    want to try\n                </div>\n                {panels}\n            </div>\n        </LemonModal>\n    )\n}\n\nfunction FeatureEnrollInstructions({ featureFlag }: { featureFlag: FeatureFlagType }): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.updateEarlyAccessFeatureEnrollment(\"${featureFlag.key}\", true)\n`}\n        </CodeSnippet>\n    )\n}\n\nfunction FeatureUnenrollInstructions({ featureFlag }: { featureFlag: FeatureFlagType }): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.updateEarlyAccessFeatureEnrollment(\"${featureFlag.key}\", false)\n`}\n        </CodeSnippet>\n    )\n}\n\nfunction RetrievePreviewsInstructions(): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.getEarlyAccessFeatures((previewItemData) => {\n    // do something with early access feature\n})\n`}\n        </CodeSnippet>\n    )\n}\n","import { Link } from '@posthog/lemon-ui'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\n\nfunction ServerSideWarning(): JSX.Element {\n    return (\n        <div className=\"warning\">\n            <p>\n                <b>Warning:</b> Server side experiment metrics require you to manually send the feature flag\n                information.{' '}\n                <Link to=\"https://posthog.com/tutorials/experiments#step-2-sending-the-right-events\" target=\"_blank\">\n                    See this tutorial for more information.\n                </Link>\n            </p>\n        </div>\n    )\n}\n\ninterface SnippetProps {\n    flagKey: string\n    variant: string\n}\n\nexport function NodeJSSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`const experimentFlagValue = await client.getFeatureFlag('${flagKey}', 'user distinct id')\n\nif (experimentFlagValue === '${variant}' ) {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n\nexport function JSSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`if (posthog.getFeatureFlag('${flagKey}') === '${variant}') {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n            <b>Test that it works</b>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`posthog.featureFlags.override({'${flagKey}': '${variant}'})`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function RNSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`if (posthog.getFeatureFlag('${flagKey}') === '${variant}') {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function PHPSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.PHP} wrap>\n                {`if (PostHog::getFeatureFlag('${flagKey}', 'user distinct id') == '${variant}') {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n\nexport function GolangSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.Go} wrap>\n                {`experimentFlagValue, err := client.GetFeatureFlag(\n                    FeatureFlagPayload{\n                        Key:        '${flagKey}',\n                        DistinctId: \"distinct-id\",\n                    })\n\nif (experimentFlagValue == '${variant}' ) {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n\nexport function RubySnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.Ruby} wrap>\n                {`experimentFlagValue = posthog.get_feature_flag('${flagKey}', 'user distinct id')\n\n\nif experimentFlagValue == '${variant}'\n    # Do something differently for this user\nelse\n    # It's a good idea to let control variant always be the default behaviour,\n    # so if something goes wrong with flag evaluation, you don't break your app.\nend\n`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n\nexport function PythonSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.Python} wrap>\n                {`experiment_flag_value = posthog.get_feature_flag(\"${flagKey}\", \"user_distinct_id\"):\n\nif experiment_flag_value == '${variant}':\n    # Do something differently for this user\nelse:\n    # It's a good idea to let control variant always be the default behaviour,\n    # so if something goes wrong with flag evaluation, you don't break your app.\n`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n","import { useValues } from 'kea'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { apiHostOrigin } from 'lib/utils/apiHost'\nimport { teamLogic } from 'scenes/teamLogic'\n\nimport { GroupType } from '~/types'\n\nexport const UTM_TAGS = '?utm_medium=in-product&utm_campaign=feature-flag'\n\nexport interface FeatureFlagSnippet {\n    flagKey: string\n    multivariant?: boolean\n    groupType?: GroupType\n    localEvaluation?: boolean\n    payload?: boolean\n    samplePropertyName?: string\n    instantlyAvailableProperties?: boolean\n}\n\nconst LOCAL_EVAL_REMINDER = `// Remember to set a personal API key in the SDK to enable local evaluation.\n`\n\nexport function NodeJSSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'await client.'\n    const flagFunction = payload ? 'getFeatureFlagPayload' : multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n                // add group properties used in the flag to ensure the flag\n                // is evaluated locally, vs. going to our servers\n                groupProperties: { ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n                // add person properties used in the flag to ensure the flag\n                // is evaluated locally, vs. going to our servers\n                personProperties: {'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',\n            {\n                groups: { '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n            }\n        )`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',\n            {${localEvalAddition}}\n            )`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n\n    const variableName = payload ? 'matchedFlagPayload' : multivariant ? 'enabledVariant' : 'isMyFlagEnabledForUser'\n\n    const conditional = multivariant ? `${variableName} === 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif (${conditional}) {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`\n\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`${localEvaluation ? LOCAL_EVAL_REMINDER : ''}const ${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function PHPSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHog::'\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n            // empty person properties\n            [],\n            // add group properties used in the flag to ensure the flag\n            // is evaluated locally, vs. going to our servers\n            [${groupType.group_type} =>  ['${propertyName}' => 'value', 'name' => 'xyz']]`\n            : `\n            // add person properties used in the flag to ensure the flag\n            // is evaluated locally, vs. going to our servers\n            ['${propertyName}' => 'value']`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',\n            // group types\n            ['${groupType.group_type}' => '<${groupType.name_singular || 'group'} ID>'],${localEvalAddition}\n        )`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',${localEvalAddition}\n        )`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = multivariant ? '$enabledVariant' : '$isMyFlagEnabledForUser'\n\n    const conditional = multivariant ? `${variableName} === 'example-variant'` : `${variableName}`\n\n    return (\n        <>\n            <CodeSnippet language={Language.PHP} wrap>\n                {`${localEvaluation ? LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}\n\nif (${conditional}) {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function GolangSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'client.'\n\n    const flagFunction = multivariant ? 'GetFeatureFlag' : 'IsFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n                // add group properties used in the flag to ensure the flag\n                // is evaluated locally, vs. going to our servers\n                \n                groupProperties: map[string]Properties{\"${groupType.group_type}\": posthog.NewProperties().Set(\"${propertyName}\", \"value\").Set(\"name\", \"xyz\")}`\n            : `\n                // add person properties used in the flag to ensure the flag\n                // is evaluated locally, vs. going to our servers\n                PersonProperties: posthog.NewProperties().Set(\"${propertyName}\", \"value\")`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n            FeatureFlagPayload{\n                Key:        \"${flagKey}\",\n                DistinctId: \"distinct-id\",\n                Groups:     Groups{'${groupType.group_type}': '<${\n              groupType.name_singular || 'group'\n          } ID>'},${localEvalAddition}\n            }\n        )`\n        : `${clientSuffix}${flagFunction}(\n            FeatureFlagPayload{\n                Key:        '${flagKey}',\n                DistinctId: \"distinct-id\",${localEvalAddition}\n            })`\n    const variableName = multivariant ? 'enabledVariant, err' : 'isMyFlagEnabledForUser, err'\n\n    const conditional = multivariant ? `enabledVariant == 'example-variant'` : `isMyFlagEnabledForUser`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Go} wrap>\n                {`${localEvaluation ? LOCAL_EVAL_REMINDER : ''}${variableName} := ${flagSnippet}\n\nif ${conditional} {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function RubySnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n    const flagFunction = payload ? 'get_feature_flag_payload' : multivariant ? 'get_feature_flag' : 'is_feature_enabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n            # // add group properties used in the flag to ensure the flag\n            # // is evaluated locally, vs. going to our servers\n            group_properties: { ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n            # // add person properties used in the flag to ensure the flag\n            # // is evaluated locally, vs. going to our servers\n            person_properties: {'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',\n            groups: { '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n        )`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',${localEvalAddition}\n        )`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = payload ? 'matched_flag_payload' : multivariant ? 'enabled_variant' : 'is_my_flag_enabled'\n\n    const conditional = multivariant ? `${variableName} == 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif ${conditional}\n    # Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\nend`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Ruby} wrap>\n                {`${localEvaluation ? '# ' + LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function PythonSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n    const flagFunction = payload ? 'get_feature_flag_payload' : multivariant ? 'get_feature_flag' : 'feature_enabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n            # // add group properties used in the flag to ensure the flag\n            # // is evaluated locally, vs. going to our servers\n            group_properties={ ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n            # // add person properties used in the flag to ensure the flag\n            # // is evaluated locally, vs. going to our servers\n            person_properties={'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',\n            groups={ '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n        )`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',${localEvalAddition}\n        )`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = payload ? 'matched_flag_payload' : multivariant ? 'enabled_variant' : 'is_my_flag_enabled'\n\n    const conditional = multivariant ? `${variableName} == 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif ${conditional}:\n    # Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Python} wrap>\n                {`${localEvaluation ? '# ' + LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function AndroidSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHog.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Kotlin} wrap>\n                {`${clientSuffix}getFeatureFlagPayload(\"${flagKey}\")`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == \"example-variant\"` : ''\n    return (\n        <CodeSnippet language={Language.Kotlin} wrap>\n            {`if (${clientSuffix}${flagFunction}(\"${flagKey}\")${variantSuffix}) {\n    // do something\n}\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function FlutterSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'await Posthog().'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Dart} wrap>\n                {`${clientSuffix}getFeatureFlagPayload('${flagKey}');`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n\n    return (\n        <CodeSnippet language={Language.Dart} wrap>\n            {`if (${clientSuffix}${flagFunction}('${flagKey}')${variantSuffix}) {\n    // do something\n}\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function iOSSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHogSDK.shared.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Swift} wrap>\n                {`${clientSuffix}getFeatureFlagPayload(\"${flagKey}\")`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? `as? String == \"example-variant\"` : ''\n    return (\n        <CodeSnippet language={Language.Swift} wrap>\n            {`if ${clientSuffix}${flagFunction}(\"${flagKey}\")${variantSuffix} {\n    // do something\n}`}\n        </CodeSnippet>\n    )\n}\n\nexport function ReactNativeSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.JSX} wrap>\n                {`${clientSuffix}getFeatureFlagPayload('${flagKey}')`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n    return (\n        <CodeSnippet language={Language.JSX} wrap>\n            {`// With a hook\nimport { useFeatureFlag } from 'posthog-react-native'\n\nconst MyComponent = () => {\n    const showFlaggedFeature = useFeatureFlag('${flagKey}')\n\n    if (showFlaggedFeature === undefined) {\n        // the response is undefined if the flags are being loaded\n        return null\n    }\n\n    return showFlaggedFeature ${variantSuffix} ? <Text>Testing feature ðŸ˜„</Text> : <Text>Not Testing feature ðŸ˜¢</Text>\n}\n\n// Or calling on the method directly\n${clientSuffix}${flagFunction}('${flagKey}')\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function ReactSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const flagFunction = payload\n        ? 'useFeatureFlagPayload'\n        : multivariant\n        ? 'useFeatureFlagVariantKey'\n        : 'useFeatureFlagEnabled'\n\n    const variable = payload ? 'payload' : multivariant ? 'variant' : 'flagEnabled'\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n\n    return (\n        <CodeSnippet language={Language.JSX} wrap>\n            {`\nimport { ${flagFunction} } from 'posthog-js/react'\n\nfunction App() {\n    const ${variable} = ${flagFunction}('${flagKey}')\n\n    if (${variable}${variantSuffix}) {\n        // do something\n    }\n}`}\n        </CodeSnippet>\n    )\n}\n\nexport function APISnippet({ groupType }: FeatureFlagSnippet): JSX.Element {\n    const { currentTeam } = useValues(teamLogic)\n\n    const groupAddition = groupType\n        ? `\n    \"groups\": { \"${groupType.group_type}\": \"<${groupType.name_singular || 'group'} ID>\" },`\n        : ''\n\n    return (\n        <>\n            <CodeSnippet language={Language.Bash} wrap>\n                {`curl ${apiHostOrigin()}/decide?v=3/ \\\\\n-X POST -H 'Content-Type: application/json' \\\\\n-d '{\n    \"api_key\": \"${currentTeam ? currentTeam.api_token : '[project_api_key]'}\",\n    \"distinct_id\": \"[user distinct id]\",${groupAddition}\n}'\n                `}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function JSSnippet({\n    flagKey,\n    multivariant,\n    payload,\n    groupType,\n    instantlyAvailableProperties,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    if (payload) {\n        return (\n            <>\n                <CodeSnippet language={Language.JavaScript} wrap>\n                    {`posthog.getFeatureFlagPayload('${flagKey ?? ''}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const propertyOverrideSnippet = `// Your flag depends on properties that are not instantly available. If you want\n// to make them available without waiting for server delays, send these properties for flag evaluation, like so:\n// Make sure to call this before evaluating flags. More info: https://posthog.com/docs/libraries/js#overriding-server-properties \nposthog.${\n        groupType\n            ? `setGroupPropertiesForFlags({ '${groupType.group_type}': {'${propertyName}': 'value'}})`\n            : `setPersonPropertiesForFlags({'${propertyName}': 'value'})`\n    }\n\n`\n\n    const clientSuffix = 'posthog.'\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`${instantlyAvailableProperties ? '' : propertyOverrideSnippet}// Ensure flags are loaded before usage.\n// You'll only need to call this on the code for when the first time a user visits.\n${clientSuffix}onFeatureFlags(function() {\n    // feature flags should be available at this point\n    if (${clientSuffix}${flagFunction}('${flagKey ?? ''}') ${variantSuffix}) {\n        // do something\n    }\n})\n\n// Otherwise, you can just do:\nif (${clientSuffix}${flagFunction}('${flagKey ?? ''}') ${variantSuffix}) {\n    // do something\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function JSBootstrappingSnippet(): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`// Initialise the posthog library with a distinct ID and feature flags for immediate loading\n// This avoids the delay between the library loading and feature flags becoming available to use.\n\nposthog.init('{project_api_key}', {\n    api_host: 'https://app.posthog.com',\n    bootstrap:\n    {\n        distinctID: 'your-anonymous-id',\n        featureFlags: {\n    // input the flag values here from 'posthog.getAllFlags(distinct_id)' which you can find in the server-side libraries.\n        // example:\n            // 'flag-1': true,\n            // 'variant-flag': 'control',\n            // 'other-flag': false\n        },\n    }\n})\n            `}\n        </CodeSnippet>\n    )\n}\n","import { mergeAttributes, Node, NodeViewProps } from '@tiptap/core'\nimport { NodeViewWrapper, ReactNodeViewRenderer } from '@tiptap/react'\nimport { NotebookNodeType, NotebookTarget } from '~/types'\nimport { dayjs } from 'lib/dayjs'\nimport { JSONContent } from '../Notebook/utils'\nimport clsx from 'clsx'\nimport { urls } from 'scenes/urls'\nimport { LemonButton } from '@posthog/lemon-ui'\nimport { notebookLogic } from '../Notebook/notebookLogic'\nimport { useValues } from 'kea'\nimport { useMemo } from 'react'\nimport { openNotebook } from '~/models/notebooksModel'\n\nexport interface NotebookNodeReplayTimestampAttrs {\n    playbackTime?: number\n    sessionRecordingId: string\n    sourceNodeId?: string\n}\n\nconst Component = (props: NodeViewProps): JSX.Element => {\n    const { shortId, findNodeLogic, findNodeLogicById } = useValues(notebookLogic)\n    const { sessionRecordingId, playbackTime = 0, sourceNodeId } = props.node.attrs as NotebookNodeReplayTimestampAttrs\n\n    const relatedNodeInNotebook = useMemo(() => {\n        const logicById = sourceNodeId ? findNodeLogicById(sourceNodeId) : null\n\n        return logicById ?? findNodeLogic(NotebookNodeType.Recording, { id: sessionRecordingId })\n    }, [findNodeLogic])\n\n    const handlePlayInNotebook = (): void => {\n        // TODO: Figure out how to send this action info to the playlist OR the replay node...\n\n        relatedNodeInNotebook?.values.sendMessage('play-replay', {\n            sessionRecordingId,\n            time: playbackTime ?? 0,\n        })\n    }\n\n    return (\n        <NodeViewWrapper\n            as=\"span\"\n            className={clsx('NotebookRecordingTimestamp', props.selected && 'NotebookRecordingTimestamp--selected')}\n        >\n            <LemonButton\n                size=\"small\"\n                noPadding\n                active\n                onClick={\n                    relatedNodeInNotebook ? handlePlayInNotebook : () => openNotebook(shortId, NotebookTarget.Popover)\n                }\n                to={\n                    !relatedNodeInNotebook\n                        ? urls.replaySingle(sessionRecordingId) + `?t=${playbackTime / 1000}`\n                        : undefined\n                }\n            >\n                <span className=\"p-1\">{formatTimestamp(playbackTime)}</span>\n            </LemonButton>\n        </NodeViewWrapper>\n    )\n}\n\nexport const NotebookNodeReplayTimestamp = Node.create({\n    name: NotebookNodeType.ReplayTimestamp,\n    inline: true,\n    group: 'inline',\n    atom: true,\n\n    serializedText: (attrs: NotebookNodeReplayTimestampAttrs): string => {\n        // timestamp is not a block so `getText` does not add a separator.\n        // we need to add it manually\n        return `${attrs.playbackTime ? formatTimestamp(attrs.playbackTime) : '00:00'}:\\n`\n    },\n\n    addAttributes() {\n        return {\n            playbackTime: { default: null, keepOnSplit: false },\n            sessionRecordingId: { default: null, keepOnSplit: true, isRequired: true },\n            sourceNodeId: { default: null, keepOnSplit: true },\n        }\n    },\n\n    parseHTML() {\n        return [{ tag: NotebookNodeType.ReplayTimestamp }]\n    },\n\n    renderHTML({ HTMLAttributes }) {\n        return [NotebookNodeType.ReplayTimestamp, mergeAttributes(HTMLAttributes)]\n    },\n\n    addNodeView() {\n        return ReactNodeViewRenderer(Component)\n    },\n})\n\nexport function formatTimestamp(time: number): string {\n    return dayjs.duration(time, 'milliseconds').format('HH:mm:ss').replace(/^00:/, '').trim()\n}\n\nexport function buildTimestampCommentContent(attrs: NotebookNodeReplayTimestampAttrs): JSONContent {\n    return {\n        type: 'paragraph',\n        content: [\n            {\n                type: NotebookNodeType.ReplayTimestamp,\n                attrs,\n            },\n            { type: 'text', text: ' ' },\n        ],\n    }\n}\n","import {\n    IconCursor,\n    IconFunnels,\n    IconHogQL,\n    IconLifecycle,\n    IconPeople,\n    IconRetention,\n    IconRewindPlay,\n    IconStickiness,\n    IconTrends,\n    IconUpload,\n    IconUserPaths,\n} from '@posthog/icons'\nimport { IconCode } from '@posthog/icons'\nimport { LemonButton, LemonDivider, lemonToast } from '@posthog/lemon-ui'\nimport { Extension } from '@tiptap/core'\nimport { ReactRenderer } from '@tiptap/react'\nimport Suggestion from '@tiptap/suggestion'\nimport Fuse from 'fuse.js'\nimport { useValues } from 'kea'\nimport { IconBold, IconItalic } from 'lib/lemon-ui/icons'\nimport { Popover } from 'lib/lemon-ui/Popover'\nimport { selectFiles } from 'lib/utils/file-utils'\nimport { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useState } from 'react'\n\nimport { KeyboardShortcut } from '~/layout/navigation-3000/components/KeyboardShortcut'\nimport { defaultDataTableColumns } from '~/queries/nodes/DataTable/utils'\nimport { NodeKind } from '~/queries/schema'\nimport { BaseMathType, ChartDisplayType, FunnelVizType, NotebookNodeType, PathType, RetentionPeriod } from '~/types'\n\nimport { buildNodeEmbed } from '../Nodes/NotebookNodeEmbed'\nimport { buildInsightVizQueryContent, buildNodeQueryContent } from '../Nodes/NotebookNodeQuery'\nimport NotebookIconHeading from './NotebookIconHeading'\nimport { notebookLogic } from './notebookLogic'\nimport { EditorCommands, EditorRange } from './utils'\n\ntype SlashCommandConditionalProps =\n    | {\n          mode: 'add'\n          getPos: () => number\n          range?: never\n      }\n    | {\n          mode: 'slash'\n          getPos?: never\n          range: EditorRange\n      }\n\ntype SlashCommandsProps = SlashCommandConditionalProps & {\n    query?: string\n    decorationNode?: any\n    onClose?: () => void\n}\n\ntype SlashCommandsPopoverProps = SlashCommandsProps & {\n    visible: boolean\n    children?: JSX.Element\n}\n\ntype SlashCommandsRef = {\n    onKeyDown: (event: KeyboardEvent) => boolean\n}\n\ntype SlashCommandsItem = {\n    title: string\n    search?: string\n    icon?: JSX.Element\n    command: (chain: EditorCommands, pos: number | EditorRange) => EditorCommands | Promise<EditorCommands>\n}\n\nconst TEXT_CONTROLS: SlashCommandsItem[] = [\n    {\n        title: 'h1',\n        icon: <NotebookIconHeading level={1} />,\n        command: (chain) => chain.toggleHeading({ level: 1 }),\n    },\n    {\n        title: 'h2',\n        icon: <NotebookIconHeading level={2} />,\n        command: (chain) => chain.toggleHeading({ level: 2 }),\n    },\n    {\n        title: 'h3',\n        icon: <NotebookIconHeading level={3} />,\n        command: (chain) => chain.toggleHeading({ level: 3 }),\n    },\n    {\n        title: 'bold',\n        icon: <IconBold />,\n        command: (chain) => chain.toggleBold(),\n    },\n    {\n        title: 'italic',\n        icon: <IconItalic />,\n        command: (chain) => chain.toggleItalic(),\n    },\n]\n\nconst SLASH_COMMANDS: SlashCommandsItem[] = [\n    {\n        title: 'Trend',\n        search: 'graph trend insight',\n        icon: <IconTrends color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.TrendsQuery,\n                    filterTestAccounts: false,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            event: '$pageview',\n                            name: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                    interval: 'day',\n                    trendsFilter: {\n                        display: ChartDisplayType.ActionsLineGraph,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Funnel',\n        search: 'funnel insight',\n        icon: <IconFunnels color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.FunnelsQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                        },\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                        },\n                    ],\n                    funnelsFilter: {\n                        funnelVizType: FunnelVizType.Steps,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Retention',\n        search: 'retention insight',\n        icon: <IconRetention color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.RetentionQuery,\n                    retentionFilter: {\n                        period: RetentionPeriod.Day,\n                        totalIntervals: 11,\n                        targetEntity: {\n                            id: '$pageview',\n                            name: '$pageview',\n                            type: 'events',\n                        },\n                        returningEntity: {\n                            id: '$pageview',\n                            name: '$pageview',\n                            type: 'events',\n                        },\n                        retentionType: 'retention_first_time',\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Paths',\n        search: 'user paths insight',\n        icon: <IconUserPaths color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.PathsQuery,\n                    pathsFilter: {\n                        includeEventTypes: [PathType.PageView],\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Stickiness',\n        search: 'stickiness insight',\n        icon: <IconStickiness color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.StickinessQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                    stickinessFilter: {},\n                })\n            ),\n    },\n    {\n        title: 'Lifecycle',\n        search: 'lifecycle insight',\n        icon: <IconLifecycle color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.LifecycleQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                })\n            ),\n    },\n    {\n        title: 'HogQL',\n        search: 'sql',\n        icon: <IconHogQL color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.HogQLQuery,\n                        query: `select event,\n        person.properties.email,\n        properties.$browser,\n        count()\n    from events\n    where {filters} -- replaced with global date and property filters\n    and person.properties.email is not null\ngroup by event,\n        properties.$browser,\n        person.properties.email\norder by count() desc\n    limit 100`,\n                        filters: {\n                            dateRange: {\n                                date_from: '-24h',\n                            },\n                        },\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Events',\n        search: 'data explore',\n        icon: <IconCursor />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.EventsQuery,\n                        select: defaultDataTableColumns(NodeKind.EventsQuery),\n                        properties: [],\n                        after: '-24h',\n                        limit: 100,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'People',\n        search: 'persons users',\n        icon: <IconPeople />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    columns: defaultDataTableColumns(NodeKind.PersonsNode),\n                    source: {\n                        kind: NodeKind.PersonsNode,\n                        properties: [],\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Session recordings',\n        search: 'video replay',\n        icon: <IconRewindPlay />,\n        command: (chain, pos) => chain.insertContentAt(pos, { type: NotebookNodeType.RecordingPlaylist, attrs: {} }),\n    },\n    {\n        title: 'Image',\n        search: 'picture gif',\n        icon: <IconUpload />,\n        command: async (chain, pos) => {\n            // Trigger upload followed by insert\n            try {\n                const files = await selectFiles({ contentType: 'image/*', multiple: false })\n\n                if (files.length) {\n                    return chain.insertContentAt(pos, { type: NotebookNodeType.Image, attrs: { file: files[0] } })\n                }\n            } catch (e) {\n                lemonToast.error('Something went wrong when trying to select a file.')\n            }\n\n            return chain\n        },\n    },\n    {\n        title: 'Embedded iframe',\n        search: 'iframe embed',\n        icon: <IconCode />,\n        command: async (chain, pos) => {\n            return chain.insertContentAt(pos, buildNodeEmbed())\n        },\n    },\n]\n\nexport const SlashCommands = forwardRef<SlashCommandsRef, SlashCommandsProps>(function SlashCommands(\n    { mode, range, getPos, onClose, query }: SlashCommandsProps,\n    ref\n): JSX.Element | null {\n    const { editor } = useValues(notebookLogic)\n    // We start with 1 because the first item is the text controls\n    const [selectedIndex, setSelectedIndex] = useState(0)\n    const [selectedHorizontalIndex, setSelectedHorizontalIndex] = useState(0)\n\n    const allCommmands = [...TEXT_CONTROLS, ...SLASH_COMMANDS]\n\n    const fuse = useMemo(() => {\n        return new Fuse(allCommmands, {\n            keys: ['title', 'search'],\n            threshold: 0.3,\n        })\n    }, [allCommmands])\n\n    const filteredCommands = useMemo(() => {\n        if (!query) {\n            return allCommmands\n        }\n        return fuse.search(query).map((result) => result.item)\n    }, [query, fuse])\n\n    const filteredSlashCommands = useMemo(\n        () => filteredCommands.filter((item) => SLASH_COMMANDS.includes(item)),\n        [filteredCommands]\n    )\n\n    useEffect(() => {\n        setSelectedIndex(0)\n        setSelectedHorizontalIndex(0)\n    }, [query])\n\n    const execute = async (item: SlashCommandsItem): Promise<void> => {\n        if (editor) {\n            const selectedNode = editor.getSelectedNode()\n            const isTextNode = selectedNode === null || selectedNode.isText\n            const isTextCommand = TEXT_CONTROLS.map((c) => c.title).includes(item.title)\n\n            const position = mode === 'slash' ? range.from : getPos()\n            let chain = mode === 'slash' ? editor.deleteRange(range) : editor.chain()\n\n            if (!isTextNode && isTextCommand) {\n                chain = chain.insertContentAt(position, { type: 'paragraph' })\n            }\n\n            const partialCommand = await item.command(chain, position)\n            partialCommand.run()\n\n            onClose?.()\n        }\n    }\n\n    const onPressEnter = async (): Promise<void> => {\n        const command =\n            selectedIndex === -1 ? TEXT_CONTROLS[selectedHorizontalIndex] : filteredSlashCommands[selectedIndex]\n\n        await execute(command)\n    }\n    const onPressUp = (): void => {\n        setSelectedIndex(Math.max(selectedIndex - 1, -1))\n    }\n    const onPressDown = (): void => {\n        setSelectedIndex(Math.min(selectedIndex + 1, SLASH_COMMANDS.length - 1))\n    }\n\n    const onPressLeft = (): void => {\n        setSelectedHorizontalIndex(Math.max(selectedHorizontalIndex - 1, 0))\n    }\n    const onPressRight = (): void => {\n        setSelectedHorizontalIndex(Math.min(selectedHorizontalIndex + 1, TEXT_CONTROLS.length - 1))\n    }\n\n    const onKeyDown = useCallback(\n        (event: KeyboardEvent): boolean => {\n            const keyMappings = {\n                ArrowUp: onPressUp,\n                ArrowDown: onPressDown,\n                ArrowLeft: onPressLeft,\n                ArrowRight: onPressRight,\n                Enter: onPressEnter,\n            }\n\n            if (keyMappings[event.key]) {\n                keyMappings[event.key]()\n                return true\n            }\n\n            return false\n        },\n        [selectedIndex, selectedHorizontalIndex, filteredCommands]\n    )\n\n    // Expose the keydown handler to the tiptap extension\n    useImperativeHandle(ref, () => ({ onKeyDown }), [onKeyDown])\n\n    useEffect(() => {\n        if (mode !== 'add') {\n            return\n        }\n\n        // If not opened from a slash command, we want to add our own keyboard listeners\n        const keyDownListener = (event: KeyboardEvent): void => {\n            const preventDefault = onKeyDown(event)\n            if (preventDefault) {\n                event.preventDefault()\n            }\n        }\n\n        window.addEventListener('keydown', keyDownListener, true)\n\n        return () => window.removeEventListener('keydown', keyDownListener, true)\n    }, [onKeyDown, mode])\n\n    if (!editor) {\n        return null\n    }\n\n    return (\n        <div className=\"space-y-px\">\n            <div className=\"flex items-center gap-1\">\n                {TEXT_CONTROLS.map((item, index) => (\n                    <LemonButton\n                        key={item.title}\n                        size=\"small\"\n                        active={selectedIndex === -1 && selectedHorizontalIndex === index}\n                        onClick={() => void execute(item)}\n                        icon={item.icon}\n                    />\n                ))}\n            </div>\n\n            <LemonDivider />\n\n            {filteredSlashCommands.map((item, index) => (\n                <LemonButton\n                    key={item.title}\n                    fullWidth\n                    icon={item.icon}\n                    active={index === selectedIndex}\n                    onClick={() => void execute(item)}\n                >\n                    {item.title}\n                </LemonButton>\n            ))}\n\n            {filteredSlashCommands.length === 0 && (\n                <div className=\"text-muted-alt p-1\">\n                    Nothing matching <code>/{query}</code>\n                </div>\n            )}\n\n            {mode === 'add' && (\n                <>\n                    <LemonDivider className=\"my-0\" />\n                    <div className=\"text-xs text-muted-alt p-1\">\n                        You can trigger this menu by typing <KeyboardShortcut forwardslash />\n                    </div>\n                </>\n            )}\n        </div>\n    )\n})\n\nexport const SlashCommandsPopover = forwardRef<SlashCommandsRef, SlashCommandsPopoverProps>(\n    function SlashCommandsPopover(\n        { visible = true, decorationNode, children, onClose, ...props }: SlashCommandsPopoverProps,\n        ref\n    ): JSX.Element | null {\n        return (\n            <Popover\n                placement=\"right-start\"\n                fallbackPlacements={['left-start', 'right-end']}\n                overlay={<SlashCommands ref={ref} onClose={onClose} {...props} />}\n                referenceElement={decorationNode}\n                visible={visible}\n                onClickOutside={onClose}\n            >\n                {children}\n            </Popover>\n        )\n    }\n)\n\nexport const SlashCommandsExtension = Extension.create({\n    name: 'slash-commands',\n\n    addProseMirrorPlugins() {\n        return [\n            Suggestion({\n                editor: this.editor,\n                char: '/',\n                startOfLine: true,\n                render: () => {\n                    let renderer: ReactRenderer<SlashCommandsRef>\n\n                    return {\n                        onStart: (props) => {\n                            renderer = new ReactRenderer(SlashCommandsPopover, {\n                                props: { ...props, mode: 'slash' },\n                                editor: props.editor,\n                            })\n                        },\n\n                        onUpdate(props) {\n                            renderer.updateProps(props)\n\n                            if (!props.clientRect) {\n                                return\n                            }\n                        },\n\n                        onKeyDown(props) {\n                            if (props.event.key === 'Escape') {\n                                renderer.destroy()\n                                return true\n                            }\n                            return renderer.ref?.onKeyDown(props.event) ?? false\n                        },\n\n                        onExit() {\n                            renderer.destroy()\n                        },\n                    }\n                },\n            }),\n        ]\n    },\n})\n","import * as d3 from 'd3'\nimport * as Sankey from 'd3-sankey'\nimport { D3Selector } from 'lib/hooks/useD3'\nimport { stripHTTP } from 'lib/utils'\nimport { Dispatch, RefObject, SetStateAction } from 'react'\n\nimport { PathsFilter } from '~/queries/schema'\n\nimport { FALLBACK_CANVAS_WIDTH, HIDE_PATH_CARD_HEIGHT } from './Paths'\nimport { PathNode } from './pathsDataLogic'\nimport { isSelectedPathStartOrEnd, PathNodeData, PathTargetLink, roundedRect } from './pathUtils'\n\nconst createCanvas = (canvasRef: RefObject<HTMLDivElement>, width: number, height: number): D3Selector => {\n    return d3\n        .select(canvasRef.current)\n        .append('svg')\n        .classed('Paths__canvas', true)\n        .style('background', 'var(--item-background)')\n        .style('width', `${width}px`)\n        .style('height', `${height}px`)\n}\n\nconst createSankey = (width: number, height: number): Sankey.SankeyLayout<any, any, any> => {\n    // @ts-expect-error - d3 sankey typing things\n    return new Sankey.sankey()\n        .nodeId((d: PathNodeData) => d.name)\n        .nodeAlign(Sankey.sankeyJustify)\n        .nodeSort(null)\n        .nodeWidth(15)\n        .size([width, height])\n}\n\nconst appendPathNodes = (\n    svg: any,\n    nodes: PathNodeData[],\n    pathsFilter: PathsFilter,\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void => {\n    svg.append('g')\n        .selectAll('rect')\n        .data(nodes)\n        .join('rect')\n        .attr('x', (d: PathNodeData) => d.x0 + 1)\n        .attr('y', (d: PathNodeData) => d.y0)\n        .attr('height', (d: PathNodeData) => d.y1 - d.y0)\n        .attr('width', (d: PathNodeData) => d.x1 - d.x0 - 2)\n        .attr('fill', (d: PathNodeData) => {\n            let c\n            for (const link of d.sourceLinks) {\n                if (c === undefined) {\n                    c = link.color\n                } else if (c !== link.color) {\n                    c = null\n                }\n            }\n            if (c === undefined) {\n                for (const link of d.targetLinks) {\n                    if (c === undefined) {\n                        c = link.color\n                    } else if (c !== link.color) {\n                        c = null\n                    }\n                }\n            }\n            if (isSelectedPathStartOrEnd(pathsFilter, d)) {\n                return d3.color('purple')\n            }\n            const startNodeColor = c && d3.color(c) ? d3.color(c) : d3.color('#5375ff')\n            return startNodeColor\n        })\n        .on('mouseover', (_event: MouseEvent, data: PathNodeData) => {\n            if (data.y1 - data.y0 > HIDE_PATH_CARD_HEIGHT) {\n                return\n            }\n            setNodeCards(\n                nodes.map((node: PathNodeData) =>\n                    node.index === data.index\n                        ? { ...node, visible: true }\n                        : { ...node, visible: node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT }\n                )\n            )\n        })\n        .append('title')\n        .text((d: PathNodeData) => `${stripHTTP(d.name)}\\n${d.value.toLocaleString()}`)\n}\n\nconst appendDropoffs = (svg: D3Selector): void => {\n    const dropOffGradient = svg\n        .append('defs')\n        .append('linearGradient')\n        .attr('id', 'dropoff-gradient')\n        .attr('gradientTransform', 'rotate(90)')\n\n    dropOffGradient.append('stop').attr('offset', '0%').attr('stop-color', 'rgba(220,53,69,0.7)')\n\n    dropOffGradient.append('stop').attr('offset', '100%').attr('stop-color', 'var(--bg-light)')\n}\n\nconst appendPathLinks = (\n    svg: any,\n    links: PathNodeData[],\n    nodes: PathNodeData[],\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void => {\n    const link = svg\n        .append('g')\n        .attr('fill', 'none')\n        .selectAll('g')\n        .data(links)\n        .join('g')\n        .attr('stroke', 'var(--primary)')\n        .attr('opacity', 0.35)\n\n    link.append('path')\n        .attr('d', Sankey.sankeyLinkHorizontal())\n        .attr('id', (d: PathNodeData) => `path-${d.index}`)\n        .attr('stroke-width', (d: PathNodeData) => {\n            return Math.max(1, d.width)\n        })\n        .on('mouseover', (_event: MouseEvent, data: PathNodeData) => {\n            svg.select(`#path-${data.index}`).attr('stroke', 'blue')\n            if (data?.source?.targetLinks.length === 0) {\n                return\n            }\n            const nodesToColor = [data.source]\n            const pathCardsToShow: number[] = []\n            while (nodesToColor.length > 0) {\n                const _node = nodesToColor.pop()\n                _node?.targetLinks.forEach((_link: PathTargetLink) => {\n                    svg.select(`#path-${_link.index}`).attr('stroke', 'blue')\n                    nodesToColor.push(_link.source)\n                    pathCardsToShow.push(_link.source.index)\n                })\n            }\n            const pathCards = [data.target]\n            pathCardsToShow.push(data.target.index, data.source.index)\n            while (pathCards.length > 0) {\n                const node = pathCards.pop()\n                node?.sourceLinks.forEach((l: PathTargetLink) => {\n                    pathCards.push(l.target)\n                    pathCardsToShow.push(l.target.index)\n                })\n            }\n            setNodeCards(\n                nodes.map((node: PathNodeData) => ({\n                    ...node,\n                    ...{\n                        visible: pathCardsToShow.includes(node.index)\n                            ? true\n                            : node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT,\n                    },\n                }))\n            )\n        })\n        .on('mouseleave', () => {\n            svg.selectAll('path').attr('stroke', 'var(--primary)')\n        })\n\n    link.append('g')\n        .append('path')\n        .attr('d', (data: PathNodeData) => {\n            if (data.source.layer === 0) {\n                return\n            }\n            const _height =\n                data.source.y1 - data.source.y0 - data.source.sourceLinks.reduce((prev, curr) => prev + curr.width, 0)\n            return roundedRect(0, 0, 30, _height, Math.min(25, _height), false, true, false, false)\n        })\n        .attr('fill', 'url(#dropoff-gradient)')\n        .attr('stroke-width', 0)\n        .attr('transform', (data: PathNodeData) => {\n            return (\n                'translate(' +\n                Math.round(data.source.x1) +\n                ',' +\n                Math.round(data.source.y0 + data.source.sourceLinks.reduce((prev, curr) => prev + curr.width, 0)) +\n                ')'\n            )\n        })\n}\n\nconst addChartAxisLines = (svg: D3Selector, height: number, nodes: PathNodeData[], maxLayer: number): void => {\n    if (maxLayer > 5) {\n        const arr = [...Array(maxLayer)]\n        const minWidthApart = nodes[1].x0 - nodes[0].x0\n        arr.forEach((_, i) => {\n            svg.append('line')\n                .style('stroke', 'var(--border)')\n                .attr('stroke-width', 2)\n                .attr('x1', minWidthApart * (i + 1) - 20)\n                .attr('y1', 0)\n                .attr('x2', minWidthApart * (i + 1) - 20)\n                .attr('y2', height)\n        })\n    }\n}\n\nexport function renderPaths(\n    canvasRef: RefObject<HTMLDivElement>,\n    canvasWidth: number,\n    canvasHeight: number,\n    paths: { links: PathNode[]; nodes: any[] },\n    pathsFilter: PathsFilter,\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void {\n    if (!paths || paths.nodes.length === 0) {\n        return\n    }\n\n    const maxLayer = paths.links.reduce((prev, curr) => {\n        // @ts-expect-error - sometimes target is an object instead of string\n        const currNum = curr.target.name || curr.target\n        return Math.max(prev, Number(currNum.match(/[^_]*/)))\n    }, 0)\n\n    const minWidth = canvasWidth > FALLBACK_CANVAS_WIDTH || maxLayer < 3 ? canvasWidth : FALLBACK_CANVAS_WIDTH\n\n    const width = maxLayer > 5 && canvasWidth ? (minWidth / 5) * maxLayer : minWidth\n    const height = canvasHeight\n\n    const svg = createCanvas(canvasRef, width, height)\n    const sankey = createSankey(width, height)\n    const { nodes, links } = sankey({\n        nodes: paths.nodes.map((d) => ({ ...d })),\n        links: paths.links.map((d) => ({ ...d })),\n    })\n\n    setNodeCards(nodes.map((node: PathNodeData) => ({ ...node, visible: node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT })))\n\n    appendPathNodes(svg, nodes, pathsFilter, setNodeCards)\n    appendDropoffs(svg)\n    appendPathLinks(svg, links, nodes, setNodeCards)\n    addChartAxisLines(svg, height, nodes, maxLayer)\n}\n","export const createDefaultPluginSource = (name: string): Record<string, any> => ({\n    'index.ts': `// Learn more about plugins at: https://posthog.com/docs/apps/build\n\n// Processes each event, optionally transforming it\nexport function processEvent(event, { config }) {\n    // Some events (such as $identify) don't have properties\n    if (event.properties) {\n        event.properties['hello'] = \\`Hello \\${config.name}\\`\n    }\n    // Return the event to be ingested, or return null to discard\n    return event\n}\n\n// Runs when the plugin is loaded, allows for preparing it as needed\nexport function setupPlugin (meta) {\n    console.log(\\`The date is \\${new Date().toDateString()}\\`)\n}`,\n    'frontend.tsx': `import React from \"react\"\n\nexport const scene = {\n    title: \"My Stuff\",\n    component: function MyStuff({ config }) {\n        return (\n            <div>\n                <h1>My Favourite Links</h1>\n                <ul>\n                    <li>\n                        <a href=\"https://news.ycombinator.com\">The NEWS</a>\n                    </li>\n                </ul>\n                <h1>My Favourite Cow</h1>\n                <img src=\"https://media.giphy.com/media/RYKFEEjtYpxL2/giphy.gif\" />\n            </div>\n        )\n    },\n}\n`,\n    'plugin.json': JSON.stringify(\n        {\n            name: name ?? 'My Plugin',\n            config: [\n                {\n                    markdown: 'Specify your config here',\n                },\n                {\n                    key: 'name',\n                    name: 'Person to greet',\n                    type: 'string',\n                    hint: 'Used to personalise the property `hello`',\n                    default: 'world',\n                    required: false,\n                },\n            ],\n        },\n        null,\n        4\n    ),\n    'site.ts': \"export function inject({ config, posthog }) {\\n    console.log('Hello from PostHog-JS')\\n}\\n\",\n})\n","import { actions, connect, kea, listeners, path, reducers } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\nimport { SessionRecordingPropertiesType, SessionRecordingType } from '~/types'\n\nimport type { sessionRecordingsListPropertiesLogicType } from './sessionRecordingsListPropertiesLogicType'\n\n// This logic is used to fetch properties for a list of recordings\n// It is used in a global way as the cached values can be re-used\nexport const sessionRecordingsListPropertiesLogic = kea<sessionRecordingsListPropertiesLogicType>([\n    path(() => ['scenes', 'session-recordings', 'playlist', 'sessionRecordingsListPropertiesLogic']),\n    connect(() => ({\n        actions: [eventUsageLogic, ['reportRecordingsListPropertiesFetched']],\n    })),\n\n    actions({\n        loadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n        maybeLoadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n    }),\n\n    loaders(({ actions }) => ({\n        recordingProperties: [\n            [] as SessionRecordingPropertiesType[],\n            {\n                loadPropertiesForSessions: async ({ sessions }, breakpoint) => {\n                    await breakpoint(100)\n\n                    const startTime = performance.now()\n                    const sessionIds = sessions.map((x) => x.id)\n\n                    const oldestTimestamp = sessions.map((x) => x.start_time).sort()[0]\n                    const newestTimestamp = sessions.map((x) => x.end_time).sort()[sessions.length - 1]\n\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$session_id as session_id, any(properties) as properties\n                                FROM events\n                                WHERE event IN ['$pageview', '$autocapture']\n                                AND session_id IN ${sessionIds}\n                                -- the timestamp range here is only to avoid querying too much of the events table\n                                -- we don't really care about the absolute value, \n                                -- but we do care about whether timezones have an odd impact\n                                -- so, we extend the range by a day on each side so that timezones don't cause issues\n                                AND timestamp >= ${dayjs(oldestTimestamp).subtract(1, 'day')}\n                                AND timestamp <= ${dayjs(newestTimestamp).add(1, 'day')}\n                                GROUP BY session_id`,\n                    }\n\n                    const response = await api.query(query)\n                    const loadTimeMs = performance.now() - startTime\n\n                    actions.reportRecordingsListPropertiesFetched(loadTimeMs)\n\n                    breakpoint()\n                    return (response.results || []).map(\n                        (x: any): SessionRecordingPropertiesType => ({\n                            id: x[0],\n                            properties: JSON.parse(x[1] || '{}'),\n                        })\n                    )\n                },\n            },\n        ],\n    })),\n\n    listeners(({ actions, values }) => ({\n        maybeLoadPropertiesForSessions: ({ sessions }) => {\n            const newSessions = sessions.filter((session) => !values.recordingPropertiesById[session.id])\n\n            if (newSessions.length > 0) {\n                actions.loadPropertiesForSessions(newSessions)\n            }\n        },\n    })),\n\n    reducers({\n        recordingPropertiesById: [\n            {} as Record<string, SessionRecordingPropertiesType['properties']>,\n            {\n                loadPropertiesForSessionsSuccess: (\n                    state,\n                    { recordingProperties }\n                ): Record<string, SessionRecordingPropertiesType['properties']> => {\n                    const newState = { ...state }\n                    recordingProperties.forEach((properties) => {\n                        newState[properties.id] = properties.properties\n                    })\n\n                    return newState\n                },\n            },\n        ],\n    }),\n])\n","import { Link } from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\nimport { CopyToClipboardInline } from 'lib/components/CopyToClipboard'\nimport { LemonBanner } from 'lib/lemon-ui/LemonBanner'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonInput } from 'lib/lemon-ui/LemonInput/LemonInput'\nimport { LemonModal } from 'lib/lemon-ui/LemonModal'\nimport { LemonTextArea } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\n\nimport { verifiedDomainsLogic } from './verifiedDomainsLogic'\n\nexport function ConfigureSAMLModal(): JSX.Element {\n    const { configureSAMLModalId, isSamlConfigSubmitting, samlConfig } = useValues(verifiedDomainsLogic)\n    const { setConfigureSAMLModalId } = useActions(verifiedDomainsLogic)\n    const { preflight } = useValues(preflightLogic)\n    const siteUrl = preflight?.site_url ?? window.location.origin\n\n    const samlReady = samlConfig.saml_acs_url && samlConfig.saml_entity_id && samlConfig.saml_x509_cert\n\n    const handleClose = (): void => {\n        setConfigureSAMLModalId(null)\n        // clean()\n    }\n\n    return (\n        <LemonModal onClose={handleClose} isOpen={!!configureSAMLModalId} title=\"\" simple>\n            <Form logic={verifiedDomainsLogic} formKey=\"samlConfig\" enableFormOnSubmit className=\"LemonModal__layout \">\n                <LemonModal.Header>\n                    <h3>Configure SAML authentication and provisioning</h3>\n                </LemonModal.Header>\n                <LemonModal.Content className=\"space-y-2\">\n                    <p>\n                        <Link to=\"https://posthog.com/docs/data/sso#setting-up-saml\" target=\"_blank\" targetBlankIcon>\n                            Read the docs\n                        </Link>\n                    </p>\n                    <LemonField label=\"ACS Consumer URL\" name=\"_ACSConsumerUrl\">\n                        <CopyToClipboardInline>{`${siteUrl}/complete/saml/`}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField label=\"RelayState\" name=\"_RelayState\">\n                        <CopyToClipboardInline>{configureSAMLModalId || 'unknown'}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField label=\"Audience / Entity ID\" name=\"_Audience\">\n                        <CopyToClipboardInline>{siteUrl}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField name=\"saml_acs_url\" label=\"SAML ACS URL\">\n                        <LemonInput className=\"ph-ignore-input\" placeholder=\"Your IdP's ACS or single sign-on URL.\" />\n                    </LemonField>\n                    <LemonField name=\"saml_entity_id\" label=\"SAML Entity ID\">\n                        <LemonInput className=\"ph-ignore-input\" placeholder=\"Entity ID provided by your IdP.\" />\n                    </LemonField>\n                    <LemonField name=\"saml_x509_cert\" label=\"SAML X.509 Certificate\">\n                        <LemonTextArea\n                            className=\"ph-ignore-input\"\n                            minRows={10}\n                            placeholder={`Enter the public certificate of your IdP. Keep all line breaks.\\n-----BEGIN CERTIFICATE-----\\nMIICVjCCAb+gAwIBAgIBADANBgkqhkiG9w0BAQ0FADBIMQswCQYDVQQGEwJ1czEL\\n-----END CERTIFICATE-----`}\n                        />\n                    </LemonField>\n                    {!samlReady && (\n                        <LemonBanner type=\"info\">\n                            SAML will not be enabled unless you enter all attributes above. However you can still\n                            settings as draft.\n                        </LemonBanner>\n                    )}\n                </LemonModal.Content>\n                <LemonModal.Footer>\n                    <LemonButton loading={isSamlConfigSubmitting} type=\"primary\" htmlType=\"submit\">\n                        Save settings\n                    </LemonButton>\n                </LemonModal.Footer>\n            </Form>\n        </LemonModal>\n    )\n}\n","import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, afterMount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl, router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { featureFlagLogic as enabledFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { featureFlagLogic } from 'scenes/feature-flags/featureFlagLogic'\nimport { Scene } from 'scenes/sceneTypes'\nimport { urls } from 'scenes/urls'\n\nimport { DataTableNode, HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\nimport {\n    Breadcrumb,\n    PropertyFilterType,\n    PropertyOperator,\n    Survey,\n    SurveyQuestionBase,\n    SurveyQuestionType,\n    SurveyUrlMatchType,\n} from '~/types'\n\nimport { defaultSurveyFieldValues, NEW_SURVEY, NewSurvey } from './constants'\nimport type { surveyLogicType } from './surveyLogicType'\nimport { surveysLogic } from './surveysLogic'\nimport { sanitizeHTML } from './utils'\n\nexport enum SurveyEditSection {\n    Steps = 'steps',\n    Widget = 'widget',\n    Presentation = 'presentation',\n    Appearance = 'appearance',\n    Customization = 'customization',\n    Targeting = 'targeting',\n}\nexport interface SurveyLogicProps {\n    /** Either a UUID or 'new'. */\n    id: string\n}\n\nexport interface SurveyMetricsQueries {\n    surveysShown: DataTableNode\n    surveysDismissed: DataTableNode\n}\n\nexport interface SurveyUserStats {\n    seen: number\n    dismissed: number\n    sent: number\n}\n\nexport interface SurveyRatingResults {\n    [key: number]: {\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveySingleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveyMultipleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n    }\n}\n\nexport interface SurveyOpenTextResults {\n    [key: number]: {\n        events: { distinct_id: string; properties: Record<string, any>; personProperties: Record<string, any> }[]\n    }\n}\n\nexport interface QuestionResultsReady {\n    [key: string]: boolean\n}\n\nconst getResponseField = (i: number): string => (i === 0 ? '$survey_response' : `$survey_response_${i}`)\n\nexport const surveyLogic = kea<surveyLogicType>([\n    props({} as SurveyLogicProps),\n    key(({ id }) => id),\n    path((key) => ['scenes', 'surveys', 'surveyLogic', key]),\n    connect(() => ({\n        actions: [\n            surveysLogic,\n            ['loadSurveys'],\n            eventUsageLogic,\n            [\n                'reportSurveyCreated',\n                'reportSurveyLaunched',\n                'reportSurveyEdited',\n                'reportSurveyArchived',\n                'reportSurveyStopped',\n                'reportSurveyResumed',\n                'reportSurveyViewed',\n            ],\n        ],\n        values: [enabledFlagLogic, ['featureFlags as enabledFlags'], surveysLogic, ['surveys']],\n    })),\n    actions({\n        setSurveyMissing: true,\n        editingSurvey: (editing: boolean) => ({ editing }),\n        setDefaultForQuestionType: (\n            idx: number,\n            type: SurveyQuestionType,\n            isEditingQuestion: boolean,\n            isEditingDescription: boolean,\n            isEditingThankYouMessage: boolean\n        ) => ({\n            idx,\n            type,\n            isEditingQuestion,\n            isEditingDescription,\n            isEditingThankYouMessage,\n        }),\n        archiveSurvey: true,\n        setWritingHTMLDescription: (writingHTML: boolean) => ({ writingHTML }),\n        setSurveyTemplateValues: (template: any) => ({ template }),\n        setSelectedQuestion: (idx: number | null) => ({ idx }),\n        setSelectedSection: (section: SurveyEditSection | null) => ({ section }),\n        resetTargeting: true,\n    }),\n    loaders(({ props, actions, values }) => ({\n        survey: {\n            loadSurvey: async () => {\n                if (props.id && props.id !== 'new') {\n                    try {\n                        const survey = await api.surveys.get(props.id)\n                        actions.reportSurveyViewed(survey)\n                        return survey\n                    } catch (error: any) {\n                        if (error.status === 404) {\n                            actions.setSurveyMissing()\n                            return { ...NEW_SURVEY }\n                        }\n                        throw error\n                    }\n                }\n                if (props.id === 'new' && router.values.hashParams.fromTemplate) {\n                    return values.survey\n                } else {\n                    return { ...NEW_SURVEY }\n                }\n            },\n            createSurvey: async (surveyPayload: Partial<Survey>) => {\n                return await api.surveys.create(sanitizeQuestions(surveyPayload))\n            },\n            updateSurvey: async (surveyPayload: Partial<Survey>) => {\n                return await api.surveys.update(props.id, sanitizeQuestions(surveyPayload))\n            },\n            launchSurvey: async () => {\n                const startDate = dayjs()\n                return await api.surveys.update(props.id, { start_date: startDate.toISOString() })\n            },\n            stopSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: dayjs().toISOString() })\n            },\n            resumeSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: null })\n            },\n        },\n        surveyUserStats: {\n            loadSurveyUserStats: async (): Promise<SurveyUserStats> => {\n                const { survey } = values\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: hogql`\n                        SELECT\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey shown'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate}),\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey dismissed'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate}),\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey sent'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate})\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n                if (results && results[0]) {\n                    const [totalSeen, dismissed, sent] = results[0]\n                    const onlySeen = totalSeen - dismissed - sent\n                    return { seen: onlySeen < 0 ? 0 : onlySeen, dismissed, sent }\n                } else {\n                    return { seen: 0, dismissed: 0, sent: 0 }\n                }\n            },\n        },\n        surveyRatingResults: {\n            loadSurveyRatingResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyRatingResults> => {\n                const { survey } = values\n\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.Rating) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.Rating}`)\n                }\n\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT\n                            JSONExtractString(properties, '${getResponseField(questionIndex)}') AS survey_response,\n                            COUNT(survey_response)\n                        FROM events\n                        WHERE event = 'survey sent' \n                            AND properties.$survey_id = '${props.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                        GROUP BY survey_response\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                let total = 0\n                const dataSize = question.scale === 10 ? 11 : question.scale\n                const data = new Array(dataSize).fill(0)\n                results?.forEach(([value, count]) => {\n                    total += count\n\n                    const index = question.scale === 10 ? value : value - 1\n                    data[index] = count\n                })\n\n                return { ...values.surveyRatingResults, [questionIndex]: { total, data } }\n            },\n        },\n        surveySingleChoiceResults: {\n            loadSurveySingleChoiceResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveySingleChoiceResults> => {\n                const { survey } = values\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT\n                            JSONExtractString(properties, '${getResponseField(questionIndex)}') AS survey_response,\n                            COUNT(survey_response)\n                        FROM events\n                        WHERE event = 'survey sent' \n                            AND properties.$survey_id = '${props.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                        GROUP BY survey_response\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                const labels = results?.map((r) => r[0])\n                const data = results?.map((r) => r[1])\n                const total = data?.reduce((a, b) => a + b, 0)\n\n                return { ...values.surveySingleChoiceResults, [questionIndex]: { labels, data, total } }\n            },\n        },\n        surveyMultipleChoiceResults: {\n            loadSurveyMultipleChoiceResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyMultipleChoiceResults> => {\n                const { survey } = values\n\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.MultipleChoice) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.MultipleChoice}`)\n                }\n\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT \n                            count(),\n                            arrayJoin(JSONExtractArrayRaw(properties, '${getResponseField(questionIndex)}')) AS choice\n                        FROM events\n                        WHERE event == 'survey sent'\n                            AND properties.$survey_id == '${survey.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                        GROUP BY choice\n                        ORDER BY count() DESC\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                let { results } = responseJSON\n\n                // Remove outside quotes\n                results = results?.map((r) => {\n                    return [r[0], r[1].slice(1, r[1].length - 1)]\n                })\n\n                // Zero-fill choices that are not open-ended\n                question.choices.forEach((choice, idx) => {\n                    const isOpenChoice = idx == question.choices.length - 1 && question?.hasOpenChoice\n                    if (results?.length && !isOpenChoice && !results.some((r) => r[1] === choice)) {\n                        results.push([0, choice])\n                    }\n                })\n\n                const data = results?.map((r) => r[0])\n                const labels = results?.map((r) => r[1])\n\n                return { ...values.surveyMultipleChoiceResults, [questionIndex]: { labels, data } }\n            },\n        },\n        surveyOpenTextResults: {\n            loadSurveyOpenTextResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyOpenTextResults> => {\n                const { survey } = values\n\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.Open) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.Open}`)\n                }\n\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT distinct_id, properties, person.properties\n                        FROM events\n                        WHERE event == 'survey sent'\n                            AND properties.$survey_id == '${survey.id}'\n                            AND trim(JSONExtractString(properties, '${getResponseField(questionIndex)}')) != ''\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                        LIMIT 20\n                    `,\n                }\n\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                const events =\n                    results?.map((r) => {\n                        const distinct_id = r[0]\n                        const properties = JSON.parse(r[1])\n                        const personProperties = JSON.parse(r[2])\n                        return { distinct_id, properties, personProperties }\n                    }) || []\n\n                return { ...values.surveyOpenTextResults, [questionIndex]: { events } }\n            },\n        },\n    })),\n    listeners(({ actions }) => ({\n        createSurveySuccess: ({ survey }) => {\n            lemonToast.success(<>Survey {survey.name} created</>)\n            actions.loadSurveys()\n            router.actions.replace(urls.survey(survey.id))\n            actions.reportSurveyCreated(survey)\n        },\n        updateSurveySuccess: ({ survey }) => {\n            lemonToast.success(<>Survey {survey.name} updated</>)\n            actions.editingSurvey(false)\n            actions.reportSurveyEdited(survey)\n            actions.loadSurveys()\n        },\n        launchSurveySuccess: ({ survey }) => {\n            lemonToast.success(<>Survey {survey.name} launched</>)\n            actions.loadSurveys()\n            actions.reportSurveyLaunched(survey)\n        },\n        stopSurveySuccess: ({ survey }) => {\n            actions.loadSurveys()\n            actions.reportSurveyStopped(survey)\n        },\n        resumeSurveySuccess: ({ survey }) => {\n            actions.loadSurveys()\n            actions.reportSurveyResumed(survey)\n        },\n        archiveSurvey: () => {\n            actions.updateSurvey({ archived: true })\n        },\n        loadSurveySuccess: () => {\n            actions.loadSurveyUserStats()\n        },\n        resetTargeting: () => {\n            actions.setSurveyValue('linked_flag_id', NEW_SURVEY.linked_flag_id)\n            actions.setSurveyValue('targeting_flag_filters', NEW_SURVEY.targeting_flag_filters)\n            actions.setSurveyValue('linked_flag', NEW_SURVEY.linked_flag)\n            actions.setSurveyValue('targeting_flag', NEW_SURVEY.targeting_flag)\n            actions.setSurveyValue('conditions', NEW_SURVEY.conditions)\n            actions.setSurveyValue('remove_targeting_flag', true)\n        },\n    })),\n    reducers({\n        isEditingSurvey: [\n            false,\n            {\n                editingSurvey: (_, { editing }) => editing,\n            },\n        ],\n        surveyMissing: [\n            false,\n            {\n                setSurveyMissing: () => true,\n            },\n        ],\n        survey: [\n            { ...NEW_SURVEY } as NewSurvey | Survey,\n            {\n                setDefaultForQuestionType: (\n                    state,\n                    { idx, type, isEditingQuestion, isEditingDescription, isEditingThankYouMessage }\n                ) => {\n                    const question = isEditingQuestion\n                        ? state.questions[idx].question\n                        : defaultSurveyFieldValues[type].questions[0].question\n                    const description = isEditingDescription\n                        ? state.questions[idx].description\n                        : defaultSurveyFieldValues[type].questions[0].description\n                    const thankYouMessageHeader = isEditingThankYouMessage\n                        ? state.appearance.thankYouMessageHeader\n                        : defaultSurveyFieldValues[type].appearance.thankYouMessageHeader\n                    const newQuestions = [...state.questions]\n                    newQuestions[idx] = {\n                        ...state.questions[idx],\n                        ...(defaultSurveyFieldValues[type].questions[0] as SurveyQuestionBase),\n                        question,\n                        description,\n                    }\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                        appearance: {\n                            ...state.appearance,\n                            ...defaultSurveyFieldValues[type].appearance,\n                            thankYouMessageHeader,\n                        },\n                    }\n                },\n                setSurveyTemplateValues: (_, { template }) => {\n                    const newTemplateSurvey = { ...NEW_SURVEY, ...template }\n                    return newTemplateSurvey\n                },\n            },\n        ],\n        selectedQuestion: [\n            0 as number | null,\n            {\n                setSelectedQuestion: (_, { idx }) => idx,\n            },\n        ],\n        selectedSection: [\n            SurveyEditSection.Steps as SurveyEditSection | null,\n            {\n                setSelectedSection: (_, { section }) => section,\n            },\n        ],\n        surveyRatingResultsReady: [\n            {},\n            {\n                loadSurveyRatingResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveySingleChoiceResultsReady: [\n            {},\n            {\n                loadSurveySingleChoiceResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveyMultipleChoiceResultsReady: [\n            {},\n            {\n                loadSurveyMultipleChoiceResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveyOpenTextResultsReady: [\n            {},\n            {\n                loadSurveyOpenTextResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        writingHTMLDescription: [\n            false,\n            {\n                setWritingHTMLDescription: (_, { writingHTML }) => writingHTML,\n            },\n        ],\n    }),\n    selectors({\n        isSurveyRunning: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(survey.start_date && !survey.end_date)\n            },\n        ],\n        hasTargetingSet: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                const hasLinkedFlag =\n                    !!survey.linked_flag_id || (survey.linked_flag && Object.keys(survey.linked_flag).length > 0)\n                const hasTargetingFlag =\n                    (survey.targeting_flag && Object.keys(survey.targeting_flag).length > 0) ||\n                    (survey.targeting_flag_filters && Object.keys(survey.targeting_flag_filters).length > 0)\n                const hasOtherConditions = survey.conditions && Object.keys(survey.conditions).length > 0\n                return !!hasLinkedFlag || !!hasTargetingFlag || !!hasOtherConditions\n            },\n        ],\n        breadcrumbs: [\n            (s) => [s.survey],\n            (survey: Survey): Breadcrumb[] => [\n                {\n                    key: Scene.Surveys,\n                    name: 'Surveys',\n                    path: urls.surveys(),\n                },\n                { key: [Scene.Survey, survey?.id || 'new'], name: survey.name },\n            ],\n        ],\n        dataTableQuery: [\n            (s) => [s.survey],\n            (survey): DataTableNode | null => {\n                if (survey.id === 'new') {\n                    return null\n                }\n                const createdAt = (survey as Survey).created_at\n                return {\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.EventsQuery,\n                        select: [\n                            '*',\n                            ...survey.questions.map((q, i) => {\n                                if (q.type === SurveyQuestionType.MultipleChoice) {\n                                    // Join array items into a string\n                                    return `coalesce(arrayStringConcat(JSONExtractArrayRaw(properties, '${getResponseField(\n                                        i\n                                    )}'), ', ')) -- ${q.question}`\n                                }\n\n                                return `coalesce(JSONExtractString(properties, '${getResponseField(i)}')) -- ${\n                                    q.question\n                                }`\n                            }),\n                            'timestamp',\n                            'person',\n                        ],\n                        orderBy: ['timestamp DESC'],\n                        where: [`event == 'survey sent'`],\n                        after: createdAt,\n                        properties: [\n                            {\n                                type: PropertyFilterType.Event,\n                                key: '$survey_id',\n                                operator: PropertyOperator.Exact,\n                                value: survey.id,\n                            },\n                        ],\n                    },\n                    propertiesViaUrl: true,\n                    showExport: true,\n                    showReload: true,\n                    showEventFilter: true,\n                    showPropertyFilter: true,\n                    showTimings: false,\n                }\n            },\n        ],\n        hasTargetingFlag: [\n            (s) => [s.survey],\n            (survey): boolean => {\n                return !!survey.targeting_flag || !!survey.targeting_flag_filters\n            },\n        ],\n        urlMatchTypeValidationError: [\n            (s) => [s.survey],\n            (survey): string | null => {\n                if (survey.conditions?.urlMatchType === SurveyUrlMatchType.Regex && survey.conditions.url) {\n                    try {\n                        new RegExp(survey.conditions.url)\n                    } catch (e: any) {\n                        return e.message\n                    }\n                }\n                return null\n            },\n        ],\n        surveyNPSScore: [\n            (s) => [s.surveyRatingResults],\n            (surveyRatingResults) => {\n                if (surveyRatingResults) {\n                    const questionIdx = Object.keys(surveyRatingResults)[0]\n                    const questionResults: number[] = surveyRatingResults[questionIdx].data\n                    if (questionResults.length === 11) {\n                        const promoters = questionResults.slice(9, 11).reduce((a, b) => a + b, 0)\n                        const passives = questionResults.slice(7, 9).reduce((a, b) => a + b, 0)\n                        const detractors = questionResults.slice(0, 7).reduce((a, b) => a + b, 0)\n                        const npsScore = ((promoters - detractors) / (promoters + passives + detractors)) * 100\n                        return npsScore.toFixed(1)\n                    }\n                }\n            },\n        ],\n    }),\n    forms(({ actions, props, values }) => ({\n        survey: {\n            defaults: { ...NEW_SURVEY } as NewSurvey | Survey,\n            errors: ({ name, questions }) => ({\n                name: !name && 'Please enter a name.',\n                questions: questions.map((question) => ({\n                    question: !question.question && 'Please enter a question.',\n                    ...(question.type === SurveyQuestionType.Rating\n                        ? {\n                              display: !question.display && 'Please choose a display type.',\n                              scale: !question.scale && 'Please choose a scale.',\n                          }\n                        : {}),\n                })),\n                // controlled using a PureField in the form\n                urlMatchType: values.urlMatchTypeValidationError,\n            }),\n            submit: (surveyPayload) => {\n                let surveyPayloadWithTargetingFlagFilters = surveyPayload\n                const flagLogic = featureFlagLogic({ id: values.survey.targeting_flag?.id || 'new' })\n                if (values.hasTargetingFlag) {\n                    const targetingFlag = flagLogic.values.featureFlag\n                    surveyPayloadWithTargetingFlagFilters = {\n                        ...surveyPayload,\n                        ...{ targeting_flag_filters: targetingFlag.filters },\n                    }\n                }\n                if (props.id && props.id !== 'new') {\n                    actions.updateSurvey(surveyPayloadWithTargetingFlagFilters)\n                } else {\n                    actions.createSurvey(surveyPayloadWithTargetingFlagFilters)\n                }\n            },\n        },\n    })),\n    urlToAction(({ actions, props }) => ({\n        [urls.survey(props.id ?? 'new')]: (_, __, ___, { method }) => {\n            // If the URL was pushed (user clicked on a link), reset the scene's data.\n            // This avoids resetting form fields if you click back/forward.\n            if (method === 'PUSH') {\n                if (props.id) {\n                    actions.loadSurvey()\n                } else {\n                    actions.resetSurvey()\n                }\n            }\n        },\n    })),\n    actionToUrl(({ values }) => ({\n        setSurveyTemplateValues: () => {\n            const hashParams = router.values.hashParams\n            hashParams['fromTemplate'] = true\n\n            return [urls.survey(values.survey.id), router.values.searchParams, hashParams]\n        },\n    })),\n    afterMount(({ props, actions }) => {\n        if (props.id !== 'new') {\n            actions.loadSurvey()\n        }\n        if (props.id === 'new') {\n            actions.resetSurvey()\n        }\n    }),\n])\n\nfunction sanitizeQuestions(surveyPayload: Partial<Survey>): Partial<Survey> {\n    if (!surveyPayload.questions) {\n        return surveyPayload\n    }\n\n    const sanitizedThankYouHeader = sanitizeHTML(surveyPayload.appearance?.thankYouMessageHeader || '')\n    const sanitizedThankYouDescription = sanitizeHTML(surveyPayload.appearance?.thankYouMessageDescription || '')\n\n    return {\n        ...surveyPayload,\n        questions: surveyPayload.questions?.map((rawQuestion) => {\n            return {\n                ...rawQuestion,\n                description: sanitizeHTML(rawQuestion.description || ''),\n                question: sanitizeHTML(rawQuestion.question || ''),\n            }\n        }),\n        appearance: {\n            ...surveyPayload.appearance,\n            ...(sanitizedThankYouHeader && { thankYouMessageHeader: sanitizedThankYouHeader }),\n            ...(sanitizedThankYouDescription && { thankYouMessageDescription: sanitizedThankYouDescription }),\n        },\n    }\n}\n"],"names":[],"sourceRoot":""}