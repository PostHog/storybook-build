"use strict";(self.webpackChunkposthog=self.webpackChunkposthog||[]).push([[6745],{"./frontend/src/scenes/web-analytics/WebAnalyticsScene.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{WebAnalyticsScene:()=>WebAnalyticsScene,scene:()=>scene});var index_esm=__webpack_require__("./node_modules/.pnpm/kea@3.1.5_react@16.14.0/node_modules/kea/lib/index.esm.js");const webAnalyticsLogic=(0,index_esm.kea)([(0,index_esm.path)(["scenes","webAnalytics","webAnalyticsSceneLogic"]),(0,index_esm.connect)({}),(0,index_esm.actions)({}),(0,index_esm.reducers)({}),(0,index_esm.selectors)((()=>({}))),(0,index_esm.sharedListeners)((()=>({}))),(0,index_esm.listeners)((()=>({})))]);var Query=__webpack_require__("./frontend/src/queries/Query/Query.tsx"),schema=__webpack_require__("./frontend/src/queries/schema.ts"),jsx_runtime=__webpack_require__("./node_modules/.pnpm/react@16.14.0/node_modules/react/jsx-runtime.js");function WebAnalyticsScene(){return(0,jsx_runtime.jsxs)("div",{children:["Top pages",(0,jsx_runtime.jsx)(Query.A,{query:{full:!0,kind:schema.O.DataTableNode,source:{kind:schema.O.HogQLQuery,query:TOP_PAGES_SQL}},readOnly:!0}),"Top sources",(0,jsx_runtime.jsx)(Query.A,{query:{full:!0,kind:schema.O.DataTableNode,source:{kind:schema.O.HogQLQuery,query:TOP_SOURCES}},readOnly:!0}),"Top clicks",(0,jsx_runtime.jsx)(Query.A,{query:{full:!0,kind:schema.O.DataTableNode,source:{kind:schema.O.HogQLQuery,query:TOP_CLICKS_SQL}},readOnly:!0})]})}const scene={component:WebAnalyticsScene,logic:webAnalyticsLogic},TOP_CLICKS_SQL="\n    SELECT\n    properties.$el_text as el_text,\n    count() as total_clicks,\n    COUNT(DISTINCT events.person_id) as unique_visitors\nFROM\n    events\nWHERE\n    event == '$autocapture'\nAND events.timestamp >= now() - INTERVAL 7 DAY\nAND events.properties.$event_type = 'click'\nAND el_text IS NOT NULL\nGROUP BY\n    el_text\nORDER BY total_clicks DESC\n    ",TOP_PAGES_SQL="\nWITH\n\nscroll_depth_cte AS (\nSELECT\n    events.properties.`$prev_pageview_pathname` AS pathname,\n    countIf(events.event == '$pageview') as total_pageviews,\n    COUNT(DISTINCT events.properties.distinct_id) as unique_visitors, -- might want to use person id? have seen a small number of pages where unique > total\n    avg(CASE\n        WHEN events.properties.`$prev_pageview_max_content_percentage` IS NULL THEN NULL\n        WHEN events.properties.`$prev_pageview_max_content_percentage` > 0.8 THEN 100\n        ELSE 0\n    END) AS scroll_gt80_percentage,\n    avg(events.properties.$prev_pageview_max_scroll_percentage) * 100 as average_scroll_percentage\nFROM\n    events\nWHERE\n    (event = '$pageview' OR event = '$pageleave') AND events.properties.`$prev_pageview_pathname` IS NOT NULL\n    AND events.timestamp >= now() - INTERVAL 7 DAY\nGROUP BY pathname\n)\n\n,\n\nsession_cte AS (\nSELECT\n    events.properties.`$session_id` AS session_id,\n    min(events.timestamp) AS min_timestamp,\n    max(events.timestamp) AS max_timestamp,\n    dateDiff('second', min_timestamp, max_timestamp) AS duration_s,\n\n    -- create a tuple so that these are grouped in the same order, see https://github.com/ClickHouse/ClickHouse/discussions/42338\n    groupArray((events.timestamp, events.properties.`$referrer`, events.properties.`$pathname`, events.properties.utm_source)) AS tuple_array,\n    arrayFirstIndex(x -> tupleElement(x, 1) == min_timestamp, tuple_array) as index_of_earliest,\n    arrayFirstIndex(x -> tupleElement(x, 1) == max_timestamp, tuple_array) as index_of_latest,\n    tupleElement(arrayElement(\n        tuple_array,\n        index_of_earliest\n    ), 2) AS earliest_referrer,\n    tupleElement(arrayElement(\n        tuple_array,\n        index_of_earliest\n    ), 3) AS earliest_pathname,\n    tupleElement(arrayElement(\n        tuple_array,\n        index_of_earliest\n    ), 4) AS earliest_utm_source,\n\n    if(domain(earliest_referrer) = '', earliest_referrer, domain(earliest_referrer)) AS referrer_domain,\n    multiIf(\n        earliest_utm_source IS NOT NULL, earliest_utm_source,\n        -- This will need to be an approach that scales better\n        referrer_domain == 'app.posthog.com', 'posthog',\n        referrer_domain == 'eu.posthog.com', 'posthog',\n        referrer_domain == 'posthog.com', 'posthog',\n        referrer_domain == 'www.google.com', 'google',\n        referrer_domain == 'www.google.co.uk', 'google',\n        referrer_domain == 'www.google.com.hk', 'google',\n        referrer_domain == 'www.google.de', 'google',\n        referrer_domain == 't.co', 'twitter',\n        referrer_domain == 'github.com', 'github',\n        referrer_domain == 'duckduckgo.com', 'duckduckgo',\n        referrer_domain == 'www.bing.com', 'bing',\n        referrer_domain == 'bing.com', 'bing',\n        referrer_domain == 'yandex.ru', 'yandex',\n        referrer_domain == 'quora.com', 'quora',\n        referrer_domain == 'www.quora.com', 'quora',\n        referrer_domain == 'linkedin.com', 'linkedin',\n        referrer_domain == 'www.linkedin.com', 'linkedin',\n        startsWith(referrer_domain, 'http://localhost:'), 'localhost',\n        referrer_domain\n    ) AS blended_source,\n\n    countIf(events.event == '$pageview') AS num_pageviews,\n    countIf(events.event == '$autocapture') AS num_autocaptures,\n    -- in v1 we'd also want to count whether there were any conversion events\n\n    any(events.person_id) as person_id,\n    -- definition of a GA4 bounce from here https://support.google.com/analytics/answer/12195621?hl=en\n    (num_autocaptures == 0 AND num_pageviews <= 1 AND duration_s < 10) AS is_bounce\nFROM\n    events\nWHERE\n    session_id IS NOT NULL\nAND\n    events.timestamp >= now() - INTERVAL 8 DAY\nGROUP BY\n    events.properties.`$session_id`\nHAVING\n    min_timestamp >= now() - INTERVAL 7 DAY\n)\n\n,\n\nbounce_rate_cte AS (\nSELECT session_cte.earliest_pathname,\n       avg(session_cte.is_bounce) as bounce_rate\nFROM session_cte\nGROUP BY earliest_pathname\n)\n\n\n\nSELECT scroll_depth_cte.pathname as pathname,\nscroll_depth_cte.total_pageviews as total_pageviews,\nscroll_depth_cte.unique_visitors as unique_visitors,\nscroll_depth_cte.scroll_gt80_percentage as scroll_gt80_percentage,\nscroll_depth_cte.average_scroll_percentage as average_scroll_percentage,\nbounce_rate_cte.bounce_rate as bounce_rate\nFROM\n    scroll_depth_cte LEFT OUTER JOIN bounce_rate_cte\nON scroll_depth_cte.pathname = bounce_rate_cte.earliest_pathname\nORDER BY total_pageviews DESC\n",TOP_SOURCES="\nWITH\n\nsession_cte AS (\nSELECT\n    events.properties.`$session_id` AS session_id,\n    min(events.timestamp) AS min_timestamp,\n    max(events.timestamp) AS max_timestamp,\n    dateDiff('second', min_timestamp, max_timestamp) AS duration_s,\n\n    -- create a tuple so that these are grouped in the same order, see https://github.com/ClickHouse/ClickHouse/discussions/42338\n    groupArray((events.timestamp, events.properties.`$referrer`, events.properties.`$pathname`, events.properties.utm_source)) AS tuple_array,\n    arrayFirstIndex(x -> tupleElement(x, 1) == min_timestamp, tuple_array) as index_of_earliest,\n    arrayFirstIndex(x -> tupleElement(x, 1) == max_timestamp, tuple_array) as index_of_latest,\n    tupleElement(arrayElement(\n        tuple_array,\n        index_of_earliest\n    ), 2) AS earliest_referrer,\n    tupleElement(arrayElement(\n        tuple_array,\n        index_of_earliest\n    ), 3) AS earliest_pathname,\n    tupleElement(arrayElement(\n        tuple_array,\n        index_of_earliest\n    ), 4) AS earliest_utm_source,\n\n    if(domain(earliest_referrer) = '', earliest_referrer, domain(earliest_referrer)) AS referrer_domain,\n    multiIf(\n        earliest_utm_source IS NOT NULL, earliest_utm_source,\n        -- This will need to be an approach that scales better\n        referrer_domain == 'app.posthog.com', 'posthog',\n        referrer_domain == 'eu.posthog.com', 'posthog',\n        referrer_domain == 'posthog.com', 'posthog',\n        referrer_domain == 'www.google.com', 'google',\n        referrer_domain == 'www.google.co.uk', 'google',\n        referrer_domain == 'www.google.com.hk', 'google',\n        referrer_domain == 'www.google.de', 'google',\n        referrer_domain == 't.co', 'twitter',\n        referrer_domain == 'github.com', 'github',\n        referrer_domain == 'duckduckgo.com', 'duckduckgo',\n        referrer_domain == 'www.bing.com', 'bing',\n        referrer_domain == 'bing.com', 'bing',\n        referrer_domain == 'yandex.ru', 'yandex',\n        referrer_domain == 'quora.com', 'quora',\n        referrer_domain == 'www.quora.com', 'quora',\n        referrer_domain == 'linkedin.com', 'linkedin',\n        referrer_domain == 'www.linkedin.com', 'linkedin',\n        startsWith(referrer_domain, 'http://localhost:'), 'localhost',\n        referrer_domain\n    ) AS blended_source,\n\n    countIf(events.event == '$pageview') AS num_pageviews,\n    countIf(events.event == '$autocapture') AS num_autocaptures,\n    -- in v1 we'd also want to count whether there were any conversion events\n\n    any(events.person_id) as person_id,\n    -- definition of a GA4 bounce from here https://support.google.com/analytics/answer/12195621?hl=en\n    (num_autocaptures == 0 AND num_pageviews <= 1 AND duration_s < 10) AS is_bounce\nFROM\n    events\nWHERE\n    session_id IS NOT NULL\nAND\n    events.timestamp >= now() - INTERVAL 8 DAY\nGROUP BY\n    events.properties.`$session_id`\nHAVING\n    min_timestamp >= now() - INTERVAL 7 DAY\n)\n\n\n\nSELECT\n    blended_source,\n    count(num_pageviews) as total_pageviews,\n    count(DISTINCT person_id) as unique_visitors,\n    avg(is_bounce) AS bounce_rate\nFROM\n    session_cte\nWHERE\n    blended_source IS NOT NULL\nGROUP BY blended_source\n\nORDER BY total_pageviews DESC\nLIMIT 100\n\n\n"}}]);