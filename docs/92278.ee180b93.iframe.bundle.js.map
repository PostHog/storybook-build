{"version":3,"file":"92278.ee180b93.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAkGA","sources":["webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/components/replayActiveHoursHeatMapLogic.ts"],"sourcesContent":["import { afterMount, kea, key, listeners, path, props, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { router } from 'kea-router'\nimport api from 'lib/api'\nimport { Dayjs, now } from 'lib/dayjs'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport posthog from 'posthog-js'\nimport { urls } from 'scenes/urls'\nimport { CalendarHeatMapProps } from 'scenes/web-analytics/CalendarHeatMap/CalendarHeatMap'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\nimport { ReplayTabs } from '~/types'\n\nimport type { replayActiveHoursHeatMapLogicType } from './replayActiveHoursHeatMapLogicType'\n\nexport interface ReplayActiveHoursHeatMapLogicProps {\n    // we can show this component in different contexts, and key it accordingly\n    scene?: 'templates' | 'filters' | 'replay-home'\n}\n\nconst rowLabels = ['00:00 - 04:00', '04:00 - 08:00', '08:00 - 12:00', '12:00 - 16:00', '16:00 - 20:00', '20:00 - 00:00']\n\nconst columnLabels = (now: Dayjs): string[] => [\n    now.subtract(6, 'day').format('ddd D'),\n    now.subtract(5, 'day').format('ddd D'),\n    now.subtract(4, 'day').format('ddd D'),\n    now.subtract(3, 'day').format('ddd D'),\n    now.subtract(2, 'day').format('ddd D'),\n    now.subtract(1, 'day').format('ddd D'),\n    'Today',\n]\n\n// does not need to be on the logic yet, since it's stateless for now\nexport const getOnClickTooltip = (colIndex: number, rowIndex: number | undefined): string => {\n    const day = columnLabels(now())[colIndex]\n    const timeRange = rowIndex === undefined ? undefined : rowLabels[rowIndex]\n    return `View recordings for ${day}${timeRange ? ` ${timeRange}` : ''}`\n}\n\n// does not need to be on the logic yet, since it's stateless for now\nexport const onCellClick = (colIndex: number, rowIndex: number | undefined): void => {\n    const daysToSubtract = 6 - colIndex\n    let startDate = now().subtract(daysToSubtract, 'day').startOf('day').utc(true)\n    let endDate = startDate.clone()\n\n    if (rowIndex !== undefined) {\n        const startHour = rowIndex * 4\n        const endHour = startHour + 4\n        startDate = startDate.hour(startHour)\n        endDate = endDate.hour(endHour)\n    } else {\n        endDate = endDate.add(1, 'day')\n    }\n\n    posthog.capture('clicked_replay_active_hours_heatmap_cell', {\n        isColumnHeader: rowIndex == undefined,\n        isIndividualCell: rowIndex != undefined,\n    })\n\n    router.actions.push(\n        urls.replay(ReplayTabs.Home, {\n            date_from: startDate.toISOString(),\n            date_to: endDate.toISOString(),\n        })\n    )\n}\n\nexport const replayActiveHoursHeatMapLogic = kea<replayActiveHoursHeatMapLogicType>([\n    path(['scenes', 'session-recordings', 'components', 'replayActiveHoursHeatMapLogic']),\n    props({} as ReplayActiveHoursHeatMapLogicProps),\n    key((props) => props.scene || 'default'),\n    loaders(() => ({\n        recordingsPerHour: {\n            loadRecordingsPerHour: async (_, breakpoint): Promise<number[][]> => {\n                const q = hogql`\n                    SELECT hour_block,\n                           countIf(_toDate(mints) = today() - 6) AS \"Day -6\",\n                           countIf(_toDate(mints) = today() - 5) AS \"Day -5\",\n                           countIf(_toDate(mints) = today() - 4) AS \"Day -4\",\n                           countIf(_toDate(mints) = today() - 3) AS \"Day -3\",\n                           countIf(_toDate(mints) = today() - 2) AS \"Day -2\",\n                           countIf(_toDate(mints) = today() - 1) AS \"Day -1\",\n                           countIf(_toDate(mints) = today())     AS \"Day 0\"\n                    FROM (SELECT intDiv(toHour(mints), 4) * 4 AS real_hour_block,\n                                 mints\n                          FROM (SELECT min(min_first_timestamp) AS mints\n                                FROM raw_session_replay_events\n                                WHERE min_first_timestamp >= now() - INTERVAL 7 day\n                                  AND min_first_timestamp <= now()\n                                GROUP BY session_id\n                                having dateDiff('SECOND'\n                                     , min (min_first_timestamp)\n                                     , max (max_last_timestamp))\n                                     > 5)) AS data\n                             RIGHT JOIN (SELECT arrayJoin([0, 4, 8, 12, 16, 20]) AS hour_block) AS hours\n                                        ON data.real_hour_block = hours.hour_block\n                    GROUP BY hour_block\n                    ORDER BY hour_block`\n\n                const qResponse = await api.query<HogQLQuery>({\n                    kind: NodeKind.HogQLQuery,\n                    query: q,\n                })\n\n                // this gives an array of arrays\n                // we're loading hours 0-4, 4-8, 8-12, 12-16, 16-20, 20-24\n                // so we get an array with 6 elements\n                // each of those has 8 values\n                // [0] is the hour block\n                // and then each of the other 7 values is the count for that day\n\n                breakpoint()\n\n                return qResponse.results as number[][]\n            },\n        },\n    })),\n    selectors(() => ({\n        calendarHeatmapProps: [\n            (s) => [s.recordingsPerHour],\n            (\n                recordingsPerHour: number[][]\n            ): Pick<CalendarHeatMapProps, 'rowLabels' | 'columnLabels' | 'processedData'> => {\n                if (!recordingsPerHour || recordingsPerHour.length === 0 || recordingsPerHour[0].length === 0) {\n                    return {\n                        rowLabels: [],\n                        columnLabels: [],\n                        processedData: {\n                            matrix: [],\n                            columnsAggregations: [],\n                            rowsAggregations: [],\n                            overallValue: 0,\n                            maxOverall: 0,\n                            minOverall: 0,\n                            maxRowAggregation: 0,\n                            minRowAggregation: 0,\n                            maxColumnAggregation: 0,\n                            minColumnAggregation: 0,\n                        },\n                    }\n                }\n\n                const dataWithoutHourBlock = recordingsPerHour.map((row) => row.slice(1))\n\n                const columnsAggregations = dataWithoutHourBlock.reduce((acc, row) => {\n                    row.forEach((value: number, index: number) => {\n                        acc[index] = (acc[index] || 0) + value\n                    })\n                    return acc\n                }, [])\n                const rowsAggregations = dataWithoutHourBlock.reduce((acc, row) => {\n                    // take each row and ignoring row[0]\n                    // gather a sum for each index in the row\n                    // so we end up with an array of numbers with length 6\n                    acc[row[0]] = (acc[row[0]] || 0) + row.reduce((a: number, b: number) => a + b, 0)\n                    return acc\n                }, [])\n                const processedData = {\n                    matrix: dataWithoutHourBlock,\n                    columnsAggregations: columnsAggregations,\n                    rowsAggregations: rowsAggregations,\n                    overallValue: columnsAggregations.reduce((a: number, b: number) => a + b, 0),\n                    maxOverall: dataWithoutHourBlock.reduce((acc, row) => {\n                        return Math.max(acc, ...row)\n                    }, 0),\n                    minOverall: dataWithoutHourBlock.reduce((acc, row) => {\n                        return Math.min(acc, ...row)\n                    }, 0),\n                    maxColumnAggregation: Math.max(...columnsAggregations),\n                    minColumnAggregation: Math.min(...columnsAggregations),\n                    maxRowAggregation: Math.max(...rowsAggregations),\n                    minRowAggregation: Math.min(...rowsAggregations),\n                }\n\n                return {\n                    rowLabels: rowLabels,\n                    columnLabels: columnLabels(now()),\n                    processedData: processedData,\n                }\n            },\n        ],\n        isClickable: [\n            (s) => [s.calendarHeatmapProps],\n            (calendarHeatmapProps) => (colIndex: number, rowIndex?: number) => {\n                const valueSource =\n                    rowIndex == undefined\n                        ? calendarHeatmapProps?.processedData.columnsAggregations\n                        : calendarHeatmapProps?.processedData.matrix[rowIndex]\n                return (valueSource[colIndex] ?? 0) > 0\n            },\n        ],\n    })),\n    listeners(() => ({\n        loadRecordingsPerHourFailed: async () => {\n            lemonToast.error('Failed to load recordings activity for heatmap')\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadRecordingsPerHour(undefined)\n    }),\n])\n"],"names":[],"sourceRoot":""}