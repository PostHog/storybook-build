{"version":3,"file":"84772.28ebe610.iframe.bundle.js","mappings":";;AAkVA;;AAGA","sources":["webpack://posthog/./products/llm_observability/frontend/llmObservabilityLogic.tsx"],"sourcesContent":["import { actions, afterMount, connect, kea, path, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { TaxonomicFilterGroupType } from 'lib/components/TaxonomicFilter/types'\nimport { isDefinitionStale } from 'lib/utils/definitions'\nimport { sceneLogic } from 'scenes/sceneLogic'\n\nimport { groupsModel } from '~/models/groupsModel'\nimport { DataTableNode, NodeKind, TrendsQuery } from '~/queries/schema/schema-general'\nimport {\n    AnyPropertyFilter,\n    BaseMathType,\n    ChartDisplayType,\n    EventDefinitionType,\n    HogQLMathType,\n    PropertyFilterType,\n    PropertyMathType,\n} from '~/types'\n\nimport type { llmObservabilityLogicType } from './llmObservabilityLogicType'\n\nexport const LLM_OBSERVABILITY_DATA_COLLECTION_NODE_ID = 'llm-observability-data'\n\nconst INITIAL_DATE_FROM = '-7d' as string | null\nconst INITIAL_DATE_TO = null as string | null\n\nexport interface QueryTile {\n    title: string\n    description?: string\n    query: TrendsQuery\n    layout?: {\n        className?: string\n    }\n}\n\nexport const llmObservabilityLogic = kea<llmObservabilityLogicType>([\n    path(['products', 'llm_observability', 'frontend', 'llmObservabilityLogic']),\n    connect({ values: [sceneLogic, ['sceneKey']] }),\n    actions({\n        setDates: (dateFrom: string | null, dateTo: string | null) => ({ dateFrom, dateTo }),\n        setShouldFilterTestAccounts: (shouldFilterTestAccounts: boolean) => ({ shouldFilterTestAccounts }),\n        setPropertyFilters: (propertyFilters: AnyPropertyFilter[]) => ({ propertyFilters }),\n    }),\n    reducers({\n        dateFilter: [\n            {\n                dateFrom: INITIAL_DATE_FROM,\n                dateTo: INITIAL_DATE_TO,\n            },\n            {\n                setDates: (_, { dateFrom, dateTo }) => ({ dateFrom, dateTo }),\n            },\n        ],\n        shouldFilterTestAccounts: [\n            false,\n            {\n                setShouldFilterTestAccounts: (_, { shouldFilterTestAccounts }) => shouldFilterTestAccounts,\n            },\n        ],\n        propertyFilters: [\n            [] as AnyPropertyFilter[],\n            {\n                setPropertyFilters: (_, { propertyFilters }) => propertyFilters,\n            },\n        ],\n    }),\n\n    loaders({\n        hasSentAiGenerationEvent: {\n            __default: undefined as boolean | undefined,\n            loadAIEventDefinition: async (): Promise<boolean> => {\n                const aiGenerationDefinition = await api.eventDefinitions.list({\n                    event_type: EventDefinitionType.Event,\n                    search: '$ai_generation',\n                })\n\n                // no need to worry about pagination here, event names beginning with $ are reserved, and we're not\n                // going to add enough reserved event names that match this search term to cause problems\n                const definition = aiGenerationDefinition.results.find((r) => r.name === '$ai_generation')\n                if (definition && !isDefinitionStale(definition)) {\n                    return true\n                }\n                return false\n            },\n        },\n    }),\n    selectors({\n        activeTab: [\n            (s) => [s.sceneKey],\n            (sceneKey) => {\n                if (sceneKey === 'llmObservabilityGenerations') {\n                    return 'generations'\n                } else if (sceneKey === 'llmObservabilityTraces') {\n                    return 'traces'\n                }\n                return 'dashboard'\n            },\n        ],\n        tiles: [\n            (s) => [s.dateFilter, s.shouldFilterTestAccounts, s.propertyFilters],\n            (dateFilter, shouldFilterTestAccounts, propertyFilters): QueryTile[] => [\n                {\n                    title: 'Traces',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                                math: HogQLMathType.HogQL,\n                                math_hogql: 'COUNT(DISTINCT properties.$ai_trace_id)',\n                            },\n                        ],\n                        dateRange: { date_from: dateFilter.dateFrom, date_to: dateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                },\n                {\n                    title: 'Generative AI users',\n                    description: 'To count users, set `distinct_id` in LLM tracking.',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                                math: BaseMathType.UniqueUsers,\n                            },\n                        ],\n                        dateRange: { date_from: dateFilter.dateFrom, date_to: dateFilter.dateTo },\n                        properties: propertyFilters.concat({\n                            type: PropertyFilterType.HogQL,\n                            key: 'distinct_id != properties.$ai_trace_id',\n                        }),\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                },\n                {\n                    title: 'Total cost (USD)',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                math: PropertyMathType.Sum,\n                                kind: NodeKind.EventsNode,\n                                math_property: '$ai_total_cost_usd',\n                            },\n                        ],\n                        trendsFilter: {\n                            aggregationAxisPrefix: '$',\n                            decimalPlaces: 4,\n                            display: ChartDisplayType.BoldNumber,\n                        },\n                        dateRange: { date_from: dateFilter.dateFrom, date_to: dateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                },\n                {\n                    title: 'Cost per user (USD)',\n                    description: \"Average cost for each generative AI user active in the data point's period.\",\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                math: PropertyMathType.Sum,\n                                kind: NodeKind.EventsNode,\n                                math_property: '$ai_total_cost_usd',\n                            },\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                                math: BaseMathType.UniqueUsers,\n                            },\n                        ],\n                        trendsFilter: {\n                            formula: 'A / B',\n                            aggregationAxisPrefix: '$',\n                            decimalPlaces: 2,\n                        },\n                        dateRange: { date_from: dateFilter.dateFrom, date_to: dateFilter.dateTo },\n                        properties: propertyFilters.concat({\n                            type: PropertyFilterType.HogQL,\n                            key: 'distinct_id != properties.$ai_trace_id',\n                        }),\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                },\n                {\n                    title: 'Cost by model (USD)',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                math: PropertyMathType.Sum,\n                                kind: NodeKind.EventsNode,\n                                math_property: '$ai_total_cost_usd',\n                            },\n                        ],\n                        breakdownFilter: {\n                            breakdown_type: 'event',\n                            breakdown: '$ai_model',\n                        },\n                        trendsFilter: {\n                            aggregationAxisPrefix: '$',\n                            decimalPlaces: 2,\n                            display: ChartDisplayType.ActionsBarValue,\n                            showValuesOnSeries: true,\n                        },\n                        dateRange: { date_from: dateFilter.dateFrom, date_to: dateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                },\n                {\n                    title: 'Generation calls',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                            },\n                        ],\n                        dateRange: { date_from: dateFilter.dateFrom, date_to: dateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                },\n                {\n                    title: 'Generation latency by model (median)',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                math: PropertyMathType.Median,\n                                kind: NodeKind.EventsNode,\n                                math_property: '$ai_latency',\n                            },\n                        ],\n                        breakdownFilter: {\n                            breakdown: '$ai_model',\n                        },\n                        trendsFilter: {\n                            aggregationAxisPostfix: ' s',\n                            decimalPlaces: 2,\n                        },\n                        dateRange: { date_from: dateFilter.dateFrom, date_to: dateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                },\n                {\n                    title: 'Generations by HTTP status',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                            },\n                        ],\n                        breakdownFilter: {\n                            breakdown: '$ai_http_status',\n                        },\n                        trendsFilter: {\n                            display: ChartDisplayType.ActionsBarValue,\n                        },\n                        dateRange: { date_from: dateFilter.dateFrom, date_to: dateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                },\n            ],\n        ],\n        tracesQuery: [\n            (s) => [\n                s.dateFilter,\n                s.shouldFilterTestAccounts,\n                s.propertyFilters,\n                groupsModel.selectors.groupsTaxonomicTypes,\n            ],\n            (dateFilter, shouldFilterTestAccounts, propertyFilters, groupsTaxonomicTypes): DataTableNode => ({\n                kind: NodeKind.DataTableNode,\n                source: {\n                    kind: NodeKind.TracesQuery,\n                    dateRange: {\n                        date_from: dateFilter.dateFrom || undefined,\n                        date_to: dateFilter.dateTo || undefined,\n                    },\n                    filterTestAccounts: shouldFilterTestAccounts ?? false,\n                    properties: propertyFilters,\n                },\n                columns: ['id', 'person', 'totalLatency', 'usage', 'totalCost', 'timestamp'],\n                showDateRange: true,\n                showReload: true,\n                showSearch: true,\n                showTestAccountFilters: true,\n                showExport: true,\n                showOpenEditorButton: false,\n                showPropertyFilter: [\n                    TaxonomicFilterGroupType.EventProperties,\n                    TaxonomicFilterGroupType.PersonProperties,\n                    ...groupsTaxonomicTypes,\n                    TaxonomicFilterGroupType.Cohorts,\n                    TaxonomicFilterGroupType.HogQLExpression,\n                ],\n            }),\n        ],\n        generationsQuery: [\n            (s) => [\n                s.dateFilter,\n                s.shouldFilterTestAccounts,\n                s.propertyFilters,\n                groupsModel.selectors.groupsTaxonomicTypes,\n            ],\n            (dateFilter, shouldFilterTestAccounts, propertyFilters, groupsTaxonomicTypes): DataTableNode => ({\n                kind: NodeKind.DataTableNode,\n                source: {\n                    kind: NodeKind.EventsQuery,\n                    select: [\n                        '*',\n                        `<strong><a href=f'/llm-observability/traces/{properties.$ai_trace_id}?event={uuid}'>\n                            {f'{left(toString(uuid), 4)}...{right(toString(uuid), 4)}'}\n                        </a></strong> -- ID`,\n                        `<a href=f'/llm-observability/traces/{properties.$ai_trace_id}'>\n                            {f'{left(properties.$ai_trace_id, 4)}...{right(properties.$ai_trace_id, 4)}'}\n                        </a> -- Trace ID`,\n                        'person',\n                        \"f'{properties.$ai_model}' -- Model\",\n                        \"f'{round(properties.$ai_latency, 2)} s' -- Latency\",\n                        \"f'{properties.$ai_input_tokens} → {properties.$ai_output_tokens} (∑ {properties.$ai_input_tokens + properties.$ai_output_tokens})' -- Token usage\",\n                        \"f'${round(toFloat(properties.$ai_total_cost_usd), 6)}' -- Total cost\",\n                        'timestamp',\n                    ],\n                    orderBy: ['timestamp DESC'],\n                    after: dateFilter.dateFrom || undefined,\n                    before: dateFilter.dateTo || undefined,\n                    filterTestAccounts: shouldFilterTestAccounts,\n                    event: '$ai_generation',\n                    properties: propertyFilters,\n                },\n                showDateRange: true,\n                showReload: true,\n                showSearch: true,\n                showTestAccountFilters: true,\n                showColumnConfigurator: true,\n                showPropertyFilter: [\n                    TaxonomicFilterGroupType.EventProperties,\n                    TaxonomicFilterGroupType.PersonProperties,\n                    ...groupsTaxonomicTypes,\n                    TaxonomicFilterGroupType.Cohorts,\n                    TaxonomicFilterGroupType.HogQLExpression,\n                ],\n                showExport: true,\n                showActions: false,\n            }),\n        ],\n    }),\n\n    afterMount(({ actions }) => {\n        actions.loadAIEventDefinition()\n    }),\n])\n"],"names":[],"sourceRoot":""}