{"version":3,"file":"35369.6c42c9a5.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;AAwCA;;;;;;;;;;;;;;;;;;;;;;;ACiEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCA","sources":["webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/components/replayActiveScreensTableLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/components/replayActiveHoursHeatMapLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/components/replayActiveUsersTableLogic.ts"],"sourcesContent":["import { defaults, kea, key, path, props } from 'kea'\nimport { lazyLoaders } from 'kea-loaders'\n\nimport api from 'lib/api'\n\nimport { hogql } from '~/queries/utils'\n\nimport type { replayActiveScreensTableLogicType } from './replayActiveScreensTableLogicType'\n\nexport interface ReplayActiveScreensTableLogicProps {\n    scene?: 'templates' | 'filters' | 'replay-home'\n}\n\nexport const replayActiveScreensTableLogic = kea<replayActiveScreensTableLogicType>([\n    path(['scenes', 'session-recordings', 'components', 'replayActiveScreensTableLogic']),\n    props({} as ReplayActiveScreensTableLogicProps),\n    key((props) => props.scene || 'default'),\n    defaults({\n        countedScreens: [] as { screen: string; count: number }[],\n    }),\n    lazyLoaders(() => ({\n        countedScreens: {\n            loadCountedScreens: async (_, breakpoint): Promise<{ screen: string; count: number }[]> => {\n                const q = hogql`\n                    SELECT\n                cutQueryString(cutFragment(url)) as screen,\n                count(distinct session_id) as count\n            FROM (\n                SELECT\n                    session_id,\n                    arrayJoin(any(all_urls)) as url\n                FROM raw_session_replay_events\n                WHERE min_first_timestamp >= now() - interval 7 day\n                  AND min_first_timestamp <= now()\n                GROUP BY session_id\n                HAVING date_diff('second', min(min_first_timestamp), max(max_last_timestamp)) > 5\n            )\n            GROUP BY screen\n            ORDER BY count DESC\n            LIMIT 10\n                `\n\n                const qResponse = await api.queryHogQL(q)\n\n                breakpoint()\n\n                return (qResponse.results || []).map((row) => {\n                    return {\n                        screen: row[0] as string,\n                        count: row[1] as number,\n                    }\n                }) as { screen: string; count: number }[]\n            },\n        },\n    })),\n])\n","import { kea, key, listeners, path, props, selectors } from 'kea'\nimport { lazyLoaders } from 'kea-loaders'\nimport { router } from 'kea-router'\nimport posthog from 'posthog-js'\n\nimport api from 'lib/api'\nimport { Dayjs, now } from 'lib/dayjs'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { urls } from 'scenes/urls'\nimport { CalendarHeatMapProps } from 'scenes/web-analytics/CalendarHeatMap/CalendarHeatMap'\n\nimport { hogql } from '~/queries/utils'\nimport { ReplayTabs } from '~/types'\n\nimport type { replayActiveHoursHeatMapLogicType } from './replayActiveHoursHeatMapLogicType'\n\nexport interface ReplayActiveHoursHeatMapLogicProps {\n    // we can show this component in different contexts, and key it accordingly\n    scene?: 'templates' | 'filters' | 'replay-home'\n}\n\nconst rowLabels = ['00:00 - 04:00', '04:00 - 08:00', '08:00 - 12:00', '12:00 - 16:00', '16:00 - 20:00', '20:00 - 00:00']\n\nconst columnLabels = (now: Dayjs): string[] => [\n    now.subtract(6, 'day').format('ddd D'),\n    now.subtract(5, 'day').format('ddd D'),\n    now.subtract(4, 'day').format('ddd D'),\n    now.subtract(3, 'day').format('ddd D'),\n    now.subtract(2, 'day').format('ddd D'),\n    now.subtract(1, 'day').format('ddd D'),\n    'Today',\n]\n\n// does not need to be on the logic yet, since it's stateless for now\nexport const getOnClickTooltip = (colIndex: number, rowIndex: number | undefined): string => {\n    const day = columnLabels(now())[colIndex]\n    const timeRange = rowIndex === undefined ? undefined : rowLabels[rowIndex]\n    return `View recordings for ${day}${timeRange ? ` ${timeRange}` : ''}`\n}\n\n// does not need to be on the logic yet, since it's stateless for now\nexport const onCellClick = (colIndex: number, rowIndex: number | undefined, timezone: string): void => {\n    const daysToSubtract = 6 - colIndex\n    let startDate = now().subtract(daysToSubtract, 'day').startOf('day').utc(true)\n    let endDate = startDate.clone()\n\n    if (rowIndex !== undefined) {\n        const startHour = rowIndex * 4\n        const endHour = startHour + 4\n        startDate = startDate.hour(startHour)\n        endDate = endDate.hour(endHour)\n    } else {\n        endDate = endDate.add(1, 'day')\n    }\n\n    posthog.capture('clicked_replay_active_hours_heatmap_cell', {\n        isColumnHeader: rowIndex == undefined,\n        isIndividualCell: rowIndex != undefined,\n        timezone,\n    })\n\n    const setTimezoneWithoutChangingOtherValues = true\n    router.actions.push(\n        urls.replay(ReplayTabs.Home, {\n            // here the browser might be in a different timezone to the project\n            // but the dateTime has already been corrected so we need to set the timezone\n            // but set `true` as the second parameter\n            // this means we set the project timezone on the dayjs object\n            // without changing the values\n            date_from: startDate.tz(timezone, setTimezoneWithoutChangingOtherValues).toISOString(),\n            date_to: endDate.tz(timezone, setTimezoneWithoutChangingOtherValues).toISOString(),\n        })\n    )\n}\n\nexport const replayActiveHoursHeatMapLogic = kea<replayActiveHoursHeatMapLogicType>([\n    path(['scenes', 'session-recordings', 'components', 'replayActiveHoursHeatMapLogic']),\n    props({} as ReplayActiveHoursHeatMapLogicProps),\n    key((props) => props.scene || 'default'),\n    lazyLoaders(() => ({\n        recordingsPerHour: {\n            loadRecordingsPerHour: async (_, breakpoint): Promise<number[][]> => {\n                const q = hogql`\n                    SELECT hour_block,\n                           countIf(_toDate(mints) = today() - 6) AS \"Day -6\",\n                           countIf(_toDate(mints) = today() - 5) AS \"Day -5\",\n                           countIf(_toDate(mints) = today() - 4) AS \"Day -4\",\n                           countIf(_toDate(mints) = today() - 3) AS \"Day -3\",\n                           countIf(_toDate(mints) = today() - 2) AS \"Day -2\",\n                           countIf(_toDate(mints) = today() - 1) AS \"Day -1\",\n                           countIf(_toDate(mints) = today())     AS \"Day 0\"\n                    FROM (SELECT intDiv(toHour(mints), 4) * 4 AS real_hour_block,\n                                 mints\n                          FROM (SELECT min(min_first_timestamp) AS mints\n                                FROM raw_session_replay_events\n                                WHERE min_first_timestamp >= now() - INTERVAL 7 day\n                                  AND min_first_timestamp <= now()\n                                GROUP BY session_id\n                                having dateDiff('SECOND'\n                                     , min (min_first_timestamp)\n                                     , max (max_last_timestamp))\n                                     > 5)) AS data\n                             RIGHT JOIN (SELECT arrayJoin([0, 4, 8, 12, 16, 20]) AS hour_block) AS hours\n                                        ON data.real_hour_block = hours.hour_block\n                    GROUP BY hour_block\n                    ORDER BY hour_block`\n\n                const qResponse = await api.queryHogQL(q)\n\n                // this gives an array of arrays\n                // we're loading hours 0-4, 4-8, 8-12, 12-16, 16-20, 20-24\n                // so we get an array with 6 elements\n                // each of those has 8 values\n                // [0] is the hour block\n                // and then each of the other 7 values is the count for that day\n\n                breakpoint()\n\n                return qResponse.results as number[][]\n            },\n        },\n    })),\n    selectors(() => ({\n        calendarHeatmapProps: [\n            (s) => [s.recordingsPerHour],\n            (\n                recordingsPerHour: number[][]\n            ): Pick<CalendarHeatMapProps, 'rowLabels' | 'columnLabels' | 'processedData'> => {\n                if (!recordingsPerHour || recordingsPerHour.length === 0 || recordingsPerHour[0].length === 0) {\n                    return {\n                        rowLabels: [],\n                        columnLabels: [],\n                        processedData: {\n                            matrix: [],\n                            columnsAggregations: [],\n                            rowsAggregations: [],\n                            overallValue: 0,\n                            maxOverall: 0,\n                            minOverall: 0,\n                            maxRowAggregation: 0,\n                            minRowAggregation: 0,\n                            maxColumnAggregation: 0,\n                            minColumnAggregation: 0,\n                        },\n                    }\n                }\n\n                const dataWithoutHourBlock = recordingsPerHour.map((row) => row.slice(1))\n\n                const columnsAggregations = dataWithoutHourBlock.reduce((acc, row) => {\n                    row.forEach((value: number, index: number) => {\n                        acc[index] = (acc[index] || 0) + value\n                    })\n                    return acc\n                }, [])\n                const rowsAggregations = dataWithoutHourBlock.reduce((acc, row) => {\n                    // take each row and ignoring row[0]\n                    // gather a sum for each index in the row\n                    // so we end up with an array of numbers with length 6\n                    acc[row[0]] = (acc[row[0]] || 0) + row.reduce((a: number, b: number) => a + b, 0)\n                    return acc\n                }, [])\n                const processedData = {\n                    matrix: dataWithoutHourBlock,\n                    columnsAggregations: columnsAggregations,\n                    rowsAggregations: rowsAggregations,\n                    overallValue: columnsAggregations.reduce((a: number, b: number) => a + b, 0),\n                    maxOverall: dataWithoutHourBlock.reduce((acc, row) => {\n                        return Math.max(acc, ...row)\n                    }, 0),\n                    minOverall: dataWithoutHourBlock.reduce((acc, row) => {\n                        return Math.min(acc, ...row)\n                    }, 0),\n                    maxColumnAggregation: Math.max(...columnsAggregations),\n                    minColumnAggregation: Math.min(...columnsAggregations),\n                    maxRowAggregation: Math.max(...rowsAggregations),\n                    minRowAggregation: Math.min(...rowsAggregations),\n                }\n\n                return {\n                    rowLabels: rowLabels,\n                    columnLabels: columnLabels(now()),\n                    processedData: processedData,\n                }\n            },\n        ],\n        isClickable: [\n            (s) => [s.calendarHeatmapProps],\n            (calendarHeatmapProps) => (colIndex: number, rowIndex?: number) => {\n                const valueSource =\n                    rowIndex == undefined\n                        ? calendarHeatmapProps?.processedData.columnsAggregations\n                        : calendarHeatmapProps?.processedData.matrix[rowIndex]\n                return (valueSource[colIndex] ?? 0) > 0\n            },\n        ],\n    })),\n    listeners(() => ({\n        loadRecordingsPerHourFailed: async () => {\n            lemonToast.error('Failed to load recordings activity for heatmap')\n        },\n    })),\n])\n","import { defaults, kea, key, path, props } from 'kea'\nimport { lazyLoaders } from 'kea-loaders'\n\nimport api from 'lib/api'\n\nimport { hogql } from '~/queries/utils'\nimport { PersonType } from '~/types'\n\nimport type { replayActiveUsersTableLogicType } from './replayActiveUsersTableLogicType'\n\nexport interface ReplayActiveUsersTableLogicProps {\n    scene?: 'templates' | 'filters' | 'replay-home'\n}\n\nexport const replayActiveUsersTableLogic = kea<replayActiveUsersTableLogicType>([\n    path(['scenes', 'session-recordings', 'components', 'replayActiveUsersTableLogic']),\n    props({} as ReplayActiveUsersTableLogicProps),\n    key((props) => props.scene || 'default'),\n    defaults({\n        countedUsers: [] as { person: PersonType; count: number }[],\n    }),\n    lazyLoaders(() => ({\n        countedUsers: {\n            loadCountedUsers: async (_, breakpoint): Promise<{ person: PersonType; count: number }[]> => {\n                const q = hogql`\n                    WITH\n            -- get the session ids for any recorded sessions in the last 7 days\n            recorded_sessions AS (\n                SELECT session_id\n                FROM raw_session_replay_events\n                WHERE min_first_timestamp >= now() - interval 7 day\n                  AND min_first_timestamp <= now()\n                GROUP BY session_id\n                HAVING date_diff('second', min(min_first_timestamp), max(max_last_timestamp)) > 5\n            ),\n            -- way faster to get person props from the events table\n            -- so get the mapping of person_id/person_properties to session_id\n            -- from the events table that has the same session_id as the recorded sessions\n            session_persons AS (\n                SELECT\n                    $session_id as session_id,\n                    any(person_id) as person_id,\n                    any(person.properties) as pp\n                FROM events\n                WHERE timestamp >= now() - interval 7 day\n                  AND timestamp <= now()\n                  AND $session_id IN (SELECT session_id FROM recorded_sessions)\n                  -- including events when querying the events table is always _much_ faster,\n                  -- but we don't know what events an account will have\n                  -- so we just include the most common ones\n                  -- this won't work for everyone but then that's try with the poorly performing query\n                  -- that this replaces, so it's at least no worse 🙈\n                  AND event IN ('$pageview', '$screen', '$autocapture', '$feature_flag_called', '$pageleave', '$identify', '$web_vitals', '$set', 'Application Opened', 'Application Backgrounded')\n                  -- exclude anonymous users since we don't care if user \"anonymous\" watched a gajillion recordings\n                  AND (properties.$process_person_profile = true or properties.$is_identified = true)\n                GROUP BY $session_id\n            )\n            -- now we can count the distinct sessions per person\n            SELECT\n                sp.person_id,\n                sp.pp,\n                count(distinct sp.session_id) as total_count\n            FROM session_persons sp \n            WHERE sp.person_id IS NOT NULL\n            GROUP BY sp.person_id, sp.pp\n            ORDER BY total_count DESC\n            LIMIT 10\n                `\n\n                const qResponse = await api.queryHogQL(q)\n\n                breakpoint()\n\n                return (qResponse.results || []).map((row) => {\n                    return {\n                        person: { id: row[0] as string, properties: JSON.parse(row[1]) as Record<string, any> },\n                        count: row[2] as number,\n                    }\n                }) as { person: PersonType; count: number }[]\n            },\n        },\n    })),\n])\n"],"names":[],"sourceRoot":""}