{"version":3,"file":"scenes-max-Max-stories.c50371ed.iframe.bundle.js","mappings":";AAmCA;AAAA;AAAA;ACMA;AA+BA;AAeA;AACA","sources":["webpack://@posthog/frontend/./frontend/src/scenes/max/__mocks__/chatResponse.mocks.ts","webpack://@posthog/frontend/./node_modules/.pnpm/eventsource-parser@3.0.0/node_modules/eventsource-parser/dist/index.js"],"sourcesContent":["import {\n    AssistantGenerationStatusEvent,\n    AssistantGenerationStatusType,\n    AssistantMessage,\n    AssistantMessageType,\n    HumanMessage,\n    ReasoningMessage,\n} from '~/queries/schema/schema-assistant-messages'\n\nimport failureMessage from './failureMessage.json'\nimport summaryMessage from './summaryMessage.json'\nimport visualizationMessage from './visualizationMessage.json'\n\n// The session ID is hard-coded here, as it's used for randomizing the welcome headline\nexport const CONVERSATION_ID = 'b1b4b3b4-1b3b-4b3b-1b3b4b3b4b3b'\n\nexport const humanMessage: HumanMessage = {\n    type: AssistantMessageType.Human,\n    content: 'What are my most popular pages?',\n    id: 'human-1',\n}\n\nconst reasoningMessage1: ReasoningMessage = {\n    type: AssistantMessageType.Reasoning,\n    content: 'Picking relevant events and properties',\n    id: 'reasoning-1',\n}\n\nconst reasoningMessage2: ReasoningMessage = {\n    type: AssistantMessageType.Reasoning,\n    content: 'Generating trends',\n    id: 'reasoning-2',\n}\n\nfunction generateChunk(events: string[]): string {\n    return events.map((event) => (event.startsWith('event:') ? `${event}\\n` : `${event}\\n\\n`)).join('')\n}\n\nexport const chatResponseChunk = generateChunk([\n    'event: conversation',\n    `data: ${JSON.stringify({ id: CONVERSATION_ID })}`,\n    'event: message',\n    `data: ${JSON.stringify(humanMessage)}`,\n    'event: message',\n    `data: ${JSON.stringify(reasoningMessage1)}`,\n    'event: message',\n    `data: ${JSON.stringify(reasoningMessage2)}`,\n    'event: message',\n    `data: ${JSON.stringify(visualizationMessage)}`,\n    'event: message',\n    `data: ${JSON.stringify(summaryMessage)}`,\n])\n\nexport const chatMidwayResponseChunk = generateChunk([\n    'event: message',\n    `data: ${JSON.stringify(reasoningMessage1)}`,\n    'event: message',\n    `data: ${JSON.stringify(reasoningMessage2)}`,\n])\n\nconst generationFailure: AssistantGenerationStatusEvent = { type: AssistantGenerationStatusType.GenerationError }\nconst responseWithReasoningStepsOnly = {\n    ...visualizationMessage,\n    answer: null,\n}\n\nexport const generationFailureChunk = generateChunk([\n    'event: message',\n    `data: ${JSON.stringify(responseWithReasoningStepsOnly)}`,\n    'event: status',\n    `data: ${JSON.stringify(generationFailure)}`,\n])\n\nexport const failureChunk = generateChunk(['event: message', `data: ${JSON.stringify(failureMessage)}`])\n\nconst formMessage: AssistantMessage = {\n    type: AssistantMessageType.Assistant,\n    content: 'Does this look like a good summary of what your product does?',\n    id: 'assistant-1',\n    meta: {\n        form: {\n            options: [\n                {\n                    value: 'Yes, save this',\n                    variant: 'primary',\n                },\n                {\n                    value: 'No, not quite right',\n                },\n            ],\n        },\n    },\n}\n\nexport const formChunk = generateChunk(['event: message', `data: ${JSON.stringify(formMessage)}`])\n","var __defProp = Object.defineProperty, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField = (obj, key, value) => __defNormalProp(obj, typeof key != \"symbol\" ? key + \"\" : key, value);\nclass ParseError extends Error {\n  constructor(message, options) {\n    super(message), __publicField(this, \"type\"), __publicField(this, \"field\"), __publicField(this, \"value\"), __publicField(this, \"line\"), this.name = \"ParseError\", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;\n  }\n}\nfunction noop(_arg) {\n}\nfunction createParser(callbacks) {\n  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;\n  let incompleteLine = \"\", isFirstChunk = !0, id, data = \"\", eventType = \"\";\n  function feed(newChunk) {\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, \"\") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);\n    for (const line of complete)\n      parseLine(line);\n    incompleteLine = incomplete, isFirstChunk = !1;\n  }\n  function parseLine(line) {\n    if (line === \"\") {\n      dispatchEvent();\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      onComment && onComment(line.slice(line.startsWith(\": \") ? 2 : 1));\n      return;\n    }\n    const fieldSeparatorIndex = line.indexOf(\":\");\n    if (fieldSeparatorIndex !== -1) {\n      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === \" \" ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);\n      processField(field, value, line);\n      return;\n    }\n    processField(line, \"\", line);\n  }\n  function processField(field, value, line) {\n    switch (field) {\n      case \"event\":\n        eventType = value;\n        break;\n      case \"data\":\n        data = `${data}${value}\n`;\n        break;\n      case \"id\":\n        id = value.includes(\"\\0\") ? void 0 : value;\n        break;\n      case \"retry\":\n        /^\\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(\n          new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n            type: \"invalid-retry\",\n            value,\n            line\n          })\n        );\n        break;\n      default:\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}\\u2026` : field}\"`,\n            { type: \"unknown-field\", field, value, line }\n          )\n        );\n        break;\n    }\n  }\n  function dispatchEvent() {\n    data.length > 0 && onEvent({\n      id,\n      event: eventType || void 0,\n      // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n      // then remove the last character from the data buffer.\n      data: data.endsWith(`\n`) ? data.slice(0, -1) : data\n    }), id = void 0, data = \"\", eventType = \"\";\n  }\n  function reset(options = {}) {\n    incompleteLine && options.consume && parseLine(incompleteLine), id = void 0, data = \"\", eventType = \"\", incompleteLine = \"\";\n  }\n  return { feed, reset };\n}\nfunction splitLines(chunk) {\n  const lines = [];\n  let incompleteLine = \"\";\n  const totalLength = chunk.length;\n  for (let i = 0; i < totalLength; i++) {\n    const char = chunk[i];\n    char === \"\\r\" && chunk[i + 1] === `\n` ? (lines.push(incompleteLine), incompleteLine = \"\", i++) : char === \"\\r\" || char === `\n` ? (lines.push(incompleteLine), incompleteLine = \"\") : incompleteLine += char;\n  }\n  return [lines, incompleteLine];\n}\nexport {\n  ParseError,\n  createParser\n};\n//# sourceMappingURL=index.js.map\n"],"names":[],"sourceRoot":""}