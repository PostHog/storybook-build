{"version":3,"file":"78823.e9ad407b.iframe.bundle.js","mappings":";;;;;;AA4gBA","sources":["webpack://posthog/./node_modules/.pnpm/posthog-js-lite@3.0.0/node_modules/posthog-js-lite/lib/index.esm.js"],"sourcesContent":["var PostHogPersistedProperty;\r\n(function (PostHogPersistedProperty) {\r\n    PostHogPersistedProperty[\"AnonymousId\"] = \"anonymous_id\";\r\n    PostHogPersistedProperty[\"DistinctId\"] = \"distinct_id\";\r\n    PostHogPersistedProperty[\"Props\"] = \"props\";\r\n    PostHogPersistedProperty[\"FeatureFlags\"] = \"feature_flags\";\r\n    PostHogPersistedProperty[\"FeatureFlagPayloads\"] = \"feature_flag_payloads\";\r\n    PostHogPersistedProperty[\"OverrideFeatureFlags\"] = \"override_feature_flags\";\r\n    PostHogPersistedProperty[\"Queue\"] = \"queue\";\r\n    PostHogPersistedProperty[\"OptedOut\"] = \"opted_out\";\r\n    PostHogPersistedProperty[\"SessionId\"] = \"session_id\";\r\n    PostHogPersistedProperty[\"SessionLastTimestamp\"] = \"session_timestamp\";\r\n    PostHogPersistedProperty[\"PersonProperties\"] = \"person_properties\";\r\n    PostHogPersistedProperty[\"GroupProperties\"] = \"group_properties\";\r\n    PostHogPersistedProperty[\"InstalledAppBuild\"] = \"installed_app_build\";\r\n    PostHogPersistedProperty[\"InstalledAppVersion\"] = \"installed_app_version\";\r\n})(PostHogPersistedProperty || (PostHogPersistedProperty = {}));\n\nfunction assert(truthyValue, message) {\r\n    if (!truthyValue) {\r\n        throw new Error(message);\r\n    }\r\n}\r\nfunction removeTrailingSlash(url) {\r\n    return url?.replace(/\\/+$/, '');\r\n}\r\nasync function retriable(fn, props) {\r\n    let lastError = null;\r\n    for (let i = 0; i < props.retryCount + 1; i++) {\r\n        if (i > 0) {\r\n            // don't wait when it's the last try\r\n            await new Promise((r) => setTimeout(r, props.retryDelay));\r\n        }\r\n        try {\r\n            const res = await fn();\r\n            return res;\r\n        }\r\n        catch (e) {\r\n            lastError = e;\r\n            if (!props.retryCheck(e)) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    throw lastError;\r\n}\r\nfunction currentTimestamp() {\r\n    return new Date().getTime();\r\n}\r\nfunction currentISOTime() {\r\n    return new Date().toISOString();\r\n}\r\nfunction safeSetTimeout(fn, timeout) {\r\n    // NOTE: we use this so rarely that it is totally fine to do `safeSetTimeout(fn, 0)``\r\n    // rather than setImmediate.\r\n    const t = setTimeout(fn, timeout);\r\n    // We unref if available to prevent Node.js hanging on exit\r\n    t?.unref && t?.unref();\r\n    return t;\r\n}\n\n// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\r\n// This work is free. You can redistribute it and/or modify it\r\n// under the terms of the WTFPL, Version 2\r\n// For more information see LICENSE.txt or http://www.wtfpl.net/\r\n//\r\n// For more information, the home page:\r\n// http://pieroxy.net/blog/pages/lz-string/testing.html\r\n//\r\n// LZ-based compression algorithm, version 1.4.4\r\n// private property\r\nconst f = String.fromCharCode;\r\nconst keyStrBase64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\nconst baseReverseDic = {};\r\nfunction getBaseValue(alphabet, character) {\r\n    if (!baseReverseDic[alphabet]) {\r\n        baseReverseDic[alphabet] = {};\r\n        for (let i = 0; i < alphabet.length; i++) {\r\n            baseReverseDic[alphabet][alphabet.charAt(i)] = i;\r\n        }\r\n    }\r\n    return baseReverseDic[alphabet][character];\r\n}\r\nconst LZString = {\r\n    compressToBase64: function (input) {\r\n        if (input == null) {\r\n            return '';\r\n        }\r\n        const res = LZString._compress(input, 6, function (a) {\r\n            return keyStrBase64.charAt(a);\r\n        });\r\n        switch (res.length % 4 // To produce valid Base64\r\n        ) {\r\n            default: // When could this happen ?\r\n            case 0:\r\n                return res;\r\n            case 1:\r\n                return res + '===';\r\n            case 2:\r\n                return res + '==';\r\n            case 3:\r\n                return res + '=';\r\n        }\r\n    },\r\n    decompressFromBase64: function (input) {\r\n        if (input == null) {\r\n            return '';\r\n        }\r\n        if (input == '') {\r\n            return null;\r\n        }\r\n        return LZString._decompress(input.length, 32, function (index) {\r\n            return getBaseValue(keyStrBase64, input.charAt(index));\r\n        });\r\n    },\r\n    compress: function (uncompressed) {\r\n        return LZString._compress(uncompressed, 16, function (a) {\r\n            return f(a);\r\n        });\r\n    },\r\n    _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\r\n        if (uncompressed == null) {\r\n            return '';\r\n        }\r\n        const context_dictionary = {}, context_dictionaryToCreate = {}, context_data = [];\r\n        let i, value, context_c = '', context_wc = '', context_w = '', context_enlargeIn = 2, // Compensate for the first entry which should not count\r\n        context_dictSize = 3, context_numBits = 2, context_data_val = 0, context_data_position = 0, ii;\r\n        for (ii = 0; ii < uncompressed.length; ii += 1) {\r\n            context_c = uncompressed.charAt(ii);\r\n            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {\r\n                context_dictionary[context_c] = context_dictSize++;\r\n                context_dictionaryToCreate[context_c] = true;\r\n            }\r\n            context_wc = context_w + context_c;\r\n            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {\r\n                context_w = context_wc;\r\n            }\r\n            else {\r\n                if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {\r\n                    if (context_w.charCodeAt(0) < 256) {\r\n                        for (i = 0; i < context_numBits; i++) {\r\n                            context_data_val = context_data_val << 1;\r\n                            if (context_data_position == bitsPerChar - 1) {\r\n                                context_data_position = 0;\r\n                                context_data.push(getCharFromInt(context_data_val));\r\n                                context_data_val = 0;\r\n                            }\r\n                            else {\r\n                                context_data_position++;\r\n                            }\r\n                        }\r\n                        value = context_w.charCodeAt(0);\r\n                        for (i = 0; i < 8; i++) {\r\n                            context_data_val = (context_data_val << 1) | (value & 1);\r\n                            if (context_data_position == bitsPerChar - 1) {\r\n                                context_data_position = 0;\r\n                                context_data.push(getCharFromInt(context_data_val));\r\n                                context_data_val = 0;\r\n                            }\r\n                            else {\r\n                                context_data_position++;\r\n                            }\r\n                            value = value >> 1;\r\n                        }\r\n                    }\r\n                    else {\r\n                        value = 1;\r\n                        for (i = 0; i < context_numBits; i++) {\r\n                            context_data_val = (context_data_val << 1) | value;\r\n                            if (context_data_position == bitsPerChar - 1) {\r\n                                context_data_position = 0;\r\n                                context_data.push(getCharFromInt(context_data_val));\r\n                                context_data_val = 0;\r\n                            }\r\n                            else {\r\n                                context_data_position++;\r\n                            }\r\n                            value = 0;\r\n                        }\r\n                        value = context_w.charCodeAt(0);\r\n                        for (i = 0; i < 16; i++) {\r\n                            context_data_val = (context_data_val << 1) | (value & 1);\r\n                            if (context_data_position == bitsPerChar - 1) {\r\n                                context_data_position = 0;\r\n                                context_data.push(getCharFromInt(context_data_val));\r\n                                context_data_val = 0;\r\n                            }\r\n                            else {\r\n                                context_data_position++;\r\n                            }\r\n                            value = value >> 1;\r\n                        }\r\n                    }\r\n                    context_enlargeIn--;\r\n                    if (context_enlargeIn == 0) {\r\n                        context_enlargeIn = Math.pow(2, context_numBits);\r\n                        context_numBits++;\r\n                    }\r\n                    delete context_dictionaryToCreate[context_w];\r\n                }\r\n                else {\r\n                    value = context_dictionary[context_w];\r\n                    for (i = 0; i < context_numBits; i++) {\r\n                        context_data_val = (context_data_val << 1) | (value & 1);\r\n                        if (context_data_position == bitsPerChar - 1) {\r\n                            context_data_position = 0;\r\n                            context_data.push(getCharFromInt(context_data_val));\r\n                            context_data_val = 0;\r\n                        }\r\n                        else {\r\n                            context_data_position++;\r\n                        }\r\n                        value = value >> 1;\r\n                    }\r\n                }\r\n                context_enlargeIn--;\r\n                if (context_enlargeIn == 0) {\r\n                    context_enlargeIn = Math.pow(2, context_numBits);\r\n                    context_numBits++;\r\n                }\r\n                // Add wc to the dictionary.\r\n                context_dictionary[context_wc] = context_dictSize++;\r\n                context_w = String(context_c);\r\n            }\r\n        }\r\n        // Output the code for w.\r\n        if (context_w !== '') {\r\n            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {\r\n                if (context_w.charCodeAt(0) < 256) {\r\n                    for (i = 0; i < context_numBits; i++) {\r\n                        context_data_val = context_data_val << 1;\r\n                        if (context_data_position == bitsPerChar - 1) {\r\n                            context_data_position = 0;\r\n                            context_data.push(getCharFromInt(context_data_val));\r\n                            context_data_val = 0;\r\n                        }\r\n                        else {\r\n                            context_data_position++;\r\n                        }\r\n                    }\r\n                    value = context_w.charCodeAt(0);\r\n                    for (i = 0; i < 8; i++) {\r\n                        context_data_val = (context_data_val << 1) | (value & 1);\r\n                        if (context_data_position == bitsPerChar - 1) {\r\n                            context_data_position = 0;\r\n                            context_data.push(getCharFromInt(context_data_val));\r\n                            context_data_val = 0;\r\n                        }\r\n                        else {\r\n                            context_data_position++;\r\n                        }\r\n                        value = value >> 1;\r\n                    }\r\n                }\r\n                else {\r\n                    value = 1;\r\n                    for (i = 0; i < context_numBits; i++) {\r\n                        context_data_val = (context_data_val << 1) | value;\r\n                        if (context_data_position == bitsPerChar - 1) {\r\n                            context_data_position = 0;\r\n                            context_data.push(getCharFromInt(context_data_val));\r\n                            context_data_val = 0;\r\n                        }\r\n                        else {\r\n                            context_data_position++;\r\n                        }\r\n                        value = 0;\r\n                    }\r\n                    value = context_w.charCodeAt(0);\r\n                    for (i = 0; i < 16; i++) {\r\n                        context_data_val = (context_data_val << 1) | (value & 1);\r\n                        if (context_data_position == bitsPerChar - 1) {\r\n                            context_data_position = 0;\r\n                            context_data.push(getCharFromInt(context_data_val));\r\n                            context_data_val = 0;\r\n                        }\r\n                        else {\r\n                            context_data_position++;\r\n                        }\r\n                        value = value >> 1;\r\n                    }\r\n                }\r\n                context_enlargeIn--;\r\n                if (context_enlargeIn == 0) {\r\n                    context_enlargeIn = Math.pow(2, context_numBits);\r\n                    context_numBits++;\r\n                }\r\n                delete context_dictionaryToCreate[context_w];\r\n            }\r\n            else {\r\n                value = context_dictionary[context_w];\r\n                for (i = 0; i < context_numBits; i++) {\r\n                    context_data_val = (context_data_val << 1) | (value & 1);\r\n                    if (context_data_position == bitsPerChar - 1) {\r\n                        context_data_position = 0;\r\n                        context_data.push(getCharFromInt(context_data_val));\r\n                        context_data_val = 0;\r\n                    }\r\n                    else {\r\n                        context_data_position++;\r\n                    }\r\n                    value = value >> 1;\r\n                }\r\n            }\r\n            context_enlargeIn--;\r\n            if (context_enlargeIn == 0) {\r\n                context_enlargeIn = Math.pow(2, context_numBits);\r\n                context_numBits++;\r\n            }\r\n        }\r\n        // Mark the end of the stream\r\n        value = 2;\r\n        for (i = 0; i < context_numBits; i++) {\r\n            context_data_val = (context_data_val << 1) | (value & 1);\r\n            if (context_data_position == bitsPerChar - 1) {\r\n                context_data_position = 0;\r\n                context_data.push(getCharFromInt(context_data_val));\r\n                context_data_val = 0;\r\n            }\r\n            else {\r\n                context_data_position++;\r\n            }\r\n            value = value >> 1;\r\n        }\r\n        // Flush the last char\r\n        while (true) {\r\n            context_data_val = context_data_val << 1;\r\n            if (context_data_position == bitsPerChar - 1) {\r\n                context_data.push(getCharFromInt(context_data_val));\r\n                break;\r\n            }\r\n            else {\r\n                context_data_position++;\r\n            }\r\n        }\r\n        return context_data.join('');\r\n    },\r\n    decompress: function (compressed) {\r\n        if (compressed == null) {\r\n            return '';\r\n        }\r\n        if (compressed == '') {\r\n            return null;\r\n        }\r\n        return LZString._decompress(compressed.length, 32768, function (index) {\r\n            return compressed.charCodeAt(index);\r\n        });\r\n    },\r\n    _decompress: function (length, resetValue, getNextValue) {\r\n        const dictionary = [], result = [], data = { val: getNextValue(0), position: resetValue, index: 1 };\r\n        let enlargeIn = 4, dictSize = 4, numBits = 3, entry = '', i, w, bits, resb, maxpower, power, c;\r\n        for (i = 0; i < 3; i += 1) {\r\n            dictionary[i] = i;\r\n        }\r\n        bits = 0;\r\n        maxpower = Math.pow(2, 2);\r\n        power = 1;\r\n        while (power != maxpower) {\r\n            resb = data.val & data.position;\r\n            data.position >>= 1;\r\n            if (data.position == 0) {\r\n                data.position = resetValue;\r\n                data.val = getNextValue(data.index++);\r\n            }\r\n            bits |= (resb > 0 ? 1 : 0) * power;\r\n            power <<= 1;\r\n        }\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        switch ((bits)) {\r\n            case 0:\r\n                bits = 0;\r\n                maxpower = Math.pow(2, 8);\r\n                power = 1;\r\n                while (power != maxpower) {\r\n                    resb = data.val & data.position;\r\n                    data.position >>= 1;\r\n                    if (data.position == 0) {\r\n                        data.position = resetValue;\r\n                        data.val = getNextValue(data.index++);\r\n                    }\r\n                    bits |= (resb > 0 ? 1 : 0) * power;\r\n                    power <<= 1;\r\n                }\r\n                c = f(bits);\r\n                break;\r\n            case 1:\r\n                bits = 0;\r\n                maxpower = Math.pow(2, 16);\r\n                power = 1;\r\n                while (power != maxpower) {\r\n                    resb = data.val & data.position;\r\n                    data.position >>= 1;\r\n                    if (data.position == 0) {\r\n                        data.position = resetValue;\r\n                        data.val = getNextValue(data.index++);\r\n                    }\r\n                    bits |= (resb > 0 ? 1 : 0) * power;\r\n                    power <<= 1;\r\n                }\r\n                c = f(bits);\r\n                break;\r\n            case 2:\r\n                return '';\r\n        }\r\n        dictionary[3] = c;\r\n        w = c;\r\n        result.push(c);\r\n        while (true) {\r\n            if (data.index > length) {\r\n                return '';\r\n            }\r\n            bits = 0;\r\n            maxpower = Math.pow(2, numBits);\r\n            power = 1;\r\n            while (power != maxpower) {\r\n                resb = data.val & data.position;\r\n                data.position >>= 1;\r\n                if (data.position == 0) {\r\n                    data.position = resetValue;\r\n                    data.val = getNextValue(data.index++);\r\n                }\r\n                bits |= (resb > 0 ? 1 : 0) * power;\r\n                power <<= 1;\r\n            }\r\n            switch ((c = bits)) {\r\n                case 0:\r\n                    bits = 0;\r\n                    maxpower = Math.pow(2, 8);\r\n                    power = 1;\r\n                    while (power != maxpower) {\r\n                        resb = data.val & data.position;\r\n                        data.position >>= 1;\r\n                        if (data.position == 0) {\r\n                            data.position = resetValue;\r\n                            data.val = getNextValue(data.index++);\r\n                        }\r\n                        bits |= (resb > 0 ? 1 : 0) * power;\r\n                        power <<= 1;\r\n                    }\r\n                    dictionary[dictSize++] = f(bits);\r\n                    c = dictSize - 1;\r\n                    enlargeIn--;\r\n                    break;\r\n                case 1:\r\n                    bits = 0;\r\n                    maxpower = Math.pow(2, 16);\r\n                    power = 1;\r\n                    while (power != maxpower) {\r\n                        resb = data.val & data.position;\r\n                        data.position >>= 1;\r\n                        if (data.position == 0) {\r\n                            data.position = resetValue;\r\n                            data.val = getNextValue(data.index++);\r\n                        }\r\n                        bits |= (resb > 0 ? 1 : 0) * power;\r\n                        power <<= 1;\r\n                    }\r\n                    dictionary[dictSize++] = f(bits);\r\n                    c = dictSize - 1;\r\n                    enlargeIn--;\r\n                    break;\r\n                case 2:\r\n                    return result.join('');\r\n            }\r\n            if (enlargeIn == 0) {\r\n                enlargeIn = Math.pow(2, numBits);\r\n                numBits++;\r\n            }\r\n            if (dictionary[c]) {\r\n                entry = dictionary[c];\r\n            }\r\n            else {\r\n                if (c === dictSize) {\r\n                    entry = w + w.charAt(0);\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n            result.push(entry);\r\n            // Add w+entry[0] to the dictionary.\r\n            dictionary[dictSize++] = w + entry.charAt(0);\r\n            enlargeIn--;\r\n            w = entry;\r\n            if (enlargeIn == 0) {\r\n                enlargeIn = Math.pow(2, numBits);\r\n                numBits++;\r\n            }\r\n        }\r\n    },\r\n};\n\nclass SimpleEventEmitter {\r\n    constructor() {\r\n        this.events = {};\r\n        this.events = {};\r\n    }\r\n    on(event, listener) {\r\n        if (!this.events[event]) {\r\n            this.events[event] = [];\r\n        }\r\n        this.events[event].push(listener);\r\n        return () => {\r\n            this.events[event] = this.events[event].filter((x) => x !== listener);\r\n        };\r\n    }\r\n    emit(event, payload) {\r\n        for (const listener of this.events[event] || []) {\r\n            listener(payload);\r\n        }\r\n        for (const listener of this.events['*'] || []) {\r\n            listener(event, payload);\r\n        }\r\n    }\r\n}\n\n// vendor from: https://github.com/LiosK/uuidv7/blob/f30b7a7faff73afbce0b27a46c638310f96912ba/src/index.ts\r\n// https://github.com/LiosK/uuidv7#license\r\n/**\r\n * uuidv7: An experimental implementation of the proposed UUID Version 7\r\n *\r\n * @license Apache-2.0\r\n * @copyright 2021-2023 LiosK\r\n * @packageDocumentation\r\n */\r\nconst DIGITS = \"0123456789abcdef\";\r\n/** Represents a UUID as a 16-byte byte array. */\r\nclass UUID {\r\n    /** @param bytes - The 16-byte byte array representation. */\r\n    constructor(bytes) {\r\n        this.bytes = bytes;\r\n    }\r\n    /**\r\n     * Creates an object from the internal representation, a 16-byte byte array\r\n     * containing the binary UUID representation in the big-endian byte order.\r\n     *\r\n     * This method does NOT shallow-copy the argument, and thus the created object\r\n     * holds the reference to the underlying buffer.\r\n     *\r\n     * @throws TypeError if the length of the argument is not 16.\r\n     */\r\n    static ofInner(bytes) {\r\n        if (bytes.length !== 16) {\r\n            throw new TypeError(\"not 128-bit length\");\r\n        }\r\n        else {\r\n            return new UUID(bytes);\r\n        }\r\n    }\r\n    /**\r\n     * Builds a byte array from UUIDv7 field values.\r\n     *\r\n     * @param unixTsMs - A 48-bit `unix_ts_ms` field value.\r\n     * @param randA - A 12-bit `rand_a` field value.\r\n     * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.\r\n     * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.\r\n     * @throws RangeError if any field value is out of the specified range.\r\n     */\r\n    static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {\r\n        if (!Number.isInteger(unixTsMs) ||\r\n            !Number.isInteger(randA) ||\r\n            !Number.isInteger(randBHi) ||\r\n            !Number.isInteger(randBLo) ||\r\n            unixTsMs < 0 ||\r\n            randA < 0 ||\r\n            randBHi < 0 ||\r\n            randBLo < 0 ||\r\n            unixTsMs > 281474976710655 ||\r\n            randA > 0xfff ||\r\n            randBHi > 1073741823 ||\r\n            randBLo > 4294967295) {\r\n            throw new RangeError(\"invalid field value\");\r\n        }\r\n        const bytes = new Uint8Array(16);\r\n        bytes[0] = unixTsMs / 2 ** 40;\r\n        bytes[1] = unixTsMs / 2 ** 32;\r\n        bytes[2] = unixTsMs / 2 ** 24;\r\n        bytes[3] = unixTsMs / 2 ** 16;\r\n        bytes[4] = unixTsMs / 2 ** 8;\r\n        bytes[5] = unixTsMs;\r\n        bytes[6] = 0x70 | (randA >>> 8);\r\n        bytes[7] = randA;\r\n        bytes[8] = 0x80 | (randBHi >>> 24);\r\n        bytes[9] = randBHi >>> 16;\r\n        bytes[10] = randBHi >>> 8;\r\n        bytes[11] = randBHi;\r\n        bytes[12] = randBLo >>> 24;\r\n        bytes[13] = randBLo >>> 16;\r\n        bytes[14] = randBLo >>> 8;\r\n        bytes[15] = randBLo;\r\n        return new UUID(bytes);\r\n    }\r\n    /**\r\n     * Builds a byte array from a string representation.\r\n     *\r\n     * This method accepts the following formats:\r\n     *\r\n     * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`\r\n     * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`\r\n     * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`\r\n     * - RFC 4122 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`\r\n     *\r\n     * Leading and trailing whitespaces represents an error.\r\n     *\r\n     * @throws SyntaxError if the argument could not parse as a valid UUID string.\r\n     */\r\n    static parse(uuid) {\r\n        let hex = undefined;\r\n        switch (uuid.length) {\r\n            case 32:\r\n                hex = /^[0-9a-f]{32}$/i.exec(uuid)?.[0];\r\n                break;\r\n            case 36:\r\n                hex =\r\n                    /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\r\n                        .exec(uuid)\r\n                        ?.slice(1, 6)\r\n                        .join(\"\");\r\n                break;\r\n            case 38:\r\n                hex =\r\n                    /^\\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\\}$/i\r\n                        .exec(uuid)\r\n                        ?.slice(1, 6)\r\n                        .join(\"\");\r\n                break;\r\n            case 45:\r\n                hex =\r\n                    /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\r\n                        .exec(uuid)\r\n                        ?.slice(1, 6)\r\n                        .join(\"\");\r\n                break;\r\n        }\r\n        if (hex) {\r\n            const inner = new Uint8Array(16);\r\n            for (let i = 0; i < 16; i += 4) {\r\n                const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);\r\n                inner[i + 0] = n >>> 24;\r\n                inner[i + 1] = n >>> 16;\r\n                inner[i + 2] = n >>> 8;\r\n                inner[i + 3] = n;\r\n            }\r\n            return new UUID(inner);\r\n        }\r\n        else {\r\n            throw new SyntaxError(\"could not parse UUID string\");\r\n        }\r\n    }\r\n    /**\r\n     * @returns The 8-4-4-4-12 canonical hexadecimal string representation\r\n     * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).\r\n     */\r\n    toString() {\r\n        let text = \"\";\r\n        for (let i = 0; i < this.bytes.length; i++) {\r\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\r\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\r\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\r\n                text += \"-\";\r\n            }\r\n        }\r\n        return text;\r\n    }\r\n    /**\r\n     * @returns The 32-digit hexadecimal representation without hyphens\r\n     * (`0189dcd553117d408db09496a2eef37b`).\r\n     */\r\n    toHex() {\r\n        let text = \"\";\r\n        for (let i = 0; i < this.bytes.length; i++) {\r\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\r\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\r\n        }\r\n        return text;\r\n    }\r\n    /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */\r\n    toJSON() {\r\n        return this.toString();\r\n    }\r\n    /**\r\n     * Reports the variant field value of the UUID or, if appropriate, \"NIL\" or\r\n     * \"MAX\".\r\n     *\r\n     * For convenience, this method reports \"NIL\" or \"MAX\" if `this` represents\r\n     * the Nil or Max UUID, although the Nil and Max UUIDs are technically\r\n     * subsumed under the variants `0b0` and `0b111`, respectively.\r\n     */\r\n    getVariant() {\r\n        const n = this.bytes[8] >>> 4;\r\n        if (n < 0) {\r\n            throw new Error(\"unreachable\");\r\n        }\r\n        else if (n <= 0b0111) {\r\n            return this.bytes.every((e) => e === 0) ? \"NIL\" : \"VAR_0\";\r\n        }\r\n        else if (n <= 0b1011) {\r\n            return \"VAR_10\";\r\n        }\r\n        else if (n <= 0b1101) {\r\n            return \"VAR_110\";\r\n        }\r\n        else if (n <= 0b1111) {\r\n            return this.bytes.every((e) => e === 0xff) ? \"MAX\" : \"VAR_RESERVED\";\r\n        }\r\n        else {\r\n            throw new Error(\"unreachable\");\r\n        }\r\n    }\r\n    /**\r\n     * Returns the version field value of the UUID or `undefined` if the UUID does\r\n     * not have the variant field value of `0b10`.\r\n     */\r\n    getVersion() {\r\n        return this.getVariant() === \"VAR_10\" ? this.bytes[6] >>> 4 : undefined;\r\n    }\r\n    /** Creates an object from `this`. */\r\n    clone() {\r\n        return new UUID(this.bytes.slice(0));\r\n    }\r\n    /** Returns true if `this` is equivalent to `other`. */\r\n    equals(other) {\r\n        return this.compareTo(other) === 0;\r\n    }\r\n    /**\r\n     * Returns a negative integer, zero, or positive integer if `this` is less\r\n     * than, equal to, or greater than `other`, respectively.\r\n     */\r\n    compareTo(other) {\r\n        for (let i = 0; i < 16; i++) {\r\n            const diff = this.bytes[i] - other.bytes[i];\r\n            if (diff !== 0) {\r\n                return Math.sign(diff);\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n/**\r\n * Encapsulates the monotonic counter state.\r\n *\r\n * This class provides APIs to utilize a separate counter state from that of the\r\n * global generator used by {@link uuidv7} and {@link uuidv7obj}. In addition to\r\n * the default {@link generate} method, this class has {@link generateOrAbort}\r\n * that is useful to absolutely guarantee the monotonically increasing order of\r\n * generated UUIDs. See their respective documentation for details.\r\n */\r\nclass V7Generator {\r\n    /**\r\n     * Creates a generator object with the default random number generator, or\r\n     * with the specified one if passed as an argument. The specified random\r\n     * number generator should be cryptographically strong and securely seeded.\r\n     */\r\n    constructor(randomNumberGenerator) {\r\n        this.timestamp = 0;\r\n        this.counter = 0;\r\n        this.random = randomNumberGenerator ?? getDefaultRandom();\r\n    }\r\n    /**\r\n     * Generates a new UUIDv7 object from the current timestamp, or resets the\r\n     * generator upon significant timestamp rollback.\r\n     *\r\n     * This method returns a monotonically increasing UUID by reusing the previous\r\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\r\n     * preceding UUID's. However, when such a clock rollback is considered\r\n     * significant (i.e., by more than ten seconds), this method resets the\r\n     * generator and returns a new UUID based on the given timestamp, breaking the\r\n     * increasing order of UUIDs.\r\n     *\r\n     * See {@link generateOrAbort} for the other mode of generation and\r\n     * {@link generateOrResetCore} for the low-level primitive.\r\n     */\r\n    generate() {\r\n        return this.generateOrResetCore(Date.now(), 10000);\r\n    }\r\n    /**\r\n     * Generates a new UUIDv7 object from the current timestamp, or returns\r\n     * `undefined` upon significant timestamp rollback.\r\n     *\r\n     * This method returns a monotonically increasing UUID by reusing the previous\r\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\r\n     * preceding UUID's. However, when such a clock rollback is considered\r\n     * significant (i.e., by more than ten seconds), this method aborts and\r\n     * returns `undefined` immediately.\r\n     *\r\n     * See {@link generate} for the other mode of generation and\r\n     * {@link generateOrAbortCore} for the low-level primitive.\r\n     */\r\n    generateOrAbort() {\r\n        return this.generateOrAbortCore(Date.now(), 10000);\r\n    }\r\n    /**\r\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the\r\n     * generator upon significant timestamp rollback.\r\n     *\r\n     * This method is equivalent to {@link generate} except that it takes a custom\r\n     * timestamp and clock rollback allowance.\r\n     *\r\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\r\n     * considered significant. A suggested value is `10_000` (milliseconds).\r\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\r\n     */\r\n    generateOrResetCore(unixTsMs, rollbackAllowance) {\r\n        let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\r\n        if (value === undefined) {\r\n            // reset state and resume\r\n            this.timestamp = 0;\r\n            value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns\r\n     * `undefined` upon significant timestamp rollback.\r\n     *\r\n     * This method is equivalent to {@link generateOrAbort} except that it takes a\r\n     * custom timestamp and clock rollback allowance.\r\n     *\r\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\r\n     * considered significant. A suggested value is `10_000` (milliseconds).\r\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\r\n     */\r\n    generateOrAbortCore(unixTsMs, rollbackAllowance) {\r\n        const MAX_COUNTER = 4398046511103;\r\n        if (!Number.isInteger(unixTsMs) ||\r\n            unixTsMs < 1 ||\r\n            unixTsMs > 281474976710655) {\r\n            throw new RangeError(\"`unixTsMs` must be a 48-bit positive integer\");\r\n        }\r\n        else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {\r\n            throw new RangeError(\"`rollbackAllowance` out of reasonable range\");\r\n        }\r\n        if (unixTsMs > this.timestamp) {\r\n            this.timestamp = unixTsMs;\r\n            this.resetCounter();\r\n        }\r\n        else if (unixTsMs + rollbackAllowance >= this.timestamp) {\r\n            // go on with previous timestamp if new one is not much smaller\r\n            this.counter++;\r\n            if (this.counter > MAX_COUNTER) {\r\n                // increment timestamp at counter overflow\r\n                this.timestamp++;\r\n                this.resetCounter();\r\n            }\r\n        }\r\n        else {\r\n            // abort if clock went backwards to unbearable extent\r\n            return undefined;\r\n        }\r\n        return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & (2 ** 30 - 1), this.random.nextUint32());\r\n    }\r\n    /** Initializes the counter at a 42-bit random integer. */\r\n    resetCounter() {\r\n        this.counter =\r\n            this.random.nextUint32() * 0x400 + (this.random.nextUint32() & 0x3ff);\r\n    }\r\n    /**\r\n     * Generates a new UUIDv4 object utilizing the random number generator inside.\r\n     *\r\n     * @internal\r\n     */\r\n    generateV4() {\r\n        const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);\r\n        bytes[6] = 0x40 | (bytes[6] >>> 4);\r\n        bytes[8] = 0x80 | (bytes[8] >>> 2);\r\n        return UUID.ofInner(bytes);\r\n    }\r\n}\r\n/** A global flag to force use of cryptographically strong RNG. */\r\n// declare const UUIDV7_DENY_WEAK_RNG: boolean;\r\n/** Returns the default random number generator available in the environment. */\r\nconst getDefaultRandom = () => {\r\n    // fix: crypto isn't available in react-native, always use Math.random\r\n    //   // detect Web Crypto API\r\n    //   if (\r\n    //     typeof crypto !== \"undefined\" &&\r\n    //     typeof crypto.getRandomValues !== \"undefined\"\r\n    //   ) {\r\n    //     return new BufferedCryptoRandom();\r\n    //   } else {\r\n    //     // fall back on Math.random() unless the flag is set to true\r\n    //     if (typeof UUIDV7_DENY_WEAK_RNG !== \"undefined\" && UUIDV7_DENY_WEAK_RNG) {\r\n    //       throw new Error(\"no cryptographically strong RNG available\");\r\n    //     }\r\n    //     return {\r\n    //       nextUint32: (): number =>\r\n    //         Math.trunc(Math.random() * 0x1_0000) * 0x1_0000 +\r\n    //         Math.trunc(Math.random() * 0x1_0000),\r\n    //     };\r\n    //   }\r\n    return {\r\n        nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 +\r\n            Math.trunc(Math.random() * 65536),\r\n    };\r\n};\r\n// /**\r\n//  * Wraps `crypto.getRandomValues()` to enable buffering; this uses a small\r\n//  * buffer by default to avoid both unbearable throughput decline in some\r\n//  * environments and the waste of time and space for unused values.\r\n//  */\r\n// class BufferedCryptoRandom {\r\n//   private readonly buffer = new Uint32Array(8);\r\n//   private cursor = 0xffff;\r\n//   nextUint32(): number {\r\n//     if (this.cursor >= this.buffer.length) {\r\n//       crypto.getRandomValues(this.buffer);\r\n//       this.cursor = 0;\r\n//     }\r\n//     return this.buffer[this.cursor++];\r\n//   }\r\n// }\r\nlet defaultGenerator;\r\n/**\r\n * Generates a UUIDv7 string.\r\n *\r\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\r\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\r\n */\r\nconst uuidv7 = () => uuidv7obj().toString();\r\n/** Generates a UUIDv7 object. */\r\nconst uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();\n\nclass PostHogFetchHttpError extends Error {\r\n    constructor(response) {\r\n        super('HTTP error while fetching PostHog: ' + response.status);\r\n        this.response = response;\r\n        this.name = 'PostHogFetchHttpError';\r\n    }\r\n}\r\nclass PostHogFetchNetworkError extends Error {\r\n    constructor(error) {\r\n        // TRICKY: \"cause\" is a newer property but is just ignored otherwise. Cast to any to ignore the type issue.\r\n        // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\r\n        // @ts-ignore\r\n        super('Network error while fetching PostHog', error instanceof Error ? { cause: error } : {});\r\n        this.error = error;\r\n        this.name = 'PostHogFetchNetworkError';\r\n    }\r\n}\r\nfunction isPostHogFetchError(err) {\r\n    return typeof err === 'object' && (err instanceof PostHogFetchHttpError || err instanceof PostHogFetchNetworkError);\r\n}\r\nclass PostHogCoreStateless {\r\n    constructor(apiKey, options) {\r\n        this.flushPromise = null;\r\n        this.disableGeoip = true;\r\n        this.disabled = false;\r\n        this.defaultOptIn = true;\r\n        this.pendingPromises = {};\r\n        // internal\r\n        this._events = new SimpleEventEmitter();\r\n        this._isInitialized = false;\r\n        assert(apiKey, \"You must pass your PostHog project's api key.\");\r\n        this.apiKey = apiKey;\r\n        this.host = removeTrailingSlash(options?.host || 'https://app.posthog.com');\r\n        this.flushAt = options?.flushAt ? Math.max(options?.flushAt, 1) : 20;\r\n        this.maxBatchSize = Math.max(this.flushAt, options?.maxBatchSize ?? 100);\r\n        this.maxQueueSize = Math.max(this.flushAt, options?.maxQueueSize ?? 1000);\r\n        this.flushInterval = options?.flushInterval ?? 10000;\r\n        this.captureMode = options?.captureMode || 'form';\r\n        // If enable is explicitly set to false we override the optout\r\n        this.defaultOptIn = options?.defaultOptIn ?? true;\r\n        this._retryOptions = {\r\n            retryCount: options?.fetchRetryCount ?? 3,\r\n            retryDelay: options?.fetchRetryDelay ?? 3000,\r\n            retryCheck: isPostHogFetchError,\r\n        };\r\n        this.requestTimeout = options?.requestTimeout ?? 10000; // 10 seconds\r\n        this.featureFlagsRequestTimeoutMs = options?.featureFlagsRequestTimeoutMs ?? 3000; // 3 seconds\r\n        this.disableGeoip = options?.disableGeoip ?? true;\r\n        this.disabled = options?.disabled ?? false;\r\n        // Init promise allows the derived class to block calls until it is ready\r\n        this._initPromise = Promise.resolve();\r\n        this._isInitialized = true;\r\n    }\r\n    wrap(fn) {\r\n        if (this.disabled) {\r\n            if (this.isDebug) {\r\n                console.warn('[PostHog] The client is disabled');\r\n            }\r\n            return;\r\n        }\r\n        if (this._isInitialized) {\r\n            // NOTE: We could also check for the \"opt in\" status here...\r\n            return fn();\r\n        }\r\n        this._initPromise.then(() => fn());\r\n    }\r\n    getCommonEventProperties() {\r\n        return {\r\n            $lib: this.getLibraryId(),\r\n            $lib_version: this.getLibraryVersion(),\r\n        };\r\n    }\r\n    get optedOut() {\r\n        return this.getPersistedProperty(PostHogPersistedProperty.OptedOut) ?? !this.defaultOptIn;\r\n    }\r\n    async optIn() {\r\n        this.wrap(() => {\r\n            this.setPersistedProperty(PostHogPersistedProperty.OptedOut, false);\r\n        });\r\n    }\r\n    async optOut() {\r\n        this.wrap(() => {\r\n            this.setPersistedProperty(PostHogPersistedProperty.OptedOut, true);\r\n        });\r\n    }\r\n    on(event, cb) {\r\n        return this._events.on(event, cb);\r\n    }\r\n    debug(enabled = true) {\r\n        this.removeDebugCallback?.();\r\n        if (enabled) {\r\n            const removeDebugCallback = this.on('*', (event, payload) => console.log('PostHog Debug', event, payload));\r\n            this.removeDebugCallback = () => {\r\n                removeDebugCallback();\r\n                this.removeDebugCallback = undefined;\r\n            };\r\n        }\r\n    }\r\n    get isDebug() {\r\n        return !!this.removeDebugCallback;\r\n    }\r\n    buildPayload(payload) {\r\n        return {\r\n            distinct_id: payload.distinct_id,\r\n            event: payload.event,\r\n            properties: {\r\n                ...(payload.properties || {}),\r\n                ...this.getCommonEventProperties(), // Common PH props\r\n            },\r\n        };\r\n    }\r\n    addPendingPromise(promise) {\r\n        const promiseUUID = uuidv7();\r\n        this.pendingPromises[promiseUUID] = promise;\r\n        promise\r\n            .catch(() => { })\r\n            .finally(() => {\r\n            delete this.pendingPromises[promiseUUID];\r\n        });\r\n        return promise;\r\n    }\r\n    /***\r\n     *** TRACKING\r\n     ***/\r\n    identifyStateless(distinctId, properties, options) {\r\n        this.wrap(() => {\r\n            // The properties passed to identifyStateless are event properties.\r\n            // To add person properties, pass in all person properties to the `$set` key.\r\n            const payload = {\r\n                ...this.buildPayload({\r\n                    distinct_id: distinctId,\r\n                    event: '$identify',\r\n                    properties,\r\n                }),\r\n            };\r\n            this.enqueue('identify', payload, options);\r\n        });\r\n    }\r\n    captureStateless(distinctId, event, properties, options) {\r\n        this.wrap(() => {\r\n            const payload = this.buildPayload({ distinct_id: distinctId, event, properties });\r\n            this.enqueue('capture', payload, options);\r\n        });\r\n    }\r\n    aliasStateless(alias, distinctId, properties, options) {\r\n        this.wrap(() => {\r\n            const payload = this.buildPayload({\r\n                event: '$create_alias',\r\n                distinct_id: distinctId,\r\n                properties: {\r\n                    ...(properties || {}),\r\n                    distinct_id: distinctId,\r\n                    alias,\r\n                },\r\n            });\r\n            this.enqueue('alias', payload, options);\r\n        });\r\n    }\r\n    /***\r\n     *** GROUPS\r\n     ***/\r\n    groupIdentifyStateless(groupType, groupKey, groupProperties, options, distinctId, eventProperties) {\r\n        this.wrap(() => {\r\n            const payload = this.buildPayload({\r\n                distinct_id: distinctId || `$${groupType}_${groupKey}`,\r\n                event: '$groupidentify',\r\n                properties: {\r\n                    $group_type: groupType,\r\n                    $group_key: groupKey,\r\n                    $group_set: groupProperties || {},\r\n                    ...(eventProperties || {}),\r\n                },\r\n            });\r\n            this.enqueue('capture', payload, options);\r\n        });\r\n    }\r\n    /***\r\n     *** FEATURE FLAGS\r\n     ***/\r\n    async getDecide(distinctId, groups = {}, personProperties = {}, groupProperties = {}, extraPayload = {}) {\r\n        await this._initPromise;\r\n        const url = `${this.host}/decide/?v=3`;\r\n        const fetchOptions = {\r\n            method: 'POST',\r\n            headers: { ...this.getCustomHeaders(), 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({\r\n                token: this.apiKey,\r\n                distinct_id: distinctId,\r\n                groups,\r\n                person_properties: personProperties,\r\n                group_properties: groupProperties,\r\n                ...extraPayload,\r\n            }),\r\n        };\r\n        // Don't retry /decide API calls\r\n        return this.fetchWithRetry(url, fetchOptions, { retryCount: 0 }, this.featureFlagsRequestTimeoutMs)\r\n            .then((response) => response.json())\r\n            .catch((error) => {\r\n            this._events.emit('error', error);\r\n            return undefined;\r\n        });\r\n    }\r\n    async getFeatureFlagStateless(key, distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip) {\r\n        await this._initPromise;\r\n        const featureFlags = await this.getFeatureFlagsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip);\r\n        if (!featureFlags) {\r\n            // If we haven't loaded flags yet, or errored out, we respond with undefined\r\n            return undefined;\r\n        }\r\n        let response = featureFlags[key];\r\n        // `/decide` v3 returns all flags\r\n        if (response === undefined) {\r\n            // For cases where the flag is unknown, return false\r\n            response = false;\r\n        }\r\n        // If we have flags we either return the value (true or string) or false\r\n        return response;\r\n    }\r\n    async getFeatureFlagPayloadStateless(key, distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip) {\r\n        await this._initPromise;\r\n        const payloads = await this.getFeatureFlagPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip);\r\n        if (!payloads) {\r\n            return undefined;\r\n        }\r\n        const response = payloads[key];\r\n        // Undefined means a loading or missing data issue. Null means evaluation happened and there was no match\r\n        if (response === undefined) {\r\n            return null;\r\n        }\r\n        return this._parsePayload(response);\r\n    }\r\n    async getFeatureFlagPayloadsStateless(distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip) {\r\n        await this._initPromise;\r\n        const payloads = (await this.getFeatureFlagsAndPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip)).payloads;\r\n        if (payloads) {\r\n            return Object.fromEntries(Object.entries(payloads).map(([k, v]) => [k, this._parsePayload(v)]));\r\n        }\r\n        return payloads;\r\n    }\r\n    _parsePayload(response) {\r\n        try {\r\n            return JSON.parse(response);\r\n        }\r\n        catch {\r\n            return response;\r\n        }\r\n    }\r\n    async getFeatureFlagsStateless(distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip) {\r\n        await this._initPromise;\r\n        return (await this.getFeatureFlagsAndPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip)).flags;\r\n    }\r\n    async getFeatureFlagsAndPayloadsStateless(distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip) {\r\n        await this._initPromise;\r\n        const extraPayload = {};\r\n        if (disableGeoip ?? this.disableGeoip) {\r\n            extraPayload['geoip_disable'] = true;\r\n        }\r\n        const decideResponse = await this.getDecide(distinctId, groups, personProperties, groupProperties, extraPayload);\r\n        const flags = decideResponse?.featureFlags;\r\n        const payloads = decideResponse?.featureFlagPayloads;\r\n        return {\r\n            flags,\r\n            payloads,\r\n        };\r\n    }\r\n    /***\r\n     *** QUEUEING AND FLUSHING\r\n     ***/\r\n    enqueue(type, _message, options) {\r\n        this.wrap(() => {\r\n            if (this.optedOut) {\r\n                this._events.emit(type, `Library is disabled. Not sending event. To re-enable, call posthog.optIn()`);\r\n                return;\r\n            }\r\n            const message = {\r\n                ..._message,\r\n                type: type,\r\n                library: this.getLibraryId(),\r\n                library_version: this.getLibraryVersion(),\r\n                timestamp: options?.timestamp ? options?.timestamp : currentISOTime(),\r\n                uuid: options?.uuid ? options.uuid : uuidv7(),\r\n            };\r\n            const addGeoipDisableProperty = options?.disableGeoip ?? this.disableGeoip;\r\n            if (addGeoipDisableProperty) {\r\n                if (!message.properties) {\r\n                    message.properties = {};\r\n                }\r\n                message['properties']['$geoip_disable'] = true;\r\n            }\r\n            if (message.distinctId) {\r\n                message.distinct_id = message.distinctId;\r\n                delete message.distinctId;\r\n            }\r\n            const queue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];\r\n            if (queue.length >= this.maxQueueSize) {\r\n                queue.shift();\r\n                console.info('Queue is full, the oldest event is dropped.');\r\n            }\r\n            queue.push({ message });\r\n            this.setPersistedProperty(PostHogPersistedProperty.Queue, queue);\r\n            this._events.emit(type, message);\r\n            // Flush queued events if we meet the flushAt length\r\n            if (queue.length >= this.flushAt) {\r\n                this.flushBackground();\r\n            }\r\n            if (this.flushInterval && !this._flushTimer) {\r\n                this._flushTimer = safeSetTimeout(() => this.flushBackground(), this.flushInterval);\r\n            }\r\n        });\r\n    }\r\n    clearFlushTimer() {\r\n        if (this._flushTimer) {\r\n            clearTimeout(this._flushTimer);\r\n            this._flushTimer = undefined;\r\n        }\r\n    }\r\n    /**\r\n     * Helper for flushing the queue in the background\r\n     * Avoids unnecessary promise errors\r\n     */\r\n    flushBackground() {\r\n        void this.flush().catch(() => { });\r\n    }\r\n    async flush() {\r\n        if (!this.flushPromise) {\r\n            this.flushPromise = this._flush().finally(() => {\r\n                this.flushPromise = null;\r\n            });\r\n            this.addPendingPromise(this.flushPromise);\r\n        }\r\n        return this.flushPromise;\r\n    }\r\n    getCustomHeaders() {\r\n        // Don't set the user agent if we're not on a browser. The latest spec allows\r\n        // the User-Agent header (see https://fetch.spec.whatwg.org/#terminology-headers\r\n        // and https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader),\r\n        // but browsers such as Chrome and Safari have not caught up.\r\n        const customUserAgent = this.getCustomUserAgent();\r\n        const headers = {};\r\n        if (customUserAgent && customUserAgent !== '') {\r\n            headers['User-Agent'] = customUserAgent;\r\n        }\r\n        return headers;\r\n    }\r\n    async _flush() {\r\n        this.clearFlushTimer();\r\n        await this._initPromise;\r\n        const queue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];\r\n        if (!queue.length) {\r\n            return [];\r\n        }\r\n        const items = queue.slice(0, this.maxBatchSize);\r\n        const messages = items.map((item) => item.message);\r\n        const persistQueueChange = () => {\r\n            const refreshedQueue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];\r\n            this.setPersistedProperty(PostHogPersistedProperty.Queue, refreshedQueue.slice(items.length));\r\n        };\r\n        const data = {\r\n            api_key: this.apiKey,\r\n            batch: messages,\r\n            sent_at: currentISOTime(),\r\n        };\r\n        const payload = JSON.stringify(data);\r\n        const url = this.captureMode === 'form'\r\n            ? `${this.host}/e/?ip=1&_=${currentTimestamp()}&v=${this.getLibraryVersion()}`\r\n            : `${this.host}/batch/`;\r\n        const fetchOptions = this.captureMode === 'form'\r\n            ? {\r\n                method: 'POST',\r\n                mode: 'no-cors',\r\n                credentials: 'omit',\r\n                headers: { ...this.getCustomHeaders(), 'Content-Type': 'application/x-www-form-urlencoded' },\r\n                body: `data=${encodeURIComponent(LZString.compressToBase64(payload))}&compression=lz64`,\r\n            }\r\n            : {\r\n                method: 'POST',\r\n                headers: { ...this.getCustomHeaders(), 'Content-Type': 'application/json' },\r\n                body: payload,\r\n            };\r\n        try {\r\n            await this.fetchWithRetry(url, fetchOptions);\r\n        }\r\n        catch (err) {\r\n            // depending on the error type, eg a malformed JSON or broken queue, it'll always return an error\r\n            // and this will be an endless loop, in this case, if the error isn't a network issue, we always remove the items from the queue\r\n            if (!(err instanceof PostHogFetchNetworkError)) {\r\n                persistQueueChange();\r\n            }\r\n            this._events.emit('error', err);\r\n            throw err;\r\n        }\r\n        persistQueueChange();\r\n        this._events.emit('flush', messages);\r\n        return messages;\r\n    }\r\n    async fetchWithRetry(url, options, retryOptions, requestTimeout) {\r\n        var _a;\r\n        (_a = AbortSignal).timeout ?? (_a.timeout = function timeout(ms) {\r\n            const ctrl = new AbortController();\r\n            setTimeout(() => ctrl.abort(), ms);\r\n            return ctrl.signal;\r\n        });\r\n        return await retriable(async () => {\r\n            let res = null;\r\n            try {\r\n                res = await this.fetch(url, {\r\n                    signal: AbortSignal.timeout(requestTimeout ?? this.requestTimeout),\r\n                    ...options,\r\n                });\r\n            }\r\n            catch (e) {\r\n                // fetch will only throw on network errors or on timeouts\r\n                throw new PostHogFetchNetworkError(e);\r\n            }\r\n            // If we're in no-cors mode, we can't access the response status\r\n            // We only throw on HTTP errors if we're not in no-cors mode\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/Request/mode#no-cors\r\n            const isNoCors = options.mode === 'no-cors';\r\n            if (!isNoCors && (res.status < 200 || res.status >= 400)) {\r\n                throw new PostHogFetchHttpError(res);\r\n            }\r\n            return res;\r\n        }, { ...this._retryOptions, ...retryOptions });\r\n    }\r\n    async shutdown(shutdownTimeoutMs = 30000) {\r\n        await this._initPromise;\r\n        this.clearFlushTimer();\r\n        try {\r\n            await Promise.all(Object.values(this.pendingPromises));\r\n            const startTimeWithDelay = Date.now() + shutdownTimeoutMs;\r\n            while (true) {\r\n                const queue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];\r\n                if (queue.length === 0) {\r\n                    break;\r\n                }\r\n                // flush again to make sure we send all events, some of which might've been added\r\n                // while we were waiting for the pending promises to resolve\r\n                // For example, see sendFeatureFlags in posthog-node/src/posthog-node.ts::capture\r\n                await this.flush();\r\n                // If we've been waiting for more than the shutdownTimeoutMs, stop it\r\n                const now = Date.now();\r\n                if (startTimeWithDelay < now) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            if (!isPostHogFetchError(e)) {\r\n                throw e;\r\n            }\r\n            console.error('Error while shutting down PostHog', e);\r\n        }\r\n    }\r\n}\r\nclass PostHogCore extends PostHogCoreStateless {\r\n    constructor(apiKey, options) {\r\n        // Default for stateful mode is to not disable geoip. Only override if explicitly set\r\n        const disableGeoipOption = options?.disableGeoip ?? false;\r\n        // Default for stateful mode is to timeout at 10s. Only override if explicitly set\r\n        const featureFlagsRequestTimeoutMs = options?.featureFlagsRequestTimeoutMs ?? 10000; // 10 seconds\r\n        super(apiKey, { ...options, disableGeoip: disableGeoipOption, featureFlagsRequestTimeoutMs });\r\n        this.flagCallReported = {};\r\n        this.sessionProps = {};\r\n        this.sendFeatureFlagEvent = options?.sendFeatureFlagEvent ?? true;\r\n        this._sessionExpirationTimeSeconds = options?.sessionExpirationTimeSeconds ?? 1800; // 30 minutes\r\n    }\r\n    setupBootstrap(options) {\r\n        if (options?.bootstrap?.distinctId) {\r\n            if (options?.bootstrap?.isIdentifiedId) {\r\n                this.setPersistedProperty(PostHogPersistedProperty.DistinctId, options.bootstrap.distinctId);\r\n            }\r\n            else {\r\n                this.setPersistedProperty(PostHogPersistedProperty.AnonymousId, options.bootstrap.distinctId);\r\n            }\r\n        }\r\n        if (options?.bootstrap?.featureFlags) {\r\n            const activeFlags = Object.keys(options.bootstrap?.featureFlags || {})\r\n                .filter((flag) => !!options.bootstrap?.featureFlags?.[flag])\r\n                .reduce((res, key) => ((res[key] = options.bootstrap?.featureFlags?.[key] || false), res), {});\r\n            this.setKnownFeatureFlags(activeFlags);\r\n            options?.bootstrap.featureFlagPayloads && this.setKnownFeatureFlagPayloads(options?.bootstrap.featureFlagPayloads);\r\n        }\r\n    }\r\n    // NOTE: Props are lazy loaded from localstorage hence the complex getter setter logic\r\n    get props() {\r\n        if (!this._props) {\r\n            this._props = this.getPersistedProperty(PostHogPersistedProperty.Props);\r\n        }\r\n        return this._props || {};\r\n    }\r\n    set props(val) {\r\n        this._props = val;\r\n    }\r\n    clearProps() {\r\n        this.props = undefined;\r\n        this.sessionProps = {};\r\n    }\r\n    on(event, cb) {\r\n        return this._events.on(event, cb);\r\n    }\r\n    reset(propertiesToKeep) {\r\n        this.wrap(() => {\r\n            const allPropertiesToKeep = [PostHogPersistedProperty.Queue, ...(propertiesToKeep || [])];\r\n            // clean up props\r\n            this.clearProps();\r\n            for (const key of Object.keys(PostHogPersistedProperty)) {\r\n                if (!allPropertiesToKeep.includes(PostHogPersistedProperty[key])) {\r\n                    this.setPersistedProperty(PostHogPersistedProperty[key], null);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    getCommonEventProperties() {\r\n        const featureFlags = this.getFeatureFlags();\r\n        const featureVariantProperties = {};\r\n        if (featureFlags) {\r\n            for (const [feature, variant] of Object.entries(featureFlags)) {\r\n                featureVariantProperties[`$feature/${feature}`] = variant;\r\n            }\r\n        }\r\n        return {\r\n            $active_feature_flags: featureFlags ? Object.keys(featureFlags) : undefined,\r\n            ...featureVariantProperties,\r\n            ...super.getCommonEventProperties(),\r\n        };\r\n    }\r\n    enrichProperties(properties) {\r\n        return {\r\n            ...this.props,\r\n            ...this.sessionProps,\r\n            ...(properties || {}),\r\n            ...this.getCommonEventProperties(),\r\n            $session_id: this.getSessionId(),\r\n        };\r\n    }\r\n    /**\r\n     * * @returns {string} The stored session ID for the current session. This may be an empty string if the client is not yet fully initialized.\r\n     */\r\n    getSessionId() {\r\n        if (!this._isInitialized) {\r\n            return '';\r\n        }\r\n        let sessionId = this.getPersistedProperty(PostHogPersistedProperty.SessionId);\r\n        const sessionTimestamp = this.getPersistedProperty(PostHogPersistedProperty.SessionLastTimestamp) || 0;\r\n        if (!sessionId || Date.now() - sessionTimestamp > this._sessionExpirationTimeSeconds * 1000) {\r\n            sessionId = uuidv7();\r\n            this.setPersistedProperty(PostHogPersistedProperty.SessionId, sessionId);\r\n        }\r\n        this.setPersistedProperty(PostHogPersistedProperty.SessionLastTimestamp, Date.now());\r\n        return sessionId;\r\n    }\r\n    resetSessionId() {\r\n        this.wrap(() => {\r\n            this.setPersistedProperty(PostHogPersistedProperty.SessionId, null);\r\n        });\r\n    }\r\n    /**\r\n     * * @returns {string} The stored anonymous ID. This may be an empty string if the client is not yet fully initialized.\r\n     */\r\n    getAnonymousId() {\r\n        if (!this._isInitialized) {\r\n            return '';\r\n        }\r\n        let anonId = this.getPersistedProperty(PostHogPersistedProperty.AnonymousId);\r\n        if (!anonId) {\r\n            anonId = uuidv7();\r\n            this.setPersistedProperty(PostHogPersistedProperty.AnonymousId, anonId);\r\n        }\r\n        return anonId;\r\n    }\r\n    /**\r\n     * * @returns {string} The stored distinct ID. This may be an empty string if the client is not yet fully initialized.\r\n     */\r\n    getDistinctId() {\r\n        if (!this._isInitialized) {\r\n            return '';\r\n        }\r\n        return this.getPersistedProperty(PostHogPersistedProperty.DistinctId) || this.getAnonymousId();\r\n    }\r\n    async unregister(property) {\r\n        this.wrap(() => {\r\n            delete this.props[property];\r\n            this.setPersistedProperty(PostHogPersistedProperty.Props, this.props);\r\n        });\r\n    }\r\n    async register(properties) {\r\n        this.wrap(() => {\r\n            this.props = {\r\n                ...this.props,\r\n                ...properties,\r\n            };\r\n            this.setPersistedProperty(PostHogPersistedProperty.Props, this.props);\r\n        });\r\n    }\r\n    registerForSession(properties) {\r\n        this.sessionProps = {\r\n            ...this.sessionProps,\r\n            ...properties,\r\n        };\r\n    }\r\n    unregisterForSession(property) {\r\n        delete this.sessionProps[property];\r\n    }\r\n    /***\r\n     *** TRACKING\r\n     ***/\r\n    identify(distinctId, properties, options) {\r\n        this.wrap(() => {\r\n            const previousDistinctId = this.getDistinctId();\r\n            distinctId = distinctId || previousDistinctId;\r\n            if (properties?.$groups) {\r\n                this.groups(properties.$groups);\r\n            }\r\n            const allProperties = this.enrichProperties({\r\n                ...properties,\r\n                $anon_distinct_id: this.getAnonymousId(),\r\n                $set: properties,\r\n            });\r\n            if (distinctId !== previousDistinctId) {\r\n                // We keep the AnonymousId to be used by decide calls and identify to link the previousId\r\n                this.setPersistedProperty(PostHogPersistedProperty.AnonymousId, previousDistinctId);\r\n                this.setPersistedProperty(PostHogPersistedProperty.DistinctId, distinctId);\r\n                this.reloadFeatureFlags();\r\n            }\r\n            super.identifyStateless(distinctId, allProperties, options);\r\n        });\r\n    }\r\n    capture(event, properties, options) {\r\n        this.wrap(() => {\r\n            const distinctId = this.getDistinctId();\r\n            if (properties?.$groups) {\r\n                this.groups(properties.$groups);\r\n            }\r\n            const allProperties = this.enrichProperties(properties);\r\n            super.captureStateless(distinctId, event, allProperties, options);\r\n        });\r\n    }\r\n    alias(alias) {\r\n        this.wrap(() => {\r\n            const distinctId = this.getDistinctId();\r\n            const allProperties = this.enrichProperties({});\r\n            super.aliasStateless(alias, distinctId, allProperties);\r\n        });\r\n    }\r\n    autocapture(eventType, elements, properties = {}, options) {\r\n        this.wrap(() => {\r\n            const distinctId = this.getDistinctId();\r\n            const payload = {\r\n                distinct_id: distinctId,\r\n                event: '$autocapture',\r\n                properties: {\r\n                    ...this.enrichProperties(properties),\r\n                    $event_type: eventType,\r\n                    $elements: elements,\r\n                },\r\n            };\r\n            this.enqueue('autocapture', payload, options);\r\n        });\r\n    }\r\n    /***\r\n     *** GROUPS\r\n     ***/\r\n    groups(groups) {\r\n        this.wrap(() => {\r\n            // Get persisted groups\r\n            const existingGroups = this.props.$groups || {};\r\n            this.register({\r\n                $groups: {\r\n                    ...existingGroups,\r\n                    ...groups,\r\n                },\r\n            });\r\n            if (Object.keys(groups).find((type) => existingGroups[type] !== groups[type])) {\r\n                this.reloadFeatureFlags();\r\n            }\r\n        });\r\n    }\r\n    group(groupType, groupKey, groupProperties, options) {\r\n        this.wrap(() => {\r\n            this.groups({\r\n                [groupType]: groupKey,\r\n            });\r\n            if (groupProperties) {\r\n                this.groupIdentify(groupType, groupKey, groupProperties, options);\r\n            }\r\n        });\r\n    }\r\n    groupIdentify(groupType, groupKey, groupProperties, options) {\r\n        this.wrap(() => {\r\n            const distinctId = this.getDistinctId();\r\n            const eventProperties = this.enrichProperties({});\r\n            super.groupIdentifyStateless(groupType, groupKey, groupProperties, options, distinctId, eventProperties);\r\n        });\r\n    }\r\n    /***\r\n     * PROPERTIES\r\n     ***/\r\n    setPersonPropertiesForFlags(properties) {\r\n        this.wrap(() => {\r\n            // Get persisted person properties\r\n            const existingProperties = this.getPersistedProperty(PostHogPersistedProperty.PersonProperties) || {};\r\n            this.setPersistedProperty(PostHogPersistedProperty.PersonProperties, {\r\n                ...existingProperties,\r\n                ...properties,\r\n            });\r\n        });\r\n    }\r\n    resetPersonPropertiesForFlags() {\r\n        this.wrap(() => {\r\n            this.setPersistedProperty(PostHogPersistedProperty.PersonProperties, {});\r\n        });\r\n    }\r\n    /** @deprecated - Renamed to setPersonPropertiesForFlags */\r\n    personProperties(properties) {\r\n        return this.setPersonPropertiesForFlags(properties);\r\n    }\r\n    setGroupPropertiesForFlags(properties) {\r\n        this.wrap(() => {\r\n            // Get persisted group properties\r\n            const existingProperties = this.getPersistedProperty(PostHogPersistedProperty.GroupProperties) ||\r\n                {};\r\n            if (Object.keys(existingProperties).length !== 0) {\r\n                Object.keys(existingProperties).forEach((groupType) => {\r\n                    existingProperties[groupType] = {\r\n                        ...existingProperties[groupType],\r\n                        ...properties[groupType],\r\n                    };\r\n                    delete properties[groupType];\r\n                });\r\n            }\r\n            this.setPersistedProperty(PostHogPersistedProperty.GroupProperties, {\r\n                ...existingProperties,\r\n                ...properties,\r\n            });\r\n        });\r\n    }\r\n    resetGroupPropertiesForFlags() {\r\n        this.wrap(() => {\r\n            this.setPersistedProperty(PostHogPersistedProperty.GroupProperties, {});\r\n        });\r\n    }\r\n    /** @deprecated - Renamed to setGroupPropertiesForFlags */\r\n    groupProperties(properties) {\r\n        this.wrap(() => {\r\n            this.setGroupPropertiesForFlags(properties);\r\n        });\r\n    }\r\n    /***\r\n     *** FEATURE FLAGS\r\n     ***/\r\n    async decideAsync(sendAnonDistinctId = true) {\r\n        await this._initPromise;\r\n        if (this._decideResponsePromise) {\r\n            return this._decideResponsePromise;\r\n        }\r\n        return this._decideAsync(sendAnonDistinctId);\r\n    }\r\n    async _decideAsync(sendAnonDistinctId = true) {\r\n        this._decideResponsePromise = this._initPromise\r\n            .then(() => {\r\n            const distinctId = this.getDistinctId();\r\n            const groups = this.props.$groups || {};\r\n            const personProperties = this.getPersistedProperty(PostHogPersistedProperty.PersonProperties) || {};\r\n            const groupProperties = this.getPersistedProperty(PostHogPersistedProperty.GroupProperties) ||\r\n                {};\r\n            const extraProperties = {\r\n                $anon_distinct_id: sendAnonDistinctId ? this.getAnonymousId() : undefined,\r\n            };\r\n            return super.getDecide(distinctId, groups, personProperties, groupProperties, extraProperties).then((res) => {\r\n                if (res?.featureFlags) {\r\n                    let newFeatureFlags = res.featureFlags;\r\n                    let newFeatureFlagPayloads = res.featureFlagPayloads;\r\n                    if (res.errorsWhileComputingFlags) {\r\n                        // if not all flags were computed, we upsert flags instead of replacing them\r\n                        const currentFlags = this.getPersistedProperty(PostHogPersistedProperty.FeatureFlags);\r\n                        const currentFlagPayloads = this.getPersistedProperty(PostHogPersistedProperty.FeatureFlagPayloads);\r\n                        newFeatureFlags = { ...currentFlags, ...res.featureFlags };\r\n                        newFeatureFlagPayloads = { ...currentFlagPayloads, ...res.featureFlagPayloads };\r\n                    }\r\n                    this.setKnownFeatureFlags(newFeatureFlags);\r\n                    this.setKnownFeatureFlagPayloads(newFeatureFlagPayloads);\r\n                }\r\n                return res;\r\n            });\r\n        })\r\n            .finally(() => {\r\n            this._decideResponsePromise = undefined;\r\n        });\r\n        return this._decideResponsePromise;\r\n    }\r\n    setKnownFeatureFlags(featureFlags) {\r\n        this.wrap(() => {\r\n            this.setPersistedProperty(PostHogPersistedProperty.FeatureFlags, featureFlags);\r\n            this._events.emit('featureflags', featureFlags);\r\n        });\r\n    }\r\n    setKnownFeatureFlagPayloads(featureFlagPayloads) {\r\n        this.wrap(() => {\r\n            this.setPersistedProperty(PostHogPersistedProperty.FeatureFlagPayloads, featureFlagPayloads);\r\n        });\r\n    }\r\n    getFeatureFlag(key) {\r\n        const featureFlags = this.getFeatureFlags();\r\n        if (!featureFlags) {\r\n            // If we haven't loaded flags yet, or errored out, we respond with undefined\r\n            return undefined;\r\n        }\r\n        let response = featureFlags[key];\r\n        // `/decide` v3 returns all flags\r\n        if (response === undefined) {\r\n            // For cases where the flag is unknown, return false\r\n            response = false;\r\n        }\r\n        if (this.sendFeatureFlagEvent && !this.flagCallReported[key]) {\r\n            this.flagCallReported[key] = true;\r\n            this.capture('$feature_flag_called', {\r\n                $feature_flag: key,\r\n                $feature_flag_response: response,\r\n            });\r\n        }\r\n        // If we have flags we either return the value (true or string) or false\r\n        return response;\r\n    }\r\n    getFeatureFlagPayload(key) {\r\n        const payloads = this.getFeatureFlagPayloads();\r\n        if (!payloads) {\r\n            return undefined;\r\n        }\r\n        const response = payloads[key];\r\n        // Undefined means a loading or missing data issue. Null means evaluation happened and there was no match\r\n        if (response === undefined) {\r\n            return null;\r\n        }\r\n        return this._parsePayload(response);\r\n    }\r\n    getFeatureFlagPayloads() {\r\n        const payloads = this.getPersistedProperty(PostHogPersistedProperty.FeatureFlagPayloads);\r\n        if (payloads) {\r\n            return Object.fromEntries(Object.entries(payloads).map(([k, v]) => [k, this._parsePayload(v)]));\r\n        }\r\n        return payloads;\r\n    }\r\n    getFeatureFlags() {\r\n        // NOTE: We don't check for _initPromise here as the function is designed to be\r\n        // callable before the state being loaded anyways\r\n        let flags = this.getPersistedProperty(PostHogPersistedProperty.FeatureFlags);\r\n        const overriddenFlags = this.getPersistedProperty(PostHogPersistedProperty.OverrideFeatureFlags);\r\n        if (!overriddenFlags) {\r\n            return flags;\r\n        }\r\n        flags = flags || {};\r\n        for (const key in overriddenFlags) {\r\n            if (!overriddenFlags[key]) {\r\n                delete flags[key];\r\n            }\r\n            else {\r\n                flags[key] = overriddenFlags[key];\r\n            }\r\n        }\r\n        return flags;\r\n    }\r\n    getFeatureFlagsAndPayloads() {\r\n        const flags = this.getFeatureFlags();\r\n        const payloads = this.getFeatureFlagPayloads();\r\n        return {\r\n            flags,\r\n            payloads,\r\n        };\r\n    }\r\n    isFeatureEnabled(key) {\r\n        const response = this.getFeatureFlag(key);\r\n        if (response === undefined) {\r\n            return undefined;\r\n        }\r\n        return !!response;\r\n    }\r\n    // Used when we want to trigger the reload but we don't care about the result\r\n    reloadFeatureFlags(cb) {\r\n        this.decideAsync()\r\n            .then((res) => {\r\n            cb?.(undefined, res?.featureFlags);\r\n        })\r\n            .catch((e) => {\r\n            cb?.(e, undefined);\r\n            if (!cb) {\r\n                console.log('[PostHog] Error reloading feature flags', e);\r\n            }\r\n        });\r\n    }\r\n    async reloadFeatureFlagsAsync(sendAnonDistinctId = true) {\r\n        return (await this.decideAsync(sendAnonDistinctId))?.featureFlags;\r\n    }\r\n    onFeatureFlags(cb) {\r\n        return this.on('featureflags', async () => {\r\n            const flags = this.getFeatureFlags();\r\n            if (flags) {\r\n                cb(flags);\r\n            }\r\n        });\r\n    }\r\n    onFeatureFlag(key, cb) {\r\n        return this.on('featureflags', async () => {\r\n            const flagResponse = this.getFeatureFlag(key);\r\n            if (flagResponse !== undefined) {\r\n                cb(flagResponse);\r\n            }\r\n        });\r\n    }\r\n    async overrideFeatureFlag(flags) {\r\n        this.wrap(() => {\r\n            if (flags === null) {\r\n                return this.setPersistedProperty(PostHogPersistedProperty.OverrideFeatureFlags, null);\r\n            }\r\n            return this.setPersistedProperty(PostHogPersistedProperty.OverrideFeatureFlags, flags);\r\n        });\r\n    }\r\n}\n\nvar version = \"3.0.0\";\n\nfunction getContext(window) {\n  let context = {};\n\n  if (window.navigator) {\n    const userAgent = window.navigator.userAgent;\n    context = { ...context,\n      $os: os(window),\n      $browser: browser(userAgent, window.navigator.vendor, !!window.opera),\n      $referrer: window.document.referrer,\n      $referring_domain: referringDomain(window.document.referrer),\n      $device: device(userAgent),\n      $current_url: window.location.href,\n      $host: window.location.host,\n      $pathname: window.location.pathname,\n      $browser_version: browserVersion(userAgent, window.navigator.vendor, !!window.opera),\n      $screen_height: window.screen.height,\n      $screen_width: window.screen.width,\n      $screen_dpr: window.devicePixelRatio\n    };\n  }\n\n  context = { ...context,\n    $lib: 'js',\n    $lib_version: version,\n    $insert_id: Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10),\n    $time: currentTimestamp() / 1000 // epoch time in seconds\n\n  };\n  return context; // TODO: strip empty props?\n}\n\nfunction includes(haystack, needle) {\n  return haystack.indexOf(needle) >= 0;\n}\n\nfunction browser(userAgent, vendor, opera) {\n  vendor = vendor || ''; // vendor is undefined for at least IE9\n\n  if (opera || includes(userAgent, ' OPR/')) {\n    if (includes(userAgent, 'Mini')) {\n      return 'Opera Mini';\n    }\n\n    return 'Opera';\n  } else if (/(BlackBerry|PlayBook|BB10)/i.test(userAgent)) {\n    return 'BlackBerry';\n  } else if (includes(userAgent, 'IEMobile') || includes(userAgent, 'WPDesktop')) {\n    return 'Internet Explorer Mobile';\n  } else if (includes(userAgent, 'SamsungBrowser/')) {\n    // https://developer.samsung.com/internet/user-agent-string-format\n    return 'Samsung Internet';\n  } else if (includes(userAgent, 'Edge') || includes(userAgent, 'Edg/')) {\n    return 'Microsoft Edge';\n  } else if (includes(userAgent, 'FBIOS')) {\n    return 'Facebook Mobile';\n  } else if (includes(userAgent, 'Chrome')) {\n    return 'Chrome';\n  } else if (includes(userAgent, 'CriOS')) {\n    return 'Chrome iOS';\n  } else if (includes(userAgent, 'UCWEB') || includes(userAgent, 'UCBrowser')) {\n    return 'UC Browser';\n  } else if (includes(userAgent, 'FxiOS')) {\n    return 'Firefox iOS';\n  } else if (includes(vendor, 'Apple')) {\n    if (includes(userAgent, 'Mobile')) {\n      return 'Mobile Safari';\n    }\n\n    return 'Safari';\n  } else if (includes(userAgent, 'Android')) {\n    return 'Android Mobile';\n  } else if (includes(userAgent, 'Konqueror')) {\n    return 'Konqueror';\n  } else if (includes(userAgent, 'Firefox')) {\n    return 'Firefox';\n  } else if (includes(userAgent, 'MSIE') || includes(userAgent, 'Trident/')) {\n    return 'Internet Explorer';\n  } else if (includes(userAgent, 'Gecko')) {\n    return 'Mozilla';\n  } else {\n    return '';\n  }\n}\n\nfunction browserVersion(userAgent, vendor, opera) {\n  const regexList = {\n    'Internet Explorer Mobile': /rv:(\\d+(\\.\\d+)?)/,\n    'Microsoft Edge': /Edge?\\/(\\d+(\\.\\d+)?)/,\n    Chrome: /Chrome\\/(\\d+(\\.\\d+)?)/,\n    'Chrome iOS': /CriOS\\/(\\d+(\\.\\d+)?)/,\n    'UC Browser': /(UCBrowser|UCWEB)\\/(\\d+(\\.\\d+)?)/,\n    Safari: /Version\\/(\\d+(\\.\\d+)?)/,\n    'Mobile Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n    Opera: /(Opera|OPR)\\/(\\d+(\\.\\d+)?)/,\n    Firefox: /Firefox\\/(\\d+(\\.\\d+)?)/,\n    'Firefox iOS': /FxiOS\\/(\\d+(\\.\\d+)?)/,\n    Konqueror: /Konqueror:(\\d+(\\.\\d+)?)/,\n    BlackBerry: /BlackBerry (\\d+(\\.\\d+)?)/,\n    'Android Mobile': /android\\s(\\d+(\\.\\d+)?)/,\n    'Samsung Internet': /SamsungBrowser\\/(\\d+(\\.\\d+)?)/,\n    'Internet Explorer': /(rv:|MSIE )(\\d+(\\.\\d+)?)/,\n    Mozilla: /rv:(\\d+(\\.\\d+)?)/\n  };\n  const browserString = browser(userAgent, vendor, opera);\n  const regex = regexList[browserString] || undefined;\n\n  if (regex === undefined) {\n    return null;\n  }\n\n  const matches = userAgent.match(regex);\n\n  if (!matches) {\n    return null;\n  }\n\n  return parseFloat(matches[matches.length - 2]);\n}\n\nfunction os(window) {\n  const a = window.navigator.userAgent;\n\n  if (/Windows/i.test(a)) {\n    if (/Phone/.test(a) || /WPDesktop/.test(a)) {\n      return 'Windows Phone';\n    }\n\n    return 'Windows';\n  } else if (/(iPhone|iPad|iPod)/.test(a)) {\n    return 'iOS';\n  } else if (/Android/.test(a)) {\n    return 'Android';\n  } else if (/(BlackBerry|PlayBook|BB10)/i.test(a)) {\n    return 'BlackBerry';\n  } else if (/Mac/i.test(a)) {\n    return 'Mac OS X';\n  } else if (/Linux/.test(a)) {\n    return 'Linux';\n  } else if (/CrOS/.test(a)) {\n    return 'Chrome OS';\n  } else {\n    return '';\n  }\n}\n\nfunction device(userAgent) {\n  if (/Windows Phone/i.test(userAgent) || /WPDesktop/.test(userAgent)) {\n    return 'Windows Phone';\n  } else if (/iPad/.test(userAgent)) {\n    return 'iPad';\n  } else if (/iPod/.test(userAgent)) {\n    return 'iPod Touch';\n  } else if (/iPhone/.test(userAgent)) {\n    return 'iPhone';\n  } else if (/(BlackBerry|PlayBook|BB10)/i.test(userAgent)) {\n    return 'BlackBerry';\n  } else if (/Android/.test(userAgent)) {\n    return 'Android';\n  } else {\n    return '';\n  }\n}\n\nfunction referringDomain(referrer) {\n  const split = referrer.split('/');\n\n  if (split.length >= 3) {\n    return split[2];\n  }\n\n  return '';\n}\n\n// Methods partially borrowed from quirksmode.org/js/cookies.html\nconst cookieStore = {\n  getItem(key) {\n    try {\n      const nameEQ = key + '=';\n      const ca = document.cookie.split(';');\n\n      for (let i = 0; i < ca.length; i++) {\n        let c = ca[i];\n\n        while (c.charAt(0) == ' ') {\n          c = c.substring(1, c.length);\n        }\n\n        if (c.indexOf(nameEQ) === 0) {\n          return decodeURIComponent(c.substring(nameEQ.length, c.length));\n        }\n      }\n    } catch (err) {}\n\n    return null;\n  },\n\n  setItem(key, value) {\n    try {\n      const cdomain = '',\n            expires = '',\n            secure = '';\n      const new_cookie_val = key + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n      document.cookie = new_cookie_val;\n    } catch (err) {\n      return;\n    }\n  },\n\n  removeItem(name) {\n    try {\n      cookieStore.setItem(name, '');\n    } catch (err) {\n      return;\n    }\n  },\n\n  clear() {\n    document.cookie = '';\n  },\n\n  getAllKeys() {\n    const ca = document.cookie.split(';');\n    const keys = [];\n\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i];\n\n      while (c.charAt(0) == ' ') {\n        c = c.substring(1, c.length);\n      }\n\n      keys.push(c.split('=')[0]);\n    }\n\n    return keys;\n  }\n\n};\n\nconst createStorageLike = store => {\n  return {\n    getItem(key) {\n      return store.getItem(key);\n    },\n\n    setItem(key, value) {\n      store.setItem(key, value);\n    },\n\n    removeItem(key) {\n      store.removeItem(key);\n    },\n\n    clear() {\n      store.clear();\n    },\n\n    getAllKeys() {\n      const keys = [];\n\n      for (const key in localStorage) {\n        keys.push(key);\n      }\n\n      return keys;\n    }\n\n  };\n};\n\nconst checkStoreIsSupported = (storage, key = '__mplssupport__') => {\n  if (!window) {\n    return false;\n  }\n\n  try {\n    const val = 'xyz';\n    storage.setItem(key, val);\n\n    if (storage.getItem(key) !== val) {\n      return false;\n    }\n\n    storage.removeItem(key);\n    return true;\n  } catch (err) {\n    return false;\n  }\n};\n\nlet localStore = undefined;\nlet sessionStore = undefined;\n\nconst createMemoryStorage = () => {\n  const _cache = {};\n  const store = {\n    getItem(key) {\n      return _cache[key];\n    },\n\n    setItem(key, value) {\n      _cache[key] = value !== null ? value : undefined;\n    },\n\n    removeItem(key) {\n      delete _cache[key];\n    },\n\n    clear() {\n      for (const key in _cache) {\n        delete _cache[key];\n      }\n    },\n\n    getAllKeys() {\n      const keys = [];\n\n      for (const key in _cache) {\n        keys.push(key);\n      }\n\n      return keys;\n    }\n\n  };\n  return store;\n};\n\nconst getStorage = (type, window) => {\n  if (window) {\n    if (!localStorage) {\n      const _localStore = createStorageLike(window.localStorage);\n\n      localStore = checkStoreIsSupported(_localStore) ? _localStore : undefined;\n    }\n\n    if (!sessionStore) {\n      const _sessionStore = createStorageLike(window.sessionStorage);\n\n      sessionStore = checkStoreIsSupported(_sessionStore) ? _sessionStore : undefined;\n    }\n  }\n\n  switch (type) {\n    case 'cookie':\n      return cookieStore || localStore || sessionStore || createMemoryStorage();\n\n    case 'localStorage':\n      return localStore || sessionStore || createMemoryStorage();\n\n    case 'sessionStorage':\n      return sessionStore || createMemoryStorage();\n\n    case 'memory':\n      return createMemoryStorage();\n\n    default:\n      return createMemoryStorage();\n  }\n};\n\nclass PostHog extends PostHogCore {\n  constructor(apiKey, options) {\n    super(apiKey, options); // posthog-js stores options in one object on\n\n    this._storageKey = options?.persistence_name ? `ph_${options.persistence_name}` : `ph_${apiKey}_posthog`;\n    this._storage = getStorage(options?.persistence || 'localStorage', window);\n    this.setupBootstrap(options);\n\n    if (options?.preloadFeatureFlags !== false) {\n      this.reloadFeatureFlags();\n    }\n  }\n\n  getPersistedProperty(key) {\n    if (!this._storageCache) {\n      this._storageCache = JSON.parse(this._storage.getItem(this._storageKey) || '{}') || {};\n    }\n\n    return this._storageCache[key];\n  }\n\n  setPersistedProperty(key, value) {\n    if (!this._storageCache) {\n      this._storageCache = JSON.parse(this._storage.getItem(this._storageKey) || '{}') || {};\n    }\n\n    if (value === null) {\n      delete this._storageCache[key];\n    } else {\n      this._storageCache[key] = value;\n    }\n\n    this._storage.setItem(this._storageKey, JSON.stringify(this._storageCache));\n  }\n\n  fetch(url, options) {\n    return window.fetch(url, options);\n  }\n\n  getLibraryId() {\n    return 'posthog-js-lite';\n  }\n\n  getLibraryVersion() {\n    return version;\n  }\n\n  getCustomUserAgent() {\n    return;\n  }\n\n  getCommonEventProperties() {\n    return { ...super.getCommonEventProperties(),\n      ...getContext(window)\n    };\n  }\n\n}\n\nexport { PostHog, PostHog as default };\n//# sourceMappingURL=index.esm.js.map\n"],"names":[],"sourceRoot":""}