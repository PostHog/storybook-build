{"version":3,"file":"71439.0dd64d1b.iframe.bundle.js","mappings":";AAyLA","sources":["webpack://posthog/./frontend/src/scenes/actions/actionEditLogic.tsx"],"sourcesContent":["import { actions, afterMount, connect, kea, key, listeners, path, props, reducers } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { beforeUnload, router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'\nimport { Link } from 'lib/lemon-ui/Link'\nimport { uuid } from 'lib/utils'\nimport { deleteWithUndo } from 'lib/utils/deleteWithUndo'\nimport { eventDefinitionsTableLogic } from 'scenes/data-management/events/eventDefinitionsTableLogic'\nimport { sceneLogic } from 'scenes/sceneLogic'\nimport { Scene } from 'scenes/sceneTypes'\nimport { urls } from 'scenes/urls'\n\nimport { actionsModel } from '~/models/actionsModel'\nimport { tagsModel } from '~/models/tagsModel'\nimport { ActionStepType, ActionType } from '~/types'\n\nimport type { actionEditLogicType } from './actionEditLogicType'\nimport { actionLogic } from './actionLogic'\n\nexport type NewActionType = Partial<ActionType> &\n    Pick<ActionType, 'name' | 'post_to_slack' | 'slack_message_format' | 'steps'>\nexport type ActionEditType = ActionType | NewActionType\n\nexport interface SetActionProps {\n    merge?: boolean\n}\n\nexport interface ActionEditLogicProps {\n    id?: number\n    action: ActionEditType\n}\n\nexport const actionEditLogic = kea<actionEditLogicType>([\n    path(['scenes', 'actions', 'actionEditLogic']),\n    props({} as ActionEditLogicProps),\n    key((props) => props.id || 'new'),\n    connect({ actions: [tagsModel, ['loadTags']], values: [sceneLogic, ['activeScene']] }),\n    actions({\n        setAction: (action: Partial<ActionEditType>, options: SetActionProps = { merge: true }) => ({\n            action,\n            options,\n        }),\n        setCreateNew: (createNew: boolean) => ({ createNew }),\n        actionAlreadyExists: (actionId: number | null) => ({ actionId }),\n        deleteAction: true,\n    }),\n\n    connect({\n        actions: [actionsModel, ['loadActions'], eventDefinitionsTableLogic, ['loadEventDefinitions']],\n    }),\n\n    reducers({\n        createNew: [\n            false,\n            {\n                setCreateNew: (_, { createNew }) => createNew,\n            },\n        ],\n        wasDeleted: [\n            false,\n            {\n                deleteAction: () => true,\n            },\n        ],\n    }),\n\n    forms(({ actions, props }) => ({\n        action: {\n            defaults: { ...props.action } as ActionEditType,\n            submit: (action) => {\n                actions.saveAction(action)\n            },\n        },\n    })),\n\n    loaders(({ props, values, actions }) => ({\n        actionCount: {\n            loadActionCount: async () => {\n                return props.id ? await api.actions.getCount(props.id) : 0\n            },\n        },\n        action: [\n            { ...props.action } as ActionEditType,\n            {\n                setAction: ({ action, options: { merge } }) =>\n                    (merge ? { ...values.action, ...action } : action) as ActionEditType,\n                saveAction: async (updatedAction: ActionEditType, breakpoint) => {\n                    let action: ActionType\n\n                    try {\n                        if (updatedAction.id) {\n                            action = await api.actions.update(updatedAction.id, updatedAction)\n                        } else {\n                            action = await api.actions.create(updatedAction)\n                        }\n                        breakpoint()\n                    } catch (response: any) {\n                        if (response.code === 'unique') {\n                            // Below works because `detail` in the format:\n                            // `This project already has an action with this name, ID ${errorActionId}`\n                            const dupeId = response.detail.split(' ').pop()\n\n                            lemonToast.error(\n                                <>\n                                    Action with this name already exists.{' '}\n                                    <Link to={urls.action(dupeId)}>Click here to edit.</Link>\n                                </>\n                            )\n\n                            return { ...updatedAction }\n                        }\n                        throw response\n                    }\n\n                    lemonToast.success(`Action saved`)\n                    if (!props.id) {\n                        router.actions.push(urls.action(action.id))\n                    }\n                    actionLogic.actions.loadActionSuccess(action)\n                    // reload actions so they are immediately available throughout the app\n                    actions.loadEventDefinitions()\n                    actions.loadActions()\n                    actions.loadActionCount()\n                    actions.loadTags() // reload tags in case new tags are being saved\n                    return action\n                },\n            },\n        ],\n    })),\n\n    listeners(({ values, actions }) => ({\n        deleteAction: async () => {\n            await deleteWithUndo({\n                endpoint: api.actions.determineDeleteEndpoint(),\n                object: values.action,\n                callback: () => {\n                    router.actions.push(urls.actions())\n                    actions.loadActions()\n                },\n            })\n        },\n    })),\n\n    afterMount(({ actions, props }) => {\n        if (props.id) {\n            actions.loadActionCount()\n        } else {\n            actions.setAction({ name: '', steps: [{ isNew: uuid() }] }, { merge: false })\n        }\n    }),\n\n    urlToAction(({ actions }) => ({\n        [urls.createAction()]: (_, searchParams) => {\n            try {\n                if (searchParams.copy) {\n                    const {\n                        id: _id,\n                        created_at: _created_at,\n                        created_by: _created_by,\n                        last_calculated_at: _last_calculated_at,\n                        ...actionToCopy\n                    } = searchParams.copy\n\n                    actions.setAction(\n                        {\n                            ...actionToCopy,\n                            steps: actionToCopy.steps.map((s: ActionStepType) => {\n                                const { id: _id, ...step } = s\n                                return { ...step, isNew: uuid() }\n                            }),\n                            name: `${actionToCopy.name} (copy)`,\n                        },\n                        { merge: false }\n                    )\n                }\n            } catch (e) {\n                throw new Error('Could not parse action to copy from URL')\n            }\n        },\n    })),\n\n    beforeUnload(({ values }) => ({\n        enabled: () => values.activeScene !== Scene.Action && values.actionChanged && !values.wasDeleted,\n        message: `Leave action?\\nChanges you made will be discarded.`,\n    })),\n])\n"],"names":[],"sourceRoot":""}