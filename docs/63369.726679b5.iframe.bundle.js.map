{"version":3,"file":"63369.726679b5.iframe.bundle.js","mappings":";AA4SA","sources":["webpack://@posthog/storybook/../../frontend/src/scenes/pipeline/hogfunctions/hogFunctionTestLogic.tsx"],"sourcesContent":["import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, afterMount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport api from 'lib/api'\nimport { tryJsonParse } from 'lib/utils'\nimport { getCurrentTeamId } from 'lib/utils/getAppContext'\nimport { editor } from 'monaco-editor'\n\nimport { groupsModel } from '~/models/groupsModel'\nimport { HogFunctionInvocationGlobals, HogFunctionTestInvocationResult } from '~/types'\n\nimport {\n    hogFunctionConfigurationLogic,\n    HogFunctionConfigurationLogicProps,\n    sanitizeConfiguration,\n} from './hogFunctionConfigurationLogic'\nimport type { hogFunctionTestLogicType } from './hogFunctionTestLogicType'\n\nexport type HogFunctionTestInvocationForm = {\n    globals: string // HogFunctionInvocationGlobals\n    mock_async_functions: boolean\n}\n\nexport type HogTransformationEvent = {\n    event: any\n    uuid: string\n    distinct_id: string\n    timestamp: string\n    properties: any\n}\n\nconst convertToTransformationEvent = (result: any): HogTransformationEvent => {\n    const properties = result.properties ?? {}\n    properties.$ip = properties.$ip ?? '89.160.20.129'\n    // We don't want to use these values given they will change in the test invocation\n    delete properties.$transformations_failed\n    delete properties.$transformations_succeeded\n    delete properties.$transformations_skipped\n    return {\n        event: result.event,\n        uuid: result.uuid,\n        distinct_id: result.distinct_id,\n        timestamp: result.timestamp,\n        properties,\n    }\n}\n\nconst convertFromTransformationEvent = (result: HogTransformationEvent): Record<string, any> => {\n    delete result.properties.$transformations_failed\n    delete result.properties.$transformations_succeeded\n    delete result.properties.$transformations_skipped\n    return {\n        event: result.event,\n        uuid: result.uuid,\n        distinct_id: result.distinct_id,\n        timestamp: result.timestamp,\n        properties: result.properties,\n    }\n}\n\nexport interface CodeEditorValidation {\n    value: string\n    editor: editor.IStandaloneCodeEditor\n    decorations: string[]\n}\n\nexport const hogFunctionTestLogic = kea<hogFunctionTestLogicType>([\n    props({} as HogFunctionConfigurationLogicProps),\n    key(({ id, templateId }: HogFunctionConfigurationLogicProps) => {\n        return id ?? templateId ?? 'new'\n    }),\n\n    path((id) => ['scenes', 'pipeline', 'hogfunctions', 'hogFunctionTestLogic', id]),\n    connect((props: HogFunctionConfigurationLogicProps) => ({\n        values: [\n            hogFunctionConfigurationLogic(props),\n            [\n                'configuration',\n                'templateId',\n                'configurationHasErrors',\n                'sampleGlobals',\n                'sampleGlobalsLoading',\n                'exampleInvocationGlobals',\n                'sampleGlobalsError',\n                'type',\n            ],\n            groupsModel,\n            ['groupTypes'],\n        ],\n        actions: [\n            hogFunctionConfigurationLogic(props),\n            ['touchConfigurationField', 'loadSampleGlobalsSuccess', 'loadSampleGlobals', 'setSampleGlobals'],\n        ],\n    })),\n    actions({\n        setTestResult: (result: HogFunctionTestInvocationResult | null) => ({ result }),\n        toggleExpanded: (expanded?: boolean) => ({ expanded }),\n        saveGlobals: (name: string, globals: HogFunctionInvocationGlobals) => ({ name, globals }),\n        deleteSavedGlobals: (index: number) => ({ index }),\n        setTestResultMode: (mode: 'raw' | 'diff') => ({ mode }),\n        receiveExampleGlobals: (globals: HogFunctionInvocationGlobals | null) => ({ globals }),\n        setJsonError: (error: string | null) => ({ error }),\n        validateJson: (value: string, editor: editor.IStandaloneCodeEditor, decorations: string[]) =>\n            ({ value, editor, decorations } as CodeEditorValidation),\n        setDecorationIds: (decorationIds: string[]) => ({ decorationIds }),\n        cancelSampleGlobalsLoading: true,\n    }),\n    reducers({\n        expanded: [\n            false as boolean,\n            {\n                toggleExpanded: (state, { expanded }) => (expanded === undefined ? !state : expanded),\n            },\n        ],\n\n        testResult: [\n            null as HogFunctionTestInvocationResult | null,\n            {\n                setTestResult: (_, { result }) => result,\n            },\n        ],\n\n        testResultMode: [\n            'diff' as 'raw' | 'diff',\n            {\n                setTestResultMode: (_, { mode }) => mode,\n            },\n        ],\n\n        savedGlobals: [\n            [] as { name: string; globals: HogFunctionInvocationGlobals }[],\n            { persist: true, prefix: `${getCurrentTeamId()}__` },\n            {\n                saveGlobals: (state, { name, globals }) => [...state, { name, globals }],\n                deleteSavedGlobals: (state, { index }) => state.filter((_, i) => i !== index),\n            },\n        ],\n\n        jsonError: [\n            null as string | null,\n            {\n                setJsonError: (_, { error }) => error,\n            },\n        ],\n\n        currentDecorationIds: [\n            [] as string[],\n            {\n                setDecorationIds: (_, { decorationIds }) => decorationIds,\n                setJsonError: () => [], // Clear decorations when error state changes\n            },\n        ],\n\n        fetchCancelled: [\n            false as boolean,\n            {\n                loadSampleGlobals: () => false,\n                cancelSampleGlobalsLoading: () => true,\n                toggleExpanded: () => false,\n            },\n        ],\n    }),\n    listeners(({ values, actions }) => ({\n        loadSampleGlobalsSuccess: () => {\n            if (values.expanded && !values.fetchCancelled && values.sampleGlobals) {\n                actions.receiveExampleGlobals(values.sampleGlobals)\n            }\n        },\n        setSampleGlobals: ({ sampleGlobals }) => {\n            actions.receiveExampleGlobals(sampleGlobals)\n        },\n\n        receiveExampleGlobals: ({ globals }) => {\n            if (!globals) {\n                return\n            }\n\n            if (values.type === 'transformation') {\n                const event = convertToTransformationEvent(globals.event)\n                // Strip down to just the real values\n                actions.setTestInvocationValue('globals', JSON.stringify(event, null, 2))\n            } else {\n                actions.setTestInvocationValue('globals', JSON.stringify(globals, null, 2))\n            }\n        },\n\n        validateJson: ({ value, editor, decorations }: CodeEditorValidation) => {\n            if (!editor?.getModel()) {\n                return\n            }\n\n            const model = editor.getModel()!\n\n            try {\n                // Try parsing the JSON\n                JSON.parse(value)\n                // If valid, ensure everything is cleared\n                actions.setJsonError(null)\n                editor.removeDecorations(decorations)\n            } catch (err: any) {\n                actions.setJsonError(err.message)\n\n                const match = err.message.match(/position (\\d+)/)\n                if (!match) {\n                    return\n                }\n\n                const position = parseInt(match[1], 10)\n                const pos = model.getPositionAt(position)\n\n                // Set single error marker\n                editor.createDecorationsCollection([\n                    {\n                        range: {\n                            startLineNumber: pos.lineNumber,\n                            startColumn: pos.column,\n                            endLineNumber: pos.lineNumber,\n                            endColumn: pos.column + 1,\n                        },\n                        options: {\n                            isWholeLine: true,\n                            className: 'bg-danger-highlight',\n                            glyphMarginClassName: 'text-danger flex items-center justify-center',\n                            glyphMarginHoverMessage: { value: err.message },\n                        },\n                    },\n                ])\n                // Scroll to error\n                editor.revealLineInCenter(pos.lineNumber)\n            }\n        },\n\n        setTestResult: ({ result }) => {\n            if (result) {\n                setTimeout(() => {\n                    // First try to scroll the test results container into view\n                    const testResults = document.querySelector('[data-attr=\"test-results\"]')\n                    if (testResults) {\n                        testResults.scrollIntoView({ behavior: 'smooth', block: 'start' })\n                    }\n\n                    // Find the Monaco editor and scroll to the first difference\n                    const editors = document.querySelectorAll('[data-attr=\"test-results\"] .monaco-editor')\n                    if (editors.length > 0 && values.sortedTestsResult?.hasDiff) {\n                        const lastEditor = editors[editors.length - 1]\n                        const monacoEditor = lastEditor.querySelector('.monaco-scrollable-element')\n                        if (monacoEditor) {\n                            const inputLines = values.sortedTestsResult.input.split('\\n')\n                            const outputLines = values.sortedTestsResult.output.split('\\n')\n\n                            // Find the first line that differs\n                            let diffLineIndex = 0\n                            for (let i = 0; i < Math.max(inputLines.length, outputLines.length); i++) {\n                                if (inputLines[i] !== outputLines[i]) {\n                                    diffLineIndex = i\n                                    break\n                                }\n                            }\n\n                            // Calculate approximate scroll position for the diff, showing 2 lines of context above\n                            const lineHeight = 19 // Default Monaco line height\n                            monacoEditor.scrollTop = Math.max(0, (diffLineIndex - 2) * lineHeight)\n                        }\n                    }\n                }, 100)\n            }\n        },\n\n        cancelSampleGlobalsLoading: () => {\n            // Just mark as cancelled - we'll ignore any results that come back\n        },\n    })),\n\n    forms(({ props, actions, values }) => ({\n        testInvocation: {\n            defaults: {\n                mock_async_functions: false,\n            } as HogFunctionTestInvocationForm,\n            alwaysShowErrors: true,\n            errors: ({ globals }) => {\n                return {\n                    globals: !globals ? 'Required' : tryJsonParse(globals) ? undefined : 'Invalid JSON',\n                }\n            },\n            submit: async (data) => {\n                // Submit the test invocation\n                // Set the response somewhere\n\n                if (values.configurationHasErrors) {\n                    // Get the configuration logic instance\n                    const configLogic = hogFunctionConfigurationLogic(props)\n                    const inputErrors = configLogic.values.inputFormErrors?.inputs || {}\n\n                    // Create a simple list of errors\n                    const errorMessages = Object.entries(inputErrors).map(([key, error]) => {\n                        const errorText = typeof error === 'string' ? error : 'Invalid format'\n                        return `${key}: ${errorText}`\n                    })\n\n                    // Show the error message\n                    const message =\n                        errorMessages.length > 0\n                            ? `Please fix the following errors:\\n${errorMessages.join('\\n')}`\n                            : 'Please fix the configuration errors before testing.'\n\n                    lemonToast.error(message, {\n                        toastId: 'hogfunction-validation-error',\n                    })\n\n                    // Show the errors in the UI\n                    configLogic.actions.touchConfigurationField && configLogic.actions.touchConfigurationField('inputs')\n                    return\n                }\n\n                const parsedData = tryJsonParse(data.globals)\n                const configuration = sanitizeConfiguration(values.configuration) as Record<string, any>\n                configuration.template_id = values.templateId\n\n                // Transformations have a simpler UI just showing the event so we need to map it back to the event\n                const globals =\n                    values.type === 'transformation'\n                        ? {\n                              event: parsedData,\n                          }\n                        : parsedData\n\n                try {\n                    const res = await api.hogFunctions.createTestInvocation(props.id ?? 'new', {\n                        globals,\n                        mock_async_functions: data.mock_async_functions,\n                        configuration,\n                    })\n\n                    // Modify the result to match better our globals format\n                    if (values.type === 'transformation' && res.result) {\n                        res.result = convertFromTransformationEvent(res.result)\n                    }\n\n                    actions.setTestResult(res)\n                } catch (e) {\n                    lemonToast.error(`An unexpected server error occurred while testing the function. ${e}`)\n                }\n            },\n        },\n    })),\n\n    selectors(() => ({\n        sortedTestsResult: [\n            (s) => [s.configuration, s.testResult, s.testInvocation],\n            (\n                configuration,\n                testResult,\n                testInvocation\n            ): {\n                input: string\n                output: string\n                hasDiff: boolean\n            } | null => {\n                if (!testResult || configuration.type !== 'transformation') {\n                    return null\n                }\n\n                const input = JSON.stringify(JSON.parse(testInvocation.globals), null, 2)\n                const output = JSON.stringify(testResult.result, null, 2)\n\n                return {\n                    input,\n                    output,\n                    hasDiff: input !== output,\n                }\n            },\n        ],\n    })),\n\n    afterMount(({ actions, values }) => {\n        actions.receiveExampleGlobals(values.exampleInvocationGlobals)\n    }),\n])\n"],"names":[],"sourceRoot":""}