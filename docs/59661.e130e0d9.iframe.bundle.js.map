{"version":3,"file":"59661.e130e0d9.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAqBA;AACA","sources":["webpack://@posthog/storybook/../../frontend/src/scenes/pipeline/hogfunctions/logs/hogFunctionLogsLogic.ts"],"sourcesContent":["import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, connect, kea, key, listeners, path, props, reducers } from 'kea'\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { delay } from 'lib/utils'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\nimport { HogFunctionInvocationGlobals, LogEntryLevel } from '~/types'\n\nimport type { hogFunctionLogsLogicType } from './hogFunctionLogsLogicType'\nimport { GroupedLogEntry, logsViewerLogic, LogsViewerLogicProps } from './logsViewerLogic'\n\nexport type RetryInvocationState = 'pending' | 'success' | 'failure'\n\nconst loadEventGlobals = async (eventId: string): Promise<Pick<HogFunctionInvocationGlobals, 'event' | 'person'>> => {\n    const query: HogQLQuery = {\n        kind: NodeKind.HogQLQuery,\n        query: hogql`\n            select uuid, distinct_id, event, timestamp, properties, person.id, person.properties \n            from events\n            where uuid = ${eventId}\n            limit 1`,\n    }\n\n    const response = await api.query(query, undefined, undefined, true)\n    const [uuid, distinct_id, event, timestamp, properties, person_id, person_properties] = response.results[0]\n\n    return {\n        event: {\n            uuid,\n            distinct_id,\n            event,\n            properties: JSON.parse(properties),\n            timestamp,\n            url: '',\n            elements_chain: '',\n        },\n        person: {\n            id: person_id,\n            properties: JSON.parse(person_properties),\n            url: '',\n            name: '',\n        },\n    }\n}\n\nexport const hogFunctionLogsLogic = kea<hogFunctionLogsLogicType>([\n    path((key) => ['scenes', 'pipeline', 'hogfunctions', 'logs', 'hogFunctionLogsLogic', key]),\n    props({} as LogsViewerLogicProps), // TODO: Remove `stage` from props, it isn't needed here for anything\n    key(({ sourceType, sourceId }) => `${sourceType}:${sourceId}`),\n    connect((props: LogsViewerLogicProps) => ({\n        values: [logsViewerLogic(props), ['logs']],\n        actions: [logsViewerLogic(props), ['addLogGroups', 'setRowExpanded']],\n    })),\n    actions({\n        retryInvocation: (groupedLogEntry: GroupedLogEntry, eventId: string) => ({ groupedLogEntry, eventId }),\n        retryInvocationSuccess: (groupedLogEntry: GroupedLogEntry) => ({ groupedLogEntry }),\n        retryInvocationFailure: (groupedLogEntry: GroupedLogEntry) => ({ groupedLogEntry }),\n    }),\n    reducers({\n        retries: [\n            {} as Record<string, RetryInvocationState>,\n            {\n                retryInvocation: (state, { groupedLogEntry }) => {\n                    return {\n                        ...state,\n                        [groupedLogEntry.instanceId]: 'pending',\n                    }\n                },\n\n                retryInvocationSuccess: (state, { groupedLogEntry }) => {\n                    return {\n                        ...state,\n                        [groupedLogEntry.instanceId]: 'success',\n                    }\n                },\n\n                retryInvocationFailure: (state, { groupedLogEntry }) => {\n                    return {\n                        ...state,\n                        [groupedLogEntry.instanceId]: 'failure',\n                    }\n                },\n            },\n        ],\n    }),\n    listeners(({ actions, props, values }) => ({\n        retryInvocation: async ({ groupedLogEntry, eventId }, breakpoint) => {\n            await breakpoint(100)\n\n            actions.setRowExpanded(groupedLogEntry.instanceId, true)\n            await delay(1000)\n\n            try {\n                const globals = await loadEventGlobals(eventId)\n\n                const res = await api.hogFunctions.createTestInvocation(props.sourceId, {\n                    globals,\n                    mock_async_functions: false,\n                    configuration: {},\n                })\n\n                const existingLogGroup = values.logs.find((x) => x.instanceId === groupedLogEntry.instanceId)\n\n                if (!existingLogGroup) {\n                    throw new Error('No log group found')\n                }\n\n                const newLogGroup: GroupedLogEntry = {\n                    ...existingLogGroup,\n                    entries: [\n                        ...existingLogGroup.entries,\n                        ...res.logs.map((x) => ({\n                            timestamp: dayjs(x.timestamp),\n                            level: x.level.toUpperCase() as LogEntryLevel,\n                            message: x.message,\n                        })),\n                    ],\n                }\n\n                actions.addLogGroups([newLogGroup])\n\n                lemonToast.success('Retry invocation success')\n                await breakpoint(10)\n                actions.retryInvocationSuccess(groupedLogEntry)\n            } catch (e) {\n                lemonToast.error('Retry invocation failed')\n                await breakpoint(10)\n                actions.retryInvocationFailure(groupedLogEntry)\n            }\n        },\n    })),\n])\n"],"names":[],"sourceRoot":""}