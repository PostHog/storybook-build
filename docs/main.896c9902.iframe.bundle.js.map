{"version":3,"file":"main.896c9902.iframe.bundle.js","mappings":";;;;;;;;AA6JA;;;AClHA;;;;;AAKA;AACA;AAIA;;;;;ACoIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AAGA","sources":["webpack://posthog/./frontend/src/lib/components/AuthorizedUrlList/authorizedUrlListLogic.ts","webpack://posthog/./frontend/src/scenes/session-recordings/playlist/sessionRecordingsListPropertiesLogic.ts","webpack://posthog/./frontend/src/scenes/surveys/surveyLogic.tsx"],"sourcesContent":["import Fuse from 'fuse.js'\nimport {\n    actions,\n    afterMount,\n    connect,\n    kea,\n    key,\n    listeners,\n    path,\n    props,\n    reducers,\n    selectors,\n    sharedListeners,\n} from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { encodeParams, urlToAction } from 'kea-router'\nimport { subscriptions } from 'kea-subscriptions'\nimport api from 'lib/api'\nimport { isDomain, isURL } from 'lib/utils'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\nimport { ToolbarParams } from '~/types'\n\nimport type { authorizedUrlListLogicType } from './authorizedUrlListLogicType'\n\nexport interface ProposeNewUrlFormType {\n    url: string\n}\n\nexport enum AuthorizedUrlListType {\n    TOOLBAR_URLS = 'TOOLBAR_URLS',\n    RECORDING_DOMAINS = 'RECORDING_DOMAINS',\n}\n\nexport const validateProposedUrl = (\n    proposedUrl: string,\n    currentUrls: string[],\n    onlyAllowDomains: boolean = false\n): string | undefined => {\n    if (!onlyAllowDomains && !isURL(proposedUrl)) {\n        return 'Please enter a valid URL'\n    }\n\n    if (onlyAllowDomains && !isDomain(proposedUrl)) {\n        return \"Please enter a valid domain (URLs with a path aren't allowed)\"\n    }\n\n    if (proposedUrl.indexOf('*') > -1 && !proposedUrl.match(/^(.*)\\*[^*]*\\.[^*]+\\.[^*]+$/)) {\n        return 'Wildcards can only be used for subdomains'\n    }\n\n    if (currentUrls.indexOf(proposedUrl) > -1) {\n        return `This ${onlyAllowDomains ? 'domains' : 'URL'} already is registered`\n    }\n\n    return\n}\n\n/** defaultIntent: whether to launch with empty intent (i.e. toolbar mode is default) */\nexport function appEditorUrl(appUrl: string, actionId?: number | null, defaultIntent?: boolean): string {\n    // See https://github.com/PostHog/posthog-js/blob/f7119c/src/extensions/toolbar.ts#L52 for where these params\n    // are passed. `appUrl` is an extra `redirect_to_site` param.\n    const params: ToolbarParams & { appUrl: string } = {\n        userIntent: defaultIntent ? undefined : actionId ? 'edit-action' : 'add-action',\n        // Make sure to pass the app url, otherwise the api_host will be used by\n        // the toolbar, which isn't correct when used behind a reverse proxy as\n        // we require e.g. SSO login to the app, which will not work when placed\n        // behind a proxy unless we register each domain with the OAuth2 client.\n        apiURL: window.location.origin,\n        appUrl,\n        ...(actionId ? { actionId } : {}),\n    }\n    return '/api/user/redirect_to_site/' + encodeParams(params, '?')\n}\n\nexport const filterNotAuthorizedUrls = (urls: string[], authorizedUrls: string[]): string[] => {\n    const suggestedDomains: string[] = []\n\n    urls.forEach((url) => {\n        try {\n            const parsedUrl = new URL(url)\n            const urlWithoutPath = parsedUrl.protocol + '//' + parsedUrl.host\n            // Have we already added this domain?\n            if (suggestedDomains.indexOf(urlWithoutPath) > -1) {\n                return\n            }\n            // Is this domain already in the list of urls?\n            const exactMatch = authorizedUrls.filter((url) => url.indexOf(urlWithoutPath) > -1).length > 0\n            const wildcardMatch = !!authorizedUrls.find((url) => {\n                // Matches something like `https://*.example.com` against the urlWithoutPath\n                const regex = new RegExp(url.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'))\n                return urlWithoutPath.match(regex)\n            })\n\n            if (!exactMatch && !wildcardMatch) {\n                suggestedDomains.push(urlWithoutPath)\n            }\n        } catch (error) {\n            return\n        }\n    })\n\n    return suggestedDomains\n}\n\nexport const NEW_URL = 'https://'\n\nexport interface KeyedAppUrl {\n    url: string\n    type: 'authorized' | 'suggestion'\n    originalIndex: number\n}\n\nexport interface AuthorizedUrlListLogicProps {\n    actionId: number | null\n    type: AuthorizedUrlListType\n}\nexport const authorizedUrlListLogic = kea<authorizedUrlListLogicType>([\n    path((key) => ['lib', 'components', 'AuthorizedUrlList', 'authorizedUrlListLogic', key]),\n    key((props) => `${props.type}-${props.actionId}`),\n    props({} as AuthorizedUrlListLogicProps),\n    connect({\n        values: [teamLogic, ['currentTeam', 'currentTeamId']],\n        actions: [teamLogic, ['updateCurrentTeam']],\n    }),\n    actions(() => ({\n        setAuthorizedUrls: (authorizedUrls: string[]) => ({ authorizedUrls }),\n        addUrl: (url: string, launch?: boolean) => ({ url, launch }),\n        newUrl: true,\n        removeUrl: (index: number) => ({ index }),\n        updateUrl: (index: number, url: string) => ({ index, url }),\n        launchAtUrl: (url: string) => ({ url }),\n        setSearchTerm: (term: string) => ({ term }),\n        setEditUrlIndex: (originalIndex: number | null) => ({ originalIndex }),\n        cancelProposingUrl: true,\n    })),\n    loaders(({ values }) => ({\n        suggestions: {\n            __default: [] as string[],\n            loadSuggestions: async () => {\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: hogql`select properties.$current_url, count()\n                        from events\n                           where event = '$pageview'\n                           and timestamp >= now() - interval 3 day \n                            and timestamp <= now()\n                         group by properties.$current_url\n                         order by count() desc\n                        limit 25`,\n                }\n\n                const response = await api.query(query)\n                const result = response.results as [string, number][]\n\n                if (result && result.length === 0) {\n                    return []\n                }\n\n                const suggestedDomains = filterNotAuthorizedUrls(\n                    result.map(([url]) => url),\n                    values.authorizedUrls\n                )\n\n                return suggestedDomains.slice(0, 20)\n            },\n        },\n    })),\n    subscriptions(({ props, actions }) => ({\n        currentTeam: (currentTeam) => {\n            actions.setAuthorizedUrls(\n                (props.type === AuthorizedUrlListType.RECORDING_DOMAINS\n                    ? currentTeam.recording_domains\n                    : currentTeam.app_urls) || []\n            )\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadSuggestions()\n    }),\n    forms(({ values, actions }) => ({\n        proposedUrl: {\n            defaults: { url: '' } as ProposeNewUrlFormType,\n            errors: ({ url }) => ({\n                url: validateProposedUrl(url, values.authorizedUrls, values.onlyAllowDomains),\n            }),\n            submit: async ({ url }) => {\n                if (values.editUrlIndex !== null && values.editUrlIndex >= 0) {\n                    actions.updateUrl(values.editUrlIndex, url)\n                } else {\n                    actions.addUrl(url)\n                }\n            },\n        },\n    })),\n    reducers(() => ({\n        showProposedURLForm: [\n            false as boolean,\n            {\n                newUrl: () => true,\n                submitProposedUrlSuccess: () => false,\n                cancelProposingUrl: () => false,\n            },\n        ],\n        authorizedUrls: [\n            [] as string[],\n            {\n                setAuthorizedUrls: (_, { authorizedUrls }) => authorizedUrls,\n                addUrl: (state, { url }) => state.concat([url]),\n                updateUrl: (state, { index, url }) => Object.assign([...state], { [index]: url }),\n                removeUrl: (state, { index }) => {\n                    const newUrls = [...state]\n                    newUrls.splice(index, 1)\n                    return newUrls\n                },\n            },\n        ],\n        suggestions: [\n            [],\n            {\n                addUrl: (state, { url }) => [...state].filter((item) => url !== item),\n            },\n        ],\n        searchTerm: [\n            '',\n            {\n                setSearchTerm: (_, { term }) => term,\n            },\n        ],\n        editUrlIndex: [\n            null as number | null,\n            {\n                setEditUrlIndex: (_, { originalIndex }) => originalIndex,\n                removeUrl: (editUrlIndex, { index }) =>\n                    editUrlIndex && index < editUrlIndex\n                        ? editUrlIndex - 1\n                        : index === editUrlIndex\n                        ? null\n                        : editUrlIndex,\n                newUrl: () => -1,\n                updateUrl: () => null,\n                addUrl: () => null,\n                cancelProposingUrl: () => null,\n            },\n        ],\n    })),\n    sharedListeners(({ values, props }) => ({\n        saveUrls: async () => {\n            if (props.type === AuthorizedUrlListType.RECORDING_DOMAINS) {\n                await teamLogic.asyncActions.updateCurrentTeam({ recording_domains: values.authorizedUrls })\n            } else {\n                await teamLogic.asyncActions.updateCurrentTeam({ app_urls: values.authorizedUrls })\n            }\n        },\n    })),\n    listeners(({ sharedListeners, values, actions }) => ({\n        setEditUrlIndex: () => {\n            actions.setProposedUrlValue('url', values.urlToEdit)\n        },\n        newUrl: () => {\n            actions.setProposedUrlValue('url', NEW_URL)\n        },\n        addUrl: [\n            sharedListeners.saveUrls,\n            ({ url, launch }) => {\n                if (launch) {\n                    actions.launchAtUrl(url)\n                }\n            },\n        ],\n        removeUrl: sharedListeners.saveUrls,\n        updateUrl: sharedListeners.saveUrls,\n        launchAtUrl: ({ url }) => {\n            window.location.href = values.launchUrl(url)\n        },\n        cancelProposingUrl: () => {\n            actions.resetProposedUrl()\n        },\n        submitProposedUrlSuccess: () => {\n            actions.setEditUrlIndex(null)\n            actions.resetProposedUrl()\n        },\n    })),\n    selectors({\n        urlToEdit: [\n            (s) => [s.authorizedUrls, s.editUrlIndex],\n            (authorizedUrls, editUrlIndex) => {\n                if (editUrlIndex === null || editUrlIndex === -1) {\n                    return NEW_URL\n                }\n                return authorizedUrls[editUrlIndex]\n            },\n        ],\n        urlsKeyed: [\n            (s) => [s.authorizedUrls, s.suggestions, s.searchTerm],\n            (authorizedUrls, suggestions, searchTerm): KeyedAppUrl[] => {\n                const keyedUrls = authorizedUrls\n                    .map((url, index) => ({\n                        url,\n                        type: 'authorized',\n                        originalIndex: index,\n                    }))\n                    .concat(\n                        suggestions.map((url, index) => ({\n                            url,\n                            type: 'suggestion',\n                            originalIndex: index,\n                        }))\n                    ) as KeyedAppUrl[]\n\n                if (!searchTerm) {\n                    return keyedUrls\n                }\n\n                return new Fuse(keyedUrls, {\n                    keys: ['url'],\n                    threshold: 0.3,\n                })\n                    .search(searchTerm)\n                    .map((result) => result.item)\n            },\n        ],\n        launchUrl: [(_, p) => [p.actionId], (actionId) => (url: string) => appEditorUrl(url, actionId, !actionId)],\n        isAddUrlFormVisible: [(s) => [s.editUrlIndex], (editUrlIndex) => editUrlIndex === -1],\n        onlyAllowDomains: [(_, p) => [p.type], (type) => type === AuthorizedUrlListType.RECORDING_DOMAINS],\n    }),\n    urlToAction(({ actions }) => ({\n        [urls.toolbarLaunch()]: (_, searchParams) => {\n            if (searchParams.addNew) {\n                actions.newUrl()\n            }\n        },\n    })),\n])\n","import { actions, connect, kea, listeners, path, reducers } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\nimport { SessionRecordingPropertiesType, SessionRecordingType } from '~/types'\n\nimport type { sessionRecordingsListPropertiesLogicType } from './sessionRecordingsListPropertiesLogicType'\n\n// This logic is used to fetch properties for a list of recordings\n// It is used in a global way as the cached values can be re-used\nexport const sessionRecordingsListPropertiesLogic = kea<sessionRecordingsListPropertiesLogicType>([\n    path(() => ['scenes', 'session-recordings', 'playlist', 'sessionRecordingsListPropertiesLogic']),\n    connect(() => ({\n        actions: [eventUsageLogic, ['reportRecordingsListPropertiesFetched']],\n    })),\n\n    actions({\n        loadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n        maybeLoadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n    }),\n\n    loaders(({ actions }) => ({\n        recordingProperties: [\n            [] as SessionRecordingPropertiesType[],\n            {\n                loadPropertiesForSessions: async ({ sessions }, breakpoint) => {\n                    await breakpoint(100)\n\n                    const startTime = performance.now()\n                    const sessionIds = sessions.map((x) => x.id)\n\n                    const oldestTimestamp = sessions.map((x) => x.start_time).sort()[0]\n                    const newestTimestamp = sessions.map((x) => x.end_time).sort()[sessions.length - 1]\n\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$session_id as session_id, any(properties) as properties\n                                FROM events\n                                WHERE event IN ['$pageview', '$autocapture']\n                                AND session_id IN ${sessionIds}\n                                -- the timestamp range here is only to avoid querying too much of the events table\n                                -- we don't really care about the absolute value, \n                                -- but we do care about whether timezones have an odd impact\n                                -- so, we extend the range by a day on each side so that timezones don't cause issues\n                                AND timestamp >= ${dayjs(oldestTimestamp).subtract(1, 'day')}\n                                AND timestamp <= ${dayjs(newestTimestamp).add(1, 'day')}\n                                GROUP BY session_id`,\n                    }\n\n                    const response = await api.query(query)\n                    const loadTimeMs = performance.now() - startTime\n\n                    actions.reportRecordingsListPropertiesFetched(loadTimeMs)\n\n                    breakpoint()\n                    return (response.results || []).map(\n                        (x: any): SessionRecordingPropertiesType => ({\n                            id: x[0],\n                            properties: JSON.parse(x[1] || '{}'),\n                        })\n                    )\n                },\n            },\n        ],\n    })),\n\n    listeners(({ actions, values }) => ({\n        maybeLoadPropertiesForSessions: ({ sessions }) => {\n            const newSessions = sessions.filter((session) => !values.recordingPropertiesById[session.id])\n\n            if (newSessions.length > 0) {\n                actions.loadPropertiesForSessions(newSessions)\n            }\n        },\n    })),\n\n    reducers({\n        recordingPropertiesById: [\n            {} as Record<string, SessionRecordingPropertiesType['properties']>,\n            {\n                loadPropertiesForSessionsSuccess: (\n                    state,\n                    { recordingProperties }\n                ): Record<string, SessionRecordingPropertiesType['properties']> => {\n                    const newState = { ...state }\n                    recordingProperties.forEach((properties) => {\n                        newState[properties.id] = properties.properties\n                    })\n\n                    return newState\n                },\n            },\n        ],\n    }),\n])\n","import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, afterMount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl, router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { featureFlagLogic as enabledFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { featureFlagLogic } from 'scenes/feature-flags/featureFlagLogic'\nimport { Scene } from 'scenes/sceneTypes'\nimport { urls } from 'scenes/urls'\n\nimport { DataTableNode, HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\nimport {\n    Breadcrumb,\n    PropertyFilterType,\n    PropertyOperator,\n    Survey,\n    SurveyQuestionBase,\n    SurveyQuestionType,\n    SurveyUrlMatchType,\n} from '~/types'\n\nimport { defaultSurveyFieldValues, NEW_SURVEY, NewSurvey } from './constants'\nimport type { surveyLogicType } from './surveyLogicType'\nimport { surveysLogic } from './surveysLogic'\nimport { sanitizeHTML } from './utils'\n\nexport enum SurveyEditSection {\n    Steps = 'steps',\n    Presentation = 'presentation',\n    Appearance = 'appearance',\n    Customization = 'customization',\n    Targeting = 'targeting',\n}\nexport interface SurveyLogicProps {\n    /** Either a UUID or 'new'. */\n    id: string\n}\n\nexport interface SurveyMetricsQueries {\n    surveysShown: DataTableNode\n    surveysDismissed: DataTableNode\n}\n\nexport interface SurveyUserStats {\n    seen: number\n    dismissed: number\n    sent: number\n}\n\nexport interface SurveyRatingResults {\n    [key: number]: {\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveySingleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveyMultipleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n    }\n}\n\nexport interface SurveyOpenTextResults {\n    [key: number]: {\n        events: { distinct_id: string; properties: Record<string, any>; personProperties: Record<string, any> }[]\n    }\n}\n\nexport interface QuestionResultsReady {\n    [key: string]: boolean\n}\n\nconst getResponseField = (i: number): string => (i === 0 ? '$survey_response' : `$survey_response_${i}`)\n\nexport const surveyLogic = kea<surveyLogicType>([\n    props({} as SurveyLogicProps),\n    key(({ id }) => id),\n    path((key) => ['scenes', 'surveys', 'surveyLogic', key]),\n    connect(() => ({\n        actions: [\n            surveysLogic,\n            ['loadSurveys'],\n            eventUsageLogic,\n            [\n                'reportSurveyCreated',\n                'reportSurveyLaunched',\n                'reportSurveyEdited',\n                'reportSurveyArchived',\n                'reportSurveyStopped',\n                'reportSurveyResumed',\n                'reportSurveyViewed',\n            ],\n        ],\n        values: [enabledFlagLogic, ['featureFlags as enabledFlags'], surveysLogic, ['surveys']],\n    })),\n    actions({\n        setSurveyMissing: true,\n        editingSurvey: (editing: boolean) => ({ editing }),\n        setDefaultForQuestionType: (\n            idx: number,\n            type: SurveyQuestionType,\n            isEditingQuestion: boolean,\n            isEditingDescription: boolean,\n            isEditingThankYouMessage: boolean\n        ) => ({\n            idx,\n            type,\n            isEditingQuestion,\n            isEditingDescription,\n            isEditingThankYouMessage,\n        }),\n        archiveSurvey: true,\n        setWritingHTMLDescription: (writingHTML: boolean) => ({ writingHTML }),\n        setSurveyTemplateValues: (template: any) => ({ template }),\n        setSelectedQuestion: (idx: number | null) => ({ idx }),\n        setSelectedSection: (section: SurveyEditSection | null) => ({ section }),\n        resetTargeting: true,\n    }),\n    loaders(({ props, actions, values }) => ({\n        survey: {\n            loadSurvey: async () => {\n                if (props.id && props.id !== 'new') {\n                    try {\n                        const survey = await api.surveys.get(props.id)\n                        actions.reportSurveyViewed(survey)\n                        return survey\n                    } catch (error: any) {\n                        if (error.status === 404) {\n                            actions.setSurveyMissing()\n                            return { ...NEW_SURVEY }\n                        }\n                        throw error\n                    }\n                }\n                if (props.id === 'new' && router.values.hashParams.fromTemplate) {\n                    return values.survey\n                } else {\n                    return { ...NEW_SURVEY }\n                }\n            },\n            createSurvey: async (surveyPayload: Partial<Survey>) => {\n                return await api.surveys.create(sanitizeQuestions(surveyPayload))\n            },\n            updateSurvey: async (surveyPayload: Partial<Survey>) => {\n                return await api.surveys.update(props.id, sanitizeQuestions(surveyPayload))\n            },\n            launchSurvey: async () => {\n                const startDate = dayjs()\n                return await api.surveys.update(props.id, { start_date: startDate.toISOString() })\n            },\n            stopSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: dayjs().toISOString() })\n            },\n            resumeSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: null })\n            },\n        },\n        surveyUserStats: {\n            loadSurveyUserStats: async (): Promise<SurveyUserStats> => {\n                const { survey } = values\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: hogql`\n                        SELECT\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey shown'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate}),\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey dismissed'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate}),\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey sent'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate})\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n                if (results && results[0]) {\n                    const [totalSeen, dismissed, sent] = results[0]\n                    const onlySeen = totalSeen - dismissed - sent\n                    return { seen: onlySeen < 0 ? 0 : onlySeen, dismissed, sent }\n                } else {\n                    return { seen: 0, dismissed: 0, sent: 0 }\n                }\n            },\n        },\n        surveyRatingResults: {\n            loadSurveyRatingResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyRatingResults> => {\n                const { survey } = values\n\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.Rating) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.Rating}`)\n                }\n\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT\n                            JSONExtractString(properties, '${getResponseField(questionIndex)}') AS survey_response,\n                            COUNT(survey_response)\n                        FROM events\n                        WHERE event = 'survey sent' \n                            AND properties.$survey_id = '${props.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                        GROUP BY survey_response\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                let total = 0\n                const dataSize = question.scale === 10 ? 11 : question.scale\n                const data = new Array(dataSize).fill(0)\n                results?.forEach(([value, count]) => {\n                    total += count\n\n                    const index = question.scale === 10 ? value : value - 1\n                    data[index] = count\n                })\n\n                return { ...values.surveyRatingResults, [questionIndex]: { total, data } }\n            },\n        },\n        surveySingleChoiceResults: {\n            loadSurveySingleChoiceResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveySingleChoiceResults> => {\n                const { survey } = values\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT\n                            JSONExtractString(properties, '${getResponseField(questionIndex)}') AS survey_response,\n                            COUNT(survey_response)\n                        FROM events\n                        WHERE event = 'survey sent' \n                            AND properties.$survey_id = '${props.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                        GROUP BY survey_response\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                const labels = results?.map((r) => r[0])\n                const data = results?.map((r) => r[1])\n                const total = data?.reduce((a, b) => a + b, 0)\n\n                return { ...values.surveySingleChoiceResults, [questionIndex]: { labels, data, total } }\n            },\n        },\n        surveyMultipleChoiceResults: {\n            loadSurveyMultipleChoiceResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyMultipleChoiceResults> => {\n                const { survey } = values\n\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.MultipleChoice) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.MultipleChoice}`)\n                }\n\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT \n                            count(),\n                            arrayJoin(JSONExtractArrayRaw(properties, '${getResponseField(questionIndex)}')) AS choice\n                        FROM events\n                        WHERE event == 'survey sent'\n                            AND properties.$survey_id == '${survey.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                        GROUP BY choice\n                        ORDER BY count() DESC\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                let { results } = responseJSON\n\n                // Remove outside quotes\n                results = results?.map((r) => {\n                    return [r[0], r[1].slice(1, r[1].length - 1)]\n                })\n\n                // Zero-fill choices that are not open-ended\n                question.choices.forEach((choice, idx) => {\n                    const isOpenChoice = idx == question.choices.length - 1 && question?.hasOpenChoice\n                    if (results?.length && !isOpenChoice && !results.some((r) => r[1] === choice)) {\n                        results.push([0, choice])\n                    }\n                })\n\n                const data = results?.map((r) => r[0])\n                const labels = results?.map((r) => r[1])\n\n                return { ...values.surveyMultipleChoiceResults, [questionIndex]: { labels, data } }\n            },\n        },\n        surveyOpenTextResults: {\n            loadSurveyOpenTextResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyOpenTextResults> => {\n                const { survey } = values\n\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.Open) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.Open}`)\n                }\n\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT distinct_id, properties, person.properties\n                        FROM events\n                        WHERE event == 'survey sent'\n                            AND properties.$survey_id == '${survey.id}'\n                            AND trim(JSONExtractString(properties, '${getResponseField(questionIndex)}')) != ''\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                        LIMIT 20\n                    `,\n                }\n\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                const events =\n                    results?.map((r) => {\n                        const distinct_id = r[0]\n                        const properties = JSON.parse(r[1])\n                        const personProperties = JSON.parse(r[2])\n                        return { distinct_id, properties, personProperties }\n                    }) || []\n\n                return { ...values.surveyOpenTextResults, [questionIndex]: { events } }\n            },\n        },\n    })),\n    listeners(({ actions }) => ({\n        createSurveySuccess: ({ survey }) => {\n            lemonToast.success(<>Survey {survey.name} created</>)\n            actions.loadSurveys()\n            router.actions.replace(urls.survey(survey.id))\n            actions.reportSurveyCreated(survey)\n        },\n        updateSurveySuccess: ({ survey }) => {\n            lemonToast.success(<>Survey {survey.name} updated</>)\n            actions.editingSurvey(false)\n            actions.reportSurveyEdited(survey)\n            actions.loadSurveys()\n        },\n        launchSurveySuccess: ({ survey }) => {\n            lemonToast.success(<>Survey {survey.name} launched</>)\n            actions.loadSurveys()\n            actions.reportSurveyLaunched(survey)\n        },\n        stopSurveySuccess: ({ survey }) => {\n            actions.loadSurveys()\n            actions.reportSurveyStopped(survey)\n        },\n        resumeSurveySuccess: ({ survey }) => {\n            actions.loadSurveys()\n            actions.reportSurveyResumed(survey)\n        },\n        archiveSurvey: () => {\n            actions.updateSurvey({ archived: true })\n        },\n        loadSurveySuccess: () => {\n            actions.loadSurveyUserStats()\n        },\n        resetTargeting: () => {\n            actions.setSurveyValue('linked_flag_id', NEW_SURVEY.linked_flag_id)\n            actions.setSurveyValue('targeting_flag_filters', NEW_SURVEY.targeting_flag_filters)\n            actions.setSurveyValue('linked_flag', NEW_SURVEY.linked_flag)\n            actions.setSurveyValue('targeting_flag', NEW_SURVEY.targeting_flag)\n            actions.setSurveyValue('conditions', NEW_SURVEY.conditions)\n            actions.setSurveyValue('remove_targeting_flag', true)\n        },\n    })),\n    reducers({\n        isEditingSurvey: [\n            false,\n            {\n                editingSurvey: (_, { editing }) => editing,\n            },\n        ],\n        surveyMissing: [\n            false,\n            {\n                setSurveyMissing: () => true,\n            },\n        ],\n        survey: [\n            { ...NEW_SURVEY } as NewSurvey | Survey,\n            {\n                setDefaultForQuestionType: (\n                    state,\n                    { idx, type, isEditingQuestion, isEditingDescription, isEditingThankYouMessage }\n                ) => {\n                    const question = isEditingQuestion\n                        ? state.questions[idx].question\n                        : defaultSurveyFieldValues[type].questions[0].question\n                    const description = isEditingDescription\n                        ? state.questions[idx].description\n                        : defaultSurveyFieldValues[type].questions[0].description\n                    const thankYouMessageHeader = isEditingThankYouMessage\n                        ? state.appearance.thankYouMessageHeader\n                        : defaultSurveyFieldValues[type].appearance.thankYouMessageHeader\n                    const newQuestions = [...state.questions]\n                    newQuestions[idx] = {\n                        ...state.questions[idx],\n                        ...(defaultSurveyFieldValues[type].questions[0] as SurveyQuestionBase),\n                        question,\n                        description,\n                    }\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                        appearance: {\n                            ...state.appearance,\n                            ...defaultSurveyFieldValues[type].appearance,\n                            thankYouMessageHeader,\n                        },\n                    }\n                },\n                setSurveyTemplateValues: (_, { template }) => {\n                    const newTemplateSurvey = { ...NEW_SURVEY, ...template }\n                    return newTemplateSurvey\n                },\n            },\n        ],\n        selectedQuestion: [\n            0 as number | null,\n            {\n                setSelectedQuestion: (_, { idx }) => idx,\n            },\n        ],\n        selectedSection: [\n            SurveyEditSection.Steps as SurveyEditSection | null,\n            {\n                setSelectedSection: (_, { section }) => section,\n            },\n        ],\n        surveyRatingResultsReady: [\n            {},\n            {\n                loadSurveyRatingResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveySingleChoiceResultsReady: [\n            {},\n            {\n                loadSurveySingleChoiceResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveyMultipleChoiceResultsReady: [\n            {},\n            {\n                loadSurveyMultipleChoiceResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveyOpenTextResultsReady: [\n            {},\n            {\n                loadSurveyOpenTextResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        writingHTMLDescription: [\n            false,\n            {\n                setWritingHTMLDescription: (_, { writingHTML }) => writingHTML,\n            },\n        ],\n    }),\n    selectors({\n        isSurveyRunning: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(survey.start_date && !survey.end_date)\n            },\n        ],\n        hasTargetingSet: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                const hasLinkedFlag =\n                    !!survey.linked_flag_id || (survey.linked_flag && Object.keys(survey.linked_flag).length > 0)\n                const hasTargetingFlag =\n                    (survey.targeting_flag && Object.keys(survey.targeting_flag).length > 0) ||\n                    (survey.targeting_flag_filters && Object.keys(survey.targeting_flag_filters).length > 0)\n                const hasOtherConditions = survey.conditions && Object.keys(survey.conditions).length > 0\n                return !!hasLinkedFlag || !!hasTargetingFlag || !!hasOtherConditions\n            },\n        ],\n        breadcrumbs: [\n            (s) => [s.survey],\n            (survey: Survey): Breadcrumb[] => [\n                {\n                    key: Scene.Surveys,\n                    name: 'Surveys',\n                    path: urls.surveys(),\n                },\n                { key: survey?.id || 'new', name: survey.name },\n            ],\n        ],\n        dataTableQuery: [\n            (s) => [s.survey],\n            (survey): DataTableNode | null => {\n                if (survey.id === 'new') {\n                    return null\n                }\n                const createdAt = (survey as Survey).created_at\n                return {\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.EventsQuery,\n                        select: [\n                            '*',\n                            ...survey.questions.map((q, i) => {\n                                if (q.type === SurveyQuestionType.MultipleChoice) {\n                                    // Join array items into a string\n                                    return `coalesce(arrayStringConcat(JSONExtractArrayRaw(properties, '${getResponseField(\n                                        i\n                                    )}'), ', ')) -- ${q.question}`\n                                }\n\n                                return `coalesce(JSONExtractString(properties, '${getResponseField(i)}')) -- ${\n                                    q.question\n                                }`\n                            }),\n                            'timestamp',\n                            'person',\n                        ],\n                        orderBy: ['timestamp DESC'],\n                        where: [`event == 'survey sent'`],\n                        after: createdAt,\n                        properties: [\n                            {\n                                type: PropertyFilterType.Event,\n                                key: '$survey_id',\n                                operator: PropertyOperator.Exact,\n                                value: survey.id,\n                            },\n                        ],\n                    },\n                    propertiesViaUrl: true,\n                    showExport: true,\n                    showReload: true,\n                    showEventFilter: true,\n                    showPropertyFilter: true,\n                    showTimings: false,\n                }\n            },\n        ],\n        hasTargetingFlag: [\n            (s) => [s.survey],\n            (survey): boolean => {\n                return !!survey.targeting_flag || !!survey.targeting_flag_filters\n            },\n        ],\n        urlMatchTypeValidationError: [\n            (s) => [s.survey],\n            (survey): string | null => {\n                if (survey.conditions?.urlMatchType === SurveyUrlMatchType.Regex && survey.conditions.url) {\n                    try {\n                        new RegExp(survey.conditions.url)\n                    } catch (e: any) {\n                        return e.message\n                    }\n                }\n                return null\n            },\n        ],\n        surveyNPSScore: [\n            (s) => [s.surveyRatingResults],\n            (surveyRatingResults) => {\n                if (surveyRatingResults) {\n                    const questionIdx = Object.keys(surveyRatingResults)[0]\n                    const questionResults: number[] = surveyRatingResults[questionIdx].data\n                    if (questionResults.length === 11) {\n                        const promoters = questionResults.slice(9, 11).reduce((a, b) => a + b, 0)\n                        const passives = questionResults.slice(7, 9).reduce((a, b) => a + b, 0)\n                        const detractors = questionResults.slice(0, 7).reduce((a, b) => a + b, 0)\n                        const npsScore = ((promoters - detractors) / (promoters + passives + detractors)) * 100\n                        return npsScore.toFixed(1)\n                    }\n                }\n            },\n        ],\n    }),\n    forms(({ actions, props, values }) => ({\n        survey: {\n            defaults: { ...NEW_SURVEY } as NewSurvey | Survey,\n            errors: ({ name, questions }) => ({\n                name: !name && 'Please enter a name.',\n                questions: questions.map((question) => ({\n                    question: !question.question && 'Please enter a question.',\n                    ...(question.type === SurveyQuestionType.Link\n                        ? { link: !question.link && 'Please enter a url for the link.' }\n                        : {}),\n                    ...(question.type === SurveyQuestionType.Rating\n                        ? {\n                              display: !question.display && 'Please choose a display type.',\n                              scale: !question.scale && 'Please choose a scale.',\n                          }\n                        : {}),\n                })),\n                // controlled using a PureField in the form\n                urlMatchType: values.urlMatchTypeValidationError,\n            }),\n            submit: (surveyPayload) => {\n                let surveyPayloadWithTargetingFlagFilters = surveyPayload\n                const flagLogic = featureFlagLogic({ id: values.survey.targeting_flag?.id || 'new' })\n                if (values.hasTargetingFlag) {\n                    const targetingFlag = flagLogic.values.featureFlag\n                    surveyPayloadWithTargetingFlagFilters = {\n                        ...surveyPayload,\n                        ...{ targeting_flag_filters: targetingFlag.filters },\n                    }\n                }\n                if (props.id && props.id !== 'new') {\n                    actions.updateSurvey(surveyPayloadWithTargetingFlagFilters)\n                } else {\n                    actions.createSurvey(surveyPayloadWithTargetingFlagFilters)\n                }\n            },\n        },\n    })),\n    urlToAction(({ actions, props }) => ({\n        [urls.survey(props.id ?? 'new')]: (_, __, ___, { method }) => {\n            // If the URL was pushed (user clicked on a link), reset the scene's data.\n            // This avoids resetting form fields if you click back/forward.\n            if (method === 'PUSH') {\n                if (props.id) {\n                    actions.loadSurvey()\n                } else {\n                    actions.resetSurvey()\n                }\n            }\n        },\n    })),\n    actionToUrl(({ values }) => ({\n        setSurveyTemplateValues: () => {\n            const hashParams = router.values.hashParams\n            hashParams['fromTemplate'] = true\n\n            return [urls.survey(values.survey.id), router.values.searchParams, hashParams]\n        },\n    })),\n    afterMount(({ props, actions }) => {\n        if (props.id !== 'new') {\n            actions.loadSurvey()\n        }\n        if (props.id === 'new') {\n            actions.resetSurvey()\n        }\n    }),\n])\n\nfunction sanitizeQuestions(surveyPayload: Partial<Survey>): Partial<Survey> {\n    if (!surveyPayload.questions) {\n        return surveyPayload\n    }\n\n    const sanitizedThankYouHeader = sanitizeHTML(surveyPayload.appearance?.thankYouMessageHeader || '')\n    const sanitizedThankYouDescription = sanitizeHTML(surveyPayload.appearance?.thankYouMessageDescription || '')\n\n    return {\n        ...surveyPayload,\n        questions: surveyPayload.questions?.map((rawQuestion) => {\n            return {\n                ...rawQuestion,\n                description: sanitizeHTML(rawQuestion.description || ''),\n                question: sanitizeHTML(rawQuestion.question || ''),\n            }\n        }),\n        appearance: {\n            ...surveyPayload.appearance,\n            ...(sanitizedThankYouHeader && { thankYouMessageHeader: sanitizedThankYouHeader }),\n            ...(sanitizedThankYouDescription && { thankYouMessageDescription: sanitizedThankYouDescription }),\n        },\n    }\n}\n"],"names":[],"sourceRoot":""}