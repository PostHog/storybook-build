{"version":3,"file":"39616.034c3085.iframe.bundle.js","mappings":";AAqDA;AACA;AAEA;AACA;AACA;AAsCA;AACA;AC4MA;;;AC5PA;;AAEA;;;;;;;;;ACQA;AACA;;;;;;AAMA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA","sources":["webpack://@posthog/storybook/../../frontend/src/scenes/hog-functions/configuration/components/hogFunctionSourceWebhookTestLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/hog-functions/configuration/hogFunctionTestLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/hog-functions/logs/hogFunctionLogsLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/hog-functions/logs/logsViewerLogic.tsx"],"sourcesContent":["import { actions, connect, kea, key, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { tryJsonParse } from 'lib/utils'\n\nimport { hogFunctionConfigurationLogic, HogFunctionConfigurationLogicProps } from '../hogFunctionConfigurationLogic'\nimport type { hogFunctionSourceWebhookTestLogicType } from './hogFunctionSourceWebhookTestLogicType'\n\nexport type HogFunctionSourceWebhookTestForm = {\n    headers: string\n    body: string\n    mock_request: boolean\n}\n\nexport type HogFunctionSourceWebhookTestResult = {\n    status: number\n    body: string\n}\n\nexport const hogFunctionSourceWebhookTestLogic = kea<hogFunctionSourceWebhookTestLogicType>([\n    props({} as HogFunctionConfigurationLogicProps),\n    key(({ id, templateId }: HogFunctionConfigurationLogicProps) => {\n        return id ?? templateId ?? 'new'\n    }),\n\n    path((id) => ['scenes', 'pipeline', 'hogfunctions', 'hogFunctionSourceWebhookTestLogic', id]),\n    connect((props: HogFunctionConfigurationLogicProps) => ({\n        values: [hogFunctionConfigurationLogic(props), ['configuration', 'templateId']],\n    })),\n    actions({\n        setTestResult: (result: HogFunctionSourceWebhookTestResult | null) => ({ result }),\n        toggleExpanded: (expanded?: boolean) => ({ expanded }),\n    }),\n    reducers({\n        expanded: [\n            false as boolean,\n            {\n                toggleExpanded: (state, { expanded }) => (expanded === undefined ? !state : expanded),\n            },\n        ],\n\n        testResult: [\n            null as HogFunctionSourceWebhookTestResult | null,\n            {\n                setTestResult: (_, { result }) => result,\n            },\n        ],\n    }),\n\n    forms(({ props, actions }) => ({\n        testInvocation: {\n            defaults: {\n                mock_request: true,\n                headers: `{\n  \"Content-Type\": \"application/json\"\n}`,\n                body: `{\n  \"event\": \"my example event\",\n  \"distinct_id\": \"webhook-test-123\"\n}`,\n            } as HogFunctionSourceWebhookTestForm,\n            alwaysShowErrors: true,\n            errors: ({ headers, body }) => {\n                return {\n                    headers: !headers ? 'Required' : tryJsonParse(headers) ? undefined : 'Invalid JSON',\n                    body: !body ? 'Required' : tryJsonParse(body) ? undefined : 'Invalid JSON',\n                }\n            },\n            submit: async (data) => {\n                actions.setTestResult(null)\n\n                const response = await fetch(`${window.location.origin}/public/webhooks/${props.id ?? 'unknown'}`, {\n                    method: 'POST',\n                    headers: tryJsonParse(data.headers),\n                    body: data.body,\n                })\n\n                actions.setTestResult({\n                    status: response.status,\n                    body: await response.text(),\n                })\n            },\n        },\n    })),\n\n    selectors({\n        exampleCurlRequest: [\n            (s) => [s.testInvocation, (_, props) => props],\n            (testInvocation, props) => {\n                const headersJson = tryJsonParse(testInvocation.headers)\n                const headers = headersJson\n                    ? Object.entries(headersJson)\n                          .map(([key, value]) => `-H \"${key}: ${value}\"`)\n                          .join(' ')\n                    : ''\n\n                return `curl -X POST ${headers} \\\\\n  -d '${testInvocation.body}' \\\\\n  ${window.location.origin}/public/webhooks/${props.id ?? 'unknown'}`\n            },\n        ],\n    }),\n])\n","import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, afterMount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport api from 'lib/api'\nimport { tryJsonParse } from 'lib/utils'\nimport { getCurrentTeamId } from 'lib/utils/getAppContext'\nimport { editor } from 'monaco-editor'\n\nimport { groupsModel } from '~/models/groupsModel'\nimport { CyclotronJobInvocationGlobals, CyclotronJobTestInvocationResult } from '~/types'\n\nimport {\n    hogFunctionConfigurationLogic,\n    HogFunctionConfigurationLogicProps,\n    sanitizeConfiguration,\n} from './hogFunctionConfigurationLogic'\nimport type { hogFunctionTestLogicType } from './hogFunctionTestLogicType'\n\nexport type HogFunctionTestInvocationForm = {\n    globals: string // CyclotronJobInvocationGlobals\n    mock_async_functions: boolean\n}\n\nexport type HogTransformationEvent = {\n    event: any\n    uuid: string\n    distinct_id: string\n    timestamp: string\n    properties: any\n}\n\nconst convertToTransformationEvent = (result: any): HogTransformationEvent => {\n    const properties = result.properties ?? {}\n    properties.$ip = properties.$ip ?? '89.160.20.129'\n    // We don't want to use these values given they will change in the test invocation\n    delete properties.$transformations_failed\n    delete properties.$transformations_succeeded\n    delete properties.$transformations_skipped\n    return {\n        event: result.event,\n        uuid: result.uuid,\n        distinct_id: result.distinct_id,\n        timestamp: result.timestamp,\n        properties,\n    }\n}\n\nconst convertFromTransformationEvent = (result: HogTransformationEvent): Record<string, any> => {\n    delete result.properties.$transformations_failed\n    delete result.properties.$transformations_succeeded\n    delete result.properties.$transformations_skipped\n    return {\n        event: result.event,\n        uuid: result.uuid,\n        distinct_id: result.distinct_id,\n        timestamp: result.timestamp,\n        properties: result.properties,\n    }\n}\n\nexport interface CodeEditorValidation {\n    value: string\n    editor: editor.IStandaloneCodeEditor\n    decorations: string[]\n}\n\nexport const hogFunctionTestLogic = kea<hogFunctionTestLogicType>([\n    props({} as HogFunctionConfigurationLogicProps),\n    key(({ id, templateId }: HogFunctionConfigurationLogicProps) => {\n        return id ?? templateId ?? 'new'\n    }),\n\n    path((id) => ['scenes', 'pipeline', 'hogfunctions', 'hogFunctionTestLogic', id]),\n    connect((props: HogFunctionConfigurationLogicProps) => ({\n        values: [\n            hogFunctionConfigurationLogic(props),\n            [\n                'configuration',\n                'templateId',\n                'configurationHasErrors',\n                'sampleGlobals',\n                'sampleGlobalsLoading',\n                'exampleInvocationGlobals',\n                'sampleGlobalsError',\n                'type',\n                'currentHogCode',\n            ],\n            groupsModel,\n            ['groupTypes'],\n        ],\n        actions: [\n            hogFunctionConfigurationLogic(props),\n            ['touchConfigurationField', 'loadSampleGlobalsSuccess', 'loadSampleGlobals', 'setSampleGlobals'],\n        ],\n    })),\n    actions({\n        setTestResult: (result: CyclotronJobTestInvocationResult | null) => ({ result }),\n        toggleExpanded: (expanded?: boolean) => ({ expanded }),\n        saveGlobals: (name: string, globals: CyclotronJobInvocationGlobals) => ({ name, globals }),\n        deleteSavedGlobals: (index: number) => ({ index }),\n        setTestResultMode: (mode: 'raw' | 'diff') => ({ mode }),\n        receiveExampleGlobals: (globals: CyclotronJobInvocationGlobals | null) => ({ globals }),\n        setJsonError: (error: string | null) => ({ error }),\n        validateJson: (value: string, editor: editor.IStandaloneCodeEditor, decorations: string[]) =>\n            ({ value, editor, decorations } as CodeEditorValidation),\n        setDecorationIds: (decorationIds: string[]) => ({ decorationIds }),\n        cancelSampleGlobalsLoading: true,\n    }),\n    reducers({\n        expanded: [\n            false as boolean,\n            {\n                toggleExpanded: (state, { expanded }) => (expanded === undefined ? !state : expanded),\n            },\n        ],\n\n        testResult: [\n            null as CyclotronJobTestInvocationResult | null,\n            {\n                setTestResult: (_, { result }) => result,\n            },\n        ],\n\n        testResultMode: [\n            'diff' as 'raw' | 'diff',\n            {\n                setTestResultMode: (_, { mode }) => mode,\n            },\n        ],\n\n        savedGlobals: [\n            [] as { name: string; globals: CyclotronJobInvocationGlobals }[],\n            { persist: true, prefix: `${getCurrentTeamId()}__` },\n            {\n                saveGlobals: (state, { name, globals }) => [...state, { name, globals }],\n                deleteSavedGlobals: (state, { index }) => state.filter((_, i) => i !== index),\n            },\n        ],\n\n        jsonError: [\n            null as string | null,\n            {\n                setJsonError: (_, { error }) => error,\n            },\n        ],\n\n        currentDecorationIds: [\n            [] as string[],\n            {\n                setDecorationIds: (_, { decorationIds }) => decorationIds,\n                setJsonError: () => [], // Clear decorations when error state changes\n            },\n        ],\n\n        fetchCancelled: [\n            false as boolean,\n            {\n                loadSampleGlobals: () => false,\n                cancelSampleGlobalsLoading: () => true,\n                toggleExpanded: () => false,\n            },\n        ],\n    }),\n    listeners(({ values, actions }) => ({\n        loadSampleGlobalsSuccess: () => {\n            if (values.expanded && !values.fetchCancelled && values.sampleGlobals) {\n                actions.receiveExampleGlobals(values.sampleGlobals)\n            }\n        },\n        setSampleGlobals: ({ sampleGlobals }) => {\n            actions.receiveExampleGlobals(sampleGlobals)\n        },\n\n        receiveExampleGlobals: ({ globals }) => {\n            if (!globals) {\n                return\n            }\n\n            if (values.type === 'transformation') {\n                const event = convertToTransformationEvent(globals.event)\n                // Strip down to just the real values\n                actions.setTestInvocationValue('globals', JSON.stringify(event, null, 2))\n            } else {\n                actions.setTestInvocationValue('globals', JSON.stringify(globals, null, 2))\n            }\n        },\n\n        validateJson: ({ value, editor, decorations }: CodeEditorValidation) => {\n            if (!editor?.getModel()) {\n                return\n            }\n\n            const model = editor.getModel()!\n\n            try {\n                // Try parsing the JSON\n                JSON.parse(value)\n                // If valid, ensure everything is cleared\n                actions.setJsonError(null)\n                editor.removeDecorations(decorations)\n            } catch (err: any) {\n                actions.setJsonError(err.message)\n\n                const match = err.message.match(/position (\\d+)/)\n                if (!match) {\n                    return\n                }\n\n                const position = parseInt(match[1], 10)\n                const pos = model.getPositionAt(position)\n\n                // Set single error marker\n                editor.createDecorationsCollection([\n                    {\n                        range: {\n                            startLineNumber: pos.lineNumber,\n                            startColumn: pos.column,\n                            endLineNumber: pos.lineNumber,\n                            endColumn: pos.column + 1,\n                        },\n                        options: {\n                            isWholeLine: true,\n                            className: 'bg-danger-highlight',\n                            glyphMarginClassName: 'text-danger flex items-center justify-center',\n                            glyphMarginHoverMessage: { value: err.message },\n                        },\n                    },\n                ])\n                // Scroll to error\n                editor.revealLineInCenter(pos.lineNumber)\n            }\n        },\n\n        setTestResult: ({ result }) => {\n            if (result) {\n                setTimeout(() => {\n                    // First try to scroll the test results container into view\n                    const testResults = document.querySelector('[data-attr=\"test-results\"]')\n                    if (testResults) {\n                        testResults.scrollIntoView({ behavior: 'smooth', block: 'start' })\n                    }\n\n                    // Find the Monaco editor and scroll to the first difference\n                    const editors = document.querySelectorAll('[data-attr=\"test-results\"] .monaco-editor')\n                    if (editors.length > 0 && values.sortedTestsResult?.hasDiff) {\n                        const lastEditor = editors[editors.length - 1]\n                        const monacoEditor = lastEditor.querySelector('.monaco-scrollable-element')\n                        if (monacoEditor) {\n                            const inputLines = values.sortedTestsResult.input.split('\\n')\n                            const outputLines = values.sortedTestsResult.output.split('\\n')\n\n                            // Find the first line that differs\n                            let diffLineIndex = 0\n                            for (let i = 0; i < Math.max(inputLines.length, outputLines.length); i++) {\n                                if (inputLines[i] !== outputLines[i]) {\n                                    diffLineIndex = i\n                                    break\n                                }\n                            }\n\n                            // Calculate approximate scroll position for the diff, showing 2 lines of context above\n                            const lineHeight = 19 // Default Monaco line height\n                            monacoEditor.scrollTop = Math.max(0, (diffLineIndex - 2) * lineHeight)\n                        }\n                    }\n                }, 100)\n            }\n        },\n\n        cancelSampleGlobalsLoading: () => {\n            // Just mark as cancelled - we'll ignore any results that come back\n        },\n    })),\n\n    forms(({ props, actions, values }) => ({\n        testInvocation: {\n            defaults: {\n                mock_async_functions: false,\n            } as HogFunctionTestInvocationForm,\n            alwaysShowErrors: true,\n            errors: ({ globals }) => {\n                return {\n                    globals: !globals ? 'Required' : tryJsonParse(globals) ? undefined : 'Invalid JSON',\n                }\n            },\n            submit: async (data) => {\n                // Submit the test invocation\n                // Set the response somewhere\n\n                if (values.configurationHasErrors) {\n                    // Get the configuration logic instance\n                    const configLogic = hogFunctionConfigurationLogic(props)\n                    const inputErrors = configLogic.values.inputFormErrors?.inputs || {}\n\n                    // Create a simple list of errors\n                    const errorMessages = Object.entries(inputErrors).map(([key, error]) => {\n                        const errorText = typeof error === 'string' ? error : 'Invalid format'\n                        return `${key}: ${errorText}`\n                    })\n\n                    // Show the error message\n                    const message =\n                        errorMessages.length > 0\n                            ? `Please fix the following errors:\\n${errorMessages.join('\\n')}`\n                            : 'Please fix the configuration errors before testing.'\n\n                    lemonToast.error(message, {\n                        toastId: 'hogfunction-validation-error',\n                    })\n\n                    // Show the errors in the UI\n                    configLogic.actions.touchConfigurationField && configLogic.actions.touchConfigurationField('inputs')\n                    return\n                }\n\n                const parsedData = tryJsonParse(data.globals)\n                const configuration = sanitizeConfiguration(values.configuration) as Record<string, any>\n                configuration.template_id = values.templateId\n                configuration.hog = values.currentHogCode\n\n                // Transformations have a simpler UI just showing the event so we need to map it back to the event\n                const globals =\n                    values.type === 'transformation'\n                        ? {\n                              event: parsedData,\n                          }\n                        : parsedData\n\n                try {\n                    const res = await api.hogFunctions.createTestInvocation(props.id ?? 'new', {\n                        globals,\n                        mock_async_functions: data.mock_async_functions,\n                        configuration,\n                    })\n\n                    // Modify the result to match better our globals format\n                    if (values.type === 'transformation' && res.result) {\n                        res.result = convertFromTransformationEvent(res.result)\n                    }\n\n                    actions.setTestResult(res)\n                } catch (e) {\n                    lemonToast.error(`An unexpected server error occurred while testing the function. ${e}`)\n                }\n            },\n        },\n    })),\n\n    selectors(() => ({\n        sortedTestsResult: [\n            (s) => [s.configuration, s.testResult, s.testInvocation],\n            (\n                configuration,\n                testResult,\n                testInvocation\n            ): {\n                input: string\n                output: string\n                hasDiff: boolean\n            } | null => {\n                if (!testResult || configuration.type !== 'transformation') {\n                    return null\n                }\n\n                const input = JSON.stringify(JSON.parse(testInvocation.globals), null, 2)\n                const output = JSON.stringify(testResult.result, null, 2)\n\n                return {\n                    input,\n                    output,\n                    hasDiff: input !== output,\n                }\n            },\n        ],\n\n        sampleGlobalsLoadingAndNotCancelled: [\n            (s) => [s.sampleGlobalsLoading, s.fetchCancelled],\n            (sampleGlobalsLoading, fetchCancelled) => sampleGlobalsLoading && !fetchCancelled,\n        ],\n    })),\n\n    afterMount(({ actions, values }) => {\n        actions.receiveExampleGlobals(values.exampleInvocationGlobals)\n    }),\n])\n","import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { beforeUnload } from 'kea-router'\nimport api from 'lib/api'\nimport { Dayjs, dayjs } from 'lib/dayjs'\n\nimport { hogql } from '~/queries/utils'\nimport { LogEntryLevel } from '~/types'\n\nimport type { hogFunctionLogsLogicType } from './hogFunctionLogsLogicType'\nimport { GroupedLogEntry, logsViewerLogic, LogsViewerLogicProps } from './logsViewerLogic'\n\nexport type RetryInvocationState = 'pending' | 'success' | 'failure'\n\nconst eventIdMatchers = [/Event: ([A-Za-z0-9-]+)/, /\\/events\\/([A-Za-z0-9-]+)\\//, /event ([A-Za-z0-9-]+)/]\n\nasync function runWithParallelism<T, R>(\n    items: T[],\n    maxParallel: number,\n    asyncFn: (item: T) => Promise<R>\n): Promise<R[]> {\n    const results: R[] = []\n    const executing = new Set<Promise<void>>()\n\n    for (const item of items) {\n        const promise = (async () => {\n            const result = await asyncFn(item)\n            results.push(result)\n        })()\n\n        executing.add(promise)\n        void promise.finally(() => executing.delete(promise))\n\n        if (executing.size >= maxParallel) {\n            await Promise.race(executing)\n        }\n    }\n\n    await Promise.all(executing)\n    return results\n}\n\nconst loadClickhouseEvents = async (\n    eventIds: string[],\n    { date_from, date_to }: { date_from?: string; date_to?: string }\n): Promise<any[]> => {\n    const query = hogql`\n        SELECT uuid, distinct_id, event, timestamp, properties, elements_chain, person.id, person.properties, person.created_at \n        FROM events\n        WHERE uuid in (${hogql.raw(eventIds.map((x) => `'${x}'`).join(','))})\n        AND timestamp > {filters.dateRange.from}\n        AND timestamp < {filters.dateRange.to}`\n\n    const response = await api.queryHogQL(query, {\n        refresh: 'force_blocking',\n        filtersOverride: {\n            date_from: date_from,\n            date_to: date_to,\n        },\n    })\n\n    return response.results.map((x) => {\n        const [\n            uuid,\n            distinct_id,\n            event,\n            timestamp,\n            properties,\n            elements_chain,\n            person_id,\n            person_properties,\n            person_created_at,\n        ] = x\n\n        return {\n            uuid,\n            event,\n            distinct_id,\n            person_id,\n            timestamp,\n            properties,\n            elements_chain,\n            person_created_at,\n            person_properties,\n        }\n    })\n}\n\nexport const hogFunctionLogsLogic = kea<hogFunctionLogsLogicType>([\n    path((key) => ['scenes', 'pipeline', 'hogfunctions', 'logs', 'hogFunctionLogsLogic', key]),\n    props({} as LogsViewerLogicProps), // TODO: Remove `stage` from props, it isn't needed here for anything\n    key(({ sourceType, sourceId }) => `${sourceType}:${sourceId}`),\n    connect((props: LogsViewerLogicProps) => ({\n        values: [logsViewerLogic(props), ['logs']],\n        actions: [logsViewerLogic(props), ['addLogGroups', 'setRowExpanded']],\n    })),\n    actions({\n        setSelectingMany: (selectingMany: boolean) => ({ selectingMany }),\n        setSelectedForRetry: (selectedForRetry: Record<string, boolean>) => ({ selectedForRetry }),\n        selectAllForRetry: true,\n        retryInvocation: (groupedLogEntry: GroupedLogEntry, eventId: string) => ({ groupedLogEntry, eventId }),\n        retryInvocations: (groupedLogEntries: GroupedLogEntry[]) => ({ groupedLogEntries }),\n        retryInvocationStarted: (groupedLogEntry: GroupedLogEntry) => ({ groupedLogEntry }),\n        retryInvocationSuccess: (groupedLogEntry: GroupedLogEntry) => ({ groupedLogEntry }),\n        retryInvocationFailure: (groupedLogEntry: GroupedLogEntry) => ({ groupedLogEntry }),\n        retrySelectedInvocations: true,\n    }),\n    reducers({\n        selectingMany: [\n            false,\n            {\n                setSelectingMany: (_, { selectingMany }) => selectingMany,\n            },\n        ],\n\n        selectedForRetry: [\n            {} as Record<string, boolean>,\n            {\n                setSelectedForRetry: (state, { selectedForRetry }) => {\n                    const newState = { ...state }\n                    Object.keys(selectedForRetry).forEach((key) => {\n                        newState[key] = selectedForRetry[key]\n\n                        if (!selectedForRetry[key]) {\n                            delete newState[key]\n                        }\n                    })\n                    return newState\n                },\n\n                setSelectingMany: (state, { selectingMany }) => {\n                    return selectingMany ? state : {}\n                },\n            },\n        ],\n\n        retries: [\n            {} as Record<string, RetryInvocationState>,\n            {\n                retryInvocationStarted: (state, { groupedLogEntry }) => {\n                    return {\n                        ...state,\n                        [groupedLogEntry.instanceId]: 'pending',\n                    }\n                },\n\n                retryInvocationSuccess: (state, { groupedLogEntry }) => {\n                    return {\n                        ...state,\n                        [groupedLogEntry.instanceId]: 'success',\n                    }\n                },\n\n                retryInvocationFailure: (state, { groupedLogEntry }) => {\n                    return {\n                        ...state,\n                        [groupedLogEntry.instanceId]: 'failure',\n                    }\n                },\n            },\n        ],\n    }),\n\n    selectors({\n        retryRunning: [\n            (s) => [s.retries],\n            (retries) => {\n                return Object.values(retries).some((x) => x === 'pending')\n            },\n        ],\n\n        eventIdByInvocationId: [\n            (s) => [s.logs],\n            (logs) => {\n                const eventIdByInvocationId: Record<string, string> = {}\n\n                for (const record of logs) {\n                    // TRICKY: We have the event ID in different places in different logs. We will standardise this to be the invocation ID in the future.\n                    const entryContainingEventId = record.entries.find(\n                        (entry) =>\n                            entry.message.includes('Function completed') ||\n                            entry.message.includes('Suspending function') ||\n                            entry.message.includes('Error executing function on event')\n                    )\n\n                    if (!entryContainingEventId) {\n                        return undefined\n                    }\n\n                    for (const matcher of eventIdMatchers) {\n                        const match = entryContainingEventId.message.match(matcher)\n                        if (match) {\n                            eventIdByInvocationId[record.instanceId] = match[1]\n                            break\n                        }\n                    }\n                }\n\n                return eventIdByInvocationId\n            },\n        ],\n    }),\n    listeners(({ actions, props, values }) => ({\n        retryInvocations: async ({ groupedLogEntries }) => {\n            await lemonToast.promise(\n                (async () => {\n                    for (const groupedLogEntry of groupedLogEntries) {\n                        actions.retryInvocationStarted(groupedLogEntry)\n                    }\n\n                    if (groupedLogEntries.length === 1) {\n                        // If we only have one log group then we can just expand it to be a little more user friendly\n                        actions.setRowExpanded(groupedLogEntries[0].instanceId, true)\n                    }\n\n                    // We want to get the oldest and newest \"min\" timestamp as that will be closest to when the event was processed\n                    // NOTE: This isn't perfect as the event timestamp might be different to the time it was processed\n                    const [timestampRangeStart, timestampRangeEnd] = groupedLogEntries.reduce(\n                        ([accStart, accEnd], x) => {\n                            if (!accStart) {\n                                return [x.minTimestamp, x.minTimestamp]\n                            }\n\n                            return [\n                                x.minTimestamp.isBefore(accStart) ? x.minTimestamp : accStart,\n                                x.maxTimestamp.isAfter(accEnd) ? x.maxTimestamp : accEnd,\n                            ]\n                        },\n                        [null as Dayjs | null, null as Dayjs | null]\n                    )\n\n                    // Load all events by ID using the date range to speed up the query (we add time either side to account for processing delays)\n                    const events = await loadClickhouseEvents(Object.values(values.eventIdByInvocationId ?? {}), {\n                        date_from: timestampRangeStart?.subtract(1, 'day').toISOString(),\n                        date_to: timestampRangeEnd?.add(1, 'day').toISOString(),\n                    })\n\n                    const eventsById: Record<string, any> = {}\n                    for (const event of events) {\n                        eventsById[event.uuid] = event\n                    }\n\n                    await runWithParallelism(groupedLogEntries, 10, async (groupedLogEntry) => {\n                        try {\n                            // If we have an event then retry it, otherwise fail\n                            const event = eventsById[values.eventIdByInvocationId![groupedLogEntry.instanceId]]\n\n                            if (!event) {\n                                actions.retryInvocationFailure(groupedLogEntry)\n                                return\n                            }\n\n                            const res = await api.hogFunctions.createTestInvocation(props.sourceId, {\n                                clickhouse_event: event,\n                                mock_async_functions: false,\n                                configuration: {\n                                    // For retries we don't care about filters\n                                    filters: {},\n                                },\n                                invocation_id: groupedLogEntry.instanceId,\n                            })\n\n                            const newLogGroup: GroupedLogEntry = {\n                                ...groupedLogEntry,\n                                entries: [\n                                    ...groupedLogEntry.entries,\n                                    ...res.logs.map((x) => ({\n                                        timestamp: dayjs(x.timestamp),\n                                        level: x.level.toUpperCase() as LogEntryLevel,\n                                        message: x.message,\n                                    })),\n                                ],\n                            }\n\n                            actions.addLogGroups([newLogGroup])\n                            actions.retryInvocationSuccess(groupedLogEntry)\n                        } catch {\n                            actions.retryInvocationFailure(groupedLogEntry)\n                        }\n                    })\n\n                    actions.setSelectingMany(false)\n                })(),\n                {\n                    success: 'Retries complete!',\n                    error: 'Retry failed!',\n                    pending: 'Retrying...',\n                }\n            )\n        },\n\n        retrySelectedInvocations: async () => {\n            const groupsToRetry = values.logs.filter((x) => values.selectedForRetry[x.instanceId])\n\n            actions.retryInvocations(groupsToRetry)\n        },\n\n        selectAllForRetry: async () => {\n            actions.setSelectingMany(true)\n\n            for (const groupedLogEntry of values.logs) {\n                actions.setSelectedForRetry({\n                    [groupedLogEntry.instanceId]: true,\n                })\n            }\n        },\n    })),\n\n    beforeUnload(({ values, cache }) => ({\n        enabled: () => !cache.disabledBeforeUnload && values.retryRunning,\n        message: 'You have running retries that will be discarded if you leave. Are you sure?',\n        onConfirm: () => {\n            cache.disabledBeforeUnload = true\n        },\n    })),\n])\n","import { actions, events, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { Dayjs, dayjs } from 'lib/dayjs'\n\nimport { hogql } from '~/queries/utils'\nimport { LogEntryLevel } from '~/types'\n\nimport type { logsViewerLogicType } from './logsViewerLogicType'\n\nexport const ALL_LOG_LEVELS: LogEntryLevel[] = ['DEBUG', 'LOG', 'INFO', 'WARNING', 'ERROR']\nexport const DEFAULT_LOG_LEVELS: LogEntryLevel[] = ['LOG', 'INFO', 'WARNING', 'ERROR']\n\nexport type LogsViewerLogicProps = {\n    sourceType: 'hog_function' | 'hog_flow'\n    sourceId: string\n}\n\nexport type LogsViewerFilters = {\n    levels: LogEntryLevel[]\n    search: string\n    date_from?: string\n    date_to?: string\n}\n\nexport const LOG_VIEWER_LIMIT = 500\n\nexport type GroupedLogEntry = {\n    instanceId: string\n    maxTimestamp: Dayjs\n    minTimestamp: Dayjs\n    logLevel: LogEntryLevel\n    entries: {\n        message: string\n        level: LogEntryLevel\n        timestamp: Dayjs\n    }[]\n}\n\ntype GroupedLogEntryRequest = {\n    sourceType: 'hog_function' | 'hog_flow'\n    sourceId: string\n    levels: LogEntryLevel[]\n    search: string\n    date_from?: string\n    date_to?: string\n    order: 'ASC' | 'DESC'\n}\n\nconst loadGroupedLogs = async (request: GroupedLogEntryRequest): Promise<GroupedLogEntry[]> => {\n    const query = hogql`\n        SELECT\n            instance_id,\n            max(timestamp) AS latest_timestamp,\n            min(timestamp) AS earliest_timestamp,\n            arraySort(\n                groupArray((timestamp, level, message))\n            ) AS messages\n        FROM log_entries\n        WHERE log_source = ${request.sourceType}\n        AND log_source_id = ${request.sourceId}\n        AND timestamp > {filters.dateRange.from}\n        AND timestamp < {filters.dateRange.to}\n        AND instance_id in (\n            SELECT DISTINCT instance_id\n            FROM log_entries\n            WHERE log_source = ${request.sourceType}\n            AND log_source_id = ${request.sourceId}\n            AND timestamp > {filters.dateRange.from}\n            AND timestamp < {filters.dateRange.to}\n            AND lower(level) IN (${hogql.raw(request.levels.map((level) => `'${level.toLowerCase()}'`).join(','))})\n            AND message ILIKE '%${hogql.raw(request.search)}%'\n            ORDER BY timestamp ${hogql.raw(request.order)}\n            LIMIT ${LOG_VIEWER_LIMIT}\n        )\n        GROUP BY instance_id\n        ORDER BY latest_timestamp DESC`\n\n    const response = await api.queryHogQL(query, {\n        refresh: 'force_blocking',\n        filtersOverride: {\n            date_from: request.date_from ?? '-7d',\n            date_to: request.date_to,\n        },\n    })\n\n    return response.results.map((result) => ({\n        instanceId: result[0],\n        maxTimestamp: dayjs(result[1]),\n        minTimestamp: dayjs(result[2]),\n        entries: result[3].map((entry: any) => ({\n            timestamp: dayjs(entry[0]),\n            level: entry[1].toUpperCase(),\n            message: entry[2],\n        })),\n    })) as GroupedLogEntry[]\n}\n\nconst sanitizeGroupedLogs = (groups: GroupedLogEntry[]): GroupedLogEntry[] => {\n    const byId: Record<string, GroupedLogEntry> = {}\n\n    for (const group of groups) {\n        // Set the group if not already set\n        if (!byId[group.instanceId]) {\n            byId[group.instanceId] = group\n        } else {\n            // If the group already exists, we need to merge the entries\n            for (const entry of group.entries) {\n                if (!byId[group.instanceId].entries.find((e) => e.timestamp.isSame(entry.timestamp))) {\n                    byId[group.instanceId].entries.push(entry)\n                }\n            }\n        }\n\n        // Sort the entries by timestamp\n        byId[group.instanceId].entries.sort((a, b) => a.timestamp.diff(b.timestamp))\n\n        // Go in reverse and find the highest level message\n\n        const highestLogLevel = group.entries.reduce((max, entry) => {\n            return Math.max(max, ALL_LOG_LEVELS.indexOf(entry.level))\n        }, 0)\n        byId[group.instanceId].logLevel = ALL_LOG_LEVELS[highestLogLevel]\n    }\n\n    return Object.values(byId).sort((a, b) => b.maxTimestamp.diff(a.maxTimestamp))\n}\n\nexport const logsViewerLogic = kea<logsViewerLogicType>([\n    path((key) => ['scenes', 'pipeline', 'hogfunctions', 'logs', 'logsViewerLogic', key]),\n    props({} as LogsViewerLogicProps), // TODO: Remove `stage` from props, it isn't needed here for anything\n    key(({ sourceType, sourceId }) => `${sourceType}:${sourceId}`),\n    actions({\n        setFilters: (filters: Partial<LogsViewerFilters>) => ({ filters }),\n        addLogGroups: (logGroups: GroupedLogEntry[]) => ({ logGroups }),\n        setHiddenLogs: (logGroups: GroupedLogEntry[]) => ({ logGroups }),\n        clearHiddenLogs: true,\n        markLogsEnd: true,\n        revealHiddenLogs: true,\n        setRowExpanded: (instanceId: string, expanded: boolean) => ({ instanceId, expanded }),\n        scheduleLoadNewerLogs: true,\n        loadLogs: true,\n        loadNewerLogs: true,\n    }),\n    loaders(({ props, values, actions }) => ({\n        logs: [\n            [] as GroupedLogEntry[],\n            {\n                loadLogs: async (_, breakpoint) => {\n                    await breakpoint(10)\n\n                    actions.clearHiddenLogs()\n\n                    const logParams: GroupedLogEntryRequest = {\n                        levels: values.filters.levels,\n                        search: values.filters.search,\n                        sourceType: props.sourceType,\n                        sourceId: props.sourceId,\n                        date_from: values.filters.date_from,\n                        date_to: values.filters.date_to,\n                        order: 'DESC',\n                    }\n                    const results = await loadGroupedLogs(logParams)\n\n                    await breakpoint(10)\n\n                    return sanitizeGroupedLogs(results)\n                },\n                loadMoreLogs: async () => {\n                    if (!values.oldestLogTimestamp) {\n                        return values.logs\n                    }\n                    const logParams: GroupedLogEntryRequest = {\n                        levels: values.filters.levels,\n                        search: values.filters.search,\n                        sourceType: props.sourceType,\n                        sourceId: props.sourceId,\n                        date_to: values.oldestLogTimestamp.toISOString(),\n                        date_from: values.filters.date_from,\n                        order: 'DESC',\n                    }\n\n                    const results = await loadGroupedLogs(logParams)\n\n                    if (!results.length) {\n                        actions.markLogsEnd()\n                    }\n                    return sanitizeGroupedLogs([...results, ...values.logs])\n                },\n\n                revealHiddenLogs: () => {\n                    // We pull out the hidden log groups and add them to the main logs\n                    const hiddenLogs = [...values.hiddenLogs]\n\n                    actions.clearHiddenLogs()\n                    return sanitizeGroupedLogs([...hiddenLogs, ...values.logs])\n                },\n                addLogGroups: ({ logGroups }) => {\n                    return sanitizeGroupedLogs([...logGroups, ...values.logs])\n                },\n            },\n        ],\n\n        hiddenLogs: [\n            [] as GroupedLogEntry[],\n            {\n                loadNewerLogs: async (_, breakpoint) => {\n                    await breakpoint(10)\n\n                    // We load all logs groups that have a timestamp after the newest log timestamp\n                    // For ones we already have we just replace them, otherwise we add them to the \"hidden\" logs list\n                    if (!values.newestLogTimestamp) {\n                        return values.hiddenLogs\n                    }\n                    const logParams: GroupedLogEntryRequest = {\n                        levels: values.filters.levels,\n                        search: values.filters.search,\n                        sourceType: props.sourceType,\n                        sourceId: props.sourceId,\n                        date_from: values.newestLogTimestamp.toISOString(),\n                        date_to: values.filters.date_to,\n                        order: 'ASC',\n                    }\n\n                    const results = await loadGroupedLogs(logParams)\n\n                    await breakpoint(10)\n\n                    const newLogs: GroupedLogEntry[] = []\n                    const existingLogsToUpdate: GroupedLogEntry[] = []\n                    const existingLogIds = values.logs.map((log) => log.instanceId)\n\n                    if (values.logsLoading) {\n                        // TRICKY: Something changed whilst we were doing this query - we don't want to mess with things\n                        // so we just exit\n                        return values.hiddenLogs\n                    }\n\n                    for (const log of results) {\n                        if (existingLogIds.includes(log.instanceId)) {\n                            // If we already have this log group showing then we can just update it\n                            existingLogsToUpdate.push(log)\n                        } else {\n                            // Otherwise we add it to the list of hidden logs\n                            newLogs.push(log)\n                        }\n                    }\n\n                    if (existingLogsToUpdate.length) {\n                        // Update the existing logs with the new data\n                        actions.loadLogsSuccess(sanitizeGroupedLogs([...existingLogsToUpdate, ...values.logs]))\n                    }\n\n                    actions.scheduleLoadNewerLogs()\n\n                    return sanitizeGroupedLogs([...newLogs, ...values.hiddenLogs])\n                },\n                clearHiddenLogs: () => [],\n            },\n        ],\n    })),\n    reducers({\n        filters: [\n            {\n                search: '',\n                levels: DEFAULT_LOG_LEVELS,\n                date_from: '-7d',\n                date_to: undefined,\n            } as LogsViewerFilters,\n            {\n                setFilters: (state, { filters }) => ({\n                    ...state,\n                    ...filters,\n                }),\n            },\n        ],\n        isThereMoreToLoad: [\n            true,\n            {\n                markLogsEnd: () => false,\n                loadLogs: () => true,\n            },\n        ],\n        expandedRows: [\n            {} as Record<string, boolean>,\n            {\n                setRowExpanded: (state, { instanceId, expanded }) => ({\n                    ...state,\n                    [instanceId]: expanded,\n                }),\n            },\n        ],\n    }),\n    selectors(() => ({\n        newestLogTimestamp: [\n            (s) => [s.logs, s.hiddenLogs],\n            (logs: GroupedLogEntry[], hiddenLogs: GroupedLogEntry[]): Dayjs | null => {\n                return logs.concat(hiddenLogs).reduce((max, log) => {\n                    if (!max) {\n                        return log.maxTimestamp\n                    }\n                    return log.maxTimestamp.isAfter(max) ? log.maxTimestamp : max\n                }, null as Dayjs | null)\n            },\n        ],\n\n        oldestLogTimestamp: [\n            (s) => [s.logs, s.hiddenLogs],\n            (logs: GroupedLogEntry[], hiddenLogs: GroupedLogEntry[]): Dayjs | null => {\n                return logs.concat(hiddenLogs).reduce((min, log) => {\n                    if (!min) {\n                        return log.minTimestamp\n                    }\n                    return log.minTimestamp.isBefore(min) ? log.minTimestamp : min\n                }, null as Dayjs | null)\n            },\n        ],\n    })),\n    listeners(({ actions, cache }) => ({\n        setFilters: async (_, breakpoint) => {\n            await breakpoint(500)\n            actions.loadLogs()\n        },\n\n        loadLogsSuccess: () => {\n            actions.scheduleLoadNewerLogs()\n        },\n\n        scheduleLoadNewerLogs: () => {\n            if (cache.pollingTimeout) {\n                clearTimeout(cache.pollingTimeout)\n            }\n            cache.pollingTimeout = setTimeout(() => actions.loadNewerLogs(), 5000)\n        },\n    })),\n    events(({ actions, cache }) => ({\n        afterMount: () => {\n            actions.loadLogs()\n        },\n        beforeUnmount: () => {\n            clearInterval(cache.pollingTimeout)\n        },\n    })),\n])\n"],"names":[],"sourceRoot":""}