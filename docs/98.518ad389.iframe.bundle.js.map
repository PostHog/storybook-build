{"version":3,"file":"98.518ad389.iframe.bundle.js","mappings":";AAgTA;AACA;AACA;ACxPA;AACA;AAGA;AACA;AACA;AA2CA;AACA;;;ACzDA;;AAEA","sources":["webpack://@posthog/storybook/../../frontend/src/scenes/hog-functions/filters/HogFunctionFilters.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/hog-functions/configuration/components/hogFunctionSourceWebhookTestLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/hog-functions/logs/hogFunctionLogsLogic.ts"],"sourcesContent":["import { id } from 'chartjs-plugin-trendline'\nimport clsx from 'clsx'\nimport { useActions, useValues } from 'kea'\nimport { useMemo } from 'react'\n\nimport { IconCheck, IconX } from '@posthog/icons'\nimport { LemonBanner, LemonButton, LemonLabel, LemonSelect } from '@posthog/lemon-ui'\n\nimport { PropertyFilters } from 'lib/components/PropertyFilters/PropertyFilters'\nimport { ExcludedProperties, TaxonomicFilterGroupType } from 'lib/components/TaxonomicFilter/types'\nimport { TestAccountFilterSwitch } from 'lib/components/TestAccountFiltersSwitch'\nimport { useFeatureFlag } from 'lib/hooks/useFeatureFlag'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { ActionFilter } from 'scenes/insights/filters/ActionFilter/ActionFilter'\nimport { MathAvailability } from 'scenes/insights/filters/ActionFilter/ActionFilterRow/ActionFilterRow'\nimport MaxTool from 'scenes/max/MaxTool'\n\nimport { groupsModel } from '~/models/groupsModel'\nimport { AnyPropertyFilter, CyclotronJobFiltersType, EntityTypes, FilterType } from '~/types'\n\nimport { hogFunctionConfigurationLogic } from '../configuration/hogFunctionConfigurationLogic'\nimport { HogFunctionFiltersInternal } from './HogFunctionFiltersInternal'\n\nfunction sanitizeActionFilters(filters?: FilterType): Partial<CyclotronJobFiltersType> {\n    if (!filters) {\n        return {}\n    }\n    const sanitized: CyclotronJobFiltersType = {}\n\n    if (filters.events) {\n        sanitized.events = filters.events.map((f) => ({\n            id: f.id,\n            type: 'events',\n            name: f.name,\n            order: f.order,\n            properties: f.properties,\n        }))\n    }\n\n    if (filters.actions) {\n        sanitized.actions = filters.actions.map((f) => ({\n            id: f.id,\n            type: 'actions',\n            name: f.name,\n            order: f.order,\n            properties: f.properties,\n        }))\n    }\n\n    return sanitized\n}\n\nexport function HogFunctionFilters({\n    embedded = false,\n    showTriggerOptions = true,\n}: {\n    embedded?: boolean\n    showTriggerOptions?: boolean\n}): JSX.Element {\n    const { groupsTaxonomicTypes } = useValues(groupsModel)\n    const { configuration, type, useMapping, filtersContainPersonProperties, oldFilters, newFilters, isLegacyPlugin } =\n        useValues(hogFunctionConfigurationLogic)\n    const {\n        setOldFilters,\n        setNewFilters,\n        clearFiltersDiff,\n        reportAIFiltersPrompted,\n        reportAIFiltersAccepted,\n        reportAIFiltersRejected,\n        reportAIFiltersPromptOpen,\n    } = useActions(hogFunctionConfigurationLogic)\n\n    const isTransformation = type === 'transformation'\n    const cdpPersonUpdatesEnabled = useFeatureFlag('CDP_PERSON_UPDATES')\n\n    const excludedProperties: ExcludedProperties = {\n        [TaxonomicFilterGroupType.EventProperties]: [\n            '$exception_types',\n            '$exception_functions',\n            '$exception_values',\n            '$exception_sources',\n            '$exception_list',\n            '$exception_type',\n            '$exception_level',\n            '$exception_message',\n        ],\n    }\n\n    if (type === 'transformation') {\n        excludedProperties[TaxonomicFilterGroupType.Events] = ['$exception']\n    }\n\n    const taxonomicGroupTypes = useMemo(() => {\n        const types = [\n            TaxonomicFilterGroupType.EventProperties,\n            TaxonomicFilterGroupType.EventMetadata,\n            TaxonomicFilterGroupType.HogQLExpression,\n        ]\n\n        if (!isTransformation) {\n            types.push(\n                TaxonomicFilterGroupType.PersonProperties,\n                TaxonomicFilterGroupType.EventFeatureFlags,\n                TaxonomicFilterGroupType.Elements,\n                ...groupsTaxonomicTypes\n            )\n        }\n\n        return types\n    }, [isTransformation, groupsTaxonomicTypes])\n\n    const showMasking = type === 'destination' && !isLegacyPlugin && showTriggerOptions\n\n    if (type === 'internal_destination') {\n        return <HogFunctionFiltersInternal />\n    }\n\n    // NOTE: Mappings won't work for person updates currently as they are totally event based...\n    const showSourcePicker = cdpPersonUpdatesEnabled && type === 'destination' && !useMapping\n    const showEventMatchers = !useMapping && (configuration?.filters?.source ?? 'events') === 'events'\n\n    const mainContent = (\n        <div\n            className={clsx(\n                'deprecated-space-y-2 rounded bg-surface-primary',\n                !embedded && 'border p-3',\n                embedded && 'p-2'\n            )}\n        >\n            {showSourcePicker && (\n                <LemonField\n                    name=\"filters\"\n                    label=\"Source\"\n                    info={\n                        <>\n                            Select the source of events for the destination.\n                            <br />\n                            <b>Events</b> will trigger from the real-time stream of ingested events.\n                            <br />\n                            <b>Person updates</b> will trigger whenever a Person is created, updated or deleted.\n                        </>\n                    }\n                >\n                    {({ value, onChange }) => {\n                        return (\n                            <LemonSelect\n                                options={[\n                                    { value: 'events', label: 'Events' },\n                                    { value: 'person-updates', label: 'Person updates' },\n                                ]}\n                                value={value?.source ?? 'events'}\n                                onChange={(val) => {\n                                    onChange({ ...value, source: val })\n                                }}\n                            />\n                        )\n                    }}\n                </LemonField>\n            )}\n            <LemonField\n                name=\"filters\"\n                label={useMapping ? 'Global filters' : 'Filters'}\n                info={\n                    useMapping\n                        ? 'Filters applied to all events before they reach a mapping'\n                        : 'Filters applied to all events'\n                }\n            >\n                {({ value, onChange: _onChange }) => {\n                    const filters = (value ?? {}) as CyclotronJobFiltersType\n                    const currentFilters = newFilters ?? filters\n\n                    const onChange = (newValue: CyclotronJobFiltersType): void => {\n                        if (oldFilters && newFilters) {\n                            clearFiltersDiff()\n                        }\n                        _onChange(newValue)\n                    }\n\n                    return (\n                        <>\n                            {useMapping && (\n                                <p className=\"mb-0 text-sm text-secondary\">\n                                    Filters here apply for all events that could trigger this function, regardless of\n                                    mappings.\n                                </p>\n                            )}\n                            {!isTransformation && (\n                                <TestAccountFilterSwitch\n                                    checked={currentFilters?.filter_test_accounts ?? false}\n                                    onChange={(filter_test_accounts) => {\n                                        const newValue = { ...currentFilters, filter_test_accounts }\n                                        onChange(newValue)\n                                    }}\n                                    fullWidth\n                                />\n                            )}\n                            <PropertyFilters\n                                propertyFilters={(currentFilters?.properties ?? []) as AnyPropertyFilter[]}\n                                taxonomicGroupTypes={taxonomicGroupTypes}\n                                onChange={(properties: AnyPropertyFilter[]) => {\n                                    const newValue = {\n                                        ...currentFilters,\n                                        properties,\n                                    }\n                                    onChange(newValue as CyclotronJobFiltersType)\n                                }}\n                                pageKey={`HogFunctionPropertyFilters.${id}`}\n                                excludedProperties={excludedProperties}\n                            />\n\n                            {showEventMatchers ? (\n                                <>\n                                    <div className=\"flex gap-2 justify-between w-full\">\n                                        <LemonLabel>\n                                            {isTransformation ? 'Match events' : 'Match events and actions'}\n                                        </LemonLabel>\n                                    </div>\n                                    <p className=\"mb-0 text-xs text-secondary\">\n                                        If set, the {type} will only run if the <b>event matches any</b> of the below.\n                                    </p>\n                                    <ActionFilter\n                                        bordered\n                                        filters={currentFilters ?? {} /* TODO: this is any */}\n                                        setFilters={(payload) => {\n                                            onChange({\n                                                ...currentFilters,\n                                                ...sanitizeActionFilters(payload),\n                                            })\n                                        }}\n                                        typeKey=\"plugin-filters\"\n                                        mathAvailability={MathAvailability.None}\n                                        hideRename\n                                        hideDuplicate\n                                        showNestedArrow={false}\n                                        actionsTaxonomicGroupTypes={\n                                            isTransformation\n                                                ? [TaxonomicFilterGroupType.Events]\n                                                : [TaxonomicFilterGroupType.Events, TaxonomicFilterGroupType.Actions]\n                                        }\n                                        propertiesTaxonomicGroupTypes={taxonomicGroupTypes}\n                                        propertyFiltersPopover\n                                        addFilterDefaultOptions={{\n                                            id: '$pageview',\n                                            name: '$pageview',\n                                            type: EntityTypes.EVENTS,\n                                        }}\n                                        buttonCopy=\"Add event matcher\"\n                                        excludedProperties={excludedProperties}\n                                    />\n                                </>\n                            ) : null}\n                            {oldFilters && newFilters && (\n                                <div className=\"flex gap-2 items-center p-2 mt-4 rounded border border-dashed bg-surface-secondary\">\n                                    <div className=\"flex-1 text-center\">\n                                        <span className=\"text-sm font-medium\">Suggested by Max</span>\n                                    </div>\n                                    <div className=\"flex gap-2\">\n                                        <LemonButton\n                                            status=\"danger\"\n                                            icon={<IconX />}\n                                            onClick={() => {\n                                                onChange(oldFilters)\n                                                reportAIFiltersRejected()\n                                                clearFiltersDiff()\n                                            }}\n                                            tooltipPlacement=\"top\"\n                                            size=\"small\"\n                                        >\n                                            Reject\n                                        </LemonButton>\n                                        <LemonButton\n                                            type=\"tertiary\"\n                                            icon={<IconCheck color=\"var(--success)\" />}\n                                            onClick={() => {\n                                                onChange(newFilters)\n                                                reportAIFiltersAccepted()\n                                                clearFiltersDiff()\n                                            }}\n                                            tooltipPlacement=\"top\"\n                                            size=\"small\"\n                                        >\n                                            Accept\n                                        </LemonButton>\n                                    </div>\n                                </div>\n                            )}\n                        </>\n                    )\n                }}\n            </LemonField>\n\n            {filtersContainPersonProperties && showEventMatchers ? (\n                <LemonBanner type=\"warning\">\n                    You are filtering on Person properties. Be aware that this filtering applies at the time the event\n                    is processed so if Person Profiles are not enabled or the person property has not been set by then\n                    then the filters may not work as expected.\n                </LemonBanner>\n            ) : null}\n            {showMasking ? (\n                <LemonField\n                    name=\"masking\"\n                    label=\"Trigger options\"\n                    info={`\n                        You can configure the destination to only run once within a given time interval or until a certain number of events have been processed.\n                        This is useful for rate limiting the destination for example if you only want to receive one message per day.\n                    `}\n                >\n                    {({ value, onChange }) => (\n                        <div className=\"flex flex-wrap gap-1 items-center\">\n                            <LemonSelect\n                                options={[\n                                    {\n                                        value: null,\n                                        label: 'Run every time',\n                                    },\n                                    {\n                                        value: 'all',\n                                        label: 'Run once per interval',\n                                    },\n                                    {\n                                        value: '{person.id}',\n                                        label: 'Run once per person per interval',\n                                    },\n                                    {\n                                        value: '{concat(person.id, event.event)}',\n                                        label: 'Run once per person per event name per interval',\n                                    },\n                                ]}\n                                value={value?.hash ?? null}\n                                onChange={(val) =>\n                                    onChange({\n                                        hash: val,\n                                        ttl: value?.ttl ?? 60 * 30,\n                                    })\n                                }\n                            />\n                            {configuration.masking?.hash ? (\n                                <>\n                                    <div className=\"flex flex-wrap gap-1 items-center\">\n                                        <span>of</span>\n                                        <LemonSelect\n                                            value={value?.ttl}\n                                            onChange={(val) => onChange({ ...value, ttl: val })}\n                                            options={[\n                                                {\n                                                    value: 5 * 60,\n                                                    label: '5 minutes',\n                                                },\n                                                {\n                                                    value: 15 * 60,\n                                                    label: '15 minutes',\n                                                },\n                                                {\n                                                    value: 30 * 60,\n                                                    label: '30 minutes',\n                                                },\n                                                {\n                                                    value: 60 * 60,\n                                                    label: '1 hour',\n                                                },\n                                                {\n                                                    value: 2 * 60 * 60,\n                                                    label: '2 hours',\n                                                },\n                                                {\n                                                    value: 4 * 60 * 60,\n                                                    label: '4 hours',\n                                                },\n                                                {\n                                                    value: 8 * 60 * 60,\n                                                    label: '8 hours',\n                                                },\n                                                {\n                                                    value: 12 * 60 * 60,\n                                                    label: '12 hours',\n                                                },\n                                                {\n                                                    value: 24 * 60 * 60,\n                                                    label: '24 hours',\n                                                },\n                                            ]}\n                                        />\n                                    </div>\n                                    <div className=\"flex flex-wrap gap-1 items-center\">\n                                        <span>or until</span>\n                                        <LemonSelect\n                                            value={value?.threshold}\n                                            onChange={(val) => onChange({ ...value, threshold: val })}\n                                            options={[\n                                                {\n                                                    value: null,\n                                                    label: 'Not set',\n                                                },\n                                                {\n                                                    value: 1000,\n                                                    label: '1000 events',\n                                                },\n                                                {\n                                                    value: 10000,\n                                                    label: '10,000 events',\n                                                },\n                                                {\n                                                    value: 100000,\n                                                    label: '100,000 events',\n                                                },\n                                                {\n                                                    value: 1000000,\n                                                    label: '1,000,000 events',\n                                                },\n                                            ]}\n                                        />\n                                    </div>\n                                </>\n                            ) : null}\n                        </div>\n                    )}\n                </LemonField>\n            ) : null}\n        </div>\n    )\n\n    return (\n        <MaxTool\n            identifier=\"create_hog_function_filters\"\n            context={{\n                current_filters: JSON.stringify(configuration?.filters ?? {}),\n                function_type: type,\n            }}\n            callback={(toolOutput: string) => {\n                const parsedFilters = JSON.parse(toolOutput)\n                setOldFilters(configuration?.filters ?? {})\n                setNewFilters(parsedFilters)\n                reportAIFiltersPrompted()\n            }}\n            onMaxOpen={() => {\n                reportAIFiltersPromptOpen()\n            }}\n            introOverride={{\n                headline: 'What events and properties should trigger this function?',\n                description: 'Let me help you set up the right filters for your function.',\n            }}\n        >\n            {mainContent}\n        </MaxTool>\n    )\n}\n","import { actions, connect, kea, key, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\n\nimport { tryJsonParse } from 'lib/utils'\nimport { publicWebhooksHostOrigin } from 'lib/utils/apiHost'\n\nimport { HogFunctionConfigurationLogicProps, hogFunctionConfigurationLogic } from '../hogFunctionConfigurationLogic'\nimport type { hogFunctionSourceWebhookTestLogicType } from './hogFunctionSourceWebhookTestLogicType'\n\nexport type HogFunctionSourceWebhookTestForm = {\n    method: string\n    headers: string\n    query: string\n    body: string\n    mock_request: boolean\n}\n\nexport type HogFunctionSourceWebhookTestResult = {\n    status: number\n    body: string\n}\n\nexport const hogFunctionSourceWebhookTestLogic = kea<hogFunctionSourceWebhookTestLogicType>([\n    props({} as HogFunctionConfigurationLogicProps),\n    key(({ id, templateId }: HogFunctionConfigurationLogicProps) => {\n        return id ?? templateId ?? 'new'\n    }),\n\n    path((id) => ['scenes', 'pipeline', 'hogfunctions', 'hogFunctionSourceWebhookTestLogic', id]),\n    connect((props: HogFunctionConfigurationLogicProps) => ({\n        values: [hogFunctionConfigurationLogic(props), ['configuration', 'templateId']],\n    })),\n    actions({\n        setTestResult: (result: HogFunctionSourceWebhookTestResult | null) => ({ result }),\n        toggleExpanded: (expanded?: boolean) => ({ expanded }),\n    }),\n    reducers({\n        expanded: [\n            false as boolean,\n            {\n                toggleExpanded: (state, { expanded }) => (expanded === undefined ? !state : expanded),\n            },\n        ],\n\n        testResult: [\n            null as HogFunctionSourceWebhookTestResult | null,\n            {\n                setTestResult: (_, { result }) => result,\n            },\n        ],\n    }),\n\n    forms(({ props, actions }) => ({\n        testInvocation: {\n            defaults: {\n                mock_request: true,\n                method: 'POST',\n                headers: `{\n  \"Content-Type\": \"application/json\"\n}`,\n                query: '',\n                body: `{\n  \"event\": \"my example event\",\n  \"distinct_id\": \"webhook-test-123\"\n}`,\n            } as HogFunctionSourceWebhookTestForm,\n            alwaysShowErrors: true,\n            errors: ({ headers, body }) => {\n                return {\n                    headers: !headers ? 'Required' : tryJsonParse(headers) ? undefined : 'Invalid JSON',\n                    body: !body ? 'Required' : tryJsonParse(body) ? undefined : 'Invalid JSON',\n                }\n            },\n            submit: async (data) => {\n                actions.setTestResult(null)\n                const fetchOptions: RequestInit = {\n                    method: data.method,\n                    headers: tryJsonParse(data.headers),\n                    body: data.method == 'GET' ? undefined : data.body,\n                    credentials: 'omit',\n                }\n\n                const response = await fetch(\n                    `${publicWebhooksHostOrigin()}/public/webhooks/${props.id ?? 'unknown'}${data.query ? `?${data.query}` : ''}`,\n                    fetchOptions\n                )\n\n                actions.setTestResult({\n                    status: response.status,\n                    body: await response.text(),\n                })\n            },\n        },\n    })),\n\n    selectors({\n        exampleCurlRequest: [\n            (s) => [s.testInvocation, (_, props) => props],\n            (testInvocation, props) => {\n                const headersJson = tryJsonParse(testInvocation.headers)\n                const headers = headersJson\n                    ? Object.entries(headersJson)\n                          .map(([key, value]) => `-H \"${key}: ${value}\"`)\n                          .join(' ')\n                    : ''\n\n                return `curl -X ${testInvocation.method} ${headers} \\\\\n  -d '${testInvocation.body}' \\\\\n  ${publicWebhooksHostOrigin()}/public/webhooks/${props.id ?? 'unknown'}${testInvocation.query ? `?${testInvocation.query}` : ''}`\n            },\n        ],\n    }),\n])\n","import { actions, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { beforeUnload } from 'kea-router'\n\nimport { lemonToast } from '@posthog/lemon-ui'\n\nimport api from 'lib/api'\nimport { Dayjs, dayjs } from 'lib/dayjs'\n\nimport { hogql } from '~/queries/utils'\nimport { LogEntryLevel } from '~/types'\n\nimport type { hogFunctionLogsLogicType } from './hogFunctionLogsLogicType'\nimport { GroupedLogEntry, LogsViewerLogicProps, logsViewerLogic } from './logsViewerLogic'\n\nexport type RetryInvocationState = 'pending' | 'success' | 'failure'\n\nconst eventIdMatchers = [/Event: ([A-Za-z0-9-]+)/, /\\/events\\/([A-Za-z0-9-]+)\\//, /event ([A-Za-z0-9-]+)/]\n\nasync function runWithParallelism<T, R>(\n    items: T[],\n    maxParallel: number,\n    asyncFn: (item: T) => Promise<R>\n): Promise<R[]> {\n    const results: R[] = []\n    const executing = new Set<Promise<void>>()\n\n    for (const item of items) {\n        const promise = (async () => {\n            const result = await asyncFn(item)\n            results.push(result)\n        })()\n\n        executing.add(promise)\n        void promise.finally(() => executing.delete(promise))\n\n        if (executing.size >= maxParallel) {\n            await Promise.race(executing)\n        }\n    }\n\n    await Promise.all(executing)\n    return results\n}\n\nconst loadClickhouseEvents = async (\n    eventIds: string[],\n    { date_from, date_to }: { date_from?: string; date_to?: string }\n): Promise<any[]> => {\n    const query = hogql`\n        SELECT uuid, distinct_id, event, timestamp, properties, elements_chain, person.id, person.properties, person.created_at \n        FROM events\n        WHERE uuid in (${hogql.raw(eventIds.map((x) => `'${x}'`).join(','))})\n        AND timestamp > {filters.dateRange.from}\n        AND timestamp < {filters.dateRange.to}`\n\n    const response = await api.queryHogQL(query, {\n        refresh: 'force_blocking',\n        filtersOverride: {\n            date_from: date_from,\n            date_to: date_to,\n        },\n    })\n\n    return response.results.map((x) => {\n        const [\n            uuid,\n            distinct_id,\n            event,\n            timestamp,\n            properties,\n            elements_chain,\n            person_id,\n            person_properties,\n            person_created_at,\n        ] = x\n\n        return {\n            uuid,\n            event,\n            distinct_id,\n            person_id,\n            timestamp,\n            properties,\n            elements_chain,\n            person_created_at,\n            person_properties,\n        }\n    })\n}\n\nexport const hogFunctionLogsLogic = kea<hogFunctionLogsLogicType>([\n    path((key) => ['scenes', 'pipeline', 'hogfunctions', 'logs', 'hogFunctionLogsLogic', key]),\n    props({} as LogsViewerLogicProps), // TODO: Remove `stage` from props, it isn't needed here for anything\n    key(({ sourceType, sourceId }) => `${sourceType}:${sourceId}`),\n    connect((props: LogsViewerLogicProps) => ({\n        values: [logsViewerLogic(props), ['groupedLogs']],\n        actions: [logsViewerLogic(props), ['addLogGroups', 'setRowExpanded']],\n    })),\n    actions({\n        setSelectingMany: (selectingMany: boolean) => ({ selectingMany }),\n        setSelectedForRetry: (selectedForRetry: Record<string, boolean>) => ({ selectedForRetry }),\n        selectAllForRetry: true,\n        retryInvocation: (groupedLogEntry: GroupedLogEntry, eventId: string) => ({ groupedLogEntry, eventId }),\n        retryInvocations: (groupedLogEntries: GroupedLogEntry[]) => ({ groupedLogEntries }),\n        retryInvocationStarted: (groupedLogEntry: GroupedLogEntry) => ({ groupedLogEntry }),\n        retryInvocationSuccess: (groupedLogEntry: GroupedLogEntry) => ({ groupedLogEntry }),\n        retryInvocationFailure: (groupedLogEntry: GroupedLogEntry) => ({ groupedLogEntry }),\n        retrySelectedInvocations: true,\n    }),\n    reducers({\n        selectingMany: [\n            false,\n            {\n                setSelectingMany: (_, { selectingMany }) => selectingMany,\n            },\n        ],\n\n        selectedForRetry: [\n            {} as Record<string, boolean>,\n            {\n                setSelectedForRetry: (state, { selectedForRetry }) => {\n                    const newState = { ...state }\n                    Object.keys(selectedForRetry).forEach((key) => {\n                        newState[key] = selectedForRetry[key]\n\n                        if (!selectedForRetry[key]) {\n                            delete newState[key]\n                        }\n                    })\n                    return newState\n                },\n\n                setSelectingMany: (state, { selectingMany }) => {\n                    return selectingMany ? state : {}\n                },\n            },\n        ],\n\n        retries: [\n            {} as Record<string, RetryInvocationState>,\n            {\n                retryInvocationStarted: (state, { groupedLogEntry }) => {\n                    return {\n                        ...state,\n                        [groupedLogEntry.instanceId]: 'pending',\n                    }\n                },\n\n                retryInvocationSuccess: (state, { groupedLogEntry }) => {\n                    return {\n                        ...state,\n                        [groupedLogEntry.instanceId]: 'success',\n                    }\n                },\n\n                retryInvocationFailure: (state, { groupedLogEntry }) => {\n                    return {\n                        ...state,\n                        [groupedLogEntry.instanceId]: 'failure',\n                    }\n                },\n            },\n        ],\n    }),\n\n    selectors({\n        retryRunning: [\n            (s) => [s.retries],\n            (retries) => {\n                return Object.values(retries).some((x) => x === 'pending')\n            },\n        ],\n\n        eventIdByInvocationId: [\n            (s) => [s.groupedLogs],\n            (groupedLogs) => {\n                const eventIdByInvocationId: Record<string, string> = {}\n\n                for (const record of groupedLogs) {\n                    // TRICKY: We have the event ID in different places in different logs. We will standardise this to be the invocation ID in the future.\n                    const entryContainingEventId = record.entries.find(\n                        (entry) =>\n                            entry.message.includes('Function completed') ||\n                            entry.message.includes('Suspending function') ||\n                            entry.message.includes('Error executing function on event')\n                    )\n\n                    if (!entryContainingEventId) {\n                        return undefined\n                    }\n\n                    for (const matcher of eventIdMatchers) {\n                        const match = entryContainingEventId.message.match(matcher)\n                        if (match) {\n                            eventIdByInvocationId[record.instanceId] = match[1]\n                            break\n                        }\n                    }\n                }\n\n                return eventIdByInvocationId\n            },\n        ],\n    }),\n    listeners(({ actions, props, values }) => ({\n        retryInvocations: async ({ groupedLogEntries }) => {\n            await lemonToast.promise(\n                (async () => {\n                    for (const groupedLogEntry of groupedLogEntries) {\n                        actions.retryInvocationStarted(groupedLogEntry)\n                    }\n\n                    if (groupedLogEntries.length === 1) {\n                        // If we only have one log group then we can just expand it to be a little more user friendly\n                        actions.setRowExpanded(groupedLogEntries[0].instanceId, true)\n                    }\n\n                    // We want to get the oldest and newest \"min\" timestamp as that will be closest to when the event was processed\n                    // NOTE: This isn't perfect as the event timestamp might be different to the time it was processed\n                    const [timestampRangeStart, timestampRangeEnd] = groupedLogEntries.reduce(\n                        ([accStart, accEnd], x) => {\n                            if (!accStart) {\n                                return [x.minTimestamp, x.minTimestamp]\n                            }\n\n                            return [\n                                x.minTimestamp.isBefore(accStart) ? x.minTimestamp : accStart,\n                                x.maxTimestamp.isAfter(accEnd) ? x.maxTimestamp : accEnd,\n                            ]\n                        },\n                        [null as Dayjs | null, null as Dayjs | null]\n                    )\n\n                    // Load all events by ID using the date range to speed up the query (we add time either side to account for processing delays)\n                    const events = await loadClickhouseEvents(Object.values(values.eventIdByInvocationId ?? {}), {\n                        date_from: timestampRangeStart?.subtract(1, 'day').toISOString(),\n                        date_to: timestampRangeEnd?.add(1, 'day').toISOString(),\n                    })\n\n                    const eventsById: Record<string, any> = {}\n                    for (const event of events) {\n                        eventsById[event.uuid] = event\n                    }\n\n                    await runWithParallelism(groupedLogEntries, 10, async (groupedLogEntry) => {\n                        try {\n                            // If we have an event then retry it, otherwise fail\n                            const event = eventsById[values.eventIdByInvocationId![groupedLogEntry.instanceId]]\n\n                            if (!event) {\n                                actions.retryInvocationFailure(groupedLogEntry)\n                                return\n                            }\n\n                            const res = await api.hogFunctions.createTestInvocation(props.sourceId, {\n                                clickhouse_event: event,\n                                mock_async_functions: false,\n                                configuration: {\n                                    // For retries we don't care about filters\n                                    filters: {},\n                                },\n                                invocation_id: groupedLogEntry.instanceId,\n                            })\n\n                            const newLogGroup: GroupedLogEntry = {\n                                ...groupedLogEntry,\n                                entries: [\n                                    ...groupedLogEntry.entries,\n                                    ...res.logs.map((x) => ({\n                                        timestamp: dayjs(x.timestamp),\n                                        level: x.level.toUpperCase() as LogEntryLevel,\n                                        message: x.message,\n                                        instanceId: groupedLogEntry.instanceId,\n                                    })),\n                                ],\n                            }\n\n                            actions.addLogGroups([newLogGroup])\n                            actions.retryInvocationSuccess(groupedLogEntry)\n                        } catch {\n                            actions.retryInvocationFailure(groupedLogEntry)\n                        }\n                    })\n\n                    actions.setSelectingMany(false)\n                })(),\n                {\n                    success: 'Retries complete!',\n                    error: 'Retry failed!',\n                    pending: 'Retrying...',\n                }\n            )\n        },\n\n        retrySelectedInvocations: async () => {\n            const groupsToRetry = values.groupedLogs.filter((x) => values.selectedForRetry[x.instanceId])\n\n            actions.retryInvocations(groupsToRetry)\n        },\n\n        selectAllForRetry: async () => {\n            actions.setSelectingMany(true)\n\n            for (const groupedLogEntry of values.groupedLogs) {\n                actions.setSelectedForRetry({\n                    [groupedLogEntry.instanceId]: true,\n                })\n            }\n        },\n    })),\n\n    beforeUnload(({ values, cache }) => ({\n        enabled: () => !cache.disabledBeforeUnload && values.retryRunning,\n        message: 'You have running retries that will be discarded if you leave. Are you sure?',\n        onConfirm: () => {\n            cache.disabledBeforeUnload = true\n        },\n    })),\n])\n"],"names":[],"sourceRoot":""}