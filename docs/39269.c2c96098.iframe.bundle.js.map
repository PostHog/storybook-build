{"version":3,"file":"39269.c2c96098.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAuHA;;AAEA;;;;;;;;;;;;;;;;;AA4DA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;;AAkFA;AACA;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;;;AAGA;AACA;;;AAqEA;AACA;AACA;AACA;;AAEA;;;AAsBA;AACA;AACA;AACA;;;;;;;;AAsCA;AACA;AACA;;;AAGA","sources":["webpack://@posthog/storybook/../../frontend/src/scenes/sessions/sessionProfileLogic.ts"],"sourcesContent":["import { actions, events, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\n\nimport api from 'lib/api'\n\nimport { NodeKind } from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\nimport { SessionEventType } from '~/types'\n\nimport type { sessionProfileLogicType } from './sessionProfileLogicType'\n\nexport interface SessionProfileLogicProps {\n    sessionId: string\n}\n\nexport interface SessionData {\n    session_id: string\n    distinct_id: string\n    person_properties: Record<string, any> | null\n    start_timestamp: string\n    end_timestamp: string\n    entry_current_url: string | null\n    end_current_url: string | null\n    urls: string[]\n    num_uniq_urls: number\n    pageview_count: number\n    autocapture_count: number\n    screen_count: number\n    session_duration: number\n    channel_type: string | null\n    is_bounce: boolean\n    entry_hostname: string | null\n    entry_pathname: string | null\n    entry_utm_source: string | null\n    entry_utm_campaign: string | null\n    entry_utm_medium: string | null\n    entry_referring_domain: string | null\n    last_external_click_url: string | null\n}\n\nexport const sessionProfileLogic = kea<sessionProfileLogicType>([\n    path(['scenes', 'sessions', 'sessionProfileLogic']),\n    props({} as SessionProfileLogicProps),\n    key((props) => props.sessionId),\n    actions({\n        loadSessionData: true,\n        loadSessionEvents: true,\n        loadMoreSessionEvents: true,\n        loadEventDetails: (eventId: string, eventName: string) => ({ eventId, eventName }),\n        setHasMoreEvents: (hasMore: boolean) => ({ hasMore }),\n        updateEventsOffset: (offset: number) => ({ offset }),\n        loadTotalEventCount: true,\n        setSortOrder: (sortOrder: 'asc' | 'desc') => ({ sortOrder }),\n        loadRecordingAvailability: true,\n        setEventsListFolded: (isFolded: boolean) => ({ isFolded }),\n        loadSupportTicketEvents: true,\n    }),\n    reducers({\n        hasMoreEvents: [\n            true,\n            {\n                loadSessionEventsSuccess: (_, { sessionEvents }) => sessionEvents.length === 50,\n                setHasMoreEvents: (_, { hasMore }) => hasMore,\n            },\n        ],\n        eventsOffset: [\n            0 as number,\n            {\n                loadSessionEventsSuccess: (_, { sessionEvents }) => sessionEvents.length,\n                loadMoreSessionEvents: (state) => state, // Preserve before loading\n                updateEventsOffset: (_, { offset }) => offset,\n                setSortOrder: () => 0, // Reset offset when sort changes\n            },\n        ],\n        sortOrder: [\n            'asc' as 'asc' | 'desc',\n            {\n                setSortOrder: (_, { sortOrder }) => sortOrder,\n            },\n        ],\n        eventsListFolded: [\n            false,\n            {\n                setEventsListFolded: (_, { isFolded }) => isFolded,\n            },\n        ],\n    }),\n    loaders(({ props, values }) => ({\n        sessionData: [\n            null as SessionData | null,\n            {\n                loadSessionData: async () => {\n                    const sessionQuery = hogql`\n                        SELECT\n                            sessions.session_id,\n                            sessions.distinct_id,\n                            persons.properties,\n                            sessions.$start_timestamp,\n                            sessions.$end_timestamp,\n                            sessions.$entry_current_url,\n                            sessions.$end_current_url,\n                            sessions.$urls,\n                            sessions.$num_uniq_urls,\n                            sessions.$pageview_count,\n                            sessions.$autocapture_count,\n                            sessions.$screen_count,\n                            sessions.$session_duration,\n                            sessions.$channel_type,\n                            sessions.$is_bounce,\n                            sessions.$entry_hostname,\n                            sessions.$entry_pathname,\n                            sessions.$entry_utm_source,\n                            sessions.$entry_utm_campaign,\n                            sessions.$entry_utm_medium,\n                            sessions.$entry_referring_domain,\n                            sessions.$last_external_click_url\n                        FROM sessions\n                        LEFT JOIN person_distinct_ids ON person_distinct_ids.distinct_id = sessions.distinct_id\n                        LEFT JOIN persons ON persons.id = person_distinct_ids.person_id\n                        WHERE sessions.session_id = ${props.sessionId}\n                        LIMIT 1\n                    `\n\n                    const response = await api.queryHogQL(sessionQuery)\n                    const row = response.results?.[0]\n\n                    if (!row) {\n                        return null\n                    }\n\n                    return {\n                        session_id: row[0],\n                        distinct_id: row[1],\n                        person_properties: row[2] ? JSON.parse(row[2]) : null,\n                        start_timestamp: row[3],\n                        end_timestamp: row[4],\n                        entry_current_url: row[5],\n                        end_current_url: row[6],\n                        urls: row[7] || [],\n                        num_uniq_urls: row[8] || 0,\n                        pageview_count: row[9] || 0,\n                        autocapture_count: row[10] || 0,\n                        screen_count: row[11] || 0,\n                        session_duration: row[12] || 0,\n                        channel_type: row[13],\n                        is_bounce: row[14] || false,\n                        entry_hostname: row[15],\n                        entry_pathname: row[16],\n                        entry_utm_source: row[17],\n                        entry_utm_campaign: row[18],\n                        entry_utm_medium: row[19],\n                        entry_referring_domain: row[20],\n                        last_external_click_url: row[21],\n                    }\n                },\n            },\n        ],\n        sessionEvents: [\n            null as SessionEventType[] | null,\n            {\n                loadSessionEvents: async () => {\n                    const sortOrder = values.sortOrder || 'asc'\n                    const eventsQuery =\n                        sortOrder === 'asc'\n                            ? hogql`\n                        SELECT\n                            uuid,\n                            event,\n                            timestamp,\n                            properties.$window_id,\n                            properties.$current_url,\n                            properties.$event_type,\n                            properties.$screen_name,\n                            properties.$pathname,\n                            properties.$exception_type,\n                            properties.$exception_message,\n                            properties.$console_log_level,\n                            properties.$response_status,\n                            properties.$exception_list,\n                            distinct_id\n                        FROM events\n                        WHERE timestamp >= UUIDv7ToDateTime(toUUID(${props.sessionId}))\n                            AND timestamp <= UUIDv7ToDateTime(toUUID(${props.sessionId})) + INTERVAL 2 DAY\n                            AND \\`$session_id\\` = ${props.sessionId}\n                        ORDER BY timestamp ASC\n                        LIMIT 50\n                    `\n                            : hogql`\n                        SELECT\n                            uuid,\n                            event,\n                            timestamp,\n                            properties.$window_id,\n                            properties.$current_url,\n                            properties.$event_type,\n                            properties.$screen_name,\n                            properties.$pathname,\n                            properties.$exception_type,\n                            properties.$exception_message,\n                            properties.$console_log_level,\n                            properties.$response_status,\n                            properties.$exception_list,\n                            distinct_id\n                        FROM events\n                        WHERE timestamp >= UUIDv7ToDateTime(toUUID(${props.sessionId}))\n                            AND timestamp <= UUIDv7ToDateTime(toUUID(${props.sessionId})) + INTERVAL 2 DAY\n                            AND \\`$session_id\\` = ${props.sessionId}\n                        ORDER BY timestamp DESC\n                        LIMIT 50\n                    `\n\n                    const response = await api.queryHogQL(eventsQuery)\n\n                    return (response.results || []).map((row: any): SessionEventType => {\n                        const properties: Record<string, any> = {}\n\n                        // Only add properties if they have values (not null/undefined)\n                        if (row[3] != null) {\n                            properties.$window_id = row[3]\n                        }\n                        if (row[4] != null) {\n                            properties.$current_url = row[4]\n                        }\n                        if (row[5] != null) {\n                            properties.$event_type = row[5]\n                        }\n                        if (row[6] != null) {\n                            properties.$screen_name = row[6]\n                        }\n                        if (row[7] != null) {\n                            properties.$pathname = row[7]\n                        }\n                        if (row[8] != null) {\n                            properties.$exception_type = row[8]\n                        }\n                        if (row[9] != null) {\n                            properties.$exception_message = row[9]\n                        }\n                        if (row[10] != null) {\n                            properties.$console_log_level = row[10]\n                        }\n                        if (row[11] != null) {\n                            properties.$response_status = row[11]\n                        }\n\n                        // Parse $exception_list if it exists (comes as JSON string)\n                        if (row[12] != null) {\n                            try {\n                                properties.$exception_list = JSON.parse(row[12])\n                            } catch (e) {\n                                console.error(e)\n                                properties.$exception_list = []\n                            }\n                        }\n\n                        return {\n                            id: row[0],\n                            event: row[1],\n                            timestamp: row[2],\n                            properties,\n                            distinct_id: row[13],\n                            fullyLoaded: false,\n                        }\n                    })\n                },\n                loadMoreSessionEvents: async (_, breakpoint) => {\n                    await breakpoint(500) // Debounce rapid scroll\n\n                    const currentEvents = values.sessionEvents || []\n                    const offset = values.eventsOffset\n                    const sortOrder = values.sortOrder || 'asc'\n\n                    const eventsQuery =\n                        sortOrder === 'asc'\n                            ? hogql`\n                        SELECT\n                            uuid,\n                            event,\n                            timestamp,\n                            properties.$window_id,\n                            properties.$current_url,\n                            properties.$event_type,\n                            properties.$screen_name,\n                            properties.$pathname,\n                            properties.$exception_type,\n                            properties.$exception_message,\n                            properties.$console_log_level,\n                            properties.$response_status,\n                            properties.$exception_list,\n                            distinct_id\n                        FROM events\n                        WHERE timestamp >= UUIDv7ToDateTime(toUUID(${props.sessionId}))\n                            AND timestamp <= UUIDv7ToDateTime(toUUID(${props.sessionId})) + INTERVAL 2 DAY\n                            AND \\`$session_id\\` = ${props.sessionId}\n                        ORDER BY timestamp ASC\n                        LIMIT 50\n                        OFFSET ${offset}\n                    `\n                            : hogql`\n                        SELECT\n                            uuid,\n                            event,\n                            timestamp,\n                            properties.$window_id,\n                            properties.$current_url,\n                            properties.$event_type,\n                            properties.$screen_name,\n                            properties.$pathname,\n                            properties.$exception_type,\n                            properties.$exception_message,\n                            properties.$console_log_level,\n                            properties.$response_status,\n                            properties.$exception_list,\n                            distinct_id\n                        FROM events\n                        WHERE timestamp >= UUIDv7ToDateTime(toUUID(${props.sessionId}))\n                            AND timestamp <= UUIDv7ToDateTime(toUUID(${props.sessionId})) + INTERVAL 2 DAY\n                            AND \\`$session_id\\` = ${props.sessionId}\n                        ORDER BY timestamp DESC\n                        LIMIT 50\n                        OFFSET ${offset}\n                    `\n\n                    const response = await api.queryHogQL(eventsQuery)\n\n                    const newEvents = (response.results || []).map((row: any): SessionEventType => {\n                        const properties: Record<string, any> = {}\n\n                        if (row[3] != null) {\n                            properties.$window_id = row[3]\n                        }\n                        if (row[4] != null) {\n                            properties.$current_url = row[4]\n                        }\n                        if (row[5] != null) {\n                            properties.$event_type = row[5]\n                        }\n                        if (row[6] != null) {\n                            properties.$screen_name = row[6]\n                        }\n                        if (row[7] != null) {\n                            properties.$pathname = row[7]\n                        }\n                        if (row[8] != null) {\n                            properties.$exception_type = row[8]\n                        }\n                        if (row[9] != null) {\n                            properties.$exception_message = row[9]\n                        }\n                        if (row[10] != null) {\n                            properties.$console_log_level = row[10]\n                        }\n                        if (row[11] != null) {\n                            properties.$response_status = row[11]\n                        }\n\n                        if (row[12] != null) {\n                            try {\n                                properties.$exception_list = JSON.parse(row[12])\n                            } catch (e) {\n                                console.error(e)\n                                properties.$exception_list = []\n                            }\n                        }\n\n                        return {\n                            id: row[0],\n                            event: row[1],\n                            timestamp: row[2],\n                            properties,\n                            distinct_id: row[13],\n                            fullyLoaded: false,\n                        }\n                    })\n\n                    // Append new events to existing events\n                    return [...currentEvents, ...newEvents]\n                },\n            },\n        ],\n        eventDetails: [\n            {} as Record<string, Record<string, any>>,\n            {\n                loadEventDetails: async ({ eventId, eventName }) => {\n                    // Fetch full properties for the specific event\n                    // Use timestamp filtering based on session_id to enable partition pruning\n                    // Also filter by event name to improve query performance\n                    const detailsQuery = hogql`\n                        SELECT properties, uuid\n                        FROM events\n                        WHERE event = ${eventName}\n                        AND timestamp >= UUIDv7ToDateTime(toUUID(${props.sessionId}))\n                        AND timestamp <= UUIDv7ToDateTime(toUUID(${props.sessionId})) + INTERVAL 2 DAY\n                        AND uuid = ${eventId}\n                        LIMIT 1\n                    `\n\n                    const response = await api.queryHogQL(detailsQuery)\n\n                    if (!response.results || response.results.length === 0) {\n                        return {}\n                    }\n\n                    const [propertiesJson, uuid] = response.results[0]\n                    const fullProperties = JSON.parse(propertiesJson)\n\n                    return { [uuid]: fullProperties }\n                },\n            },\n        ],\n        totalEventCount: [\n            null as number | null,\n            {\n                loadTotalEventCount: async () => {\n                    const countQuery = hogql`\n                        SELECT count(*) as total\n                        FROM events\n                        WHERE timestamp >= UUIDv7ToDateTime(toUUID(${props.sessionId}))\n                            AND timestamp <= UUIDv7ToDateTime(toUUID(${props.sessionId})) + INTERVAL 2 DAY\n                            AND \\`$session_id\\` = ${props.sessionId}\n                    `\n\n                    const response = await api.queryHogQL(countQuery)\n                    return response.results?.[0]?.[0] || 0\n                },\n            },\n        ],\n        hasRecording: [\n            false as boolean,\n            {\n                loadRecordingAvailability: async () => {\n                    // Use UUIDv7 timestamp for partition pruning (session_id is UUIDv7)\n                    const startTime = `UUIDv7ToDateTime(toUUID('${props.sessionId}'))`\n                    const endTime = `${startTime} + INTERVAL 1 DAY`\n\n                    const response = await api.recordings.list({\n                        kind: NodeKind.RecordingsQuery,\n                        session_ids: [props.sessionId],\n                        date_from: startTime,\n                        date_to: endTime,\n                        limit: 1,\n                    })\n                    return (response.results?.length ?? 0) > 0\n                },\n            },\n        ],\n        supportTicketEvents: [\n            [] as SessionEventType[],\n            {\n                loadSupportTicketEvents: async () => {\n                    const ticketsQuery = hogql`\n                        SELECT\n                            uuid,\n                            event,\n                            timestamp,\n                            properties.zendesk_ticket_id,\n                            distinct_id\n                        FROM events\n                        WHERE timestamp >= UUIDv7ToDateTime(toUUID(${props.sessionId}))\n                            AND timestamp <= UUIDv7ToDateTime(toUUID(${props.sessionId})) + INTERVAL 2 DAY\n                            AND \\`$session_id\\` = ${props.sessionId}\n                            AND event = 'support_ticket'\n                        ORDER BY timestamp DESC\n                    `\n\n                    const response = await api.queryHogQL(ticketsQuery)\n\n                    return (response.results || []).map((row: any): SessionEventType => {\n                        const properties: Record<string, any> = {}\n\n                        if (row[3] != null) {\n                            properties.zendesk_ticket_id = row[3]\n                        }\n\n                        return {\n                            id: row[0],\n                            event: row[1],\n                            timestamp: row[2],\n                            properties,\n                            distinct_id: row[4],\n                            fullyLoaded: false,\n                        }\n                    })\n                },\n            },\n        ],\n    })),\n    selectors({\n        sessionId: [() => [(_, props) => props.sessionId], (sessionId) => sessionId],\n        sessionDuration: [\n            (s) => [s.sessionData],\n            (sessionData: SessionData | null): number | null => {\n                // Session duration is already calculated in seconds in the table\n                return sessionData?.session_duration || null\n            },\n        ],\n        uniqueUrlCount: [\n            (s) => [s.sessionData],\n            (sessionData: SessionData | null): number => {\n                return sessionData?.num_uniq_urls || 0\n            },\n        ],\n        categorizedEventCount: [\n            (s) => [s.sessionData],\n            (sessionData: SessionData | null): number => {\n                if (!sessionData) {\n                    return 0\n                }\n                return (\n                    (sessionData.pageview_count || 0) +\n                    (sessionData.autocapture_count || 0) +\n                    (sessionData.screen_count || 0)\n                )\n            },\n        ],\n        otherEventCount: [\n            (s) => [s.totalEventCount, s.sessionData],\n            (totalEventCount: number | null, sessionData: SessionData | null): number => {\n                if (!totalEventCount || !sessionData) {\n                    return 0\n                }\n                const categorized =\n                    (sessionData.pageview_count || 0) +\n                    (sessionData.autocapture_count || 0) +\n                    (sessionData.screen_count || 0)\n                return Math.max(0, totalEventCount - categorized)\n            },\n        ],\n        isInitialLoading: [\n            (s) => [s.sessionDataLoading, s.sessionEventsLoading, s.sessionEvents],\n            (\n                sessionDataLoading: boolean,\n                sessionEventsLoading: boolean,\n                sessionEvents: SessionEventType[] | null\n            ): boolean => (sessionDataLoading || sessionEventsLoading) && sessionEvents === null,\n        ],\n        isLoadingMore: [\n            (s) => [s.sessionEventsLoading, s.sessionEvents],\n            (sessionEventsLoading: boolean, sessionEvents: SessionEventType[] | null): boolean =>\n                sessionEventsLoading && sessionEvents !== null,\n        ],\n    }),\n    listeners(({ actions, values }) => ({\n        loadSessionData: () => {\n            actions.loadSessionEvents()\n            actions.loadTotalEventCount()\n            actions.loadRecordingAvailability()\n            actions.loadSupportTicketEvents()\n        },\n        setSortOrder: () => {\n            // Reset hasMoreEvents when changing sort order\n            actions.setHasMoreEvents(true)\n            // Reload events with new sort order\n            actions.loadSessionEvents()\n        },\n        loadMoreSessionEventsSuccess: ({ sessionEvents }) => {\n            const previousCount = values.eventsOffset\n            const newCount = sessionEvents.length\n            const fetchedCount = newCount - previousCount\n\n            // Stop loading if we fetched less than 50 events (or if something went wrong)\n            if (fetchedCount < 50) {\n                actions.setHasMoreEvents(false)\n            }\n\n            // Only update offset if we actually got new events\n            if (fetchedCount > 0) {\n                actions.updateEventsOffset(newCount)\n            }\n        },\n        loadEventDetailsSuccess: ({ eventDetails }) => {\n            // After loading event details, update the sessionEvents array\n            const events = values.sessionEvents\n            if (!events || !eventDetails || Object.keys(eventDetails).length === 0) {\n                return\n            }\n\n            const updatedEvents = events.map((event) => {\n                const fullProperties = eventDetails[event.id]\n                if (fullProperties) {\n                    return {\n                        ...event,\n                        properties: {\n                            ...event.properties,\n                            ...fullProperties,\n                        },\n                        fullyLoaded: true,\n                    }\n                }\n                return event\n            })\n\n            actions.loadSessionEventsSuccess(updatedEvents)\n        },\n    })),\n    events(({ actions }) => ({\n        afterMount: () => {\n            actions.loadSessionData()\n        },\n    })),\n])\n"],"names":[],"sourceRoot":""}