{"version":3,"file":"12951.a4711fb0.iframe.bundle.js","mappings":";;;;AA0DA;;AAEA;;;;;;AAsBA","sources":["webpack://posthog/./frontend/src/scenes/heatmaps/heatmapsBrowserLogic.ts"],"sourcesContent":["import { actions, afterMount, connect, kea, listeners, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { authorizedUrlListLogic, AuthorizedUrlListType } from 'lib/components/AuthorizedUrlList/authorizedUrlListLogic'\nimport { RefObject } from 'react'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\nimport { PostHogAppToolbarEvent } from '~/toolbar/bar/toolbarLogic'\n\nimport type { heatmapsBrowserLogicType } from './heatmapsBrowserLogicType'\n\nexport type HeatmapsBrowserLogicProps = {\n    iframeRef: RefObject<HTMLIFrameElement | null>\n}\n\nexport const heatmapsBrowserLogic = kea<heatmapsBrowserLogicType>([\n    path(['scenes', 'heatmaps', 'heatmapsBrowserLogic']),\n    props({} as HeatmapsBrowserLogicProps),\n\n    connect({\n        values: [\n            authorizedUrlListLogic({ actionId: null, type: AuthorizedUrlListType.TOOLBAR_URLS }),\n            ['urlsKeyed', 'checkUrlIsAuthorized'],\n        ],\n    }),\n\n    actions({\n        setBrowserSearch: (searchTerm: string) => ({ searchTerm }),\n        setBrowserUrl: (url: string) => ({ url }),\n        setIframePosthogJsConnected: (ready: boolean) => ({ ready }),\n        onIframeLoad: true,\n        onIframeToolbarLoad: true,\n        sendToolbarMessage: (type: PostHogAppToolbarEvent, payload?: Record<string, any>) => ({\n            type,\n            payload,\n        }),\n        setLoading: (loading: boolean) => ({ loading }),\n        loadTopUrls: true,\n        maybeLoadTopUrls: true,\n        loadBrowserSearchResults: true,\n    }),\n\n    loaders(({ values }) => ({\n        browserSearchResults: [\n            null as string[] | null,\n            {\n                loadBrowserSearchResults: async () => {\n                    if (!values.browserSearchTerm) {\n                        return []\n                    }\n\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT distinct properties.$current_url AS urls\n                                FROM events\n                                WHERE timestamp >= now() - INTERVAL 7 DAY\n                                AND timestamp <= now()\n                                AND properties.$current_url like '%${hogql.identifier(values.browserSearchTerm)}%'\n                                ORDER BY timestamp DESC\n                                limit 100`,\n                    }\n\n                    const res = await api.query(query)\n\n                    return res.results?.map((x) => x[0]) as string[]\n                },\n            },\n        ],\n\n        topUrls: [\n            null as { url: string; count: number }[] | null,\n            {\n                loadTopUrls: async () => {\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$current_url AS url, count() as count FROM events\n                                WHERE timestamp >= now() - INTERVAL 7 DAY\n                                AND event in ('$pageview', '$autocapture')\n                                AND timestamp <= now()\n                                GROUP BY properties.$current_url\n                                ORDER BY count DESC\n                                LIMIT 10`,\n                    }\n\n                    const res = await api.query(query)\n\n                    return res.results?.map((x) => ({ url: x[0], count: x[1] })) as { url: string; count: number }[]\n                },\n            },\n        ],\n    })),\n\n    reducers({\n        browserSearchTerm: [\n            '',\n            {\n                setBrowserSearch: (_, { searchTerm }) => searchTerm,\n            },\n        ],\n        browserUrl: [\n            null as string | null,\n            { persist: true },\n            {\n                setBrowserUrl: (_, { url }) => url,\n            },\n        ],\n        iframePosthogJsConnected: [\n            false as boolean,\n            {\n                setIframePosthogJsConnected: (_, { ready }) => ready,\n            },\n        ],\n\n        loading: [\n            false as boolean,\n            {\n                setLoading: (_, { loading }) => loading,\n                setBrowserUrl: () => true,\n                onIframeToolbarLoad: () => false,\n            },\n        ],\n    }),\n\n    selectors({\n        browserUrlSearchOptions: [\n            (s) => [s.browserSearchResults, s.topUrls, s.browserSearchTerm],\n            (browserSearchResults, topUrls, browserSearchTerm) => {\n                return browserSearchTerm ? browserSearchResults : topUrls?.map((x) => x.url) ?? []\n            },\n        ],\n\n        isBrowserUrlAuthorized: [\n            (s) => [s.browserUrl, s.checkUrlIsAuthorized],\n            (browserUrl, checkUrlIsAuthorized) => {\n                if (!browserUrl) {\n                    return false\n                }\n                return checkUrlIsAuthorized(browserUrl)\n            },\n        ],\n    }),\n\n    listeners(({ actions, props, values }) => ({\n        setBrowserSearch: async (_, breakpoint) => {\n            await breakpoint(200)\n            actions.loadBrowserSearchResults()\n        },\n        sendToolbarMessage: ({ type, payload }) => {\n            props.iframeRef?.current?.contentWindow?.postMessage(\n                {\n                    type,\n                    payload,\n                },\n                '*'\n            )\n        },\n\n        onIframeLoad: () => {\n            // TODO: Add a timeout - if we haven't received a message from the iframe in X seconds, show an error\n            const init = (): void => {\n                actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_APP_INIT)\n                actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_HEATMAPS_CONFIG, {\n                    enabled: true,\n                })\n            }\n\n            const onIframeMessage = (e: MessageEvent): void => {\n                // TODO: Probably need to have strict checks here\n                const type: PostHogAppToolbarEvent = e?.data?.type\n\n                if (!type || !type.startsWith('ph-')) {\n                    return\n                }\n\n                switch (type) {\n                    case PostHogAppToolbarEvent.PH_TOOLBAR_INIT:\n                        return init()\n                    case PostHogAppToolbarEvent.PH_TOOLBAR_READY:\n                        return actions.onIframeToolbarLoad()\n                    default:\n                        console.warn(`[PostHog Heatmpas] Received unknown child window message: ${type}`)\n                }\n            }\n\n            window.addEventListener('message', onIframeMessage, false)\n            // We call init in case the toolbar got there first (unlikely)\n            init()\n        },\n\n        maybeLoadTopUrls: () => {\n            if (!values.topUrls && !values.topUrlsLoading) {\n                actions.loadTopUrls()\n            }\n        },\n\n        setBrowserUrl: () => {\n            actions.maybeLoadTopUrls()\n        },\n    })),\n\n    afterMount(({ actions, values }) => {\n        if (values.browserUrl) {\n            actions.setLoading(true)\n        } else {\n            actions.maybeLoadTopUrls()\n        }\n    }),\n])\n"],"names":[],"sourceRoot":""}