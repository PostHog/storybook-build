{"version":3,"file":"63562.9f55df0b.iframe.bundle.js","mappings":";AAsDA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@posthog/storybook/../../frontend/src/scenes/experiments/MetricsView/legacy/violinUtils.ts","webpack://@posthog/storybook/../../frontend/src/scenes/experiments/ExperimentCodeSnippets.tsx"],"sourcesContent":["/**\n * Generates an SVG path for a violin plot visualization\n *\n * @param x1 - Left boundary of the violin\n * @param x2 - Right boundary of the violin\n * @param y - Vertical position of the violin\n * @param height - Height of the violin\n * @param deltaX - Position of the delta marker\n * @returns SVG path string\n */\nexport function generateViolinPath(x1: number, x2: number, y: number, height: number, deltaX: number): string {\n    // Create points for the violin curve\n    const points: [number, number][] = []\n    const steps = 20\n    const maxWidth = height / 2\n\n    // Generate left side points (x1 to deltaX)\n    for (let i = 0; i <= steps; i++) {\n        const t = i / steps\n        const x = x1 + (deltaX - x1) * t\n        // Standard normal distribution PDF from x1 to deltaX\n        const z = (t - 1) * 2 // Reduced scale factor from 2.5 to 2 for thicker tails\n        const width = Math.exp(-0.5 * z * z) * maxWidth\n        points.push([x, y + height / 2 - width])\n    }\n\n    // Generate right side points (deltaX to x2)\n    for (let i = 0; i <= steps; i++) {\n        const t = i / steps\n        const x = deltaX + (x2 - deltaX) * t\n        // Standard normal distribution PDF from deltaX to x2\n        const z = t * 2 // Reduced scale factor from 2.5 to 2 for thicker tails\n        const width = Math.exp(-0.5 * z * z) * maxWidth\n        points.push([x, y + height / 2 - width])\n    }\n\n    // Generate bottom curve points (mirror of top)\n    for (let i = steps; i >= 0; i--) {\n        const t = i / steps\n        const x = deltaX + (x2 - deltaX) * t\n        const z = t * 2\n        const width = Math.exp(-0.5 * z * z) * maxWidth\n        points.push([x, y + height / 2 + width])\n    }\n    for (let i = steps; i >= 0; i--) {\n        const t = i / steps\n        const x = x1 + (deltaX - x1) * t\n        const z = (t - 1) * 2\n        const width = Math.exp(-0.5 * z * z) * maxWidth\n        points.push([x, y + height / 2 + width])\n    }\n\n    // Create SVG path\n    return `\n        M ${points[0][0]} ${points[0][1]}\n        ${points.map((point) => `L ${point[0]} ${point[1]}`).join(' ')}\n        Z\n    `\n}\n","import { Link } from '@posthog/lemon-ui'\n\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\n\nfunction ServerSideWarning(): JSX.Element {\n    return (\n        <div className=\"warning\">\n            <p>\n                <b>Warning:</b> Server side experiment metrics require you to manually send the feature flag\n                information.{' '}\n                <Link to=\"https://posthog.com/docs/experiments/adding-experiment-code\" target=\"_blank\">\n                    See this tutorial for more information.\n                </Link>\n            </p>\n        </div>\n    )\n}\n\ninterface SnippetProps {\n    flagKey: string\n    variant: string\n}\n\nexport function AndroidSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.Kotlin} wrap>\n                {`if (PostHog.getFeatureFlag(\"${flagKey}\") == \"${variant}\") {\n    // do something\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function IOSSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.Swift} wrap>\n                {`if (PostHogSDK.shared.getFeatureFlag(\"${flagKey}\") as? String == \"${variant}\") {\n    // do something\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function NodeJSSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`const experimentFlagValue = await client.getFeatureFlag('${flagKey}', 'user distinct id')\n\nif (experimentFlagValue === '${variant}' ) {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n\nexport function JSSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <div>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`if (posthog.getFeatureFlag('${flagKey}') === '${variant}') {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n            <div className=\"mt-4 mb-1\">\n                <b>Test that it works</b>\n            </div>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`posthog.featureFlags.overrideFeatureFlags({ flags: {'${flagKey}': '${variant}'} })`}\n            </CodeSnippet>\n        </div>\n    )\n}\n\nexport function ReactSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`// You can either use the useFeatureFlagVariantKey hook,\n// or you can use the feature flags component - https://posthog.com/docs/libraries/react#feature-flags-react-component\n\n// Method one: using the useFeatureFlagVariantKey hook\nimport { useFeatureFlagVariantKey } from 'posthog-js/react'\n\nfunction App() {\n    const variant = useFeatureFlagVariantKey('${flagKey}')\n    if (variant === '${variant}') {\n        // do something\n    }\n}\n\n// Method two: using the feature flags component\nimport { PostHogFeature } from 'posthog-js/react'\n\nfunction App() {\n    return (\n        <PostHogFeature flag='${flagKey}' match='${variant}'>\n            <div>\n                {/* the component to show */}\n            </div>\n        </PostHogFeature>\n    )\n}\n\n// You can also test your code by overriding the feature flag:\nposthog.featureFlags.overrideFeatureFlags({ flags: {'${flagKey}': '${variant}'} })`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function RNSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`if (posthog.getFeatureFlag('${flagKey}') === '${variant}') {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function PHPSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.PHP} wrap>\n                {`if (PostHog::getFeatureFlag('${flagKey}', 'user distinct id') == '${variant}') {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n\nexport function GolangSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.Go} wrap>\n                {`experimentFlagValue, err := client.GetFeatureFlag(posthog.FeatureFlagPayload{\n    Key:        '${flagKey}',\n    DistinctId: \"distinct-id\",\n})\nif err != nil {\n    // Handle error (e.g. capture error and fallback to default behaviour)\n}\nif experimentFlagValue == '${variant}' {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n\nexport function FlutterSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    const clientSuffix = 'await Posthog().'\n    const flagFunction = 'getFeatureFlag'\n    const variantSuffix = ` == '${variant}'`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Dart} wrap>\n                {`if (${clientSuffix}${flagFunction}('${flagKey}')${variantSuffix}) {\n  // Do something differently for this user\n} else {\n  // It's a good idea to let control variant always be the default behaviour,\n  // so if something goes wrong with flag evaluation, you don't break your app.\n}\n            `}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function RubySnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.Ruby} wrap>\n                {`experimentFlagValue = posthog.get_feature_flag('${flagKey}', 'user distinct id')\n\n\nif experimentFlagValue == '${variant}'\n    # Do something differently for this user\nelse\n    # It's a good idea to let control variant always be the default behaviour,\n    # so if something goes wrong with flag evaluation, you don't break your app.\nend\n`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n\nexport function PythonSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.Python} wrap>\n                {`experiment_flag_value = posthog.get_feature_flag(\"${flagKey}\", \"user_distinct_id\"):\n\nif experiment_flag_value == '${variant}':\n    # Do something differently for this user\nelse:\n    # It's a good idea to let control variant always be the default behaviour,\n    # so if something goes wrong with flag evaluation, you don't break your app.\n`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n\nexport function JavaSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.Java} wrap>\n                {`Object flagValue = postHog.getFeatureFlag(\"user distinct id\", \"${flagKey}\");\nif (\"${variant}\".equals(flagValue)) {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}\n`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n"],"names":[],"sourceRoot":""}