{"version":3,"file":"33260.cd637b4a.iframe.bundle.js","mappings":";AAsDA;AACA;AAEA;AACA;AACA;AAsCA;AACA;AC2MA;ACjBA;AACA;AACA;;;AC7OA;;AAEA","sources":["webpack://@posthog/storybook/../../frontend/src/scenes/hog-functions/configuration/components/hogFunctionSourceWebhookTestLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/hog-functions/configuration/hogFunctionTestLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/hog-functions/filters/HogFunctionFilters.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/hog-functions/logs/hogFunctionLogsLogic.ts"],"sourcesContent":["import { apiHostOrigin } from 'lib/utils/apiHost'\nimport { actions, connect, kea, key, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { tryJsonParse } from 'lib/utils'\n\nimport { hogFunctionConfigurationLogic, HogFunctionConfigurationLogicProps } from '../hogFunctionConfigurationLogic'\nimport type { hogFunctionSourceWebhookTestLogicType } from './hogFunctionSourceWebhookTestLogicType'\n\nexport type HogFunctionSourceWebhookTestForm = {\n    headers: string\n    body: string\n    mock_request: boolean\n}\n\nexport type HogFunctionSourceWebhookTestResult = {\n    status: number\n    body: string\n}\n\nexport const hogFunctionSourceWebhookTestLogic = kea<hogFunctionSourceWebhookTestLogicType>([\n    props({} as HogFunctionConfigurationLogicProps),\n    key(({ id, templateId }: HogFunctionConfigurationLogicProps) => {\n        return id ?? templateId ?? 'new'\n    }),\n\n    path((id) => ['scenes', 'pipeline', 'hogfunctions', 'hogFunctionSourceWebhookTestLogic', id]),\n    connect((props: HogFunctionConfigurationLogicProps) => ({\n        values: [hogFunctionConfigurationLogic(props), ['configuration', 'templateId']],\n    })),\n    actions({\n        setTestResult: (result: HogFunctionSourceWebhookTestResult | null) => ({ result }),\n        toggleExpanded: (expanded?: boolean) => ({ expanded }),\n    }),\n    reducers({\n        expanded: [\n            false as boolean,\n            {\n                toggleExpanded: (state, { expanded }) => (expanded === undefined ? !state : expanded),\n            },\n        ],\n\n        testResult: [\n            null as HogFunctionSourceWebhookTestResult | null,\n            {\n                setTestResult: (_, { result }) => result,\n            },\n        ],\n    }),\n\n    forms(({ props, actions }) => ({\n        testInvocation: {\n            defaults: {\n                mock_request: true,\n                headers: `{\n  \"Content-Type\": \"application/json\"\n}`,\n                body: `{\n  \"event\": \"my example event\",\n  \"distinct_id\": \"webhook-test-123\"\n}`,\n            } as HogFunctionSourceWebhookTestForm,\n            alwaysShowErrors: true,\n            errors: ({ headers, body }) => {\n                return {\n                    headers: !headers ? 'Required' : tryJsonParse(headers) ? undefined : 'Invalid JSON',\n                    body: !body ? 'Required' : tryJsonParse(body) ? undefined : 'Invalid JSON',\n                }\n            },\n            submit: async (data) => {\n                actions.setTestResult(null)\n\n                const response = await fetch(`${apiHostOrigin()}/public/webhooks/${props.id ?? 'unknown'}`, {\n                    method: 'POST',\n                    headers: tryJsonParse(data.headers),\n                    body: data.body,\n                })\n\n                actions.setTestResult({\n                    status: response.status,\n                    body: await response.text(),\n                })\n            },\n        },\n    })),\n\n    selectors({\n        exampleCurlRequest: [\n            (s) => [s.testInvocation, (_, props) => props],\n            (testInvocation, props) => {\n                const headersJson = tryJsonParse(testInvocation.headers)\n                const headers = headersJson\n                    ? Object.entries(headersJson)\n                          .map(([key, value]) => `-H \"${key}: ${value}\"`)\n                          .join(' ')\n                    : ''\n\n                return `curl -X POST ${headers} \\\\\n  -d '${testInvocation.body}' \\\\\n  ${apiHostOrigin()}/public/webhooks/${props.id ?? 'unknown'}`\n            },\n        ],\n    }),\n])\n","import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, afterMount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport api from 'lib/api'\nimport { tryJsonParse } from 'lib/utils'\nimport { getCurrentTeamId } from 'lib/utils/getAppContext'\nimport { editor } from 'monaco-editor'\n\nimport { groupsModel } from '~/models/groupsModel'\nimport { CyclotronJobInvocationGlobals, CyclotronJobTestInvocationResult } from '~/types'\n\nimport {\n    hogFunctionConfigurationLogic,\n    HogFunctionConfigurationLogicProps,\n    sanitizeConfiguration,\n} from './hogFunctionConfigurationLogic'\nimport type { hogFunctionTestLogicType } from './hogFunctionTestLogicType'\n\nexport type HogFunctionTestInvocationForm = {\n    globals: string // CyclotronJobInvocationGlobals\n    mock_async_functions: boolean\n}\n\nexport type HogTransformationEvent = {\n    event: any\n    uuid: string\n    distinct_id: string\n    timestamp: string\n    properties: any\n}\n\nconst convertToTransformationEvent = (result: any): HogTransformationEvent => {\n    const properties = result.properties ?? {}\n    properties.$ip = properties.$ip ?? '89.160.20.129'\n    // We don't want to use these values given they will change in the test invocation\n    delete properties.$transformations_failed\n    delete properties.$transformations_succeeded\n    delete properties.$transformations_skipped\n    return {\n        event: result.event,\n        uuid: result.uuid,\n        distinct_id: result.distinct_id,\n        timestamp: result.timestamp,\n        properties,\n    }\n}\n\nconst convertFromTransformationEvent = (result: HogTransformationEvent): Record<string, any> => {\n    delete result.properties.$transformations_failed\n    delete result.properties.$transformations_succeeded\n    delete result.properties.$transformations_skipped\n    return {\n        event: result.event,\n        uuid: result.uuid,\n        distinct_id: result.distinct_id,\n        timestamp: result.timestamp,\n        properties: result.properties,\n    }\n}\n\nexport interface CodeEditorValidation {\n    value: string\n    editor: editor.IStandaloneCodeEditor\n    decorations: string[]\n}\n\nexport const hogFunctionTestLogic = kea<hogFunctionTestLogicType>([\n    props({} as HogFunctionConfigurationLogicProps),\n    key(({ id, templateId }: HogFunctionConfigurationLogicProps) => {\n        return id ?? templateId ?? 'new'\n    }),\n\n    path((id) => ['scenes', 'pipeline', 'hogfunctions', 'hogFunctionTestLogic', id]),\n    connect((props: HogFunctionConfigurationLogicProps) => ({\n        values: [\n            hogFunctionConfigurationLogic(props),\n            [\n                'configuration',\n                'templateId',\n                'configurationHasErrors',\n                'sampleGlobals',\n                'sampleGlobalsLoading',\n                'exampleInvocationGlobals',\n                'sampleGlobalsError',\n                'type',\n                'currentHogCode',\n            ],\n            groupsModel,\n            ['groupTypes'],\n        ],\n        actions: [\n            hogFunctionConfigurationLogic(props),\n            ['touchConfigurationField', 'loadSampleGlobalsSuccess', 'loadSampleGlobals', 'setSampleGlobals'],\n        ],\n    })),\n    actions({\n        setTestResult: (result: CyclotronJobTestInvocationResult | null) => ({ result }),\n        toggleExpanded: (expanded?: boolean) => ({ expanded }),\n        saveGlobals: (name: string, globals: CyclotronJobInvocationGlobals) => ({ name, globals }),\n        deleteSavedGlobals: (index: number) => ({ index }),\n        setTestResultMode: (mode: 'raw' | 'diff') => ({ mode }),\n        receiveExampleGlobals: (globals: CyclotronJobInvocationGlobals | null) => ({ globals }),\n        setJsonError: (error: string | null) => ({ error }),\n        validateJson: (value: string, editor: editor.IStandaloneCodeEditor, decorations: string[]) =>\n            ({ value, editor, decorations } as CodeEditorValidation),\n        setDecorationIds: (decorationIds: string[]) => ({ decorationIds }),\n        cancelSampleGlobalsLoading: true,\n    }),\n    reducers({\n        expanded: [\n            false as boolean,\n            {\n                toggleExpanded: (state, { expanded }) => (expanded === undefined ? !state : expanded),\n            },\n        ],\n\n        testResult: [\n            null as CyclotronJobTestInvocationResult | null,\n            {\n                setTestResult: (_, { result }) => result,\n            },\n        ],\n\n        testResultMode: [\n            'diff' as 'raw' | 'diff',\n            {\n                setTestResultMode: (_, { mode }) => mode,\n            },\n        ],\n\n        savedGlobals: [\n            [] as { name: string; globals: CyclotronJobInvocationGlobals }[],\n            { persist: true, prefix: `${getCurrentTeamId()}__` },\n            {\n                saveGlobals: (state, { name, globals }) => [...state, { name, globals }],\n                deleteSavedGlobals: (state, { index }) => state.filter((_, i) => i !== index),\n            },\n        ],\n\n        jsonError: [\n            null as string | null,\n            {\n                setJsonError: (_, { error }) => error,\n            },\n        ],\n\n        currentDecorationIds: [\n            [] as string[],\n            {\n                setDecorationIds: (_, { decorationIds }) => decorationIds,\n                setJsonError: () => [], // Clear decorations when error state changes\n            },\n        ],\n\n        fetchCancelled: [\n            false as boolean,\n            {\n                loadSampleGlobals: () => false,\n                cancelSampleGlobalsLoading: () => true,\n                toggleExpanded: () => false,\n            },\n        ],\n    }),\n    listeners(({ values, actions }) => ({\n        loadSampleGlobalsSuccess: () => {\n            if (values.expanded && !values.fetchCancelled && values.sampleGlobals) {\n                actions.receiveExampleGlobals(values.sampleGlobals)\n            }\n        },\n        setSampleGlobals: ({ sampleGlobals }) => {\n            actions.receiveExampleGlobals(sampleGlobals)\n        },\n\n        receiveExampleGlobals: ({ globals }) => {\n            if (!globals) {\n                return\n            }\n\n            if (values.type === 'transformation') {\n                const event = convertToTransformationEvent(globals.event)\n                // Strip down to just the real values\n                actions.setTestInvocationValue('globals', JSON.stringify(event, null, 2))\n            } else {\n                actions.setTestInvocationValue('globals', JSON.stringify(globals, null, 2))\n            }\n        },\n\n        validateJson: ({ value, editor, decorations }: CodeEditorValidation) => {\n            if (!editor?.getModel()) {\n                return\n            }\n\n            const model = editor.getModel()!\n\n            try {\n                // Try parsing the JSON\n                JSON.parse(value)\n                // If valid, ensure everything is cleared\n                actions.setJsonError(null)\n                editor.removeDecorations(decorations)\n            } catch (err: any) {\n                actions.setJsonError(err.message)\n\n                const match = err.message.match(/position (\\d+)/)\n                if (!match) {\n                    return\n                }\n\n                const position = parseInt(match[1], 10)\n                const pos = model.getPositionAt(position)\n\n                // Set single error marker\n                editor.createDecorationsCollection([\n                    {\n                        range: {\n                            startLineNumber: pos.lineNumber,\n                            startColumn: pos.column,\n                            endLineNumber: pos.lineNumber,\n                            endColumn: pos.column + 1,\n                        },\n                        options: {\n                            isWholeLine: true,\n                            className: 'bg-danger-highlight',\n                            glyphMarginClassName: 'text-danger flex items-center justify-center',\n                            glyphMarginHoverMessage: { value: err.message },\n                        },\n                    },\n                ])\n                // Scroll to error\n                editor.revealLineInCenter(pos.lineNumber)\n            }\n        },\n\n        setTestResult: ({ result }) => {\n            if (result) {\n                setTimeout(() => {\n                    // First try to scroll the test results container into view\n                    const testResults = document.querySelector('[data-attr=\"test-results\"]')\n                    if (testResults) {\n                        testResults.scrollIntoView({ behavior: 'smooth', block: 'start' })\n                    }\n\n                    // Find the Monaco editor and scroll to the first difference\n                    const editors = document.querySelectorAll('[data-attr=\"test-results\"] .monaco-editor')\n                    if (editors.length > 0 && values.sortedTestsResult?.hasDiff) {\n                        const lastEditor = editors[editors.length - 1]\n                        const monacoEditor = lastEditor.querySelector('.monaco-scrollable-element')\n                        if (monacoEditor) {\n                            const inputLines = values.sortedTestsResult.input.split('\\n')\n                            const outputLines = values.sortedTestsResult.output.split('\\n')\n\n                            // Find the first line that differs\n                            let diffLineIndex = 0\n                            for (let i = 0; i < Math.max(inputLines.length, outputLines.length); i++) {\n                                if (inputLines[i] !== outputLines[i]) {\n                                    diffLineIndex = i\n                                    break\n                                }\n                            }\n\n                            // Calculate approximate scroll position for the diff, showing 2 lines of context above\n                            const lineHeight = 19 // Default Monaco line height\n                            monacoEditor.scrollTop = Math.max(0, (diffLineIndex - 2) * lineHeight)\n                        }\n                    }\n                }, 100)\n            }\n        },\n\n        cancelSampleGlobalsLoading: () => {\n            // Just mark as cancelled - we'll ignore any results that come back\n        },\n    })),\n\n    forms(({ props, actions, values }) => ({\n        testInvocation: {\n            defaults: {\n                mock_async_functions: false,\n            } as HogFunctionTestInvocationForm,\n            alwaysShowErrors: true,\n            errors: ({ globals }) => {\n                return {\n                    globals: !globals ? 'Required' : tryJsonParse(globals) ? undefined : 'Invalid JSON',\n                }\n            },\n            submit: async (data) => {\n                // Submit the test invocation\n                // Set the response somewhere\n\n                if (values.configurationHasErrors) {\n                    // Get the configuration logic instance\n                    const configLogic = hogFunctionConfigurationLogic(props)\n                    const inputErrors = configLogic.values.inputFormErrors?.inputs || {}\n\n                    // Create a simple list of errors\n                    const errorMessages = Object.entries(inputErrors).map(([key, error]) => {\n                        const errorText = typeof error === 'string' ? error : 'Invalid format'\n                        return `${key}: ${errorText}`\n                    })\n\n                    // Show the error message\n                    const message =\n                        errorMessages.length > 0\n                            ? `Please fix the following errors:\\n${errorMessages.join('\\n')}`\n                            : 'Please fix the configuration errors before testing.'\n\n                    lemonToast.error(message, {\n                        toastId: 'hogfunction-validation-error',\n                    })\n\n                    // Show the errors in the UI\n                    configLogic.actions.touchConfigurationField && configLogic.actions.touchConfigurationField('inputs')\n                    return\n                }\n\n                const parsedData = tryJsonParse(data.globals)\n                const configuration = sanitizeConfiguration(values.configuration) as Record<string, any>\n                configuration.template_id = values.templateId\n                configuration.hog = values.currentHogCode\n\n                // Transformations have a simpler UI just showing the event so we need to map it back to the event\n                const globals =\n                    values.type === 'transformation'\n                        ? {\n                              event: parsedData,\n                          }\n                        : parsedData\n\n                try {\n                    const res = await api.hogFunctions.createTestInvocation(props.id ?? 'new', {\n                        globals,\n                        mock_async_functions: data.mock_async_functions,\n                        configuration,\n                    })\n\n                    // Modify the result to match better our globals format\n                    if (values.type === 'transformation' && res.result) {\n                        res.result = convertFromTransformationEvent(res.result)\n                    }\n\n                    actions.setTestResult(res)\n                } catch (e) {\n                    lemonToast.error(`An unexpected server error occurred while testing the function. ${e}`)\n                }\n            },\n        },\n    })),\n\n    selectors(() => ({\n        sortedTestsResult: [\n            (s) => [s.configuration, s.testResult, s.testInvocation],\n            (\n                configuration,\n                testResult,\n                testInvocation\n            ): {\n                input: string\n                output: string\n                hasDiff: boolean\n            } | null => {\n                if (!testResult || configuration.type !== 'transformation') {\n                    return null\n                }\n\n                const input = JSON.stringify(JSON.parse(testInvocation.globals), null, 2)\n                const output = JSON.stringify(testResult.result, null, 2)\n\n                return {\n                    input,\n                    output,\n                    hasDiff: input !== output,\n                }\n            },\n        ],\n\n        sampleGlobalsLoadingAndNotCancelled: [\n            (s) => [s.sampleGlobalsLoading, s.fetchCancelled],\n            (sampleGlobalsLoading, fetchCancelled) => sampleGlobalsLoading && !fetchCancelled,\n        ],\n    })),\n\n    afterMount(({ actions, values }) => {\n        actions.receiveExampleGlobals(values.exampleInvocationGlobals)\n    }),\n])\n","import { IconCheck, IconX } from '@posthog/icons'\nimport { LemonBanner, LemonButton, LemonLabel, LemonSelect } from '@posthog/lemon-ui'\nimport { id } from 'chartjs-plugin-trendline'\nimport clsx from 'clsx'\nimport { useActions, useValues } from 'kea'\nimport { PropertyFilters } from 'lib/components/PropertyFilters/PropertyFilters'\nimport { TaxonomicFilterGroupType } from 'lib/components/TaxonomicFilter/types'\nimport { TestAccountFilterSwitch } from 'lib/components/TestAccountFiltersSwitch'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { useMemo } from 'react'\nimport { ActionFilter } from 'scenes/insights/filters/ActionFilter/ActionFilter'\nimport { MathAvailability } from 'scenes/insights/filters/ActionFilter/ActionFilterRow/ActionFilterRow'\nimport MaxTool from 'scenes/max/MaxTool'\n\nimport { groupsModel } from '~/models/groupsModel'\nimport { AnyPropertyFilter, CyclotronJobFiltersType, EntityTypes, FilterType } from '~/types'\n\nimport { hogFunctionConfigurationLogic } from '../configuration/hogFunctionConfigurationLogic'\nimport { HogFunctionFiltersInternal } from './HogFunctionFiltersInternal'\nimport { useFeatureFlag } from 'lib/hooks/useFeatureFlag'\n\nfunction sanitizeActionFilters(filters?: FilterType): Partial<CyclotronJobFiltersType> {\n    if (!filters) {\n        return {}\n    }\n    const sanitized: CyclotronJobFiltersType = {}\n\n    if (filters.events) {\n        sanitized.events = filters.events.map((f) => ({\n            id: f.id,\n            type: 'events',\n            name: f.name,\n            order: f.order,\n            properties: f.properties,\n        }))\n    }\n\n    if (filters.actions) {\n        sanitized.actions = filters.actions.map((f) => ({\n            id: f.id,\n            type: 'actions',\n            name: f.name,\n            order: f.order,\n            properties: f.properties,\n        }))\n    }\n\n    return sanitized\n}\n\nexport function HogFunctionFilters({\n    embedded = false,\n    showTriggerOptions = true,\n}: {\n    embedded?: boolean\n    showTriggerOptions?: boolean\n}): JSX.Element {\n    const { groupsTaxonomicTypes } = useValues(groupsModel)\n    const { configuration, type, useMapping, filtersContainPersonProperties, oldFilters, newFilters } =\n        useValues(hogFunctionConfigurationLogic)\n    const {\n        setOldFilters,\n        setNewFilters,\n        clearFiltersDiff,\n        reportAIFiltersPrompted,\n        reportAIFiltersAccepted,\n        reportAIFiltersRejected,\n        reportAIFiltersPromptOpen,\n    } = useActions(hogFunctionConfigurationLogic)\n\n    const isLegacyPlugin = configuration?.template?.id?.startsWith('plugin-')\n    const isTransformation = type === 'transformation'\n    const cdpPersonUpdatesEnabled = useFeatureFlag('CDP_PERSON_UPDATES')\n\n    const taxonomicGroupTypes = useMemo(() => {\n        const types = [\n            TaxonomicFilterGroupType.EventProperties,\n            TaxonomicFilterGroupType.EventMetadata,\n            TaxonomicFilterGroupType.HogQLExpression,\n        ]\n\n        if (!isTransformation) {\n            types.push(\n                TaxonomicFilterGroupType.PersonProperties,\n                TaxonomicFilterGroupType.EventFeatureFlags,\n                TaxonomicFilterGroupType.Elements,\n                ...groupsTaxonomicTypes\n            )\n        }\n\n        return types\n    }, [isTransformation, groupsTaxonomicTypes])\n\n    const showMasking = type === 'destination' && !isLegacyPlugin && showTriggerOptions\n\n    if (type === 'internal_destination') {\n        return <HogFunctionFiltersInternal />\n    }\n\n    // NOTE: Mappings won't work for person updates currently as they are totally event based...\n    const showSourcePicker = cdpPersonUpdatesEnabled && type === 'destination' && !useMapping\n    const showEventMatchers = !useMapping && (configuration?.filters?.source ?? 'events') === 'events'\n\n    const mainContent = (\n        <div\n            className={clsx(\n                'deprecated-space-y-2 rounded bg-surface-primary',\n                !embedded && 'border p-3',\n                embedded && 'p-2'\n            )}\n        >\n            {showSourcePicker && (\n                <LemonField\n                    name=\"filters\"\n                    label=\"Source\"\n                    info={\n                        <>\n                            Select the source of events for the destination.\n                            <br />\n                            <b>Events</b> will trigger from the real-time stream of ingested events.\n                            <br />\n                            <b>Person updates</b> will trigger whenever a Person is created, updated or deleted.\n                        </>\n                    }\n                >\n                    {({ value, onChange }) => {\n                        return (\n                            <LemonSelect\n                                options={[\n                                    { value: 'events', label: 'Events' },\n                                    { value: 'person-updates', label: 'Person updates' },\n                                ]}\n                                value={value?.source ?? 'events'}\n                                onChange={(val) => {\n                                    onChange({ ...value, source: val })\n                                }}\n                            />\n                        )\n                    }}\n                </LemonField>\n            )}\n            <LemonField\n                name=\"filters\"\n                label={useMapping ? 'Global filters' : 'Filters'}\n                info={\n                    useMapping\n                        ? 'Filters applied to all events before they reach a mapping'\n                        : 'Filters applied to all events'\n                }\n            >\n                {({ value, onChange: _onChange }) => {\n                    const filters = (value ?? {}) as CyclotronJobFiltersType\n                    const currentFilters = newFilters ?? filters\n\n                    const onChange = (newValue: CyclotronJobFiltersType): void => {\n                        if (oldFilters && newFilters) {\n                            clearFiltersDiff()\n                        }\n                        _onChange(newValue)\n                    }\n\n                    return (\n                        <>\n                            {useMapping && (\n                                <p className=\"mb-0 text-sm text-secondary\">\n                                    Filters here apply for all events that could trigger this function, regardless of\n                                    mappings.\n                                </p>\n                            )}\n                            {!isTransformation && (\n                                <TestAccountFilterSwitch\n                                    checked={currentFilters?.filter_test_accounts ?? false}\n                                    onChange={(filter_test_accounts) => {\n                                        const newValue = { ...currentFilters, filter_test_accounts }\n                                        onChange(newValue)\n                                    }}\n                                    fullWidth\n                                />\n                            )}\n                            <PropertyFilters\n                                propertyFilters={(currentFilters?.properties ?? []) as AnyPropertyFilter[]}\n                                taxonomicGroupTypes={taxonomicGroupTypes}\n                                onChange={(properties: AnyPropertyFilter[]) => {\n                                    const newValue = {\n                                        ...currentFilters,\n                                        properties,\n                                    }\n                                    onChange(newValue as CyclotronJobFiltersType)\n                                }}\n                                pageKey={`HogFunctionPropertyFilters.${id}`}\n                            />\n\n                            {showEventMatchers ? (\n                                <>\n                                    <div className=\"flex gap-2 justify-between w-full\">\n                                        <LemonLabel>\n                                            {isTransformation ? 'Match events' : 'Match events and actions'}\n                                        </LemonLabel>\n                                    </div>\n                                    <p className=\"mb-0 text-xs text-secondary\">\n                                        If set, the {type} will only run if the <b>event matches any</b> of the below.\n                                    </p>\n                                    <ActionFilter\n                                        bordered\n                                        filters={currentFilters ?? {} /* TODO: this is any */}\n                                        setFilters={(payload) => {\n                                            onChange({\n                                                ...currentFilters,\n                                                ...sanitizeActionFilters(payload),\n                                            })\n                                        }}\n                                        typeKey=\"plugin-filters\"\n                                        mathAvailability={MathAvailability.None}\n                                        hideRename\n                                        hideDuplicate\n                                        showNestedArrow={false}\n                                        actionsTaxonomicGroupTypes={\n                                            isTransformation\n                                                ? [TaxonomicFilterGroupType.Events]\n                                                : [TaxonomicFilterGroupType.Events, TaxonomicFilterGroupType.Actions]\n                                        }\n                                        propertiesTaxonomicGroupTypes={taxonomicGroupTypes}\n                                        propertyFiltersPopover\n                                        addFilterDefaultOptions={{\n                                            id: '$pageview',\n                                            name: '$pageview',\n                                            type: EntityTypes.EVENTS,\n                                        }}\n                                        buttonCopy=\"Add event matcher\"\n                                    />\n                                </>\n                            ) : null}\n                            {oldFilters && newFilters && (\n                                <div className=\"flex gap-2 items-center p-2 mt-4 rounded border border-dashed bg-surface-secondary\">\n                                    <div className=\"flex-1 text-center\">\n                                        <span className=\"text-sm font-medium\">Suggested by Max</span>\n                                    </div>\n                                    <div className=\"flex gap-2\">\n                                        <LemonButton\n                                            status=\"danger\"\n                                            icon={<IconX />}\n                                            onClick={() => {\n                                                onChange(oldFilters)\n                                                reportAIFiltersRejected()\n                                                clearFiltersDiff()\n                                            }}\n                                            tooltipPlacement=\"top\"\n                                            size=\"small\"\n                                        >\n                                            Reject\n                                        </LemonButton>\n                                        <LemonButton\n                                            type=\"tertiary\"\n                                            icon={<IconCheck color=\"var(--success)\" />}\n                                            onClick={() => {\n                                                onChange(newFilters)\n                                                reportAIFiltersAccepted()\n                                                clearFiltersDiff()\n                                            }}\n                                            tooltipPlacement=\"top\"\n                                            size=\"small\"\n                                        >\n                                            Accept\n                                        </LemonButton>\n                                    </div>\n                                </div>\n                            )}\n                        </>\n                    )\n                }}\n            </LemonField>\n\n            {filtersContainPersonProperties && showEventMatchers ? (\n                <LemonBanner type=\"warning\">\n                    You are filtering on Person properties. Be aware that this filtering applies at the time the event\n                    is processed so if Person Profiles are not enabled or the person property has not been set by then\n                    then the filters may not work as expected.\n                </LemonBanner>\n            ) : null}\n            {showMasking ? (\n                <LemonField\n                    name=\"masking\"\n                    label=\"Trigger options\"\n                    info={`\n                        You can configure the destination to only run once within a given time interval or until a certain number of events have been processed. \n                        This is useful for rate limiting the destination for example if you only want to receive one message per day.\n                    `}\n                >\n                    {({ value, onChange }) => (\n                        <div className=\"flex flex-wrap gap-1 items-center\">\n                            <LemonSelect\n                                options={[\n                                    {\n                                        value: null,\n                                        label: 'Run every time',\n                                    },\n                                    {\n                                        value: 'all',\n                                        label: 'Run once per interval',\n                                    },\n                                    {\n                                        value: '{person.id}',\n                                        label: 'Run once per person per interval',\n                                    },\n                                    {\n                                        value: '{concat(person.id, event.event)}',\n                                        label: 'Run once per person per event name per interval',\n                                    },\n                                ]}\n                                value={value?.hash ?? null}\n                                onChange={(val) =>\n                                    onChange({\n                                        hash: val,\n                                        ttl: value?.ttl ?? 60 * 30,\n                                    })\n                                }\n                            />\n                            {configuration.masking?.hash ? (\n                                <>\n                                    <div className=\"flex flex-wrap gap-1 items-center\">\n                                        <span>of</span>\n                                        <LemonSelect\n                                            value={value?.ttl}\n                                            onChange={(val) => onChange({ ...value, ttl: val })}\n                                            options={[\n                                                {\n                                                    value: 5 * 60,\n                                                    label: '5 minutes',\n                                                },\n                                                {\n                                                    value: 15 * 60,\n                                                    label: '15 minutes',\n                                                },\n                                                {\n                                                    value: 30 * 60,\n                                                    label: '30 minutes',\n                                                },\n                                                {\n                                                    value: 60 * 60,\n                                                    label: '1 hour',\n                                                },\n                                                {\n                                                    value: 2 * 60 * 60,\n                                                    label: '2 hours',\n                                                },\n                                                {\n                                                    value: 4 * 60 * 60,\n                                                    label: '4 hours',\n                                                },\n                                                {\n                                                    value: 8 * 60 * 60,\n                                                    label: '8 hours',\n                                                },\n                                                {\n                                                    value: 12 * 60 * 60,\n                                                    label: '12 hours',\n                                                },\n                                                {\n                                                    value: 24 * 60 * 60,\n                                                    label: '24 hours',\n                                                },\n                                            ]}\n                                        />\n                                    </div>\n                                    <div className=\"flex flex-wrap gap-1 items-center\">\n                                        <span>or until</span>\n                                        <LemonSelect\n                                            value={value?.threshold}\n                                            onChange={(val) => onChange({ ...value, threshold: val })}\n                                            options={[\n                                                {\n                                                    value: null,\n                                                    label: 'Not set',\n                                                },\n                                                {\n                                                    value: 1000,\n                                                    label: '1000 events',\n                                                },\n                                                {\n                                                    value: 10000,\n                                                    label: '10,000 events',\n                                                },\n                                                {\n                                                    value: 100000,\n                                                    label: '100,000 events',\n                                                },\n                                                {\n                                                    value: 1000000,\n                                                    label: '1,000,000 events',\n                                                },\n                                            ]}\n                                        />\n                                    </div>\n                                </>\n                            ) : null}\n                        </div>\n                    )}\n                </LemonField>\n            ) : null}\n        </div>\n    )\n\n    return (\n        <MaxTool\n            name=\"create_hog_function_filters\"\n            displayName=\"Set up filters with AI\"\n            description=\"Max can set up filters for your function\"\n            context={{\n                current_filters: JSON.stringify(configuration?.filters ?? {}),\n                function_type: type,\n            }}\n            callback={(toolOutput: string) => {\n                const parsedFilters = JSON.parse(toolOutput)\n                setOldFilters(configuration?.filters ?? {})\n                setNewFilters(parsedFilters)\n                reportAIFiltersPrompted()\n            }}\n            onMaxOpen={() => {\n                reportAIFiltersPromptOpen()\n            }}\n            introOverride={{\n                headline: 'What events and properties should trigger this function?',\n                description: 'Let me help you set up the right filters for your function.',\n            }}\n        >\n            {mainContent}\n        </MaxTool>\n    )\n}\n","import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { beforeUnload } from 'kea-router'\nimport api from 'lib/api'\nimport { Dayjs, dayjs } from 'lib/dayjs'\n\nimport { hogql } from '~/queries/utils'\nimport { LogEntryLevel } from '~/types'\n\nimport type { hogFunctionLogsLogicType } from './hogFunctionLogsLogicType'\nimport { GroupedLogEntry, logsViewerLogic, LogsViewerLogicProps } from './logsViewerLogic'\n\nexport type RetryInvocationState = 'pending' | 'success' | 'failure'\n\nconst eventIdMatchers = [/Event: ([A-Za-z0-9-]+)/, /\\/events\\/([A-Za-z0-9-]+)\\//, /event ([A-Za-z0-9-]+)/]\n\nasync function runWithParallelism<T, R>(\n    items: T[],\n    maxParallel: number,\n    asyncFn: (item: T) => Promise<R>\n): Promise<R[]> {\n    const results: R[] = []\n    const executing = new Set<Promise<void>>()\n\n    for (const item of items) {\n        const promise = (async () => {\n            const result = await asyncFn(item)\n            results.push(result)\n        })()\n\n        executing.add(promise)\n        void promise.finally(() => executing.delete(promise))\n\n        if (executing.size >= maxParallel) {\n            await Promise.race(executing)\n        }\n    }\n\n    await Promise.all(executing)\n    return results\n}\n\nconst loadClickhouseEvents = async (\n    eventIds: string[],\n    { date_from, date_to }: { date_from?: string; date_to?: string }\n): Promise<any[]> => {\n    const query = hogql`\n        SELECT uuid, distinct_id, event, timestamp, properties, elements_chain, person.id, person.properties, person.created_at \n        FROM events\n        WHERE uuid in (${hogql.raw(eventIds.map((x) => `'${x}'`).join(','))})\n        AND timestamp > {filters.dateRange.from}\n        AND timestamp < {filters.dateRange.to}`\n\n    const response = await api.queryHogQL(query, {\n        refresh: 'force_blocking',\n        filtersOverride: {\n            date_from: date_from,\n            date_to: date_to,\n        },\n    })\n\n    return response.results.map((x) => {\n        const [\n            uuid,\n            distinct_id,\n            event,\n            timestamp,\n            properties,\n            elements_chain,\n            person_id,\n            person_properties,\n            person_created_at,\n        ] = x\n\n        return {\n            uuid,\n            event,\n            distinct_id,\n            person_id,\n            timestamp,\n            properties,\n            elements_chain,\n            person_created_at,\n            person_properties,\n        }\n    })\n}\n\nexport const hogFunctionLogsLogic = kea<hogFunctionLogsLogicType>([\n    path((key) => ['scenes', 'pipeline', 'hogfunctions', 'logs', 'hogFunctionLogsLogic', key]),\n    props({} as LogsViewerLogicProps), // TODO: Remove `stage` from props, it isn't needed here for anything\n    key(({ sourceType, sourceId }) => `${sourceType}:${sourceId}`),\n    connect((props: LogsViewerLogicProps) => ({\n        values: [logsViewerLogic(props), ['logs']],\n        actions: [logsViewerLogic(props), ['addLogGroups', 'setRowExpanded']],\n    })),\n    actions({\n        setSelectingMany: (selectingMany: boolean) => ({ selectingMany }),\n        setSelectedForRetry: (selectedForRetry: Record<string, boolean>) => ({ selectedForRetry }),\n        selectAllForRetry: true,\n        retryInvocation: (groupedLogEntry: GroupedLogEntry, eventId: string) => ({ groupedLogEntry, eventId }),\n        retryInvocations: (groupedLogEntries: GroupedLogEntry[]) => ({ groupedLogEntries }),\n        retryInvocationStarted: (groupedLogEntry: GroupedLogEntry) => ({ groupedLogEntry }),\n        retryInvocationSuccess: (groupedLogEntry: GroupedLogEntry) => ({ groupedLogEntry }),\n        retryInvocationFailure: (groupedLogEntry: GroupedLogEntry) => ({ groupedLogEntry }),\n        retrySelectedInvocations: true,\n    }),\n    reducers({\n        selectingMany: [\n            false,\n            {\n                setSelectingMany: (_, { selectingMany }) => selectingMany,\n            },\n        ],\n\n        selectedForRetry: [\n            {} as Record<string, boolean>,\n            {\n                setSelectedForRetry: (state, { selectedForRetry }) => {\n                    const newState = { ...state }\n                    Object.keys(selectedForRetry).forEach((key) => {\n                        newState[key] = selectedForRetry[key]\n\n                        if (!selectedForRetry[key]) {\n                            delete newState[key]\n                        }\n                    })\n                    return newState\n                },\n\n                setSelectingMany: (state, { selectingMany }) => {\n                    return selectingMany ? state : {}\n                },\n            },\n        ],\n\n        retries: [\n            {} as Record<string, RetryInvocationState>,\n            {\n                retryInvocationStarted: (state, { groupedLogEntry }) => {\n                    return {\n                        ...state,\n                        [groupedLogEntry.instanceId]: 'pending',\n                    }\n                },\n\n                retryInvocationSuccess: (state, { groupedLogEntry }) => {\n                    return {\n                        ...state,\n                        [groupedLogEntry.instanceId]: 'success',\n                    }\n                },\n\n                retryInvocationFailure: (state, { groupedLogEntry }) => {\n                    return {\n                        ...state,\n                        [groupedLogEntry.instanceId]: 'failure',\n                    }\n                },\n            },\n        ],\n    }),\n\n    selectors({\n        retryRunning: [\n            (s) => [s.retries],\n            (retries) => {\n                return Object.values(retries).some((x) => x === 'pending')\n            },\n        ],\n\n        eventIdByInvocationId: [\n            (s) => [s.logs],\n            (logs) => {\n                const eventIdByInvocationId: Record<string, string> = {}\n\n                for (const record of logs) {\n                    // TRICKY: We have the event ID in different places in different logs. We will standardise this to be the invocation ID in the future.\n                    const entryContainingEventId = record.entries.find(\n                        (entry) =>\n                            entry.message.includes('Function completed') ||\n                            entry.message.includes('Suspending function') ||\n                            entry.message.includes('Error executing function on event')\n                    )\n\n                    if (!entryContainingEventId) {\n                        return undefined\n                    }\n\n                    for (const matcher of eventIdMatchers) {\n                        const match = entryContainingEventId.message.match(matcher)\n                        if (match) {\n                            eventIdByInvocationId[record.instanceId] = match[1]\n                            break\n                        }\n                    }\n                }\n\n                return eventIdByInvocationId\n            },\n        ],\n    }),\n    listeners(({ actions, props, values }) => ({\n        retryInvocations: async ({ groupedLogEntries }) => {\n            await lemonToast.promise(\n                (async () => {\n                    for (const groupedLogEntry of groupedLogEntries) {\n                        actions.retryInvocationStarted(groupedLogEntry)\n                    }\n\n                    if (groupedLogEntries.length === 1) {\n                        // If we only have one log group then we can just expand it to be a little more user friendly\n                        actions.setRowExpanded(groupedLogEntries[0].instanceId, true)\n                    }\n\n                    // We want to get the oldest and newest \"min\" timestamp as that will be closest to when the event was processed\n                    // NOTE: This isn't perfect as the event timestamp might be different to the time it was processed\n                    const [timestampRangeStart, timestampRangeEnd] = groupedLogEntries.reduce(\n                        ([accStart, accEnd], x) => {\n                            if (!accStart) {\n                                return [x.minTimestamp, x.minTimestamp]\n                            }\n\n                            return [\n                                x.minTimestamp.isBefore(accStart) ? x.minTimestamp : accStart,\n                                x.maxTimestamp.isAfter(accEnd) ? x.maxTimestamp : accEnd,\n                            ]\n                        },\n                        [null as Dayjs | null, null as Dayjs | null]\n                    )\n\n                    // Load all events by ID using the date range to speed up the query (we add time either side to account for processing delays)\n                    const events = await loadClickhouseEvents(Object.values(values.eventIdByInvocationId ?? {}), {\n                        date_from: timestampRangeStart?.subtract(1, 'day').toISOString(),\n                        date_to: timestampRangeEnd?.add(1, 'day').toISOString(),\n                    })\n\n                    const eventsById: Record<string, any> = {}\n                    for (const event of events) {\n                        eventsById[event.uuid] = event\n                    }\n\n                    await runWithParallelism(groupedLogEntries, 10, async (groupedLogEntry) => {\n                        try {\n                            // If we have an event then retry it, otherwise fail\n                            const event = eventsById[values.eventIdByInvocationId![groupedLogEntry.instanceId]]\n\n                            if (!event) {\n                                actions.retryInvocationFailure(groupedLogEntry)\n                                return\n                            }\n\n                            const res = await api.hogFunctions.createTestInvocation(props.sourceId, {\n                                clickhouse_event: event,\n                                mock_async_functions: false,\n                                configuration: {\n                                    // For retries we don't care about filters\n                                    filters: {},\n                                },\n                                invocation_id: groupedLogEntry.instanceId,\n                            })\n\n                            const newLogGroup: GroupedLogEntry = {\n                                ...groupedLogEntry,\n                                entries: [\n                                    ...groupedLogEntry.entries,\n                                    ...res.logs.map((x) => ({\n                                        timestamp: dayjs(x.timestamp),\n                                        level: x.level.toUpperCase() as LogEntryLevel,\n                                        message: x.message,\n                                    })),\n                                ],\n                            }\n\n                            actions.addLogGroups([newLogGroup])\n                            actions.retryInvocationSuccess(groupedLogEntry)\n                        } catch {\n                            actions.retryInvocationFailure(groupedLogEntry)\n                        }\n                    })\n\n                    actions.setSelectingMany(false)\n                })(),\n                {\n                    success: 'Retries complete!',\n                    error: 'Retry failed!',\n                    pending: 'Retrying...',\n                }\n            )\n        },\n\n        retrySelectedInvocations: async () => {\n            const groupsToRetry = values.logs.filter((x) => values.selectedForRetry[x.instanceId])\n\n            actions.retryInvocations(groupsToRetry)\n        },\n\n        selectAllForRetry: async () => {\n            actions.setSelectingMany(true)\n\n            for (const groupedLogEntry of values.logs) {\n                actions.setSelectedForRetry({\n                    [groupedLogEntry.instanceId]: true,\n                })\n            }\n        },\n    })),\n\n    beforeUnload(({ values, cache }) => ({\n        enabled: () => !cache.disabledBeforeUnload && values.retryRunning,\n        message: 'You have running retries that will be discarded if you leave. Are you sure?',\n        onConfirm: () => {\n            cache.disabledBeforeUnload = true\n        },\n    })),\n])\n"],"names":[],"sourceRoot":""}