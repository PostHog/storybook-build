{"version":3,"file":"12951.3cd5b016.iframe.bundle.js","mappings":";;;;AAoEA;;AAIA;;;;;;;;AAwBA","sources":["webpack://posthog/./frontend/src/scenes/heatmaps/heatmapsBrowserLogic.ts"],"sourcesContent":["import { actions, afterMount, connect, kea, listeners, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl, router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { authorizedUrlListLogic, AuthorizedUrlListType } from 'lib/components/AuthorizedUrlList/authorizedUrlListLogic'\nimport { CommonFilters, HeatmapFilters, HeatmapFixedPositionMode } from 'lib/components/heatmaps/types'\nimport { calculateViewportRange, DEFAULT_HEATMAP_FILTERS, PostHogAppToolbarEvent } from 'lib/components/heatmaps/utils'\nimport posthog from 'posthog-js'\nimport { RefObject } from 'react'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\n\nimport type { heatmapsBrowserLogicType } from './heatmapsBrowserLogicType'\n\nexport type HeatmapsBrowserLogicProps = {\n    iframeRef: RefObject<HTMLIFrameElement | null>\n}\n\nexport const heatmapsBrowserLogic = kea<heatmapsBrowserLogicType>([\n    path(['scenes', 'heatmaps', 'heatmapsBrowserLogic']),\n    props({} as HeatmapsBrowserLogicProps),\n\n    connect({\n        values: [\n            authorizedUrlListLogic({ actionId: null, type: AuthorizedUrlListType.TOOLBAR_URLS }),\n            ['urlsKeyed', 'checkUrlIsAuthorized'],\n        ],\n    }),\n\n    actions({\n        setBrowserSearch: (searchTerm: string) => ({ searchTerm }),\n        setBrowserUrl: (url: string) => ({ url }),\n        setIframePosthogJsConnected: (ready: boolean) => ({ ready }),\n        onIframeLoad: true,\n        onIframeToolbarLoad: true,\n        sendToolbarMessage: (type: PostHogAppToolbarEvent, payload?: Record<string, any>) => ({\n            type,\n            payload,\n        }),\n        setLoading: (loading: boolean) => ({ loading }),\n        loadTopUrls: true,\n        maybeLoadTopUrls: true,\n        loadBrowserSearchResults: true,\n        // TRICKY: duplicated with the heatmapLogic so that we can share the settings picker\n        patchHeatmapFilters: (filters: Partial<HeatmapFilters>) => ({ filters }),\n        setHeatmapColorPalette: (Palette: string | null) => ({ Palette }),\n        setHeatmapFixedPositionMode: (mode: HeatmapFixedPositionMode) => ({ mode }),\n        setCommonFilters: (filters: CommonFilters) => ({ filters }),\n        // TRICKY: duplication ends\n        setIframeWidth: (width: number | null) => ({ width }),\n    }),\n\n    loaders(({ values }) => ({\n        browserSearchResults: [\n            null as string[] | null,\n            {\n                loadBrowserSearchResults: async () => {\n                    if (!values.browserSearchTerm) {\n                        return []\n                    }\n\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT distinct properties.$current_url AS urls\n                                     FROM events\n                                     WHERE timestamp >= now() - INTERVAL 7 DAY\n                                       AND timestamp <= now()\n                                       AND properties.$current_url like '%${hogql.identifier(\n                                           values.browserSearchTerm\n                                       )}%'\n                                     ORDER BY timestamp DESC\n                                         limit 100`,\n                    }\n\n                    const res = await api.query(query)\n\n                    return res.results?.map((x) => x[0]) as string[]\n                },\n            },\n        ],\n\n        topUrls: [\n            null as { url: string; count: number }[] | null,\n            {\n                loadTopUrls: async () => {\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$current_url AS url, count() as count\n                                     FROM events\n                                     WHERE timestamp >= now() - INTERVAL 7 DAY\n                                       AND event in ('$pageview'\n                                         , '$autocapture')\n                                       AND timestamp <= now()\n                                     GROUP BY properties.$current_url\n                                     ORDER BY count DESC\n                                         LIMIT 10`,\n                    }\n\n                    const res = await api.query(query)\n\n                    return res.results?.map((x) => ({ url: x[0], count: x[1] })) as { url: string; count: number }[]\n                },\n            },\n        ],\n    })),\n\n    reducers({\n        // they're called common filters in the toolbar because they're shared between heatmaps and clickmaps\n        // the name is continued here since they're passed down into the embedded iframe\n        commonFilters: [\n            { date_from: '-7d' } as CommonFilters,\n            {\n                setCommonFilters: (_, { filters }) => filters,\n            },\n        ],\n        heatmapColorPalette: [\n            'default' as string | null,\n            {\n                setHeatmapColorPalette: (_, { Palette }) => Palette,\n            },\n        ],\n        heatmapFilters: [\n            DEFAULT_HEATMAP_FILTERS,\n            {\n                patchHeatmapFilters: (state, { filters }) => ({ ...state, ...filters }),\n            },\n        ],\n        heatmapFixedPositionMode: [\n            'fixed' as HeatmapFixedPositionMode,\n            {\n                setHeatmapFixedPositionMode: (_, { mode }) => mode,\n            },\n        ],\n        iframeWidth: [\n            null as number | null,\n            {\n                setIframeWidth: (_, { width }) => width,\n            },\n        ],\n        browserSearchTerm: [\n            '',\n            {\n                setBrowserSearch: (_, { searchTerm }) => searchTerm,\n            },\n        ],\n        browserUrl: [\n            null as string | null,\n            { persist: true },\n            {\n                setBrowserUrl: (_, { url }) => url,\n            },\n        ],\n        iframePosthogJsConnected: [\n            false as boolean,\n            {\n                setIframePosthogJsConnected: (_, { ready }) => ready,\n            },\n        ],\n\n        loading: [\n            false as boolean,\n            {\n                setLoading: (_, { loading }) => loading,\n                setBrowserUrl: () => true,\n                onIframeToolbarLoad: () => false,\n            },\n        ],\n    }),\n\n    selectors({\n        browserUrlSearchOptions: [\n            (s) => [s.browserSearchResults, s.topUrls, s.browserSearchTerm],\n            (browserSearchResults, topUrls, browserSearchTerm) => {\n                return browserSearchTerm ? browserSearchResults : topUrls?.map((x) => x.url) ?? []\n            },\n        ],\n\n        isBrowserUrlAuthorized: [\n            (s) => [s.browserUrl, s.checkUrlIsAuthorized],\n            (browserUrl, checkUrlIsAuthorized) => {\n                if (!browserUrl) {\n                    return false\n                }\n                return checkUrlIsAuthorized(browserUrl)\n            },\n        ],\n\n        viewportRange: [\n            (s) => [s.heatmapFilters, s.iframeWidth],\n            (heatmapFilters, iframeWidth) => {\n                return iframeWidth ? calculateViewportRange(heatmapFilters, iframeWidth) : { min: 0, max: 1800 }\n            },\n        ],\n\n        noPageviews: [\n            (s) => [s.topUrlsLoading, s.topUrls],\n            (topUrlsLoading, topUrls) => !topUrlsLoading && (!topUrls || topUrls.length === 0),\n        ],\n    }),\n\n    listeners(({ actions, props, values }) => ({\n        setBrowserSearch: async (_, breakpoint) => {\n            await breakpoint(200)\n            actions.loadBrowserSearchResults()\n        },\n\n        sendToolbarMessage: ({ type, payload }) => {\n            props.iframeRef?.current?.contentWindow?.postMessage(\n                {\n                    type,\n                    payload,\n                },\n                '*'\n            )\n        },\n\n        patchHeatmapFilters: ({ filters }) => {\n            actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_PATCH_HEATMAP_FILTERS, { filters })\n        },\n        setHeatmapFixedPositionMode: ({ mode }) => {\n            actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_HEATMAPS_FIXED_POSITION_MODE, {\n                fixedPositionMode: mode,\n            })\n        },\n        setHeatmapColorPalette: ({ Palette }) => {\n            actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_HEATMAPS_COLOR_PALETTE, {\n                colorPalette: Palette,\n            })\n        },\n        setCommonFilters: ({ filters }) => {\n            actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_HEATMAPS_COMMON_FILTERS, { commonFilters: filters })\n        },\n\n        onIframeLoad: () => {\n            // TODO: Add a timeout - if we haven't received a message from the iframe in X seconds, show an error\n            const init = (): void => {\n                actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_APP_INIT, {\n                    filters: values.heatmapFilters,\n                    colorPalette: values.heatmapColorPalette,\n                    fixedPositionMode: values.heatmapFixedPositionMode,\n                    commonFilters: values.commonFilters,\n                })\n                actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_HEATMAPS_CONFIG, {\n                    enabled: true,\n                })\n            }\n\n            const onIframeMessage = (e: MessageEvent): void => {\n                // TODO: Probably need to have strict checks here\n                const type: PostHogAppToolbarEvent = e?.data?.type\n\n                if (!type || !type.startsWith('ph-')) {\n                    return\n                }\n\n                switch (type) {\n                    case PostHogAppToolbarEvent.PH_TOOLBAR_INIT:\n                        return init()\n                    case PostHogAppToolbarEvent.PH_TOOLBAR_READY:\n                        posthog.capture('in-app heatmap loaded', {\n                            inapp_heatmap_page_url_visited: values.browserUrl,\n                            inapp_heatmap_filters: values.heatmapFilters,\n                            inapp_heatmap_color_palette: values.heatmapColorPalette,\n                            inapp_heatmap_fixed_position_mode: values.heatmapFixedPositionMode,\n                        })\n                        return actions.onIframeToolbarLoad()\n                    default:\n                        console.warn(`[PostHog Heatmpas] Received unknown child window message: ${type}`)\n                }\n            }\n\n            window.addEventListener('message', onIframeMessage, false)\n            // We call init in case the toolbar got there first (unlikely)\n            init()\n        },\n\n        maybeLoadTopUrls: () => {\n            if (!values.topUrls && !values.topUrlsLoading) {\n                actions.loadTopUrls()\n            }\n        },\n\n        setBrowserUrl: () => {\n            actions.maybeLoadTopUrls()\n        },\n    })),\n\n    afterMount(({ actions, values }) => {\n        if (values.browserUrl) {\n            actions.setLoading(true)\n        } else {\n            actions.maybeLoadTopUrls()\n        }\n    }),\n\n    urlToAction(({ actions }) => ({\n        '/heatmaps': (_, searchParams) => {\n            if (searchParams.pageURL) {\n                actions.setBrowserUrl(searchParams.pageURL)\n                // otherwise we could have a race\n                // between the aftermount setting the loading state and the toolbar load cancelling it\n                actions.setLoading(false)\n            }\n            if (searchParams.heatmapFilters) {\n                actions.patchHeatmapFilters(searchParams.heatmapFilters)\n            }\n            if (searchParams.heatmapPalette) {\n                actions.setHeatmapColorPalette(searchParams.heatmapPalette)\n            }\n            if (searchParams.heatmapFixedPositionMode) {\n                actions.setHeatmapFixedPositionMode(searchParams.heatmapFixedPositionMode as HeatmapFixedPositionMode)\n            }\n            if (searchParams.commonFilters) {\n                actions.setCommonFilters(searchParams.commonFilters as CommonFilters)\n            }\n        },\n    })),\n\n    actionToUrl(({ values }) => ({\n        setBrowserUrl: ({ url }) => {\n            const searchParams = { ...router.values.searchParams, pageURL: url }\n            if (!url || url.trim() === '') {\n                delete searchParams.pageURL\n            }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n        patchHeatmapFilters: () => {\n            const searchParams = { ...router.values.searchParams, heatmapFilters: values.heatmapFilters }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n        setHeatmapColorPalette: ({ Palette }) => {\n            const searchParams = { ...router.values.searchParams, heatmapPalette: Palette }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n        setHeatmapFixedPositionMode: ({ mode }) => {\n            const searchParams = { ...router.values.searchParams, heatmapFixedPositionMode: mode }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n        setCommonFilters: ({ filters }) => {\n            const searchParams = { ...router.values.searchParams, commonFilters: filters }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n    })),\n])\n"],"names":[],"sourceRoot":""}