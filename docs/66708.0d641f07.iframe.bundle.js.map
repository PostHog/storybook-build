{"version":3,"file":"66708.0d641f07.iframe.bundle.js","mappings":";AAoFA;AAAA","sources":["webpack://posthog/./frontend/src/scenes/llm-observability/utils.ts"],"sourcesContent":["import { LLMGeneration, LLMTrace } from '~/queries/schema'\n\nexport function formatLLMUsage(trace: LLMTrace | LLMGeneration): string | null {\n    if (typeof trace.inputTokens === 'number') {\n        return `${trace.inputTokens} → ${trace.outputTokens || 0} (∑ ${trace.inputTokens + (trace.outputTokens || 0)})`\n    }\n\n    return null\n}\n\nexport function formatLLMLatency(latency: number): string {\n    return `${Math.round(latency * 100) / 100} s`\n}\n\nconst usdFormatter = new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD',\n    maximumFractionDigits: 4,\n})\n\nexport function formatLLMCost(cost: number): string {\n    return usdFormatter.format(cost)\n}\n\nexport interface RoleBasedMessage {\n    role: string\n    content: string\n    additional_kwargs?: any\n    tool_calls?: any\n}\n\nexport function isRoleBasedMessage(input: any): input is RoleBasedMessage {\n    return (\n        typeof input === 'object' &&\n        'role' in input &&\n        'content' in input &&\n        typeof input.role === 'string' &&\n        typeof input.content === 'string'\n    )\n}\n\nexport interface ChoicesOutput {\n    choices: RoleBasedMessage[]\n}\n\nexport function isChoicesOutput(input: any): input is ChoicesOutput {\n    return typeof input === 'object' && 'choices' in input && Array.isArray(input.choices)\n}\n\nexport interface ToolCall {\n    type: string\n    id?: string\n    function: {\n        name: string\n        arguments: string\n    }\n}\n\nexport function isToolCall(input: any): input is ToolCall {\n    return typeof input === 'object' && 'type' in input && 'function' in input && input.type === 'function'\n}\n\nexport type ToolCalls = ToolCall[]\n\nexport function isToolCallsArray(input: any): input is ToolCalls {\n    return Array.isArray(input) && input.every(isToolCall)\n}\n\nexport function formatToolCalls(toolCalls: ToolCalls): string {\n    const toolsWithParsedArguments = toolCalls.map((toolCall) => ({\n        ...toolCall,\n        function: {\n            ...toolCall.function,\n            arguments:\n                typeof toolCall.function.arguments === 'string'\n                    ? JSON.parse(toolCall.function.arguments)\n                    : toolCall.function.arguments,\n        },\n    }))\n\n    return JSON.stringify(toolsWithParsedArguments, null, 2)\n}\n\nexport function formatAsMarkdownJSONBlock(output: string): string {\n    return `\\`\\`\\`json\\n${output}\\n\\`\\`\\``\n}\n"],"names":[],"sourceRoot":""}