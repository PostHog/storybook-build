{"version":3,"file":"main.a21f0d30.iframe.bundle.js","mappings":";;;;;AAyBA;;;;;;;ACiIA;;AC/IA;AACA;;AC8CA;;ACoTA;AAAA;AAAA;AAAA;;;;;;;AC1TA;;AC7BA;;;;;;;;;;;AC+RA;;;;;AAgBA;ACFA;AC9PA;ACgPA;AACA;ACtNA;AASA;;;AAWA;;;;;ACpEA;;;;;AAqBA;;AA1CA;;;;;AAKA;;;;;AAoDA;;;AAoCA;;;;;;AAMA;;AA7BA;;;;AAIA;;;;;AAKA;;AAiCA;;;;;AAKA;AC7HA;;;AAoBA;;;AAIA;AAKA;;;AAGA;;AAEA;AAGA;;AAEA;AACA;;AAWA;AACA;AACA;;;;;AA+BA;;;AAIA;AAKA;;;AAGA;AACA;AAGA;AACA;AACA;;AAWA;AACA;AACA;;;;AAyBA;;;AAIA;;AAMA;;AAEA;;AAIA;;AAGA;AACA;AACA;;AAUA;AACA;AACA;;;AAwBA;;;AAIA;AAKA;;AAEA;AACA;AAGA;AACA;AACA;;AAUA;AACA;AACA;;;AA6BA;;;AAIA;AAKA;;AAEA;AACA;AAGA;AACA;AACA;;AAUA;AACA;AACA;;;AA8BA;;;AAyBA;;AAuBA;;;;AAyBA;;;;;;;AAOA;;;;AAIA;AACA;AAkBA;;;AAGA;;AAEA;;;AAGA;AAUA;;;AASA;AACA;;AAEA;;;AA6BA;;AAMA;;AAWA;;AAEA;;;;;;AAMA;;AAEA;;;;;;;;;;;;;;;;;AA0BA;AC9dA;;;;;;;;;;;ACyLA;AC9KA;;;;;;;;;;;;;;;AClEA;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;;;;;;;;;;;ACy1CA;;;ACl1CA;;;;;AAKA;AACA;AACA;;;ACQA;;;;;ACkIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAmCA;;;;AAIA;AACA;AACA;;AAEA;;AAkCA;;;;AAIA;AACA;AACA;;AAEA;;;AAmCA;;;AAGA;AACA;AACA;;;AAGA;;;;AAgDA;AACA;AACA;AACA;;AAEA","sources":["webpack://posthog/./frontend/src/lib/components/ReverseProxyChecker/reverseProxyCheckerLogic.ts","webpack://posthog/./frontend/src/lib/components/AuthorizedUrlList/authorizedUrlListLogic.ts","webpack://posthog/./frontend/src/lib/components/JSSnippet.tsx","webpack://posthog/./frontend/src/lib/components/Support/SupportForm.tsx","webpack://posthog/./frontend/src/lib/components/Support/supportLogic.ts","webpack://posthog/./frontend/src/lib/components/VersionChecker/versionCheckerLogic.ts","webpack://posthog/./frontend/src/lib/lemon-ui/LemonTextArea/LemonTextAreaMarkdown.tsx","webpack://posthog/./frontend/src/queries/examples.ts","webpack://posthog/./frontend/src/scenes/batch_exports/batchExportEditLogic.ts","webpack://posthog/./frontend/src/scenes/billing/BillingProduct.tsx","webpack://posthog/./frontend/src/scenes/billing/billingLogic.ts","webpack://posthog/./frontend/src/scenes/early-access-features/InstructionsModal.tsx","webpack://posthog/./frontend/src/scenes/experiments/ExperimentCodeSnippets.tsx","webpack://posthog/./frontend/src/scenes/feature-flags/FeatureFlagSnippets.tsx","webpack://posthog/./frontend/src/scenes/notebooks/Nodes/NotebookNodeReplayTimestamp.tsx","webpack://posthog/./frontend/src/scenes/notebooks/Notebook/SlashCommands.tsx","webpack://posthog/./frontend/src/scenes/paths/renderPaths.ts","webpack://posthog/./frontend/src/scenes/plugins/source/createDefaultPluginSource.ts","webpack://posthog/./ee/frontend/mobile-replay/transformer/transformers.ts","webpack://posthog/./frontend/src/scenes/session-recordings/playlist/sessionRecordingsListPropertiesLogic.ts","webpack://posthog/./frontend/src/scenes/settings/organization/VerifiedDomains/ConfigureSAMLModal.tsx","webpack://posthog/./frontend/src/scenes/surveys/surveyLogic.tsx"],"sourcesContent":["import { afterMount, kea, path, reducers } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\n\nimport type { reverseProxyCheckerLogicType } from './reverseProxyCheckerLogicType'\n\nconst CHECK_INTERVAL_MS = 1000 * 60 * 60 // 1 hour\n\nexport const reverseProxyCheckerLogic = kea<reverseProxyCheckerLogicType>([\n    path(['components', 'ReverseProxyChecker', 'reverseProxyCheckerLogic']),\n    loaders({\n        hasReverseProxy: [\n            false as boolean | null,\n            {\n                loadHasReverseProxy: async () => {\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$lib_custom_api_host AS lib_custom_api_host\n                                FROM events\n                                WHERE timestamp >= now() - INTERVAL 1 DAY \n                                AND timestamp <= now()\n                                ORDER BY timestamp DESC\n                                limit 10`,\n                    }\n\n                    const res = await api.query(query)\n                    return !!res.results?.find((x) => !!x[0])\n                },\n            },\n        ],\n    }),\n    reducers({\n        lastCheckedTimestamp: [\n            0,\n            { persist: true },\n            {\n                loadHasReverseProxySuccess: () => Date.now(),\n            },\n        ],\n    }),\n    afterMount(({ actions, values }) => {\n        if (values.lastCheckedTimestamp < Date.now() - CHECK_INTERVAL_MS) {\n            actions.loadHasReverseProxy()\n        }\n    }),\n])\n","import Fuse from 'fuse.js'\nimport {\n    actions,\n    afterMount,\n    connect,\n    kea,\n    key,\n    listeners,\n    path,\n    props,\n    reducers,\n    selectors,\n    sharedListeners,\n} from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { encodeParams, urlToAction } from 'kea-router'\nimport { subscriptions } from 'kea-subscriptions'\nimport api from 'lib/api'\nimport { isDomain, isURL } from 'lib/utils'\nimport { apiHostOrigin } from 'lib/utils/apiHost'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\nimport { ToolbarParams } from '~/types'\n\nimport type { authorizedUrlListLogicType } from './authorizedUrlListLogicType'\n\nexport interface ProposeNewUrlFormType {\n    url: string\n}\n\nexport enum AuthorizedUrlListType {\n    TOOLBAR_URLS = 'TOOLBAR_URLS',\n    RECORDING_DOMAINS = 'RECORDING_DOMAINS',\n}\n\nexport const validateProposedUrl = (\n    proposedUrl: string,\n    currentUrls: string[],\n    onlyAllowDomains: boolean = false\n): string | undefined => {\n    if (!onlyAllowDomains && !isURL(proposedUrl)) {\n        return 'Please enter a valid URL'\n    }\n\n    if (onlyAllowDomains && !isDomain(proposedUrl)) {\n        return \"Please enter a valid domain (URLs with a path aren't allowed)\"\n    }\n\n    if (proposedUrl.indexOf('*') > -1 && !proposedUrl.match(/^(.*)\\*[^*]*\\.[^*]+\\.[^*]+$/)) {\n        return 'Wildcards can only be used for subdomains'\n    }\n\n    if (currentUrls.indexOf(proposedUrl) > -1) {\n        return `This ${onlyAllowDomains ? 'domains' : 'URL'} already is registered`\n    }\n\n    return\n}\n\n/** defaultIntent: whether to launch with empty intent (i.e. toolbar mode is default) */\nexport function appEditorUrl(appUrl: string, actionId?: number | null, defaultIntent?: boolean): string {\n    // See https://github.com/PostHog/posthog-js/blob/f7119c/src/extensions/toolbar.ts#L52 for where these params\n    // are passed. `appUrl` is an extra `redirect_to_site` param.\n    const params: ToolbarParams & { appUrl: string } = {\n        userIntent: defaultIntent ? undefined : actionId ? 'edit-action' : 'add-action',\n        // Make sure to pass the app url, otherwise the api_host will be used by\n        // the toolbar, which isn't correct when used behind a reverse proxy as\n        // we require e.g. SSO login to the app, which will not work when placed\n        // behind a proxy unless we register each domain with the OAuth2 client.\n        apiURL: apiHostOrigin(),\n        appUrl,\n        ...(actionId ? { actionId } : {}),\n    }\n    return '/api/user/redirect_to_site/' + encodeParams(params, '?')\n}\n\nexport const filterNotAuthorizedUrls = (urls: string[], authorizedUrls: string[]): string[] => {\n    const suggestedDomains: string[] = []\n\n    urls.forEach((url) => {\n        try {\n            const parsedUrl = new URL(url)\n            const urlWithoutPath = parsedUrl.protocol + '//' + parsedUrl.host\n            // Have we already added this domain?\n            if (suggestedDomains.indexOf(urlWithoutPath) > -1) {\n                return\n            }\n            // Is this domain already in the list of urls?\n            const exactMatch = authorizedUrls.filter((url) => url.indexOf(urlWithoutPath) > -1).length > 0\n            const wildcardMatch = !!authorizedUrls.find((url) => {\n                // Matches something like `https://*.example.com` against the urlWithoutPath\n                const regex = new RegExp(url.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'))\n                return urlWithoutPath.match(regex)\n            })\n\n            if (!exactMatch && !wildcardMatch) {\n                suggestedDomains.push(urlWithoutPath)\n            }\n        } catch (error) {\n            return\n        }\n    })\n\n    return suggestedDomains\n}\n\nexport const NEW_URL = 'https://'\n\nexport interface KeyedAppUrl {\n    url: string\n    type: 'authorized' | 'suggestion'\n    originalIndex: number\n}\n\nexport interface AuthorizedUrlListLogicProps {\n    actionId: number | null\n    type: AuthorizedUrlListType\n}\nexport const authorizedUrlListLogic = kea<authorizedUrlListLogicType>([\n    path((key) => ['lib', 'components', 'AuthorizedUrlList', 'authorizedUrlListLogic', key]),\n    key((props) => `${props.type}-${props.actionId}`),\n    props({} as AuthorizedUrlListLogicProps),\n    connect({\n        values: [teamLogic, ['currentTeam', 'currentTeamId']],\n        actions: [teamLogic, ['updateCurrentTeam']],\n    }),\n    actions(() => ({\n        setAuthorizedUrls: (authorizedUrls: string[]) => ({ authorizedUrls }),\n        addUrl: (url: string, launch?: boolean) => ({ url, launch }),\n        newUrl: true,\n        removeUrl: (index: number) => ({ index }),\n        updateUrl: (index: number, url: string) => ({ index, url }),\n        launchAtUrl: (url: string) => ({ url }),\n        setSearchTerm: (term: string) => ({ term }),\n        setEditUrlIndex: (originalIndex: number | null) => ({ originalIndex }),\n        cancelProposingUrl: true,\n    })),\n    loaders(({ values }) => ({\n        suggestions: {\n            __default: [] as string[],\n            loadSuggestions: async () => {\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: hogql`select properties.$current_url, count()\n                        from events\n                           where event = '$pageview'\n                           and timestamp >= now() - interval 3 day \n                            and timestamp <= now()\n                         group by properties.$current_url\n                         order by count() desc\n                        limit 25`,\n                }\n\n                const response = await api.query(query)\n                const result = response.results as [string, number][]\n\n                if (result && result.length === 0) {\n                    return []\n                }\n\n                const suggestedDomains = filterNotAuthorizedUrls(\n                    result.map(([url]) => url),\n                    values.authorizedUrls\n                )\n\n                return suggestedDomains.slice(0, 20)\n            },\n        },\n    })),\n    subscriptions(({ props, actions }) => ({\n        currentTeam: (currentTeam) => {\n            actions.setAuthorizedUrls(\n                (props.type === AuthorizedUrlListType.RECORDING_DOMAINS\n                    ? currentTeam.recording_domains\n                    : currentTeam.app_urls) || []\n            )\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadSuggestions()\n    }),\n    forms(({ values, actions }) => ({\n        proposedUrl: {\n            defaults: { url: '' } as ProposeNewUrlFormType,\n            errors: ({ url }) => ({\n                url: validateProposedUrl(url, values.authorizedUrls, values.onlyAllowDomains),\n            }),\n            submit: async ({ url }) => {\n                if (values.editUrlIndex !== null && values.editUrlIndex >= 0) {\n                    actions.updateUrl(values.editUrlIndex, url)\n                } else {\n                    actions.addUrl(url)\n                }\n            },\n        },\n    })),\n    reducers(() => ({\n        showProposedURLForm: [\n            false as boolean,\n            {\n                newUrl: () => true,\n                submitProposedUrlSuccess: () => false,\n                cancelProposingUrl: () => false,\n            },\n        ],\n        authorizedUrls: [\n            [] as string[],\n            {\n                setAuthorizedUrls: (_, { authorizedUrls }) => authorizedUrls,\n                addUrl: (state, { url }) => state.concat([url]),\n                updateUrl: (state, { index, url }) => Object.assign([...state], { [index]: url }),\n                removeUrl: (state, { index }) => {\n                    const newUrls = [...state]\n                    newUrls.splice(index, 1)\n                    return newUrls\n                },\n            },\n        ],\n        suggestions: [\n            [],\n            {\n                addUrl: (state, { url }) => [...state].filter((item) => url !== item),\n            },\n        ],\n        searchTerm: [\n            '',\n            {\n                setSearchTerm: (_, { term }) => term,\n            },\n        ],\n        editUrlIndex: [\n            null as number | null,\n            {\n                setEditUrlIndex: (_, { originalIndex }) => originalIndex,\n                removeUrl: (editUrlIndex, { index }) =>\n                    editUrlIndex && index < editUrlIndex\n                        ? editUrlIndex - 1\n                        : index === editUrlIndex\n                        ? null\n                        : editUrlIndex,\n                newUrl: () => -1,\n                updateUrl: () => null,\n                addUrl: () => null,\n                cancelProposingUrl: () => null,\n            },\n        ],\n    })),\n    sharedListeners(({ values, props }) => ({\n        saveUrls: async () => {\n            if (props.type === AuthorizedUrlListType.RECORDING_DOMAINS) {\n                await teamLogic.asyncActions.updateCurrentTeam({ recording_domains: values.authorizedUrls })\n            } else {\n                await teamLogic.asyncActions.updateCurrentTeam({ app_urls: values.authorizedUrls })\n            }\n        },\n    })),\n    listeners(({ sharedListeners, values, actions }) => ({\n        setEditUrlIndex: () => {\n            actions.setProposedUrlValue('url', values.urlToEdit)\n        },\n        newUrl: () => {\n            actions.setProposedUrlValue('url', NEW_URL)\n        },\n        addUrl: [\n            sharedListeners.saveUrls,\n            ({ url, launch }) => {\n                if (launch) {\n                    actions.launchAtUrl(url)\n                }\n            },\n        ],\n        removeUrl: sharedListeners.saveUrls,\n        updateUrl: sharedListeners.saveUrls,\n        launchAtUrl: ({ url }) => {\n            window.location.href = values.launchUrl(url)\n        },\n        cancelProposingUrl: () => {\n            actions.resetProposedUrl()\n        },\n        submitProposedUrlSuccess: () => {\n            actions.setEditUrlIndex(null)\n            actions.resetProposedUrl()\n        },\n    })),\n    selectors({\n        urlToEdit: [\n            (s) => [s.authorizedUrls, s.editUrlIndex],\n            (authorizedUrls, editUrlIndex) => {\n                if (editUrlIndex === null || editUrlIndex === -1) {\n                    return NEW_URL\n                }\n                return authorizedUrls[editUrlIndex]\n            },\n        ],\n        urlsKeyed: [\n            (s) => [s.authorizedUrls, s.suggestions, s.searchTerm],\n            (authorizedUrls, suggestions, searchTerm): KeyedAppUrl[] => {\n                const keyedUrls = authorizedUrls\n                    .map((url, index) => ({\n                        url,\n                        type: 'authorized',\n                        originalIndex: index,\n                    }))\n                    .concat(\n                        suggestions.map((url, index) => ({\n                            url,\n                            type: 'suggestion',\n                            originalIndex: index,\n                        }))\n                    ) as KeyedAppUrl[]\n\n                if (!searchTerm) {\n                    return keyedUrls\n                }\n\n                return new Fuse(keyedUrls, {\n                    keys: ['url'],\n                    threshold: 0.3,\n                })\n                    .search(searchTerm)\n                    .map((result) => result.item)\n            },\n        ],\n        launchUrl: [(_, p) => [p.actionId], (actionId) => (url: string) => appEditorUrl(url, actionId, !actionId)],\n        isAddUrlFormVisible: [(s) => [s.editUrlIndex], (editUrlIndex) => editUrlIndex === -1],\n        onlyAllowDomains: [(_, p) => [p.type], (type) => type === AuthorizedUrlListType.RECORDING_DOMAINS],\n    }),\n    urlToAction(({ actions }) => ({\n        [urls.toolbarLaunch()]: (_, searchParams) => {\n            if (searchParams.addNew) {\n                actions.newUrl()\n            }\n        },\n    })),\n])\n","import { useValues } from 'kea'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { apiHostOrigin } from 'lib/utils/apiHost'\nimport { teamLogic } from 'scenes/teamLogic'\n\nexport function JSSnippet(): JSX.Element {\n    const { currentTeam } = useValues(teamLogic)\n\n    return (\n        <CodeSnippet language={Language.HTML}>{`<script>\n    !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(\".\");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement(\"script\")).type=\"text/javascript\",p.async=!0,p.src=s.api_host+\"/static/array.js\",(r=t.getElementsByTagName(\"script\")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a=\"posthog\",u.people=u.people||[],u.toString=function(t){var e=\"posthog\";return\"posthog\"!==a&&(e+=\".\"+a),t||(e+=\" (stub)\"),e},u.people.toString=function(){return u.toString(1)+\".people (stub)\"},o=\"capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys onSessionId\".split(\" \"),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);\n    posthog.init('${currentTeam?.api_token}',{api_host:'${apiHostOrigin()}'})\n</script>`}</CodeSnippet>\n    )\n}\n","import { IconBug, IconInfo, IconQuestion } from '@posthog/icons'\nimport {\n    LemonInput,\n    LemonSegmentedButton,\n    LemonSegmentedButtonOption,\n    lemonToast,\n    Link,\n    Tooltip,\n} from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\nimport { useUploadFiles } from 'lib/hooks/useUploadFiles'\nimport { IconFeedback } from 'lib/lemon-ui/icons'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonFileInput } from 'lib/lemon-ui/LemonFileInput/LemonFileInput'\nimport { LemonSelect } from 'lib/lemon-ui/LemonSelect/LemonSelect'\nimport { LemonTextArea } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { useEffect, useRef } from 'react'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { SEVERITY_LEVEL_TO_NAME, supportLogic, SupportTicketKind, TARGET_AREA_TO_NAME } from './supportLogic'\n\nconst SUPPORT_TICKET_OPTIONS: LemonSegmentedButtonOption<SupportTicketKind>[] = [\n    {\n        value: 'support',\n        label: 'Question',\n        icon: <IconQuestion />,\n    },\n    {\n        value: 'feedback',\n        label: 'Feedback',\n        icon: <IconFeedback />,\n    },\n    {\n        value: 'bug',\n        label: 'Bug',\n        icon: <IconBug />,\n    },\n]\n\nconst SUPPORT_TICKET_KIND_TO_PROMPT: Record<SupportTicketKind, string> = {\n    bug: \"What's the bug?\",\n    feedback: 'What feedback do you have?',\n    support: 'What can we help you with?',\n}\n\nexport function SupportForm(): JSX.Element | null {\n    const { sendSupportRequest } = useValues(supportLogic)\n    const { setSendSupportRequestValue } = useActions(supportLogic)\n    const { objectStorageAvailable } = useValues(preflightLogic)\n    // the support model can be shown when logged out, file upload is not offered to anonymous users\n    const { user } = useValues(userLogic)\n\n    const dropRef = useRef<HTMLDivElement>(null)\n\n    const { setFilesToUpload, filesToUpload, uploading } = useUploadFiles({\n        onUpload: (url, fileName) => {\n            setSendSupportRequestValue('message', sendSupportRequest.message + `\\n\\nAttachment \"${fileName}\": ${url}`)\n        },\n        onError: (detail) => {\n            lemonToast.error(`Error uploading image: ${detail}`)\n        },\n    })\n\n    useEffect(() => {\n        if (sendSupportRequest.kind === 'bug') {\n            setSendSupportRequestValue('severity_level', 'medium')\n        } else {\n            setSendSupportRequestValue('severity_level', 'low')\n        }\n    }, [sendSupportRequest.kind])\n\n    return (\n        <Form\n            logic={supportLogic}\n            formKey=\"sendSupportRequest\"\n            id=\"support-modal-form\"\n            enableFormOnSubmit\n            className=\"space-y-4\"\n        >\n            {!user && (\n                <>\n                    <LemonField name=\"name\" label=\"Name\">\n                        <LemonInput data-attr=\"name\" placeholder=\"Jane\" />\n                    </LemonField>\n                    <LemonField name=\"email\" label=\"Email\">\n                        <LemonInput data-attr=\"email\" placeholder=\"your@email.com\" />\n                    </LemonField>\n                </>\n            )}\n            <LemonField name=\"kind\" label=\"Message type\">\n                <LemonSegmentedButton fullWidth options={SUPPORT_TICKET_OPTIONS} />\n            </LemonField>\n            <LemonField name=\"target_area\" label=\"Topic\">\n                <LemonSelect fullWidth options={TARGET_AREA_TO_NAME} />\n            </LemonField>\n            <LemonField\n                name=\"message\"\n                label={sendSupportRequest.kind ? SUPPORT_TICKET_KIND_TO_PROMPT[sendSupportRequest.kind] : 'Content'}\n            >\n                {(props) => (\n                    <div ref={dropRef} className=\"flex flex-col gap-2\">\n                        <LemonTextArea\n                            placeholder=\"Type your message here\"\n                            data-attr=\"support-form-content-input\"\n                            {...props}\n                        />\n                        {objectStorageAvailable && !!user && (\n                            <LemonFileInput\n                                accept=\"image/*\"\n                                multiple={false}\n                                alternativeDropTargetRef={dropRef}\n                                onChange={setFilesToUpload}\n                                loading={uploading}\n                                value={filesToUpload}\n                            />\n                        )}\n                    </div>\n                )}\n            </LemonField>\n            <div className=\"flex gap-2 flex-col\">\n                <div className=\"flex justify-between items-center\">\n                    <label className=\"LemonLabel\">\n                        Severity level\n                        <Tooltip title=\"Severity levels help us prioritize your request.\">\n                            <span>\n                                <IconInfo className=\"opacity-75\" />\n                            </span>\n                        </Tooltip>\n                    </label>\n                    <Link target=\"_blank\" to=\"https://posthog.com/docs/support-options#severity-levels\">\n                        Definitions\n                    </Link>\n                </div>\n                <LemonField name=\"severity_level\">\n                    <LemonSelect\n                        fullWidth\n                        options={Object.entries(SEVERITY_LEVEL_TO_NAME).map(([key, value]) => ({\n                            label: value,\n                            value: key,\n                        }))}\n                    />\n                </LemonField>\n            </div>\n        </Form>\n    )\n}\n","import { captureException } from '@sentry/react'\nimport * as Sentry from '@sentry/react'\nimport { actions, connect, kea, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { urlToAction } from 'kea-router'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'\nimport { uuid } from 'lib/utils'\nimport posthog from 'posthog-js'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { sidePanelStateLogic } from '~/layout/navigation-3000/sidepanel/sidePanelStateLogic'\nimport { Region, SidePanelTab, TeamType, UserType } from '~/types'\n\nimport type { supportLogicType } from './supportLogicType'\nimport { openSupportModal } from './SupportModal'\n\nfunction getSessionReplayLink(): string {\n    const link = posthog\n        .get_session_replay_url({ withTimestamp: true, timestampLookBack: 30 })\n        .replace(window.location.origin + '/replay/', 'http://go/session/')\n\n    return `Session: ${link} (at ${window.location.href.replace(/&supportModal=.+($|&)?/, '$1')})`\n}\n\nfunction getDjangoAdminLink(\n    user: UserType | null,\n    cloudRegion: Region | null | undefined,\n    currentTeamId: TeamType['id'] | null\n): string {\n    if (!user || !cloudRegion) {\n        return ''\n    }\n    const link = `http://go/admin${cloudRegion}/${user.email}`\n    return `Admin: ${link} (Organization: '${user.organization?.name}'; Project: ${currentTeamId}:'${user.team?.name}')`\n}\n\nfunction getBillingAdminLink(user: UserType | null): string {\n    if (!user) {\n        return ''\n    }\n    const link = `http://go/billing/customer/${user.organization?.id}`\n    return `Billing Admin: ${link} (Organization: '${user.organization?.name}'`\n}\n\nfunction getSentryLink(user: UserType | null, cloudRegion: Region | null | undefined): string {\n    if (!user || !cloudRegion) {\n        return ''\n    }\n    const link = `http://go/sentry${cloudRegion}/${user.team?.id}`\n    return `Sentry: ${link}`\n}\n\nconst SUPPORT_TICKET_KIND_TO_TITLE: Record<SupportTicketKind, string> = {\n    support: 'Contact support',\n    feedback: 'Give feedback',\n    bug: 'Report a bug',\n}\n\nexport const TARGET_AREA_TO_NAME = [\n    {\n        title: 'General',\n        options: [\n            {\n                value: 'apps',\n                'data-attr': `support-form-target-area-apps`,\n                label: 'Apps',\n            },\n            {\n                value: 'login',\n                'data-attr': `support-form-target-area-login`,\n                label: 'Authentication (incl. login, sign-up, invites)',\n            },\n            {\n                value: 'billing',\n                'data-attr': `support-form-target-area-billing`,\n                label: 'Billing',\n            },\n            {\n                value: 'onboarding',\n                'data-attr': `support-form-target-area-onboarding`,\n                label: 'Onboarding',\n            },\n            {\n                value: 'cohorts',\n                'data-attr': `support-form-target-area-cohorts`,\n                label: 'Cohorts',\n            },\n            {\n                value: 'data_management',\n                'data-attr': `support-form-target-area-data_management`,\n                label: 'Data management (incl. events, actions, properties)',\n            },\n            {\n                value: 'notebooks',\n                'data-attr': `support-form-target-area-notebooks`,\n                label: 'Notebooks',\n            },\n            {\n                value: 'mobile',\n                'data-attr': `support-form-target-area-mobile`,\n                label: 'Mobile',\n            },\n        ],\n    },\n    {\n        title: 'Individual product',\n        options: [\n            {\n                value: 'experiments',\n                'data-attr': `support-form-target-area-experiments`,\n                label: 'A/B testing',\n            },\n            {\n                value: 'data_warehouse',\n                'data-attr': `support-form-target-area-data_warehouse`,\n                label: 'Data warehouse (beta)',\n            },\n            {\n                value: 'feature_flags',\n                'data-attr': `support-form-target-area-feature_flags`,\n                label: 'Feature flags',\n            },\n            {\n                value: 'analytics',\n                'data-attr': `support-form-target-area-analytics`,\n                label: 'Product analytics (incl. insights, dashboards, annotations)',\n            },\n            {\n                value: 'session_replay',\n                'data-attr': `support-form-target-area-session_replay`,\n                label: 'Session replay (incl. recordings)',\n            },\n            {\n                value: 'toolbar',\n                'data-attr': `support-form-target-area-toolbar`,\n                label: 'Toolbar (incl. heatmaps)',\n            },\n            {\n                value: 'surveys',\n                'data-attr': `support-form-target-area-surveys`,\n                label: 'Surveys',\n            },\n            {\n                value: 'web_analytics',\n                'data-attr': `support-form-target-area-web_analytics`,\n                label: 'Web Analytics (beta)',\n            },\n        ],\n    },\n]\n\nexport const SEVERITY_LEVEL_TO_NAME = {\n    critical: 'Product outage / data loss / data breach',\n    high: 'Specific feature not working at all',\n    medium: 'Feature functioning but not as expected',\n    low: 'General question or feature request',\n}\n\nexport const SUPPORT_KIND_TO_SUBJECT = {\n    bug: 'Bug Report',\n    feedback: 'Feedback',\n    support: 'Support Ticket',\n}\n\nexport type SupportTicketTargetArea =\n    | 'experiments'\n    | 'apps'\n    | 'login'\n    | 'billing'\n    | 'onboarding'\n    | 'cohorts'\n    | 'data_management'\n    | 'notebooks'\n    | 'data_warehouse'\n    | 'feature_flags'\n    | 'analytics'\n    | 'session_replay'\n    | 'toolbar'\n    | 'surveys'\n    | 'web_analytics'\nexport type SupportTicketSeverityLevel = keyof typeof SEVERITY_LEVEL_TO_NAME\nexport type SupportTicketKind = keyof typeof SUPPORT_KIND_TO_SUBJECT\n\nexport const getLabelBasedOnTargetArea = (target_area: SupportTicketTargetArea): null | string => {\n    for (const category of TARGET_AREA_TO_NAME) {\n        for (const option of category.options) {\n            if (option.value === target_area) {\n                return option.label\n            }\n        }\n    }\n    return null // Return null if the value is not found\n}\n\nexport const URL_PATH_TO_TARGET_AREA: Record<string, SupportTicketTargetArea> = {\n    insights: 'analytics',\n    recordings: 'session_replay',\n    replay: 'session_replay',\n    dashboard: 'analytics',\n    feature_flags: 'feature_flags',\n    experiments: 'experiments',\n    'web-performance': 'session_replay',\n    events: 'analytics',\n    'data-management': 'data_management',\n    cohorts: 'cohorts',\n    annotations: 'analytics',\n    persons: 'analytics',\n    groups: 'analytics',\n    app: 'apps',\n    toolbar: 'session_replay',\n    warehouse: 'data_warehouse',\n    surveys: 'surveys',\n    web: 'web_analytics',\n}\n\nexport function getURLPathToTargetArea(pathname: string): SupportTicketTargetArea | null {\n    const first_part = pathname.split('/')[1]\n    return URL_PATH_TO_TARGET_AREA[first_part] ?? null\n}\n\nexport type SupportFormLogicProps = {\n    onClose?: () => void\n}\n\nexport type SupportFormFields = {\n    name: string\n    email: string\n    kind: SupportTicketKind\n    target_area: SupportTicketTargetArea | null\n    severity_level: SupportTicketSeverityLevel | null\n    message: string\n}\n\nexport const supportLogic = kea<supportLogicType>([\n    props({} as SupportFormLogicProps),\n    path(['lib', 'components', 'support', 'supportLogic']),\n    connect(() => ({\n        values: [userLogic, ['user'], preflightLogic, ['preflight'], sidePanelStateLogic, ['sidePanelAvailable']],\n        actions: [sidePanelStateLogic, ['openSidePanel', 'setSidePanelOptions']],\n    })),\n    actions(() => ({\n        closeSupportForm: true,\n        openSupportForm: (values: Partial<SupportFormFields>) => values,\n        submitZendeskTicket: (form: SupportFormFields) => form,\n        updateUrlParams: true,\n        openEmailForm: true,\n        closeEmailForm: true,\n    })),\n    reducers(() => ({\n        isSupportFormOpen: [\n            false,\n            {\n                openSupportForm: () => true,\n                closeSupportForm: () => false,\n            },\n        ],\n        isEmailFormOpen: [\n            false,\n            {\n                openEmailForm: () => true,\n                closeEmailForm: () => false,\n            },\n        ],\n    })),\n    forms(({ actions, values }) => ({\n        sendSupportRequest: {\n            defaults: {\n                name: '',\n                email: '',\n                kind: 'support',\n                severity_level: null,\n                target_area: null,\n                message: '',\n            } as SupportFormFields,\n            errors: ({ name, email, message, kind, target_area, severity_level }) => {\n                return {\n                    name: !values.user ? (!name ? 'Please enter your name' : '') : '',\n                    email: !values.user ? (!email ? 'Please enter your email' : '') : '',\n                    message: !message ? 'Please enter a message' : '',\n                    kind: !kind ? 'Please choose' : undefined,\n                    severity_level: !severity_level ? 'Please choose' : undefined,\n                    target_area: !target_area ? 'Please choose' : undefined,\n                }\n            },\n            submit: async (formValues) => {\n                // name must be present for zendesk to accept the ticket\n                formValues.name = values.user?.first_name ?? formValues.name ?? 'name not set'\n                formValues.email = values.user?.email ?? formValues.email ?? ''\n                actions.submitZendeskTicket(formValues)\n                actions.closeSupportForm()\n                actions.resetSendSupportRequest()\n            },\n        },\n    })),\n    selectors({\n        title: [\n            (s) => [s.sendSupportRequest ?? null],\n            (sendSupportRequest) =>\n                sendSupportRequest.kind\n                    ? SUPPORT_TICKET_KIND_TO_TITLE[sendSupportRequest.kind]\n                    : 'Leave a message with PostHog',\n        ],\n    }),\n    listeners(({ actions, props, values }) => ({\n        updateUrlParams: async () => {\n            const panelOptions = [\n                values.sendSupportRequest.kind ?? '',\n                values.sendSupportRequest.target_area ?? '',\n                values.sendSupportRequest.severity_level ?? '',\n            ].join(':')\n\n            if (panelOptions !== ':') {\n                actions.setSidePanelOptions(panelOptions)\n            }\n        },\n        openSupportForm: async ({ name, email, kind, target_area, severity_level, message }) => {\n            const area = target_area ?? getURLPathToTargetArea(window.location.pathname)\n            kind = kind ?? 'support'\n            actions.resetSendSupportRequest({\n                name: name ?? '',\n                email: email ?? '',\n                kind,\n                target_area: area,\n                severity_level: severity_level ?? null,\n                message: message ?? '',\n            })\n\n            if (values.sidePanelAvailable) {\n                const panelOptions = [kind ?? '', area ?? ''].join(':')\n                actions.openSidePanel(SidePanelTab.Support, panelOptions === ':' ? undefined : panelOptions)\n            } else {\n                openSupportModal()\n            }\n\n            actions.updateUrlParams()\n        },\n        submitZendeskTicket: async ({ name, email, kind, target_area, severity_level, message }) => {\n            const zendesk_ticket_uuid = uuid()\n            const subject =\n                SUPPORT_KIND_TO_SUBJECT[kind ?? 'support'] +\n                ': ' +\n                (target_area\n                    ? getLabelBasedOnTargetArea(target_area) ?? `${target_area} (feature preview)`\n                    : 'General') +\n                ' (' +\n                zendesk_ticket_uuid +\n                ')'\n            const cloudRegion = preflightLogic.values.preflight?.region\n\n            const payload = {\n                request: {\n                    requester: { name: name, email: email },\n                    subject: subject,\n                    custom_fields: [\n                        {\n                            id: 22084126888475,\n                            value: severity_level,\n                        },\n                        {\n                            id: 22129191462555,\n                            value: posthog.get_distinct_id(),\n                        },\n                    ],\n                    comment: {\n                        body: (\n                            message +\n                            `\\n\\n-----` +\n                            `\\nKind: ${kind}` +\n                            `\\nTarget area: ${target_area}` +\n                            `\\nReport event: http://go/ticketByUUID/${zendesk_ticket_uuid}` +\n                            '\\n' +\n                            getSessionReplayLink() +\n                            '\\n' +\n                            getDjangoAdminLink(userLogic.values.user, cloudRegion, teamLogic.values.currentTeamId) +\n                            '\\n' +\n                            (target_area === 'billing' || target_area === 'login' || target_area === 'onboarding'\n                                ? getBillingAdminLink(userLogic.values.user) + '\\n'\n                                : '') +\n                            getSentryLink(userLogic.values.user, cloudRegion)\n                        ).trim(),\n                    },\n                },\n            }\n\n            try {\n                const zendeskRequestBody = JSON.stringify(payload, undefined, 4)\n                const response = await fetch('https://posthoghelp.zendesk.com/api/v2/requests.json', {\n                    method: 'POST',\n                    body: zendeskRequestBody,\n                    headers: { 'Content-Type': 'application/json' },\n                })\n                if (!response.ok) {\n                    const error = new Error(`There was an error creating the support ticket with zendesk.`)\n                    const extra: Record<string, any> = { zendeskBody: zendeskRequestBody }\n                    Object.entries(payload).forEach(([key, value]) => {\n                        extra[`payload_${key}`] = value\n                    })\n                    const body = await response.text()\n                    const contexts = {\n                        response: {\n                            status_code: response.status,\n                            data: body,\n                            body_size: body?.length,\n                        },\n                    }\n                    captureException(error, {\n                        extra,\n                        contexts,\n                    })\n                    lemonToast.error(`There was an error sending the message.`)\n                    return\n                }\n\n                const json = await response.json()\n\n                const zendesk_ticket_id = json.request.id\n                const zendesk_ticket_link = `https://posthoghelp.zendesk.com/agent/tickets/${zendesk_ticket_id}`\n                const properties = {\n                    zendesk_ticket_uuid,\n                    kind,\n                    target_area,\n                    message,\n                    zendesk_ticket_id,\n                    zendesk_ticket_link,\n                }\n                posthog.capture('support_ticket', properties)\n                Sentry.captureMessage('User submitted Zendesk ticket', {\n                    tags: {\n                        zendesk_ticket_uuid,\n                        zendesk_ticket_link,\n                        support_request_kind: kind,\n                        support_request_area: target_area,\n                        team_id: teamLogic.values.currentTeamId,\n                    },\n                    extra: properties,\n                    level: 'log',\n                })\n                lemonToast.success(\"Got the message! If we have follow-up information for you, we'll reply via email.\")\n            } catch (e) {\n                captureException(e)\n                lemonToast.error(`There was an error sending the message.`)\n            }\n        },\n\n        closeSupportForm: () => {\n            props.onClose?.()\n        },\n\n        setSendSupportRequestValue: () => {\n            actions.updateUrlParams()\n        },\n    })),\n\n    urlToAction(({ actions, values }) => ({\n        '*': (_, _search, hashParams) => {\n            if (values.isSupportFormOpen) {\n                return\n            }\n\n            const [panel, ...panelOptions] = (hashParams['panel'] ?? '').split(':')\n\n            if (panel === SidePanelTab.Support) {\n                const [kind, area, severity] = panelOptions\n\n                actions.openSupportForm({\n                    kind: Object.keys(SUPPORT_KIND_TO_SUBJECT).includes(kind) ? kind : null,\n                    target_area: Object.keys(TARGET_AREA_TO_NAME).includes(area) ? area : null,\n                    severity_level: Object.keys(SEVERITY_LEVEL_TO_NAME).includes(severity) ? severity : null,\n                })\n                return\n            }\n\n            // Legacy supportModal param\n            if ('supportModal' in hashParams) {\n                const [kind, area, severity] = (hashParams['supportModal'] || '').split(':')\n\n                actions.openSupportForm({\n                    kind: Object.keys(SUPPORT_KIND_TO_SUBJECT).includes(kind) ? kind : null,\n                    target_area: Object.keys(TARGET_AREA_TO_NAME).includes(area) ? area : null,\n                    severity_level: Object.keys(SEVERITY_LEVEL_TO_NAME).includes(severity) ? severity : null,\n                })\n            }\n        },\n    })),\n])\n","import { actions, afterMount, kea, listeners, path, reducers, sharedListeners } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\n\nimport type { versionCheckerLogicType } from './versionCheckerLogicType'\n\nconst CHECK_INTERVAL_MS = 1000 * 60 * 60 * 6 // 6 hour\n\nexport type SDKVersion = {\n    version: string\n    timestamp?: string\n}\n\nexport type SDKVersionWarning = {\n    currentVersion: string\n    latestVersion: string\n    diff: number\n    level: 'warning' | 'info' | 'error'\n}\n\nexport const versionCheckerLogic = kea<versionCheckerLogicType>([\n    path(['components', 'VersionChecker', 'versionCheckerLogic']),\n    actions({\n        setVersionWarning: (versionWarning: SDKVersionWarning | null) => ({ versionWarning }),\n    }),\n    loaders({\n        availableVersions: [\n            null as SDKVersion[] | null,\n            {\n                loadAvailableVersions: async () => {\n                    return await fetch('https://api.github.com/repos/posthog/posthog-js/tags')\n                        .then((r) => r.json())\n                        .then((r) => r.map((x: any) => ({ version: x.name.replace('v', '') })))\n                },\n            },\n        ],\n        usedVersions: [\n            null as SDKVersion[] | null,\n            {\n                loadUsedVersions: async () => {\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$lib_version AS lib_version, max(timestamp) AS latest_timestamp, count(lib_version) as count\n                                FROM events\n                                WHERE timestamp >= now() - INTERVAL 1 DAY \n                                AND timestamp <= now()\n                                AND properties.$lib = 'web'\n                                GROUP BY lib_version\n                                ORDER BY latest_timestamp DESC\n                                limit 10`,\n                    }\n\n                    const res = await api.query(query)\n\n                    return (\n                        res.results?.map((x) => ({\n                            version: x[0],\n                            timestamp: x[1],\n                        })) ?? null\n                    )\n                },\n            },\n        ],\n    }),\n\n    reducers({\n        lastCheckTimestamp: [\n            0,\n            { persist: true },\n            {\n                loadUsedVersionsSuccess: () => Date.now(),\n            },\n        ],\n        versionWarning: [\n            null as SDKVersionWarning | null,\n            // bumping cache key due to an incorrect tag being cached on 2024-02-12\n            { persist: true, prefix: '2024-02-12' },\n            {\n                setVersionWarning: (_, { versionWarning }) => versionWarning,\n            },\n        ],\n    }),\n\n    sharedListeners(({ values, actions }) => ({\n        checkForVersionWarning: () => {\n            if (!values.availableVersions?.length || !values.usedVersions?.length) {\n                return\n            }\n\n            const latestVersion = values.availableVersions[0].version\n\n            // reverse sort, hence reversed arguments to localeCompare.\n            // We want the highest semantic version to be the latest used one, rather than\n            // the one with the latest timestamp, because secondary installations can spew old versions\n            const latestUsedVersion = [...values.usedVersions].sort((a, b) =>\n                b.version.localeCompare(a.version, undefined, { numeric: true })\n            )[0].version\n\n            if (latestVersion === latestUsedVersion) {\n                actions.setVersionWarning(null)\n                return\n            }\n\n            let diff = values.availableVersions.findIndex((v) => v.version === latestUsedVersion)\n            diff = diff === -1 ? values.availableVersions.length : diff\n\n            const warning: SDKVersionWarning = {\n                currentVersion: latestUsedVersion,\n                latestVersion,\n                diff,\n                level: diff > 20 ? 'error' : diff > 10 ? 'warning' : 'info',\n            }\n\n            actions.setVersionWarning(warning)\n        },\n    })),\n\n    listeners(({ sharedListeners }) => ({\n        loadAvailableVersionsSuccess: sharedListeners.checkForVersionWarning,\n        loadUsedVersionsSuccess: sharedListeners.checkForVersionWarning,\n    })),\n\n    afterMount(({ actions, values }) => {\n        if (values.lastCheckTimestamp < Date.now() - CHECK_INTERVAL_MS) {\n            actions.loadAvailableVersions()\n            actions.loadUsedVersions()\n        }\n    }),\n])\n","import { useValues } from 'kea'\nimport { TextContent } from 'lib/components/Cards/TextCard/TextCard'\nimport { useUploadFiles } from 'lib/hooks/useUploadFiles'\nimport { IconMarkdown, IconTools } from 'lib/lemon-ui/icons'\nimport { LemonFileInput } from 'lib/lemon-ui/LemonFileInput'\nimport { LemonTabs } from 'lib/lemon-ui/LemonTabs'\nimport { LemonTextArea, LemonTextAreaProps } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { Link } from 'lib/lemon-ui/Link'\nimport { Tooltip } from 'lib/lemon-ui/Tooltip'\nimport posthog from 'posthog-js'\nimport React, { useRef, useState } from 'react'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\n\nexport const LemonTextAreaMarkdown = React.forwardRef<HTMLTextAreaElement, LemonTextAreaProps>(\n    function _LemonTextAreaMarkdown({ value, onChange, ...editAreaProps }, ref): JSX.Element {\n        const { objectStorageAvailable } = useValues(preflightLogic)\n\n        const [isPreviewShown, setIsPreviewShown] = useState(false)\n        const dropRef = useRef<HTMLDivElement>(null)\n\n        const { setFilesToUpload, filesToUpload, uploading } = useUploadFiles({\n            onUpload: (url, fileName) => {\n                onChange?.(value + `\\n\\n![${fileName}](${url})`)\n                posthog.capture('markdown image uploaded', { name: fileName })\n            },\n            onError: (detail) => {\n                posthog.capture('markdown image upload failed', { error: detail })\n                lemonToast.error(`Error uploading image: ${detail}`)\n            },\n        })\n\n        return (\n            <LemonTabs\n                activeKey={isPreviewShown ? 'preview' : 'write'}\n                onChange={(key) => setIsPreviewShown(key === 'preview')}\n                tabs={[\n                    {\n                        key: 'write',\n                        label: 'Write',\n                        content: (\n                            <div ref={dropRef} className=\"LemonTextMarkdown flex flex-col space-y-1 rounded\">\n                                <LemonTextArea\n                                    ref={ref}\n                                    {...editAreaProps}\n                                    autoFocus\n                                    value={value}\n                                    onChange={onChange}\n                                />\n                                <div className=\"text-muted inline-flex items-center space-x-1\">\n                                    <IconMarkdown className=\"text-2xl\" />\n                                    <span>Markdown formatting support</span>\n                                </div>\n                                {objectStorageAvailable ? (\n                                    <LemonFileInput\n                                        accept={'image/*'}\n                                        multiple={false}\n                                        alternativeDropTargetRef={dropRef}\n                                        onChange={setFilesToUpload}\n                                        loading={uploading}\n                                        value={filesToUpload}\n                                    />\n                                ) : (\n                                    <div className=\"text-muted inline-flex items-center space-x-1\">\n                                        <Tooltip title=\"Enable object storage to add images by dragging and dropping.\">\n                                            <span>\n                                                <IconTools className=\"text-xl mr-1\" />\n                                            </span>\n                                        </Tooltip>\n                                        <span>\n                                            Add external images using{' '}\n                                            <Link to=\"https://www.markdownguide.org/basic-syntax/#images-1\">\n                                                {' '}\n                                                Markdown image links\n                                            </Link>\n                                            .\n                                        </span>\n                                    </div>\n                                )}\n                            </div>\n                        ),\n                    },\n                    {\n                        key: 'preview',\n                        label: 'Preview',\n                        content: value ? (\n                            <TextContent text={value} className=\"LemonTextArea--preview\" />\n                        ) : (\n                            <i>Nothing to preview</i>\n                        ),\n                    },\n                ]}\n            />\n        )\n    }\n)\n","// This file contains example queries, used in storybook and in the /query interface.\nimport { defaultDataTableColumns } from '~/queries/nodes/DataTable/utils'\nimport {\n    ActionsNode,\n    DataTableNode,\n    DataVisualizationNode,\n    EventsNode,\n    EventsQuery,\n    FunnelsQuery,\n    HogQLQuery,\n    LifecycleQuery,\n    Node,\n    NodeKind,\n    PathsQuery,\n    PersonsNode,\n    RetentionQuery,\n    StickinessQuery,\n    TimeToSeeDataJSONNode,\n    TimeToSeeDataSessionsQuery,\n    TimeToSeeDataWaterfallNode,\n    TrendsQuery,\n} from '~/queries/schema'\nimport {\n    ChartDisplayType,\n    FilterLogicalOperator,\n    PropertyFilterType,\n    PropertyGroupFilter,\n    PropertyOperator,\n    StepOrderValue,\n} from '~/types'\n\nconst Events: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: defaultDataTableColumns(NodeKind.EventsQuery),\n    properties: [\n        { type: PropertyFilterType.Event, key: '$browser', operator: PropertyOperator.Exact, value: 'Chrome' },\n    ],\n    after: '-24h',\n    limit: 100,\n}\n\nconst EventsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: Events,\n}\nconst EventsTableFull: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: Events,\n}\n\nconst TotalEvents: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: ['count()'],\n}\n\nexport const TotalEventsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: TotalEvents,\n}\n\nconst PropertyFormulas: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: [\n        '1 + 2 + 3',\n        'event',\n        'person.created_at',\n        \"concat(properties['$browser'], ' 💚 ', properties['$geoip_city_name']) -- Browser 💚 City\",\n        \"'random string'\",\n    ],\n    limit: 100,\n}\n\nconst PropertyFormulasTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: PropertyFormulas,\n}\n\nconst EventAggregations: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: {\n        kind: NodeKind.EventsQuery,\n        select: [\n            \"concat(properties['$geoip_city_name'], ' ', 'Rocks') -- City\",\n            'event',\n            'count() + 100000 -- Inflamed total',\n            '1 + 2',\n        ],\n        orderBy: ['-count()'],\n    },\n}\n\nconst Persons: PersonsNode = {\n    kind: NodeKind.PersonsNode,\n    properties: [\n        { type: PropertyFilterType.Person, key: '$browser', operator: PropertyOperator.Exact, value: 'Chrome' },\n    ],\n}\n\nconst PersonsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    columns: defaultDataTableColumns(NodeKind.PersonsNode),\n    source: Persons,\n}\n\nconst PersonsTableFull: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    columns: defaultDataTableColumns(NodeKind.PersonsNode),\n    source: Persons,\n}\n\nconst properties: PropertyGroupFilter = {\n    type: FilterLogicalOperator.And,\n    values: [\n        {\n            type: FilterLogicalOperator.Or,\n            values: [\n                {\n                    type: PropertyFilterType.Event,\n                    key: '$current_url',\n                    operator: PropertyOperator.Exact,\n                    value: ['https://hedgebox.net/files/'],\n                },\n                {\n                    type: PropertyFilterType.Event,\n                    key: '$geoip_country_code',\n                    operator: PropertyOperator.Exact,\n                    value: ['US', 'AU'],\n                },\n            ],\n        },\n    ],\n}\n\nconst filterTestAccounts = false\nconst series: (EventsNode | ActionsNode)[] = [\n    {\n        kind: NodeKind.EventsNode,\n        name: '$pageview',\n        custom_name: 'Views',\n        event: '$pageview',\n        properties: [\n            {\n                type: PropertyFilterType.Event,\n                key: '$browser',\n                operator: PropertyOperator.Exact,\n                value: 'Chrome',\n            },\n            {\n                type: PropertyFilterType.Cohort,\n                key: 'id',\n                value: 2,\n            },\n        ],\n        limit: 100, // TODO - can't find a use for `limits` in insights/trends\n    },\n    // {\n    //     kind: NodeKind.ActionsNode,\n    //     id: 1,\n    //     name: 'Interacted with file',\n    //     custom_name: 'Interactions',\n    //     properties: [\n    //         {\n    //             type: PropertyFilterType.Event,\n    //             key: '$geoip_country_code',\n    //             operator: PropertyOperator.Exact,\n    //             value: ['US'],\n    //         },\n    //     ],\n    //     math: PropertyMathType.Average,\n    //     math_property: '$session_duration',\n    // },\n]\n\nconst InsightTrendsQuery: TrendsQuery = {\n    kind: NodeKind.TrendsQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    trendsFilter: {\n        display: ChartDisplayType.ActionsAreaGraph,\n    },\n    breakdownFilter: {\n        breakdown: '$geoip_country_code',\n        breakdown_type: 'event',\n    },\n}\n\nconst InsightFunnelsQuery: FunnelsQuery = {\n    kind: NodeKind.FunnelsQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    funnelsFilter: {\n        funnelOrderType: StepOrderValue.ORDERED,\n    },\n    breakdownFilter: {\n        breakdown: '$geoip_country_code',\n        breakdown_type: 'event',\n    },\n}\n\nconst InsightRetentionQuery: RetentionQuery = {\n    kind: NodeKind.RetentionQuery,\n    properties,\n    filterTestAccounts,\n    retentionFilter: {\n        // TODO: this should be typed as (EventsNode | ActionsNode)[] without math and properties\n        targetEntity: { type: 'events', id: '$pageview', name: '$pageview' },\n        returningEntity: { type: 'events', id: '$pageview', name: '$pageview' },\n    },\n}\n\nconst InsightPathsQuery: PathsQuery = {\n    kind: NodeKind.PathsQuery,\n    properties,\n    filterTestAccounts,\n    pathsFilter: {},\n}\n\nconst InsightStickinessQuery: StickinessQuery = {\n    kind: NodeKind.StickinessQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    stickinessFilter: {},\n}\n\nconst InsightLifecycleQuery: LifecycleQuery = {\n    kind: NodeKind.LifecycleQuery,\n    properties,\n    filterTestAccounts,\n    dateRange: {\n        date_from: '-7d',\n    },\n    series, // TODO: Visualization only supports one event or action\n}\n\nconst TimeToSeeDataSessionsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    columns: [\n        'session_id',\n        'session_start',\n        'session_end',\n        'duration_ms',\n        'team_events_last_month',\n        'events_count',\n        'interactions_count',\n        'total_interaction_time_to_see_data_ms',\n        'frustrating_interactions_count',\n        'user.email',\n    ],\n    source: {\n        kind: NodeKind.TimeToSeeDataSessionsQuery,\n    },\n}\n\nconst TimeToSeeDataSessionsJSON: TimeToSeeDataSessionsQuery = {\n    kind: NodeKind.TimeToSeeDataSessionsQuery,\n}\n\nconst TimeToSeeDataJSON: TimeToSeeDataJSONNode = {\n    kind: NodeKind.TimeToSeeDataSessionsJSONNode,\n    source: {\n        kind: NodeKind.TimeToSeeDataQuery,\n        sessionId: 'complete_me',\n        sessionStart: 'iso_date',\n        sessionEnd: 'iso_date',\n    },\n}\n\nconst TimeToSeeDataWaterfall: TimeToSeeDataWaterfallNode = {\n    kind: NodeKind.TimeToSeeDataSessionsWaterfallNode,\n    source: {\n        kind: NodeKind.TimeToSeeDataQuery,\n        sessionId: 'complete_me',\n        sessionStart: 'iso_date',\n        sessionEnd: 'iso_date',\n    },\n}\n\nconst HogQLRaw: HogQLQuery = {\n    kind: NodeKind.HogQLQuery,\n    query: `   select event,\n          person.properties.email,\n          properties.$browser,\n          count()\n     from events\n    where {filters} -- replaced with global date and property filters\n      and person.properties.email is not null\n group by event,\n          properties.$browser,\n          person.properties.email\n order by count() desc\n    limit 100`,\n    explain: true,\n    filters: {\n        dateRange: {\n            date_from: '-24h',\n        },\n    },\n}\n\nconst HogQLForDataVisualization: HogQLQuery = {\n    kind: NodeKind.HogQLQuery,\n    query: `select toDate(timestamp) as timestamp, count()\nfrom events\nwhere {filters} and timestamp <= now()\ngroup by timestamp\norder by timestamp asc\nlimit 100`,\n    explain: true,\n    filters: {\n        dateRange: {\n            date_from: '-7d',\n        },\n    },\n}\n\nconst HogQLTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: HogQLRaw,\n}\n\nconst DataVisualization: DataVisualizationNode = {\n    kind: NodeKind.DataVisualizationNode,\n    source: HogQLForDataVisualization,\n}\n\n/* a subset of examples including only those we can show all users and that don't use HogQL */\nexport const queryExamples: Record<string, Node> = {\n    Events,\n    EventsTable,\n    EventsTableFull,\n    TotalEventsTable,\n    PropertyFormulasTable,\n    EventAggregations,\n    Persons,\n    PersonsTable,\n    PersonsTableFull,\n    InsightTrendsQuery,\n    InsightFunnelsQuery,\n    InsightRetentionQuery,\n    InsightPathsQuery,\n    InsightStickinessQuery,\n    InsightLifecycleQuery,\n}\n\nexport const stringifiedQueryExamples: Record<string, string> = Object.fromEntries(\n    Object.entries(queryExamples).map(([key, node]) => [key, JSON.stringify(node)])\n)\n\nexport const examples: Record<string, Node> = {\n    ...queryExamples,\n    TimeToSeeDataSessionsTable,\n    TimeToSeeDataSessionsJSON,\n    TimeToSeeDataWaterfall,\n    TimeToSeeDataJSON,\n    HogQLRaw,\n    HogQLTable,\n    DataVisualization,\n}\n\nexport const stringifiedExamples: Record<string, string> = Object.fromEntries(\n    Object.entries(examples).map(([key, node]) => [key, JSON.stringify(node)])\n)\n","import { actions, afterMount, connect, kea, key, listeners, path, props, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { beforeUnload, router } from 'kea-router'\nimport api from 'lib/api'\nimport { Dayjs, dayjs } from 'lib/dayjs'\nimport { Scene } from 'scenes/sceneTypes'\nimport { urls } from 'scenes/urls'\n\nimport {\n    BatchExportConfiguration,\n    BatchExportDestination,\n    BatchExportDestinationBigQuery,\n    BatchExportDestinationHTTP,\n    BatchExportDestinationPostgres,\n    BatchExportDestinationRedshift,\n    BatchExportDestinationS3,\n    BatchExportDestinationSnowflake,\n    Breadcrumb,\n} from '~/types'\n\nimport type { batchExportsEditLogicType } from './batchExportEditLogicType'\nimport { batchExportLogic } from './batchExportLogic'\n\nexport type BatchExportsEditLogicProps = {\n    id: string\n}\n\nexport type BatchExportConfigurationForm = Omit<\n    BatchExportConfiguration,\n    'id' | 'destination' | 'start_at' | 'end_at'\n> &\n    Partial<BatchExportDestinationPostgres['config']> &\n    Partial<BatchExportDestinationRedshift['config']> &\n    Partial<BatchExportDestinationBigQuery['config']> &\n    Partial<BatchExportDestinationS3['config']> &\n    Partial<BatchExportDestinationSnowflake['config']> &\n    Partial<BatchExportDestinationHTTP['config']> & {\n        destination: 'S3' | 'Snowflake' | 'Postgres' | 'BigQuery' | 'Redshift' | 'HTTP'\n        start_at: Dayjs | null\n        end_at: Dayjs | null\n        json_config_file?: File[] | null\n    }\n\nexport const batchExportFormFields = (\n    isNew: boolean,\n    { name, destination, interval, start_at, end_at, paused, ...config }: BatchExportConfigurationForm,\n    { isPipeline }: { isPipeline?: boolean } = {}\n): Record<string, any> => {\n    // Important! All fields that are required must be checked here as it is used also to sanitise the existing\n\n    return {\n        name: !name && !isPipeline ? 'Please enter a name' : '', // In pipeline UI the name is in the top bar\n        destination: !destination ? 'Please select a destination' : '',\n        interval: !interval ? 'Please select a frequency' : '',\n        paused: '',\n        start_at: '',\n        end_at: '',\n        ...(destination === 'Postgres'\n            ? {\n                  user: isNew ? (!config.user ? 'This field is required' : '') : '',\n                  password: isNew ? (!config.password ? 'This field is required' : '') : '',\n                  host: !config.host ? 'This field is required' : '',\n                  port: !config.port ? 'This field is required' : '',\n                  database: !config.database ? 'This field is required' : '',\n                  schema: !config.schema ? 'This field is required' : '',\n                  table_name: !config.table_name ? 'This field is required' : '',\n                  has_self_signed_cert: false,\n                  exclude_events: '',\n                  include_events: '',\n              }\n            : destination === 'Redshift'\n            ? {\n                  user: isNew ? (!config.user ? 'This field is required' : '') : '',\n                  password: isNew ? (!config.password ? 'This field is required' : '') : '',\n                  host: !config.host ? 'This field is required' : '',\n                  port: !config.port ? 'This field is required' : '',\n                  database: !config.database ? 'This field is required' : '',\n                  schema: !config.schema ? 'This field is required' : '',\n                  table_name: !config.table_name ? 'This field is required' : '',\n                  properties_data_type: '',\n                  exclude_events: '',\n                  include_events: '',\n              }\n            : destination === 'S3'\n            ? {\n                  bucket_name: !config.bucket_name ? 'This field is required' : '',\n                  region: !config.region ? 'This field is required' : '',\n                  prefix: !config.prefix ? 'This field is required' : '',\n                  aws_access_key_id: isNew ? (!config.aws_access_key_id ? 'This field is required' : '') : '',\n                  aws_secret_access_key: isNew ? (!config.aws_secret_access_key ? 'This field is required' : '') : '',\n                  compression: '',\n                  encryption: '',\n                  file_format: isNew ? (!config.file_format ? 'This field is required' : '') : '',\n                  kms_key_id: !config.kms_key_id && config.encryption == 'aws:kms' ? 'This field is required' : '',\n                  exclude_events: '',\n                  include_events: '',\n                  endpoint_url: null,\n              }\n            : destination === 'BigQuery'\n            ? {\n                  json_config_file: isNew\n                      ? !config.json_config_file\n                          ? 'This field is required'\n                          : !config.project_id ||\n                            !config.private_key ||\n                            !config.private_key_id ||\n                            !config.client_email ||\n                            !config.token_uri\n                          ? 'The config file is not valid'\n                          : ''\n                      : '',\n                  dataset_id: !config.dataset_id ? 'This field is required' : '',\n                  table_id: !config.table_id ? 'This field is required' : '',\n                  exclude_events: '',\n                  include_events: '',\n                  use_json_type: '',\n              }\n            : destination === 'HTTP'\n            ? {\n                  url: !config.url ? 'This field is required' : '',\n                  token: !config.token ? 'This field is required' : '',\n                  exclude_events: '',\n                  include_events: '',\n              }\n            : destination === 'Snowflake'\n            ? {\n                  account: !config.account ? 'This field is required' : '',\n                  database: !config.database ? 'This field is required' : '',\n                  warehouse: !config.warehouse ? 'This field is required' : '',\n                  user: isNew ? (!config.user ? 'This field is required' : '') : '',\n                  password: isNew ? (!config.password ? 'This field is required' : '') : '',\n                  schema: !config.schema ? 'This field is required' : '',\n                  table_name: !config.table_name ? 'This field is required' : '',\n                  role: '',\n                  exclude_events: '',\n                  include_events: '',\n              }\n            : {}),\n    }\n}\n\nexport const batchExportsEditLogic = kea<batchExportsEditLogicType>([\n    props({} as BatchExportsEditLogicProps),\n    key(({ id }) => id),\n    path((key) => ['scenes', 'batch_exports', 'batchExportsEditLogic', key]),\n    connect((props: BatchExportsEditLogicProps) => ({\n        values: [batchExportLogic(props), ['batchExportConfig', 'batchExportConfigLoading']],\n        actions: [batchExportLogic(props), ['loadBatchExportConfig', 'loadBatchExportConfigSuccess']],\n    })),\n\n    actions({\n        cancelEditing: true,\n    }),\n\n    forms(({ props, actions }) => ({\n        batchExportConfigForm: {\n            defaults: {\n                name: '',\n            } as BatchExportConfigurationForm,\n            errors: (form) => batchExportFormFields(props.id === 'new', form),\n            submit: async ({ name, destination, interval, start_at, end_at, paused, ...config }) => {\n                const destinationObject: BatchExportDestination =\n                    destination === 'Postgres'\n                        ? ({\n                              type: 'Postgres',\n                              config: config,\n                          } as unknown as BatchExportDestinationPostgres)\n                        : destination === 'S3'\n                        ? ({\n                              type: 'S3',\n                              config: config,\n                          } as unknown as BatchExportDestinationS3)\n                        : destination === 'Redshift'\n                        ? ({\n                              type: 'Redshift',\n                              config: config,\n                          } as unknown as BatchExportDestinationRedshift)\n                        : destination === 'BigQuery'\n                        ? ({\n                              type: 'BigQuery',\n                              config: config,\n                          } as unknown as BatchExportDestinationBigQuery)\n                        : destination === 'HTTP'\n                        ? ({\n                              type: 'HTTP',\n                              config: config,\n                          } as unknown as BatchExportDestinationHTTP)\n                        : ({\n                              type: 'Snowflake',\n                              config: config,\n                          } as unknown as BatchExportDestinationSnowflake)\n\n                const data: Omit<BatchExportConfiguration, 'id' | 'created_at' | 'team_id'> = {\n                    paused,\n                    name,\n                    interval,\n                    start_at: start_at?.toISOString() ?? null,\n                    end_at: end_at?.toISOString() ?? null,\n                    destination: destinationObject,\n                }\n\n                const result =\n                    props.id === 'new'\n                        ? await api.batchExports.create(data)\n                        : await api.batchExports.update(props.id, data)\n\n                await new Promise((resolve) => setTimeout(resolve, 1000))\n\n                actions.resetBatchExportConfigForm()\n                router.actions.replace(urls.batchExport(result.id))\n\n                return\n            },\n        },\n    })),\n\n    listeners(({ values, props, actions }) => ({\n        cancelEditing: () => {\n            if (values.isNew) {\n                router.actions.push(urls.batchExports())\n            } else {\n                router.actions.push(urls.batchExport(props.id))\n            }\n        },\n\n        setBatchExportConfigFormValue: async ({ name, value }) => {\n            if (name[0] === 'json_config_file' && value) {\n                try {\n                    const loadedFile: string = await new Promise((resolve, reject) => {\n                        const filereader = new FileReader()\n                        filereader.onload = (e) => resolve(e.target?.result as string)\n                        filereader.onerror = (e) => reject(e)\n                        filereader.readAsText(value[0])\n                    })\n                    const jsonConfig = JSON.parse(loadedFile)\n                    actions.setBatchExportConfigFormValues({\n                        ...values.batchExportConfigForm,\n                        project_id: jsonConfig.project_id,\n                        private_key: jsonConfig.private_key,\n                        private_key_id: jsonConfig.private_key_id,\n                        client_email: jsonConfig.client_email,\n                        token_uri: jsonConfig.token_uri,\n                    })\n                } catch (e) {\n                    actions.setBatchExportConfigFormManualErrors({\n                        json_config_file: 'The config file is not valid',\n                    })\n                }\n            }\n        },\n\n        loadBatchExportConfigSuccess: ({ batchExportConfig }) => {\n            if (!batchExportConfig) {\n                return\n            }\n\n            const destination = batchExportConfig.destination.type\n\n            const transformedConfig: BatchExportConfigurationForm = {\n                ...batchExportConfig,\n                destination,\n                start_at: batchExportConfig.start_at ? dayjs(batchExportConfig.start_at) : null,\n                end_at: batchExportConfig.end_at ? dayjs(batchExportConfig.end_at) : null,\n                ...batchExportConfig.destination.config,\n            }\n\n            // Filter out any values that aren't part of our from\n\n            const validFormFields = Object.keys(batchExportFormFields(props.id === 'new', transformedConfig))\n\n            Object.keys(transformedConfig).forEach((key) => {\n                if (!validFormFields.includes(key)) {\n                    delete transformedConfig[key]\n                }\n            })\n\n            actions.resetBatchExportConfigForm(transformedConfig)\n        },\n    })),\n\n    selectors({\n        isNew: [() => [(_, props) => props], (props): boolean => props.id === 'new'],\n        breadcrumbs: [\n            (s) => [s.batchExportConfig, s.isNew],\n            (config, isNew): Breadcrumb[] => [\n                {\n                    key: Scene.BatchExports,\n                    name: 'Batch Exports',\n                    path: urls.batchExports(),\n                },\n                ...(isNew\n                    ? [\n                          {\n                              key: 'new',\n                              name: 'New',\n                          },\n                      ]\n                    : [\n                          {\n                              key: config?.id ?? 'loading',\n                              name: config?.name,\n                              path: config?.id ? urls.batchExport(config.id) : undefined,\n                          },\n                          {\n                              key: 'edit',\n                              name: 'Edit',\n                          },\n                      ]),\n            ],\n        ],\n    }),\n\n    afterMount(({ values, actions }) => {\n        if (!values.isNew) {\n            if (values.batchExportConfig) {\n                actions.loadBatchExportConfigSuccess(values.batchExportConfig)\n            } else {\n                actions.loadBatchExportConfig()\n            }\n        }\n    }),\n\n    beforeUnload(({ values }) => ({\n        enabled: () => values.batchExportConfigFormChanged,\n        message: `Leave?\\nChanges you made will be discarded.`,\n    })),\n])\n","import { IconCheckCircle, IconChevronDown, IconDocument, IconInfo, IconPlus } from '@posthog/icons'\nimport { LemonButton, LemonSelectOptions, LemonTable, LemonTag, Link } from '@posthog/lemon-ui'\nimport clsx from 'clsx'\nimport { useActions, useValues } from 'kea'\nimport { BillingUpgradeCTA } from 'lib/components/BillingUpgradeCTA'\nimport { FEATURE_FLAGS, UNSUBSCRIBE_SURVEY_ID } from 'lib/constants'\nimport { useResizeBreakpoints } from 'lib/hooks/useResizeObserver'\nimport { IconChevronRight } from 'lib/lemon-ui/icons'\nimport { LemonBanner } from 'lib/lemon-ui/LemonBanner'\nimport { More } from 'lib/lemon-ui/LemonButton/More'\nimport { Tooltip } from 'lib/lemon-ui/Tooltip'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { capitalizeFirstLetter, compactNumber } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport posthog from 'posthog-js'\nimport { useRef } from 'react'\nimport { getProductIcon } from 'scenes/products/Products'\n\nimport { BillingProductV2AddonType, BillingProductV2Type, BillingV2TierType } from '~/types'\n\nimport { convertLargeNumberToWords, getUpgradeProductLink, summarizeUsage } from './billing-utils'\nimport { BillingGauge } from './BillingGauge'\nimport { BillingLimitInput } from './BillingLimitInput'\nimport { billingLogic } from './billingLogic'\nimport { billingProductLogic } from './billingProductLogic'\nimport { PlanComparisonModal } from './PlanComparison'\nimport { ProductPricingModal } from './ProductPricingModal'\nimport { UnsubscribeSurveyModal } from './UnsubscribeSurveyModal'\n\nexport const getTierDescription = (\n    tiers: BillingV2TierType[],\n    i: number,\n    product: BillingProductV2Type | BillingProductV2AddonType,\n    interval: string\n): string => {\n    return i === 0\n        ? `First ${summarizeUsage(tiers[i].up_to)} ${product.unit}s / ${interval}`\n        : tiers[i].up_to\n        ? `${summarizeUsage(tiers?.[i - 1].up_to || null)} - ${summarizeUsage(tiers[i].up_to)}`\n        : `> ${summarizeUsage(tiers?.[i - 1].up_to || null)}`\n}\n\nexport const BillingProductAddon = ({ addon }: { addon: BillingProductV2AddonType }): JSX.Element => {\n    const { billing, redirectPath } = useValues(billingLogic)\n    const { isPricingModalOpen, currentAndUpgradePlans, surveyID } = useValues(billingProductLogic({ product: addon }))\n    const { toggleIsPricingModalOpen, reportSurveyShown, setSurveyResponse } = useActions(\n        billingProductLogic({ product: addon })\n    )\n    const { featureFlags } = useValues(featureFlagLogic)\n    const { setProductSpecificAlert } = useActions(billingLogic)\n\n    const productType = { plural: `${addon.unit}s`, singular: addon.unit }\n    const tierDisplayOptions: LemonSelectOptions<string> = [\n        { label: `Per ${productType.singular}`, value: 'individual' },\n    ]\n\n    if (billing?.has_active_subscription) {\n        tierDisplayOptions.push({ label: `Current bill`, value: 'total' })\n    }\n\n    const isOGPipelineAddon =\n        addon.type === 'data_pipelines' &&\n        addon.subscribed &&\n        addon.plans?.[0]?.plan_key === 'addon-20240111-og-customers'\n\n    if (isOGPipelineAddon && featureFlags['data-pipelines-notice']) {\n        setProductSpecificAlert({\n            status: 'info',\n            title: 'Welcome to the data pipelines addon!',\n            message: `We've moved data export features (and cost) here to better reflect user needs. Your overall\n                    price hasn't changed.`,\n            action: {\n                onClick: () => {\n                    posthog.capture('data pipelines notice clicked')\n                    // if they don't dismiss it now, we won't show it next time they come back\n                    posthog.capture('data pipelines notice dismissed', {\n                        $set: {\n                            dismissedDataPipelinesNotice: true,\n                        },\n                    })\n                },\n                children: 'Learn more',\n                to: 'https://posthog.com/changelog/2024#data-pipeline-add-on-launched',\n                targetBlank: true,\n            },\n            dismissKey: 'data-pipelines-notice',\n            onClose: () => {\n                posthog.capture('data pipelines notice dismissed', {\n                    $set: {\n                        dismissedDataPipelinesNotice: true,\n                    },\n                })\n            },\n        })\n    }\n    return (\n        <div className=\"bg-side rounded p-6 flex flex-col\">\n            <div className=\"flex justify-between gap-x-4\">\n                <div className=\"flex gap-x-4\">\n                    <div className=\"w-8\">{getProductIcon(addon.name, addon.icon_key, 'text-2xl')}</div>\n                    <div>\n                        <div className=\"flex gap-x-2 items-center mt-0 mb-2 \">\n                            <h4 className=\"leading-5 mb-1 font-bold\">{addon.name}</h4>\n                            {addon.subscribed && (\n                                <div>\n                                    <LemonTag type=\"primary\" icon={<IconCheckCircle />}>\n                                        Subscribed\n                                    </LemonTag>\n                                </div>\n                            )}\n                        </div>\n                        <p className=\"ml-0 mb-0\">{addon.description}</p>\n                        {isOGPipelineAddon && (\n                            <div className=\"mt-2\">\n                                <Link\n                                    targetBlankIcon\n                                    target=\"_blank\"\n                                    to=\"https://posthog.com/changelog/2024#data-pipeline-add-on-launched\"\n                                >\n                                    <span className=\"text-xs italic\">Why am I subscribed to this?</span>\n                                </Link>\n                            </div>\n                        )}\n                    </div>\n                </div>\n                <div className=\"ml-4 mr-4 mt-2 self-center flex gap-x-2 whitespace-nowrap\">\n                    {addon.docs_url && (\n                        <LemonButton icon={<IconDocument />} size=\"small\" to={addon.docs_url} tooltip=\"Read the docs\" />\n                    )}\n                    {addon.subscribed ? (\n                        <>\n                            <More\n                                overlay={\n                                    <>\n                                        <LemonButton\n                                            fullWidth\n                                            onClick={() => {\n                                                setSurveyResponse(addon.type, '$survey_response_1')\n                                                reportSurveyShown(UNSUBSCRIBE_SURVEY_ID, addon.type)\n                                            }}\n                                        >\n                                            Remove addon\n                                        </LemonButton>\n                                    </>\n                                }\n                            />\n                        </>\n                    ) : addon.included_with_main_product ? (\n                        <LemonTag type=\"completion\" icon={<IconCheckCircle />}>\n                            Included with plan\n                        </LemonTag>\n                    ) : (\n                        <>\n                            <LemonButton\n                                type=\"secondary\"\n                                disableClientSideRouting\n                                onClick={() => {\n                                    toggleIsPricingModalOpen()\n                                }}\n                            >\n                                View pricing\n                            </LemonButton>\n                            <LemonButton\n                                type=\"primary\"\n                                icon={<IconPlus />}\n                                size=\"small\"\n                                to={`/api/billing-v2/activation?products=${addon.type}:${\n                                    currentAndUpgradePlans?.upgradePlan?.plan_key\n                                }${redirectPath && `&redirect_path=${redirectPath}`}`}\n                                disableClientSideRouting\n                            >\n                                Add\n                            </LemonButton>\n                        </>\n                    )}\n                </div>\n            </div>\n            <ProductPricingModal\n                modalOpen={isPricingModalOpen}\n                onClose={toggleIsPricingModalOpen}\n                product={addon}\n                planKey={\n                    addon.subscribed\n                        ? currentAndUpgradePlans?.currentPlan?.plan_key\n                        : currentAndUpgradePlans?.upgradePlan?.plan_key\n                }\n            />\n            {surveyID && <UnsubscribeSurveyModal product={addon} />}\n        </div>\n    )\n}\n\nexport const BillingProduct = ({ product }: { product: BillingProductV2Type }): JSX.Element => {\n    const productRef = useRef<HTMLDivElement | null>(null)\n    const { billing, redirectPath, isOnboarding, isUnlicensedDebug } = useValues(billingLogic)\n    const {\n        customLimitUsd,\n        showTierBreakdown,\n        billingGaugeItems,\n        isPricingModalOpen,\n        isPlanComparisonModalOpen,\n        currentAndUpgradePlans,\n        surveyID,\n    } = useValues(billingProductLogic({ product }))\n    const {\n        setIsEditingBillingLimit,\n        setShowTierBreakdown,\n        toggleIsPricingModalOpen,\n        toggleIsPlanComparisonModalOpen,\n        reportSurveyShown,\n        setSurveyResponse,\n    } = useActions(billingProductLogic({ product, productRef }))\n    const { reportBillingUpgradeClicked } = useActions(eventUsageLogic)\n\n    const { featureFlags } = useValues(featureFlagLogic)\n    const upgradePlan = currentAndUpgradePlans?.upgradePlan\n    const currentPlan = currentAndUpgradePlans?.currentPlan\n    const downgradePlan = currentAndUpgradePlans?.downgradePlan\n    const additionalFeaturesOnUpgradedPlan = upgradePlan\n        ? upgradePlan?.features?.filter(\n              (feature) =>\n                  !currentPlan?.features?.some((currentPlanFeature) => currentPlanFeature.name === feature.name)\n          )\n        : currentPlan?.features?.filter(\n              (feature) =>\n                  !downgradePlan?.features?.some((downgradePlanFeature) => downgradePlanFeature.name === feature.name)\n          ) || []\n\n    const upgradeToPlanKey = upgradePlan?.plan_key\n    const currentPlanKey = currentPlan?.plan_key\n\n    const { ref, size } = useResizeBreakpoints({\n        0: 'small',\n        700: 'medium',\n    })\n\n    const addonPriceColumns = product.addons\n        // only get addons that are subscribed or were subscribed and have a projected amount\n        ?.filter((addon) => addon.subscribed || parseFloat(addon.projected_amount_usd || ''))\n        .map((addon) => ({\n            title: `${addon.name} price`,\n            dataIndex: `${addon.type}-price`,\n        }))\n\n    const tableColumns = [\n        { title: `Priced per ${product.unit}`, dataIndex: 'volume' },\n        { title: addonPriceColumns?.length > 0 ? 'Base price' : 'Price', dataIndex: 'basePrice' },\n        ...(addonPriceColumns || []),\n        { title: 'Current Usage', dataIndex: 'usage' },\n        { title: 'Total', dataIndex: 'total' },\n        { title: 'Projected Total', dataIndex: 'projectedTotal' },\n    ]\n\n    type TableTierDatum = {\n        volume: string\n        basePrice: string\n        [addonPrice: string]: string\n        usage: string\n        total: string\n        projectedTotal: string\n    }\n\n    // TODO: SUPPORT NON-TIERED PRODUCT TYPES\n    // still use the table, but the data will be different\n    const tableTierData: TableTierDatum[] | undefined =\n        product.tiers && product.tiers.length > 0\n            ? product.tiers\n                  ?.map((tier, i) => {\n                      const addonPricesForTier = product.addons?.map((addon) => ({\n                          [`${addon.type}-price`]: `${\n                              addon.tiers?.[i]?.unit_amount_usd !== '0'\n                                  ? '$' + addon.tiers?.[i]?.unit_amount_usd\n                                  : 'Free'\n                          }`,\n                      }))\n                      // take the tier.current_amount_usd and add it to the same tier level for all the addons\n                      const totalForTier =\n                          parseFloat(tier.current_amount_usd || '') +\n                          (product.addons?.reduce(\n                              (acc, addon) => acc + parseFloat(addon.tiers?.[i]?.current_amount_usd || ''),\n                              0\n                              // if there aren't any addons we get NaN from the above, so we need to default to 0\n                          ) || 0)\n                      const projectedTotalForTier =\n                          (parseFloat(tier.projected_amount_usd || '') || 0) +\n                          product.addons?.reduce(\n                              (acc, addon) => acc + (parseFloat(addon.tiers?.[i]?.projected_amount_usd || '') || 0),\n                              0\n                          )\n\n                      const tierData = {\n                          volume: product.tiers // this is silly because we know there are tiers since we check above, but typescript doesn't\n                              ? getTierDescription(product.tiers, i, product, billing?.billing_period?.interval || '')\n                              : '',\n                          basePrice: tier.unit_amount_usd !== '0' ? `$${tier.unit_amount_usd}` : 'Free',\n                          usage: compactNumber(tier.current_usage),\n                          total: `$${totalForTier.toFixed(2) || '0.00'}`,\n                          projectedTotal: `$${projectedTotalForTier.toFixed(2) || '0.00'}`,\n                      }\n                      // if there are any addon prices we need to include, put them in the table\n                      addonPricesForTier?.map((addonPrice) => {\n                          Object.assign(tierData, addonPrice)\n                      })\n                      return tierData\n                  })\n                  // Add a row at the end for the total\n                  .concat({\n                      volume: 'Total',\n                      basePrice: '',\n                      usage: '',\n                      total: `$${product.current_amount_usd || '0.00'}`,\n                      projectedTotal: `$${product.projected_amount_usd || '0.00'}`,\n                  })\n            : undefined\n\n    if (billing?.discount_percent && parseFloat(product.projected_amount_usd || '')) {\n        // If there is a discount, add a row for the total after discount if there is also a projected amount\n        tableTierData?.push({\n            volume: 'Total after discount',\n            basePrice: '',\n            usage: '',\n            total: `$${\n                (parseInt(product.current_amount_usd || '0') * (1 - billing?.discount_percent / 100)).toFixed(2) ||\n                '0.00'\n            }`,\n            projectedTotal: `$${\n                (\n                    parseInt(product.projected_amount_usd || '0') -\n                    parseInt(product.projected_amount_usd || '0') * (billing?.discount_percent / 100)\n                ).toFixed(2) || '0.00'\n            }`,\n        })\n    }\n\n    return (\n        <div\n            className={clsx('flex flex-wrap max-w-300 pb-12', {\n                'flex-col pb-4': size === 'small',\n            })}\n            ref={ref}\n        >\n            <div className=\"border border-border rounded w-full bg-bg-light\" ref={productRef}>\n                <div className=\"border-b border-border rounded-t bg-mid p-4\">\n                    <div className=\"flex gap-4 items-center justify-between\">\n                        {getProductIcon(product.name, product.icon_key, 'text-2xl')}\n                        <div>\n                            <h3 className=\"font-bold mb-0\">{product.name}</h3>\n                            <div>{product.description}</div>\n                        </div>\n                        <div className=\"flex grow justify-end gap-x-2 items-center\">\n                            {product.docs_url && (\n                                <LemonButton\n                                    icon={<IconDocument />}\n                                    size=\"small\"\n                                    to={product.docs_url}\n                                    className=\"justify-end\"\n                                    tooltip=\"Read the docs\"\n                                />\n                            )}\n                            {product.contact_support ? (\n                                <>\n                                    {product.subscribed && <p className=\"m-0\">Need to manage your plan?</p>}\n                                    <LemonButton\n                                        type=\"primary\"\n                                        to=\"mailto:sales@posthog.com?subject=Enterprise%20plan%20request\"\n                                    >\n                                        Get in touch\n                                    </LemonButton>\n                                </>\n                            ) : (\n                                product.subscribed && (\n                                    <More\n                                        overlay={\n                                            <>\n                                                {billing?.billing_period?.interval == 'month' && (\n                                                    <LemonButton\n                                                        fullWidth\n                                                        onClick={() => setIsEditingBillingLimit(true)}\n                                                    >\n                                                        Set billing limit\n                                                    </LemonButton>\n                                                )}\n                                                <LemonButton\n                                                    fullWidth\n                                                    to=\"https://posthog.com/docs/billing/estimating-usage-costs#how-to-reduce-your-posthog-costs\"\n                                                >\n                                                    Learn how to reduce your bill\n                                                </LemonButton>\n                                                {product.plans?.length > 0 ? (\n                                                    <LemonButton\n                                                        fullWidth\n                                                        onClick={() => {\n                                                            setSurveyResponse(product.type, '$survey_response_1')\n                                                            reportSurveyShown(UNSUBSCRIBE_SURVEY_ID, product.type)\n                                                        }}\n                                                    >\n                                                        Unsubscribe\n                                                    </LemonButton>\n                                                ) : (\n                                                    <LemonButton\n                                                        fullWidth\n                                                        to=\"mailto:sales@posthog.com?subject=Custom%20plan%20unsubscribe%20request\"\n                                                    >\n                                                        Contact support to unsubscribe\n                                                    </LemonButton>\n                                                )}\n                                            </>\n                                        }\n                                    />\n                                )\n                            )}\n                            {surveyID && <UnsubscribeSurveyModal product={product} />}\n                        </div>\n                    </div>\n                </div>\n                <div className=\"px-8\">\n                    {product.percentage_usage > 1 && (\n                        <LemonBanner className=\"mt-6\" type=\"error\">\n                            You have exceeded the {customLimitUsd ? 'billing limit' : 'free tier limit'} for this\n                            product.\n                        </LemonBanner>\n                    )}\n                    <div className=\"flex w-full items-center gap-x-8\">\n                        {product.contact_support && (!product.subscribed || isUnlicensedDebug) ? (\n                            <div className=\"py-8\">\n                                {!billing?.has_active_subscription && (\n                                    <p className=\"ml-0\">\n                                        Every product subsciption comes with free platform features such as{' '}\n                                        <b>Multiple projects, Integrations, Apps, and more</b>. Subscribe to one of the\n                                        products above to get instant access.\n                                    </p>\n                                )}\n                                <p className=\"m-0\">\n                                    Need additional platform and support (aka enterprise) features like <b>SAML SSO</b>,{' '}\n                                    <b>advanced permissioning</b>, and more?{' '}\n                                    <Link to=\"mailto:sales@posthog.com?subject=Enterprise%20plan%20request\">\n                                        Get in touch\n                                    </Link>{' '}\n                                    for a quick chat.\n                                </p>\n                            </div>\n                        ) : (\n                            !isOnboarding &&\n                            !isUnlicensedDebug && (\n                                <>\n                                    {product.tiered ? (\n                                        <>\n                                            {product.subscribed && (\n                                                <LemonButton\n                                                    icon={\n                                                        showTierBreakdown ? <IconChevronDown /> : <IconChevronRight />\n                                                    }\n                                                    onClick={() => setShowTierBreakdown(!showTierBreakdown)}\n                                                />\n                                            )}\n                                            <div className=\"grow\">\n                                                <BillingGauge items={billingGaugeItems} product={product} />\n                                            </div>\n                                            {product.current_amount_usd ? (\n                                                <div className=\"flex justify-end gap-8 flex-wrap items-end\">\n                                                    <Tooltip\n                                                        title={`The current ${\n                                                            billing?.discount_percent ? 'discounted ' : ''\n                                                        }amount you have been billed for this ${\n                                                            billing?.billing_period?.interval\n                                                        } so far.`}\n                                                    >\n                                                        <div className=\"flex flex-col items-center\">\n                                                            <div className=\"font-bold text-3xl leading-7\">\n                                                                $\n                                                                {(\n                                                                    parseFloat(product.current_amount_usd || '') *\n                                                                    (1 -\n                                                                        (billing?.discount_percent\n                                                                            ? billing.discount_percent / 100\n                                                                            : 0))\n                                                                ).toFixed(2) || '0.00'}\n                                                            </div>\n                                                            <span className=\"text-xs text-muted\">\n                                                                {capitalizeFirstLetter(\n                                                                    billing?.billing_period?.interval || ''\n                                                                )}\n                                                                -to-date\n                                                            </span>\n                                                        </div>\n                                                    </Tooltip>\n                                                    {product.tiers && (\n                                                        <Tooltip\n                                                            title={`This is roughly calculated based on your current bill${\n                                                                billing?.discount_percent\n                                                                    ? ', discounts on your account,'\n                                                                    : ''\n                                                            } and the remaining time left in this billing period.`}\n                                                        >\n                                                            <div className=\"flex flex-col items-center justify-end\">\n                                                                <div className=\"font-bold text-muted text-lg leading-5\">\n                                                                    $\n                                                                    {(\n                                                                        parseFloat(product.projected_amount_usd || '') *\n                                                                        (1 -\n                                                                            (billing?.discount_percent\n                                                                                ? billing.discount_percent / 100\n                                                                                : 0))\n                                                                    ).toFixed(2) || '0.00'}\n                                                                </div>\n                                                                <span className=\"text-xs text-muted\">Projected</span>\n                                                            </div>\n                                                        </Tooltip>\n                                                    )}\n                                                </div>\n                                            ) : null}\n                                        </>\n                                    ) : product.current_amount_usd ? (\n                                        <div className=\"my-8\">\n                                            <Tooltip\n                                                title={`The current amount you will be billed for this ${billing?.billing_period?.interval}.`}\n                                            >\n                                                <div className=\"flex flex-col items-center\">\n                                                    <div className=\"font-bold text-3xl leading-7\">\n                                                        ${product.current_amount_usd}\n                                                    </div>\n                                                    <span className=\"text-xs text-muted\">\n                                                        per {billing?.billing_period?.interval || 'period'}\n                                                    </span>\n                                                </div>\n                                            </Tooltip>\n                                        </div>\n                                    ) : null}\n                                </>\n                            )\n                        )}\n                    </div>\n                    {product.price_description ? (\n                        <LemonBanner type=\"info\">\n                            <span dangerouslySetInnerHTML={{ __html: product.price_description }} />\n                        </LemonBanner>\n                    ) : null}\n                    {/* Table with tiers */}\n                    {showTierBreakdown && (\n                        <div className=\"pl-16 pb-8\">\n                            {product.tiered && tableTierData ? (\n                                <>\n                                    <LemonTable\n                                        stealth\n                                        embedded\n                                        size=\"small\"\n                                        uppercaseHeader={false}\n                                        columns={tableColumns}\n                                        dataSource={tableTierData}\n                                    />\n                                    {product.type === 'feature_flags' && (\n                                        <p className=\"mt-4 ml-0 text-sm text-muted italic\">\n                                            <IconInfo className=\"mr-1\" />\n                                            Using local evaluation? Here's{' '}\n                                            <Link\n                                                to=\"https://posthog.com/docs/feature-flags/bootstrapping-and-local-evaluation#server-side-local-evaluation\"\n                                                className=\"italic\"\n                                            >\n                                                how we calculate usage\n                                            </Link>\n                                            .\n                                        </p>\n                                    )}\n                                </>\n                            ) : (\n                                <LemonTable\n                                    stealth\n                                    embedded\n                                    size=\"small\"\n                                    uppercaseHeader={false}\n                                    columns={[\n                                        { title: '', dataIndex: 'name' },\n                                        { title: 'Total', dataIndex: 'total' },\n                                    ]}\n                                    dataSource={[\n                                        {\n                                            name: product.name,\n                                            total: product.unit_amount_usd,\n                                        },\n                                    ]}\n                                />\n                            )}\n                        </div>\n                    )}\n                    {!isOnboarding && product.addons?.length > 0 && (\n                        <div className=\"pb-8\">\n                            <h4 className=\"my-4\">Addons</h4>\n                            <div className=\"gap-y-4 flex flex-col\">\n                                {product.addons\n                                    .filter((addon) => !addon.inclusion_only)\n                                    .map((addon, i) => {\n                                        return <BillingProductAddon key={i} addon={addon} />\n                                    })}\n                            </div>\n                        </div>\n                    )}\n                </div>\n                {(upgradePlan ||\n                    (!upgradePlan && !product.current_amount_usd) ||\n                    (isOnboarding && !product.contact_support)) && (\n                    <div\n                        data-attr={`upgrade-card-${product.type}`}\n                        className={`border-t border-border p-8 flex justify-between ${\n                            !upgradePlan ? 'bg-success-highlight' : 'bg-warning-highlight'\n                        }`}\n                    >\n                        <div>\n                            {currentPlan && (\n                                <h4 className={`${!upgradePlan ? 'text-success-dark' : 'text-warning-dark'}`}>\n                                    You're on the {currentPlan.name} plan for {product.name}.\n                                </h4>\n                            )}\n                            {additionalFeaturesOnUpgradedPlan?.length > 0 ? (\n                                <>\n                                    <p className=\"ml-0 max-w-200\">\n                                        {product.subscribed\n                                            ? 'You now'\n                                            : featureFlags[FEATURE_FLAGS.BILLING_UPGRADE_LANGUAGE] === 'subscribe'\n                                            ? 'Subscribe to'\n                                            : featureFlags[FEATURE_FLAGS.BILLING_UPGRADE_LANGUAGE] === 'credit_card' &&\n                                              !billing?.has_active_subscription\n                                            ? 'Add a credit card to'\n                                            : featureFlags[FEATURE_FLAGS.BILLING_UPGRADE_LANGUAGE] === 'credit_card' &&\n                                              billing?.has_active_subscription\n                                            ? 'Add paid plan'\n                                            : 'Upgrade to'}{' '}\n                                        get sweet features such as:\n                                    </p>\n                                    <div>\n                                        {additionalFeaturesOnUpgradedPlan?.map((feature, i) => {\n                                            return (\n                                                i < 3 && (\n                                                    <div\n                                                        className=\"flex gap-x-2 items-center mb-2\"\n                                                        key={'additional-features-' + product.type + i}\n                                                    >\n                                                        <IconCheckCircle className=\"text-success\" />\n                                                        <Tooltip key={feature.key} title={feature.description}>\n                                                            <b>{feature.name} </b>\n                                                        </Tooltip>\n                                                    </div>\n                                                )\n                                            )\n                                        })}\n                                        {!billing?.has_active_subscription && (\n                                            <div className=\"flex gap-x-2 items-center mb-2\">\n                                                <IconCheckCircle className=\"text-success\" />\n                                                <Tooltip title=\"Multiple projects, Feature flags, Experiments, Integrations, Apps, and more\">\n                                                    <b>Upgraded platform features</b>\n                                                </Tooltip>\n                                            </div>\n                                        )}\n                                        <div className=\"flex gap-x-2 items-center mb-2\">\n                                            <IconCheckCircle className=\"text-success\" />\n                                            <Link onClick={() => toggleIsPlanComparisonModalOpen()}>\n                                                <b>And more...</b>\n                                            </Link>\n                                        </div>\n                                    </div>\n                                </>\n                            ) : (\n                                <p className=\"ml-0 max-w-200\">\n                                    You've got access to all the features we offer for {product.name}.\n                                </p>\n                            )}\n                            {upgradePlan?.tiers?.[0]?.unit_amount_usd &&\n                                parseInt(upgradePlan?.tiers?.[0].unit_amount_usd) === 0 && (\n                                    <p className=\"ml-0 mb-0 mt-4\">\n                                        <b>\n                                            First {convertLargeNumberToWords(upgradePlan?.tiers?.[0].up_to, null)}{' '}\n                                            {product.unit}s free\n                                        </b>\n                                        , then just ${upgradePlan?.tiers?.[1]?.unit_amount_usd} per {product.unit} and{' '}\n                                        <Link onClick={() => toggleIsPlanComparisonModalOpen()}>volume discounts</Link>.\n                                    </p>\n                                )}\n                        </div>\n                        {upgradePlan && (\n                            <div className=\"ml-4\">\n                                <div className=\"flex flex-wrap gap-x-2 gap-y-2\">\n                                    <LemonButton\n                                        type=\"secondary\"\n                                        onClick={() => toggleIsPlanComparisonModalOpen()}\n                                        className=\"grow\"\n                                        center\n                                    >\n                                        Compare plans\n                                    </LemonButton>\n                                    {upgradePlan.contact_support ? (\n                                        <LemonButton\n                                            type=\"primary\"\n                                            to=\"mailto:sales@posthog.com?subject=Enterprise%20plan%20request\"\n                                        >\n                                            Get in touch\n                                        </LemonButton>\n                                    ) : (\n                                        upgradePlan.included_if !== 'has_subscription' &&\n                                        !upgradePlan.unit_amount_usd && (\n                                            <BillingUpgradeCTA\n                                                data-attr={`${product.type}-upgrade-cta`}\n                                                to={getUpgradeProductLink(\n                                                    product,\n                                                    upgradeToPlanKey || '',\n                                                    redirectPath,\n                                                    isOnboarding // if in onboarding, we want to include addons, otherwise don't\n                                                )}\n                                                type=\"primary\"\n                                                icon={<IconPlus />}\n                                                disableClientSideRouting\n                                                onClick={() => {\n                                                    reportBillingUpgradeClicked(product.type)\n                                                }}\n                                                className=\"grow\"\n                                                center\n                                            >\n                                                {featureFlags[FEATURE_FLAGS.BILLING_UPGRADE_LANGUAGE] === 'subscribe'\n                                                    ? 'Subscribe'\n                                                    : featureFlags[FEATURE_FLAGS.BILLING_UPGRADE_LANGUAGE] ===\n                                                          'credit_card' && !billing?.has_active_subscription\n                                                    ? 'Add credit card'\n                                                    : featureFlags[FEATURE_FLAGS.BILLING_UPGRADE_LANGUAGE] ===\n                                                          'credit_card' && billing?.has_active_subscription\n                                                    ? 'Add paid plan'\n                                                    : 'Upgrade'}\n                                            </BillingUpgradeCTA>\n                                        )\n                                    )}\n                                </div>\n                            </div>\n                        )}\n                        <PlanComparisonModal\n                            product={product}\n                            includeAddons={isOnboarding}\n                            modalOpen={isPlanComparisonModalOpen}\n                            onClose={() => toggleIsPlanComparisonModalOpen()}\n                        />\n                    </div>\n                )}\n                <BillingLimitInput product={product} />\n            </div>\n            <ProductPricingModal\n                modalOpen={isPricingModalOpen}\n                onClose={toggleIsPricingModalOpen}\n                product={product}\n                planKey={product.subscribed ? currentPlanKey : upgradeToPlanKey}\n            />\n        </div>\n    )\n}\n","import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, afterMount, connect, kea, listeners, path, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { LemonBannerAction } from 'lib/lemon-ui/LemonBanner/LemonBanner'\nimport { lemonBannerLogic } from 'lib/lemon-ui/LemonBanner/lemonBannerLogic'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { pluralize } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport posthog from 'posthog-js'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { BillingProductV2Type, BillingV2Type, ProductKey } from '~/types'\n\nimport type { billingLogicType } from './billingLogicType'\n\nexport const ALLOCATION_THRESHOLD_ALERT = 0.85 // Threshold to show warning of event usage near limit\nexport const ALLOCATION_THRESHOLD_BLOCK = 1.2 // Threshold to block usage\n\nexport interface BillingAlertConfig {\n    status: 'info' | 'warning' | 'error'\n    title: string\n    message?: string\n    contactSupport?: boolean\n    buttonCTA?: string\n    dismissKey?: string\n    action?: LemonBannerAction\n    pathName?: string\n    onClose?: () => void\n}\n\nconst parseBillingResponse = (data: Partial<BillingV2Type>): BillingV2Type => {\n    if (data.billing_period) {\n        data.billing_period = {\n            current_period_start: dayjs(data.billing_period.current_period_start),\n            current_period_end: dayjs(data.billing_period.current_period_end),\n            interval: data.billing_period.interval,\n        }\n    }\n\n    data.free_trial_until = data.free_trial_until ? dayjs(data.free_trial_until) : undefined\n    data.amount_off_expires_at = data.amount_off_expires_at ? dayjs(data.amount_off_expires_at) : undefined\n    // If expiration is in the middle of the current period, we let it expire at the end of the period\n    if (\n        data.amount_off_expires_at &&\n        data.billing_period &&\n        data.amount_off_expires_at.isBefore(data.billing_period.current_period_end) &&\n        data.amount_off_expires_at.isAfter(data.billing_period.current_period_start)\n    ) {\n        data.amount_off_expires_at = data.billing_period.current_period_end\n    }\n\n    return data as BillingV2Type\n}\n\nexport const billingLogic = kea<billingLogicType>([\n    path(['scenes', 'billing', 'billingLogic']),\n    actions({\n        setProductSpecificAlert: (productSpecificAlert: BillingAlertConfig | null) => ({ productSpecificAlert }),\n        setScrollToProductKey: (scrollToProductKey: ProductKey | null) => ({ scrollToProductKey }),\n        setShowLicenseDirectInput: (show: boolean) => ({ show }),\n        reportBillingAlertShown: (alertConfig: BillingAlertConfig) => ({ alertConfig }),\n        reportBillingAlertActionClicked: (alertConfig: BillingAlertConfig) => ({ alertConfig }),\n        reportBillingV2Shown: true,\n        registerInstrumentationProps: true,\n        setRedirectPath: true,\n        setIsOnboarding: true,\n        determineBillingAlert: true,\n        setBillingAlert: (billingAlert: BillingAlertConfig | null) => ({ billingAlert }),\n    }),\n    connect(() => ({\n        values: [featureFlagLogic, ['featureFlags'], preflightLogic, ['preflight']],\n        actions: [\n            userLogic,\n            ['loadUser'],\n            eventUsageLogic,\n            ['reportProductUnsubscribed'],\n            lemonBannerLogic({ dismissKey: 'usage-limit-exceeded' }),\n            ['resetDismissKey as resetUsageLimitExceededKey'],\n            lemonBannerLogic({ dismissKey: 'usage-limit-approaching' }),\n            ['resetDismissKey as resetUsageLimitApproachingKey'],\n        ],\n    })),\n    reducers({\n        billingAlert: [\n            null as BillingAlertConfig | null,\n            {\n                setBillingAlert: (_, { billingAlert }) => billingAlert,\n            },\n        ],\n        scrollToProductKey: [\n            null as ProductKey | null,\n            {\n                setScrollToProductKey: (_, { scrollToProductKey }) => scrollToProductKey,\n            },\n        ],\n        productSpecificAlert: [\n            null as BillingAlertConfig | null,\n            {\n                setProductSpecificAlert: (_, { productSpecificAlert }) => productSpecificAlert,\n            },\n        ],\n        showLicenseDirectInput: [\n            false,\n            {\n                setShowLicenseDirectInput: (_, { show }) => show,\n            },\n        ],\n        redirectPath: [\n            '' as string,\n            {\n                setRedirectPath: () => {\n                    return window.location.pathname.includes('/onboarding')\n                        ? window.location.pathname + window.location.search\n                        : ''\n                },\n            },\n        ],\n        isOnboarding: [\n            false,\n            {\n                setIsOnboarding: () => window.location.pathname.includes('/onboarding'),\n            },\n        ],\n    }),\n    loaders(({ actions }) => ({\n        billing: [\n            null as BillingV2Type | null,\n            {\n                loadBilling: async () => {\n                    const response = await api.get('api/billing-v2')\n\n                    return parseBillingResponse(response)\n                },\n\n                updateBillingLimits: async (limits: { [key: string]: string | null }) => {\n                    const response = await api.update('api/billing-v2', { custom_limits_usd: limits })\n\n                    lemonToast.success('Billing limits updated')\n                    return parseBillingResponse(response)\n                },\n\n                deactivateProduct: async (key: string) => {\n                    const response = await api.get('api/billing-v2/deactivate?products=' + key)\n                    lemonToast.success('Product unsubscribed')\n                    actions.reportProductUnsubscribed(key)\n                    return parseBillingResponse(response)\n                },\n            },\n        ],\n        products: [\n            [] as BillingProductV2Type[],\n            {\n                loadProducts: async () => {\n                    const response = await api.get('api/billing-v2/available_products')\n                    return response\n                },\n            },\n        ],\n    })),\n    selectors({\n        upgradeLink: [(s) => [s.preflight], (): string => '/organization/billing'],\n        isUnlicensedDebug: [\n            (s) => [s.preflight, s.billing],\n            (preflight, billing): boolean => !!preflight?.is_debug && !billing?.billing_period,\n        ],\n        projectedTotalAmountUsd: [\n            (s) => [s.billing],\n            (billing: BillingV2Type): number => {\n                if (!billing) {\n                    return 0\n                }\n                let projectedTotal = 0\n                for (const product of billing.products || []) {\n                    projectedTotal += parseFloat(product.projected_amount_usd || '0')\n                }\n                return projectedTotal\n            },\n        ],\n        over20kAnnual: [\n            (s) => [s.billing, s.preflight, s.projectedTotalAmountUsd],\n            (billing, preflight, projectedTotalAmountUsd) => {\n                if (!billing || !preflight?.cloud) {\n                    return\n                }\n                if (\n                    billing.current_total_amount_usd_after_discount &&\n                    (parseFloat(billing.current_total_amount_usd_after_discount) > 1666 ||\n                        projectedTotalAmountUsd > 1666) &&\n                    billing.billing_period?.interval === 'month'\n                ) {\n                    return true\n                }\n                return\n            },\n        ],\n        isAnnualPlan: [\n            (s) => [s.billing],\n            (billing) => {\n                return billing?.billing_period?.interval === 'year'\n            },\n        ],\n    }),\n    forms(({ actions, values }) => ({\n        activateLicense: {\n            defaults: { license: '' } as { license: string },\n            errors: ({ license }) => ({\n                license: !license ? 'Please enter your license key' : undefined,\n            }),\n            submit: async ({ license }, breakpoint) => {\n                await breakpoint(500)\n                try {\n                    await api.update('api/billing-v2/license', {\n                        license,\n                    })\n\n                    // Reset the URL so we don't trigger the license submission again\n                    router.actions.replace(\n                        `/${values.isOnboarding ? 'ingestion' : 'organization'}/billing?success=true`\n                    )\n                    setTimeout(() => {\n                        window.location.reload() // Permissions, projects etc will be out of date at this point, so refresh\n                    }, 100)\n                } catch (e: any) {\n                    actions.setActivateLicenseManualErrors({\n                        license: e.detail || 'License could not be activated. Please contact support.',\n                    })\n                    throw e\n                }\n            },\n        },\n    })),\n    listeners(({ actions, values }) => ({\n        reportBillingV2Shown: () => {\n            posthog.capture('billing v2 shown')\n        },\n        reportBillingAlertShown: ({ alertConfig }) => {\n            posthog.capture('billing alert shown', {\n                ...alertConfig,\n            })\n        },\n        reportBillingAlertActionClicked: ({ alertConfig }) => {\n            posthog.capture('billing alert action clicked', {\n                ...alertConfig,\n            })\n        },\n        loadBillingSuccess: () => {\n            if (\n                router.values.location.pathname.includes('/organization/billing') &&\n                router.values.searchParams['success']\n            ) {\n                // if the activation is successful, we reload the user to get the updated billing info on the organization\n                actions.loadUser()\n                router.actions.replace('/organization/billing')\n            }\n            actions.registerInstrumentationProps()\n\n            actions.determineBillingAlert()\n        },\n        determineBillingAlert: () => {\n            if (values.productSpecificAlert) {\n                actions.setBillingAlert(values.productSpecificAlert)\n                return\n            }\n\n            if (!values.billing || !values.preflight?.cloud) {\n                return\n            }\n\n            if (values.billing.free_trial_until && values.billing.free_trial_until.isAfter(dayjs())) {\n                const remainingDays = values.billing.free_trial_until.diff(dayjs(), 'days')\n                const remainingHours = values.billing.free_trial_until.diff(dayjs(), 'hours')\n\n                if (remainingHours > 72) {\n                    return\n                }\n\n                actions.setBillingAlert({\n                    status: 'info',\n                    title: `Your free trial will end in ${\n                        remainingHours < 24 ? pluralize(remainingHours, 'hour') : pluralize(remainingDays, 'day')\n                    }.`,\n                    message: `Setup billing now to ensure you don't lose access to premium features.`,\n                })\n                return\n            }\n\n            if (values.billing.deactivated) {\n                actions.setBillingAlert({\n                    status: 'error',\n                    title: 'Your organization has been temporarily suspended.',\n                    message: 'Please contact support to reactivate it.',\n                    contactSupport: true,\n                })\n                return\n            }\n\n            const productOverLimit = values.billing.products?.find((x: BillingProductV2Type) => {\n                return x.percentage_usage > 1 && x.usage_key\n            })\n\n            if (productOverLimit) {\n                actions.setBillingAlert({\n                    status: 'error',\n                    title: 'Usage limit exceeded',\n                    message: `You have exceeded the usage limit for ${productOverLimit.name}. Please \n                        ${productOverLimit.subscribed ? 'increase your billing limit' : 'upgrade your plan'}\n                        or data loss may occur.`,\n                    dismissKey: 'usage-limit-exceeded',\n                })\n                return\n            }\n\n            actions.resetUsageLimitExceededKey()\n\n            const productApproachingLimit = values.billing.products?.find(\n                (x) => x.percentage_usage > ALLOCATION_THRESHOLD_ALERT\n            )\n\n            if (productApproachingLimit) {\n                actions.setBillingAlert({\n                    status: 'info',\n                    title: 'You will soon hit your usage limit',\n                    message: `You have currently used ${parseFloat(\n                        (productApproachingLimit.percentage_usage * 100).toFixed(2)\n                    )}% of your ${\n                        productApproachingLimit.usage_key && productApproachingLimit.usage_key.toLowerCase()\n                    } allocation.`,\n                    dismissKey: 'usage-limit-approaching',\n                })\n                return\n            }\n\n            actions.resetUsageLimitApproachingKey()\n        },\n        registerInstrumentationProps: async (_, breakpoint) => {\n            await breakpoint(100)\n            if (posthog && values.billing) {\n                const payload = {\n                    has_billing_plan: !!values.billing.has_active_subscription,\n                    free_trial_until: values.billing.free_trial_until?.toISOString(),\n                    customer_deactivated: values.billing.deactivated,\n                    current_total_amount_usd: values.billing.current_total_amount_usd,\n                }\n                if (values.billing.custom_limits_usd) {\n                    for (const product of Object.keys(values.billing.custom_limits_usd)) {\n                        payload[`custom_limits_usd.${product}`] = values.billing.custom_limits_usd[product]\n                    }\n                }\n                if (values.billing.products) {\n                    for (const product of values.billing.products) {\n                        const type = product.type.toLowerCase()\n                        payload[`percentage_usage.${type}`] = product.percentage_usage\n                        payload[`current_amount_usd.${type}`] = product.current_amount_usd\n                        payload[`unit_amount_usd.${type}`] = product.unit_amount_usd\n                        payload[`usage_limit.${type}`] = product.usage_limit\n                        payload[`current_usage.${type}`] = product.current_usage\n                        payload[`projected_usage.${type}`] = product.projected_usage\n                        payload[`free_allocation.${type}`] = product.free_allocation\n                    }\n                }\n                if (values.billing.billing_period) {\n                    payload['billing_period_start'] = values.billing.billing_period.current_period_start\n                    payload['billing_period_end'] = values.billing.billing_period.current_period_end\n                }\n                posthog.register(payload)\n            }\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadBilling()\n    }),\n    urlToAction(({ actions }) => ({\n        // IMPORTANT: This needs to be above the \"*\" so it takes precedence\n        '/*/billing': (_params, _search, hash) => {\n            if (hash.license) {\n                actions.setShowLicenseDirectInput(true)\n                actions.setActivateLicenseValues({ license: hash.license })\n                actions.submitActivateLicense()\n            }\n            if (_search.products) {\n                const products = _search.products.split(',')\n                actions.setScrollToProductKey(products[0])\n            }\n            actions.setRedirectPath()\n            actions.setIsOnboarding()\n        },\n        '*': () => {\n            actions.setRedirectPath()\n            actions.setIsOnboarding()\n        },\n    })),\n])\n","import { LemonCollapse, LemonModal, Link } from '@posthog/lemon-ui'\nimport { useValues } from 'kea'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport EarlyAccessFeatureImage from 'public/early-access-feature-demo.png'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\n\nimport { FeatureFlagType } from '~/types'\n\ninterface InstructionsModalProps {\n    flag: FeatureFlagType['key']\n    visible: boolean\n    onClose: () => void\n}\n\nexport function InstructionsModal({ onClose, visible, flag }: InstructionsModalProps): JSX.Element {\n    const { preflight } = useValues(preflightLogic)\n\n    const getCloudPanels = (): JSX.Element => (\n        <LemonCollapse\n            className=\"mt-2 bg-bg-light\"\n            defaultActiveKey=\"1\"\n            panels={[\n                {\n                    key: '1',\n                    header: 'Option 1: Widget Site App',\n                    content: (\n                        <div>\n                            Give your users a <Link to=\"https://app.posthog.com/project/apps/574\">prebuilt widget</Link>{' '}\n                            to opt-in to features\n                            <img className=\"max-h-full max-w-full mt-2.5\" src={EarlyAccessFeatureImage} />\n                        </div>\n                    ),\n                },\n                {\n                    key: '2',\n                    header: 'Option 2: Custom implementation',\n                    content: (\n                        <div>\n                            <b>Opt user in</b>\n                            <div>\n                                <FeatureEnrollInstructions flag={flag} />\n                            </div>\n\n                            <b>Opt user out</b>\n                            <div>\n                                <FeatureUnenrollInstructions flag={flag} />\n                            </div>\n\n                            <b>Retrieve Previews</b>\n                            <div>\n                                <RetrievePreviewsInstructions />\n                            </div>\n                        </div>\n                    ),\n                },\n            ]}\n        />\n    )\n\n    const getSelfHostedPanels = (): JSX.Element => (\n        <div>\n            <b>Opt user in</b>\n            <div>\n                <FeatureEnrollInstructions flag={flag} />\n            </div>\n\n            <b>Opt user out</b>\n            <div>\n                <FeatureUnenrollInstructions flag={flag} />\n            </div>\n\n            <b>Retrieve Previews</b>\n            <div>\n                <RetrievePreviewsInstructions />\n            </div>\n        </div>\n    )\n\n    const panels: JSX.Element = preflight?.cloud ? getCloudPanels() : getSelfHostedPanels()\n\n    return (\n        <LemonModal title=\"How to implement opt-in feature flags\" isOpen={visible} onClose={onClose} width={640}>\n            <div>\n                <div className=\"mb-2\">\n                    Implement manual release condition toggles to give your users the ability choose which features they\n                    want to try\n                </div>\n                {panels}\n            </div>\n        </LemonModal>\n    )\n}\n\nfunction FeatureEnrollInstructions({ flag }: { flag: string }): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.updateEarlyAccessFeatureEnrollment(\"${flag}\", true)\n`}\n        </CodeSnippet>\n    )\n}\n\nfunction FeatureUnenrollInstructions({ flag }: { flag: string }): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.updateEarlyAccessFeatureEnrollment(\"${flag}\", false)\n`}\n        </CodeSnippet>\n    )\n}\n\nfunction RetrievePreviewsInstructions(): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.getEarlyAccessFeatures((previewItemData) => {\n    // do something with early access feature\n})\n`}\n        </CodeSnippet>\n    )\n}\n","import { Link } from '@posthog/lemon-ui'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\n\nfunction ServerSideWarning(): JSX.Element {\n    return (\n        <div className=\"warning\">\n            <p>\n                <b>Warning:</b> Server side experiment metrics require you to manually send the feature flag\n                information.{' '}\n                <Link to=\"https://posthog.com/tutorials/experiments#step-2-sending-the-right-events\" target=\"_blank\">\n                    See this tutorial for more information.\n                </Link>\n            </p>\n        </div>\n    )\n}\n\ninterface SnippetProps {\n    flagKey: string\n    variant: string\n}\n\nexport function NodeJSSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`const experimentFlagValue = await client.getFeatureFlag('${flagKey}', 'user distinct id')\n\nif (experimentFlagValue === '${variant}' ) {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n\nexport function JSSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <div>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`if (posthog.getFeatureFlag('${flagKey}') === '${variant}') {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n            <div className=\"mt-4 mb-1\">\n                <b>Test that it works</b>\n            </div>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`posthog.featureFlags.override({'${flagKey}': '${variant}'})`}\n            </CodeSnippet>\n        </div>\n    )\n}\n\nexport function RNSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`if (posthog.getFeatureFlag('${flagKey}') === '${variant}') {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function PHPSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.PHP} wrap>\n                {`if (PostHog::getFeatureFlag('${flagKey}', 'user distinct id') == '${variant}') {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n\nexport function GolangSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.Go} wrap>\n                {`experimentFlagValue, err := client.GetFeatureFlag(\n                    FeatureFlagPayload{\n                        Key:        '${flagKey}',\n                        DistinctId: \"distinct-id\",\n                    })\n\nif (experimentFlagValue == '${variant}' ) {\n    // Do something differently for this user\n} else {\n    // It's a good idea to let control variant always be the default behaviour,\n    // so if something goes wrong with flag evaluation, you don't break your app.\n}`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n\nexport function RubySnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.Ruby} wrap>\n                {`experimentFlagValue = posthog.get_feature_flag('${flagKey}', 'user distinct id')\n\n\nif experimentFlagValue == '${variant}'\n    # Do something differently for this user\nelse\n    # It's a good idea to let control variant always be the default behaviour,\n    # so if something goes wrong with flag evaluation, you don't break your app.\nend\n`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n\nexport function PythonSnippet({ flagKey, variant }: SnippetProps): JSX.Element {\n    return (\n        <>\n            <CodeSnippet language={Language.Python} wrap>\n                {`experiment_flag_value = posthog.get_feature_flag(\"${flagKey}\", \"user_distinct_id\"):\n\nif experiment_flag_value == '${variant}':\n    # Do something differently for this user\nelse:\n    # It's a good idea to let control variant always be the default behaviour,\n    # so if something goes wrong with flag evaluation, you don't break your app.\n`}\n            </CodeSnippet>\n            <ServerSideWarning />\n        </>\n    )\n}\n","import { useValues } from 'kea'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { apiHostOrigin } from 'lib/utils/apiHost'\nimport { teamLogic } from 'scenes/teamLogic'\n\nimport { GroupType } from '~/types'\n\nexport const UTM_TAGS = '?utm_medium=in-product&utm_campaign=feature-flag'\n\nexport interface FeatureFlagSnippet {\n    flagKey: string\n    multivariant?: boolean\n    groupType?: GroupType\n    localEvaluation?: boolean\n    payload?: boolean\n    samplePropertyName?: string\n    instantlyAvailableProperties?: boolean\n}\n\nconst LOCAL_EVAL_REMINDER = `// Remember to set a personal API key in the SDK to enable local evaluation.\n`\n\nexport function NodeJSSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'await client.'\n    const flagFunction = payload ? 'getFeatureFlagPayload' : multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n                // add group properties used in the flag to ensure the flag\n                // is evaluated locally, vs. going to our servers\n                groupProperties: { ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n                // add person properties used in the flag to ensure the flag\n                // is evaluated locally, vs. going to our servers\n                personProperties: {'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',\n            {\n                groups: { '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n            }\n        )`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',\n            {${localEvalAddition}}\n            )`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n\n    const variableName = payload ? 'matchedFlagPayload' : multivariant ? 'enabledVariant' : 'isMyFlagEnabledForUser'\n\n    const conditional = multivariant ? `${variableName} === 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif (${conditional}) {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`\n\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`${localEvaluation ? LOCAL_EVAL_REMINDER : ''}const ${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function PHPSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHog::'\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n            // empty person properties\n            [],\n            // add group properties used in the flag to ensure the flag\n            // is evaluated locally, vs. going to our servers\n            [${groupType.group_type} =>  ['${propertyName}' => 'value', 'name' => 'xyz']]`\n            : `\n            // add person properties used in the flag to ensure the flag\n            // is evaluated locally, vs. going to our servers\n            ['${propertyName}' => 'value']`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',\n            // group types\n            ['${groupType.group_type}' => '<${groupType.name_singular || 'group'} ID>'],${localEvalAddition}\n        )`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',${localEvalAddition}\n        )`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = multivariant ? '$enabledVariant' : '$isMyFlagEnabledForUser'\n\n    const conditional = multivariant ? `${variableName} === 'example-variant'` : `${variableName}`\n\n    return (\n        <>\n            <CodeSnippet language={Language.PHP} wrap>\n                {`${localEvaluation ? LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}\n\nif (${conditional}) {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function GolangSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'client.'\n\n    const flagFunction = multivariant ? 'GetFeatureFlag' : 'IsFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n                // add group properties used in the flag to ensure the flag\n                // is evaluated locally, vs. going to our servers\n                \n                groupProperties: map[string]Properties{\"${groupType.group_type}\": posthog.NewProperties().Set(\"${propertyName}\", \"value\").Set(\"name\", \"xyz\")}`\n            : `\n                // add person properties used in the flag to ensure the flag\n                // is evaluated locally, vs. going to our servers\n                PersonProperties: posthog.NewProperties().Set(\"${propertyName}\", \"value\")`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n            FeatureFlagPayload{\n                Key:        \"${flagKey}\",\n                DistinctId: \"distinct-id\",\n                Groups:     Groups{'${groupType.group_type}': '<${\n              groupType.name_singular || 'group'\n          } ID>'},${localEvalAddition}\n            }\n        )`\n        : `${clientSuffix}${flagFunction}(\n            FeatureFlagPayload{\n                Key:        '${flagKey}',\n                DistinctId: \"distinct-id\",${localEvalAddition}\n            })`\n    const variableName = multivariant ? 'enabledVariant, err' : 'isMyFlagEnabledForUser, err'\n\n    const conditional = multivariant ? `enabledVariant == 'example-variant'` : `isMyFlagEnabledForUser`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Go} wrap>\n                {`${localEvaluation ? LOCAL_EVAL_REMINDER : ''}${variableName} := ${flagSnippet}\n\nif ${conditional} {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function RubySnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n    const flagFunction = payload ? 'get_feature_flag_payload' : multivariant ? 'get_feature_flag' : 'is_feature_enabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n            # // add group properties used in the flag to ensure the flag\n            # // is evaluated locally, vs. going to our servers\n            group_properties: { ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n            # // add person properties used in the flag to ensure the flag\n            # // is evaluated locally, vs. going to our servers\n            person_properties: {'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',\n            groups: { '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n        )`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',${localEvalAddition}\n        )`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = payload ? 'matched_flag_payload' : multivariant ? 'enabled_variant' : 'is_my_flag_enabled'\n\n    const conditional = multivariant ? `${variableName} == 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif ${conditional}\n    # Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\nend`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Ruby} wrap>\n                {`${localEvaluation ? '# ' + LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function PythonSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n    const flagFunction = payload ? 'get_feature_flag_payload' : multivariant ? 'get_feature_flag' : 'feature_enabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n            # // add group properties used in the flag to ensure the flag\n            # // is evaluated locally, vs. going to our servers\n            group_properties={ ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n            # // add person properties used in the flag to ensure the flag\n            # // is evaluated locally, vs. going to our servers\n            person_properties={'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',\n            groups={ '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n        )`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n            '${flagKey}',\n            'user distinct id',${localEvalAddition}\n        )`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = payload ? 'matched_flag_payload' : multivariant ? 'enabled_variant' : 'is_my_flag_enabled'\n\n    const conditional = multivariant ? `${variableName} == 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif ${conditional}:\n    # Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Python} wrap>\n                {`${localEvaluation ? '# ' + LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function AndroidSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHog.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Kotlin} wrap>\n                {`${clientSuffix}getFeatureFlagPayload(\"${flagKey}\")`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == \"example-variant\"` : ''\n    return (\n        <CodeSnippet language={Language.Kotlin} wrap>\n            {`if (${clientSuffix}${flagFunction}(\"${flagKey}\")${variantSuffix}) {\n    // do something\n}\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function FlutterSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'await Posthog().'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Dart} wrap>\n                {`${clientSuffix}getFeatureFlagPayload('${flagKey}');`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n\n    return (\n        <CodeSnippet language={Language.Dart} wrap>\n            {`if (${clientSuffix}${flagFunction}('${flagKey}')${variantSuffix}) {\n    // do something\n}\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function iOSSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHogSDK.shared.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Swift} wrap>\n                {`${clientSuffix}getFeatureFlagPayload(\"${flagKey}\")`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? `as? String == \"example-variant\"` : ''\n    return (\n        <CodeSnippet language={Language.Swift} wrap>\n            {`if ${clientSuffix}${flagFunction}(\"${flagKey}\")${variantSuffix} {\n    // do something\n}`}\n        </CodeSnippet>\n    )\n}\n\nexport function ReactNativeSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.JSX} wrap>\n                {`${clientSuffix}getFeatureFlagPayload('${flagKey}')`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n    return (\n        <CodeSnippet language={Language.JSX} wrap>\n            {`// With a hook\nimport { useFeatureFlag } from 'posthog-react-native'\n\nconst MyComponent = () => {\n    const showFlaggedFeature = useFeatureFlag('${flagKey}')\n\n    if (showFlaggedFeature === undefined) {\n        // the response is undefined if the flags are being loaded\n        return null\n    }\n\n    return showFlaggedFeature ${variantSuffix} ? <Text>Testing feature 😄</Text> : <Text>Not Testing feature 😢</Text>\n}\n\n// Or calling on the method directly\n${clientSuffix}${flagFunction}('${flagKey}')\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function ReactSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const flagFunction = payload\n        ? 'useFeatureFlagPayload'\n        : multivariant\n        ? 'useFeatureFlagVariantKey'\n        : 'useFeatureFlagEnabled'\n\n    const variable = payload ? 'payload' : multivariant ? 'variant' : 'flagEnabled'\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n\n    return (\n        <CodeSnippet language={Language.JSX} wrap>\n            {`\nimport { ${flagFunction} } from 'posthog-js/react'\n\nfunction App() {\n    const ${variable} = ${flagFunction}('${flagKey}')\n\n    if (${variable}${variantSuffix}) {\n        // do something\n    }\n}`}\n        </CodeSnippet>\n    )\n}\n\nexport function APISnippet({ groupType }: FeatureFlagSnippet): JSX.Element {\n    const { currentTeam } = useValues(teamLogic)\n\n    const groupAddition = groupType\n        ? `\n    \"groups\": { \"${groupType.group_type}\": \"<${groupType.name_singular || 'group'} ID>\" },`\n        : ''\n\n    return (\n        <>\n            <CodeSnippet language={Language.Bash} wrap>\n                {`curl ${apiHostOrigin()}/decide?v=3/ \\\\\n-X POST -H 'Content-Type: application/json' \\\\\n-d '{\n    \"api_key\": \"${currentTeam ? currentTeam.api_token : '[project_api_key]'}\",\n    \"distinct_id\": \"[user distinct id]\",${groupAddition}\n}'\n                `}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function JSSnippet({\n    flagKey,\n    multivariant,\n    payload,\n    groupType,\n    instantlyAvailableProperties,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    if (payload) {\n        return (\n            <>\n                <CodeSnippet language={Language.JavaScript} wrap>\n                    {`posthog.getFeatureFlagPayload('${flagKey ?? ''}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const propertyOverrideSnippet = `// Your flag depends on properties that are not instantly available. If you want\n// to make them available without waiting for server delays, send these properties for flag evaluation, like so:\n// Make sure to call this before evaluating flags. More info: https://posthog.com/docs/libraries/js#overriding-server-properties \nposthog.${\n        groupType\n            ? `setGroupPropertiesForFlags({ '${groupType.group_type}': {'${propertyName}': 'value'}})`\n            : `setPersonPropertiesForFlags({'${propertyName}': 'value'})`\n    }\n\n`\n\n    const clientSuffix = 'posthog.'\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`${instantlyAvailableProperties ? '' : propertyOverrideSnippet}// Ensure flags are loaded before usage.\n// You'll only need to call this on the code for when the first time a user visits.\n${clientSuffix}onFeatureFlags(function() {\n    // feature flags should be available at this point\n    if (${clientSuffix}${flagFunction}('${flagKey ?? ''}') ${variantSuffix}) {\n        // do something\n    }\n})\n\n// Otherwise, you can just do:\nif (${clientSuffix}${flagFunction}('${flagKey ?? ''}') ${variantSuffix}) {\n    // do something\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function JSBootstrappingSnippet(): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`// Initialise the posthog library with a distinct ID and feature flags for immediate loading\n// This avoids the delay between the library loading and feature flags becoming available to use.\n\nposthog.init('{project_api_key}', {\n    api_host: 'https://app.posthog.com',\n    bootstrap:\n    {\n        distinctID: 'your-anonymous-id',\n        featureFlags: {\n    // input the flag values here from 'posthog.getAllFlags(distinct_id)' which you can find in the server-side libraries.\n        // example:\n            // 'flag-1': true,\n            // 'variant-flag': 'control',\n            // 'other-flag': false\n        },\n    }\n})\n            `}\n        </CodeSnippet>\n    )\n}\n","import { mergeAttributes, Node, NodeViewProps } from '@tiptap/core'\nimport { NodeViewWrapper, ReactNodeViewRenderer } from '@tiptap/react'\nimport { NotebookNodeType, NotebookTarget } from '~/types'\nimport { dayjs } from 'lib/dayjs'\nimport { JSONContent } from '../Notebook/utils'\nimport clsx from 'clsx'\nimport { urls } from 'scenes/urls'\nimport { LemonButton } from '@posthog/lemon-ui'\nimport { notebookLogic } from '../Notebook/notebookLogic'\nimport { useValues } from 'kea'\nimport { useMemo } from 'react'\nimport { openNotebook } from '~/models/notebooksModel'\n\nexport interface NotebookNodeReplayTimestampAttrs {\n    playbackTime?: number\n    sessionRecordingId: string\n    sourceNodeId?: string\n}\n\nconst Component = (props: NodeViewProps): JSX.Element => {\n    const { shortId, findNodeLogic, findNodeLogicById } = useValues(notebookLogic)\n    const { sessionRecordingId, playbackTime = 0, sourceNodeId } = props.node.attrs as NotebookNodeReplayTimestampAttrs\n\n    const relatedNodeInNotebook = useMemo(() => {\n        const logicById = sourceNodeId ? findNodeLogicById(sourceNodeId) : null\n\n        return logicById ?? findNodeLogic(NotebookNodeType.Recording, { id: sessionRecordingId })\n    }, [findNodeLogic])\n\n    const handlePlayInNotebook = (): void => {\n        // TODO: Figure out how to send this action info to the playlist OR the replay node...\n\n        relatedNodeInNotebook?.values.sendMessage('play-replay', {\n            sessionRecordingId,\n            time: playbackTime ?? 0,\n        })\n    }\n\n    return (\n        <NodeViewWrapper\n            as=\"span\"\n            className={clsx('NotebookRecordingTimestamp', props.selected && 'NotebookRecordingTimestamp--selected')}\n        >\n            <LemonButton\n                size=\"small\"\n                noPadding\n                active\n                onClick={\n                    relatedNodeInNotebook ? handlePlayInNotebook : () => openNotebook(shortId, NotebookTarget.Popover)\n                }\n                to={\n                    !relatedNodeInNotebook\n                        ? urls.replaySingle(sessionRecordingId) + `?t=${playbackTime / 1000}`\n                        : undefined\n                }\n            >\n                <span className=\"p-1\">{formatTimestamp(playbackTime)}</span>\n            </LemonButton>\n        </NodeViewWrapper>\n    )\n}\n\nexport const NotebookNodeReplayTimestamp = Node.create({\n    name: NotebookNodeType.ReplayTimestamp,\n    inline: true,\n    group: 'inline',\n    atom: true,\n\n    serializedText: (attrs: NotebookNodeReplayTimestampAttrs): string => {\n        // timestamp is not a block so `getText` does not add a separator.\n        // we need to add it manually\n        return `${attrs.playbackTime ? formatTimestamp(attrs.playbackTime) : '00:00'}:\\n`\n    },\n\n    addAttributes() {\n        return {\n            playbackTime: { default: null, keepOnSplit: false },\n            sessionRecordingId: { default: null, keepOnSplit: true, isRequired: true },\n            sourceNodeId: { default: null, keepOnSplit: true },\n        }\n    },\n\n    parseHTML() {\n        return [{ tag: NotebookNodeType.ReplayTimestamp }]\n    },\n\n    renderHTML({ HTMLAttributes }) {\n        return [NotebookNodeType.ReplayTimestamp, mergeAttributes(HTMLAttributes)]\n    },\n\n    addNodeView() {\n        return ReactNodeViewRenderer(Component)\n    },\n})\n\nexport function formatTimestamp(time: number): string {\n    return dayjs.duration(time, 'milliseconds').format('HH:mm:ss').replace(/^00:/, '').trim()\n}\n\nexport function buildTimestampCommentContent(attrs: NotebookNodeReplayTimestampAttrs): JSONContent {\n    return {\n        type: 'paragraph',\n        content: [\n            {\n                type: NotebookNodeType.ReplayTimestamp,\n                attrs,\n            },\n            { type: 'text', text: ' ' },\n        ],\n    }\n}\n","import {\n    IconCursor,\n    IconFunnels,\n    IconHogQL,\n    IconLifecycle,\n    IconPeople,\n    IconRetention,\n    IconRewindPlay,\n    IconStickiness,\n    IconTrends,\n    IconUpload,\n    IconUserPaths,\n} from '@posthog/icons'\nimport { IconCode } from '@posthog/icons'\nimport { LemonButton, LemonDivider, lemonToast } from '@posthog/lemon-ui'\nimport { Extension } from '@tiptap/core'\nimport { ReactRenderer } from '@tiptap/react'\nimport Suggestion from '@tiptap/suggestion'\nimport Fuse from 'fuse.js'\nimport { useValues } from 'kea'\nimport { IconBold, IconItalic } from 'lib/lemon-ui/icons'\nimport { Popover } from 'lib/lemon-ui/Popover'\nimport { selectFiles } from 'lib/utils/file-utils'\nimport { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useState } from 'react'\n\nimport { KeyboardShortcut } from '~/layout/navigation-3000/components/KeyboardShortcut'\nimport { defaultDataTableColumns } from '~/queries/nodes/DataTable/utils'\nimport { NodeKind } from '~/queries/schema'\nimport { BaseMathType, ChartDisplayType, FunnelVizType, NotebookNodeType, PathType, RetentionPeriod } from '~/types'\n\nimport { buildNodeEmbed } from '../Nodes/NotebookNodeEmbed'\nimport { buildInsightVizQueryContent, buildNodeQueryContent } from '../Nodes/NotebookNodeQuery'\nimport NotebookIconHeading from './NotebookIconHeading'\nimport { notebookLogic } from './notebookLogic'\nimport { EditorCommands, EditorRange } from './utils'\n\ntype SlashCommandConditionalProps =\n    | {\n          mode: 'add'\n          getPos: () => number\n          range?: never\n      }\n    | {\n          mode: 'slash'\n          getPos?: never\n          range: EditorRange\n      }\n\ntype SlashCommandsProps = SlashCommandConditionalProps & {\n    query?: string\n    decorationNode?: any\n    onClose?: () => void\n}\n\ntype SlashCommandsPopoverProps = SlashCommandsProps & {\n    visible: boolean\n    children?: JSX.Element\n}\n\ntype SlashCommandsRef = {\n    onKeyDown: (event: KeyboardEvent) => boolean\n}\n\ntype SlashCommandsItem = {\n    title: string\n    search?: string\n    icon?: JSX.Element\n    command: (chain: EditorCommands, pos: number | EditorRange) => EditorCommands | Promise<EditorCommands>\n}\n\nconst TEXT_CONTROLS: SlashCommandsItem[] = [\n    {\n        title: 'h1',\n        icon: <NotebookIconHeading level={1} />,\n        command: (chain) => chain.toggleHeading({ level: 1 }),\n    },\n    {\n        title: 'h2',\n        icon: <NotebookIconHeading level={2} />,\n        command: (chain) => chain.toggleHeading({ level: 2 }),\n    },\n    {\n        title: 'h3',\n        icon: <NotebookIconHeading level={3} />,\n        command: (chain) => chain.toggleHeading({ level: 3 }),\n    },\n    {\n        title: 'bold',\n        icon: <IconBold />,\n        command: (chain) => chain.toggleBold(),\n    },\n    {\n        title: 'italic',\n        icon: <IconItalic />,\n        command: (chain) => chain.toggleItalic(),\n    },\n]\n\nconst SLASH_COMMANDS: SlashCommandsItem[] = [\n    {\n        title: 'Trend',\n        search: 'graph trend insight',\n        icon: <IconTrends color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.TrendsQuery,\n                    filterTestAccounts: false,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            event: '$pageview',\n                            name: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                    interval: 'day',\n                    trendsFilter: {\n                        display: ChartDisplayType.ActionsLineGraph,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Funnel',\n        search: 'funnel insight',\n        icon: <IconFunnels color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.FunnelsQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                        },\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                        },\n                    ],\n                    funnelsFilter: {\n                        funnelVizType: FunnelVizType.Steps,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Retention',\n        search: 'retention insight',\n        icon: <IconRetention color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.RetentionQuery,\n                    retentionFilter: {\n                        period: RetentionPeriod.Day,\n                        totalIntervals: 11,\n                        targetEntity: {\n                            id: '$pageview',\n                            name: '$pageview',\n                            type: 'events',\n                        },\n                        returningEntity: {\n                            id: '$pageview',\n                            name: '$pageview',\n                            type: 'events',\n                        },\n                        retentionType: 'retention_first_time',\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Paths',\n        search: 'user paths insight',\n        icon: <IconUserPaths color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.PathsQuery,\n                    pathsFilter: {\n                        includeEventTypes: [PathType.PageView],\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Stickiness',\n        search: 'stickiness insight',\n        icon: <IconStickiness color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.StickinessQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                    stickinessFilter: {},\n                })\n            ),\n    },\n    {\n        title: 'Lifecycle',\n        search: 'lifecycle insight',\n        icon: <IconLifecycle color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.LifecycleQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                })\n            ),\n    },\n    {\n        title: 'HogQL',\n        search: 'sql',\n        icon: <IconHogQL color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.HogQLQuery,\n                        query: `select event,\n        person.properties.email,\n        properties.$browser,\n        count()\n    from events\n    where {filters} -- replaced with global date and property filters\n    and person.properties.email is not null\ngroup by event,\n        properties.$browser,\n        person.properties.email\norder by count() desc\n    limit 100`,\n                        filters: {\n                            dateRange: {\n                                date_from: '-24h',\n                            },\n                        },\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Events',\n        search: 'data explore',\n        icon: <IconCursor />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.EventsQuery,\n                        select: defaultDataTableColumns(NodeKind.EventsQuery),\n                        properties: [],\n                        after: '-24h',\n                        limit: 100,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'People',\n        search: 'persons users',\n        icon: <IconPeople />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    columns: defaultDataTableColumns(NodeKind.PersonsNode),\n                    source: {\n                        kind: NodeKind.PersonsNode,\n                        properties: [],\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Session recordings',\n        search: 'video replay',\n        icon: <IconRewindPlay />,\n        command: (chain, pos) => chain.insertContentAt(pos, { type: NotebookNodeType.RecordingPlaylist, attrs: {} }),\n    },\n    {\n        title: 'Image',\n        search: 'picture gif',\n        icon: <IconUpload />,\n        command: async (chain, pos) => {\n            // Trigger upload followed by insert\n            try {\n                const files = await selectFiles({ contentType: 'image/*', multiple: false })\n\n                if (files.length) {\n                    return chain.insertContentAt(pos, { type: NotebookNodeType.Image, attrs: { file: files[0] } })\n                }\n            } catch (e) {\n                lemonToast.error('Something went wrong when trying to select a file.')\n            }\n\n            return chain\n        },\n    },\n    {\n        title: 'Embedded iframe',\n        search: 'iframe embed',\n        icon: <IconCode />,\n        command: async (chain, pos) => {\n            return chain.insertContentAt(pos, buildNodeEmbed())\n        },\n    },\n]\n\nexport const SlashCommands = forwardRef<SlashCommandsRef, SlashCommandsProps>(function SlashCommands(\n    { mode, range, getPos, onClose, query }: SlashCommandsProps,\n    ref\n): JSX.Element | null {\n    const { editor } = useValues(notebookLogic)\n    // We start with 1 because the first item is the text controls\n    const [selectedIndex, setSelectedIndex] = useState(0)\n    const [selectedHorizontalIndex, setSelectedHorizontalIndex] = useState(0)\n\n    const allCommmands = [...TEXT_CONTROLS, ...SLASH_COMMANDS]\n\n    const fuse = useMemo(() => {\n        return new Fuse(allCommmands, {\n            keys: ['title', 'search'],\n            threshold: 0.3,\n        })\n    }, [allCommmands])\n\n    const filteredCommands = useMemo(() => {\n        if (!query) {\n            return allCommmands\n        }\n        return fuse.search(query).map((result) => result.item)\n    }, [query, fuse])\n\n    const filteredSlashCommands = useMemo(\n        () => filteredCommands.filter((item) => SLASH_COMMANDS.includes(item)),\n        [filteredCommands]\n    )\n\n    useEffect(() => {\n        setSelectedIndex(0)\n        setSelectedHorizontalIndex(0)\n    }, [query])\n\n    const execute = async (item: SlashCommandsItem): Promise<void> => {\n        if (editor) {\n            const selectedNode = editor.getSelectedNode()\n            const isTextNode = selectedNode === null || selectedNode.isText\n            const isTextCommand = TEXT_CONTROLS.map((c) => c.title).includes(item.title)\n\n            const position = mode === 'slash' ? range.from : getPos()\n            let chain = mode === 'slash' ? editor.deleteRange(range) : editor.chain()\n\n            if (!isTextNode && isTextCommand) {\n                chain = chain.insertContentAt(position, { type: 'paragraph' })\n            }\n\n            const partialCommand = await item.command(chain, position)\n            partialCommand.run()\n\n            onClose?.()\n        }\n    }\n\n    const onPressEnter = async (): Promise<void> => {\n        const command =\n            selectedIndex === -1 ? TEXT_CONTROLS[selectedHorizontalIndex] : filteredSlashCommands[selectedIndex]\n\n        await execute(command)\n    }\n    const onPressUp = (): void => {\n        setSelectedIndex(Math.max(selectedIndex - 1, -1))\n    }\n    const onPressDown = (): void => {\n        setSelectedIndex(Math.min(selectedIndex + 1, SLASH_COMMANDS.length - 1))\n    }\n\n    const onPressLeft = (): void => {\n        setSelectedHorizontalIndex(Math.max(selectedHorizontalIndex - 1, 0))\n    }\n    const onPressRight = (): void => {\n        setSelectedHorizontalIndex(Math.min(selectedHorizontalIndex + 1, TEXT_CONTROLS.length - 1))\n    }\n\n    const onKeyDown = useCallback(\n        (event: KeyboardEvent): boolean => {\n            const keyMappings = {\n                ArrowUp: onPressUp,\n                ArrowDown: onPressDown,\n                ArrowLeft: onPressLeft,\n                ArrowRight: onPressRight,\n                Enter: onPressEnter,\n            }\n\n            if (keyMappings[event.key]) {\n                keyMappings[event.key]()\n                return true\n            }\n\n            return false\n        },\n        [selectedIndex, selectedHorizontalIndex, filteredCommands]\n    )\n\n    // Expose the keydown handler to the tiptap extension\n    useImperativeHandle(ref, () => ({ onKeyDown }), [onKeyDown])\n\n    useEffect(() => {\n        if (mode !== 'add') {\n            return\n        }\n\n        // If not opened from a slash command, we want to add our own keyboard listeners\n        const keyDownListener = (event: KeyboardEvent): void => {\n            const preventDefault = onKeyDown(event)\n            if (preventDefault) {\n                event.preventDefault()\n            }\n        }\n\n        window.addEventListener('keydown', keyDownListener, true)\n\n        return () => window.removeEventListener('keydown', keyDownListener, true)\n    }, [onKeyDown, mode])\n\n    if (!editor) {\n        return null\n    }\n\n    return (\n        <div className=\"space-y-px\">\n            <div className=\"flex items-center gap-1\">\n                {TEXT_CONTROLS.map((item, index) => (\n                    <LemonButton\n                        key={item.title}\n                        size=\"small\"\n                        active={selectedIndex === -1 && selectedHorizontalIndex === index}\n                        onClick={() => void execute(item)}\n                        icon={item.icon}\n                    />\n                ))}\n            </div>\n\n            <LemonDivider />\n\n            {filteredSlashCommands.map((item, index) => (\n                <LemonButton\n                    key={item.title}\n                    fullWidth\n                    icon={item.icon}\n                    active={index === selectedIndex}\n                    onClick={() => void execute(item)}\n                >\n                    {item.title}\n                </LemonButton>\n            ))}\n\n            {filteredSlashCommands.length === 0 && (\n                <div className=\"text-muted-alt p-1\">\n                    Nothing matching <code>/{query}</code>\n                </div>\n            )}\n\n            {mode === 'add' && (\n                <>\n                    <LemonDivider className=\"my-0\" />\n                    <div className=\"text-xs text-muted-alt p-1\">\n                        You can trigger this menu by typing <KeyboardShortcut forwardslash />\n                    </div>\n                </>\n            )}\n        </div>\n    )\n})\n\nexport const SlashCommandsPopover = forwardRef<SlashCommandsRef, SlashCommandsPopoverProps>(\n    function SlashCommandsPopover(\n        { visible = true, decorationNode, children, onClose, ...props }: SlashCommandsPopoverProps,\n        ref\n    ): JSX.Element | null {\n        return (\n            <Popover\n                placement=\"right-start\"\n                fallbackPlacements={['left-start', 'right-end']}\n                overlay={<SlashCommands ref={ref} onClose={onClose} {...props} />}\n                referenceElement={decorationNode}\n                visible={visible}\n                onClickOutside={onClose}\n            >\n                {children}\n            </Popover>\n        )\n    }\n)\n\nexport const SlashCommandsExtension = Extension.create({\n    name: 'slash-commands',\n\n    addProseMirrorPlugins() {\n        return [\n            Suggestion({\n                editor: this.editor,\n                char: '/',\n                startOfLine: true,\n                render: () => {\n                    let renderer: ReactRenderer<SlashCommandsRef>\n\n                    return {\n                        onStart: (props) => {\n                            renderer = new ReactRenderer(SlashCommandsPopover, {\n                                props: { ...props, mode: 'slash' },\n                                editor: props.editor,\n                            })\n                        },\n\n                        onUpdate(props) {\n                            renderer.updateProps(props)\n\n                            if (!props.clientRect) {\n                                return\n                            }\n                        },\n\n                        onKeyDown(props) {\n                            if (props.event.key === 'Escape') {\n                                renderer.destroy()\n                                return true\n                            }\n                            return renderer.ref?.onKeyDown(props.event) ?? false\n                        },\n\n                        onExit() {\n                            renderer.destroy()\n                        },\n                    }\n                },\n            }),\n        ]\n    },\n})\n","import * as d3 from 'd3'\nimport * as Sankey from 'd3-sankey'\nimport { D3Selector } from 'lib/hooks/useD3'\nimport { stripHTTP } from 'lib/utils'\nimport { Dispatch, RefObject, SetStateAction } from 'react'\n\nimport { FunnelPathsFilter, PathsFilter } from '~/queries/schema'\n\nimport { FALLBACK_CANVAS_WIDTH, HIDE_PATH_CARD_HEIGHT } from './Paths'\nimport { PathNode } from './pathsDataLogic'\nimport { isSelectedPathStartOrEnd, PathNodeData, PathTargetLink, roundedRect } from './pathUtils'\n\nconst createCanvas = (canvasRef: RefObject<HTMLDivElement>, width: number, height: number): D3Selector => {\n    return d3\n        .select(canvasRef.current)\n        .append('svg')\n        .classed('Paths__canvas', true)\n        .style('background', 'var(--item-background)')\n        .style('width', `${width}px`)\n        .style('height', `${height}px`)\n}\n\nconst createSankey = (width: number, height: number): Sankey.SankeyLayout<any, any, any> => {\n    // @ts-expect-error - d3 sankey typing things\n    return new Sankey.sankey()\n        .nodeId((d: PathNodeData) => d.name)\n        .nodeAlign(Sankey.sankeyJustify)\n        .nodeSort(null)\n        .nodeWidth(15)\n        .size([width, height])\n}\n\nconst appendPathNodes = (\n    svg: any,\n    nodes: PathNodeData[],\n    pathsFilter: PathsFilter,\n    funnelPathsFilter: FunnelPathsFilter,\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void => {\n    svg.append('g')\n        .selectAll('rect')\n        .data(nodes)\n        .join('rect')\n        .attr('x', (d: PathNodeData) => d.x0 + 1)\n        .attr('y', (d: PathNodeData) => d.y0)\n        .attr('height', (d: PathNodeData) => d.y1 - d.y0)\n        .attr('width', (d: PathNodeData) => d.x1 - d.x0 - 2)\n        .attr('fill', (d: PathNodeData) => {\n            let c\n            for (const link of d.sourceLinks) {\n                if (c === undefined) {\n                    c = link.color\n                } else if (c !== link.color) {\n                    c = null\n                }\n            }\n            if (c === undefined) {\n                for (const link of d.targetLinks) {\n                    if (c === undefined) {\n                        c = link.color\n                    } else if (c !== link.color) {\n                        c = null\n                    }\n                }\n            }\n            if (isSelectedPathStartOrEnd(pathsFilter, funnelPathsFilter, d)) {\n                return d3.color('purple')\n            }\n            const startNodeColor = c && d3.color(c) ? d3.color(c) : d3.color('#5375ff')\n            return startNodeColor\n        })\n        .on('mouseover', (_event: MouseEvent, data: PathNodeData) => {\n            if (data.y1 - data.y0 > HIDE_PATH_CARD_HEIGHT) {\n                return\n            }\n            setNodeCards(\n                nodes.map((node: PathNodeData) =>\n                    node.index === data.index\n                        ? { ...node, visible: true }\n                        : { ...node, visible: node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT }\n                )\n            )\n        })\n        .append('title')\n        .text((d: PathNodeData) => `${stripHTTP(d.name)}\\n${d.value.toLocaleString()}`)\n}\n\nconst appendDropoffs = (svg: D3Selector): void => {\n    const dropOffGradient = svg\n        .append('defs')\n        .append('linearGradient')\n        .attr('id', 'dropoff-gradient')\n        .attr('gradientTransform', 'rotate(90)')\n\n    dropOffGradient.append('stop').attr('offset', '0%').attr('stop-color', 'rgba(220,53,69,0.7)')\n\n    dropOffGradient.append('stop').attr('offset', '100%').attr('stop-color', 'var(--bg-light)')\n}\n\nconst appendPathLinks = (\n    svg: any,\n    links: PathNodeData[],\n    nodes: PathNodeData[],\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void => {\n    const link = svg\n        .append('g')\n        .attr('fill', 'none')\n        .selectAll('g')\n        .data(links)\n        .join('g')\n        .attr('stroke', 'var(--primary)')\n        .attr('opacity', 0.35)\n\n    link.append('path')\n        .attr('d', Sankey.sankeyLinkHorizontal())\n        .attr('id', (d: PathNodeData) => `path-${d.index}`)\n        .attr('stroke-width', (d: PathNodeData) => {\n            return Math.max(1, d.width)\n        })\n        .on('mouseover', (_event: MouseEvent, data: PathNodeData) => {\n            svg.select(`#path-${data.index}`).attr('stroke', 'blue')\n            if (data?.source?.targetLinks.length === 0) {\n                return\n            }\n            const nodesToColor = [data.source]\n            const pathCardsToShow: number[] = []\n            while (nodesToColor.length > 0) {\n                const _node = nodesToColor.pop()\n                _node?.targetLinks.forEach((_link: PathTargetLink) => {\n                    svg.select(`#path-${_link.index}`).attr('stroke', 'blue')\n                    nodesToColor.push(_link.source)\n                    pathCardsToShow.push(_link.source.index)\n                })\n            }\n            const pathCards = [data.target]\n            pathCardsToShow.push(data.target.index, data.source.index)\n            while (pathCards.length > 0) {\n                const node = pathCards.pop()\n                node?.sourceLinks.forEach((l: PathTargetLink) => {\n                    pathCards.push(l.target)\n                    pathCardsToShow.push(l.target.index)\n                })\n            }\n            setNodeCards(\n                nodes.map((node: PathNodeData) => ({\n                    ...node,\n                    ...{\n                        visible: pathCardsToShow.includes(node.index)\n                            ? true\n                            : node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT,\n                    },\n                }))\n            )\n        })\n        .on('mouseleave', () => {\n            svg.selectAll('path').attr('stroke', 'var(--primary)')\n        })\n\n    link.append('g')\n        .append('path')\n        .attr('d', (data: PathNodeData) => {\n            if (data.source.layer === 0) {\n                return\n            }\n            const _height =\n                data.source.y1 - data.source.y0 - data.source.sourceLinks.reduce((prev, curr) => prev + curr.width, 0)\n            return roundedRect(0, 0, 30, _height, Math.min(25, _height), false, true, false, false)\n        })\n        .attr('fill', 'url(#dropoff-gradient)')\n        .attr('stroke-width', 0)\n        .attr('transform', (data: PathNodeData) => {\n            return (\n                'translate(' +\n                Math.round(data.source.x1) +\n                ',' +\n                Math.round(data.source.y0 + data.source.sourceLinks.reduce((prev, curr) => prev + curr.width, 0)) +\n                ')'\n            )\n        })\n}\n\nconst addChartAxisLines = (svg: D3Selector, height: number, nodes: PathNodeData[], maxLayer: number): void => {\n    if (maxLayer > 5) {\n        const arr = [...Array(maxLayer)]\n        const minWidthApart = nodes[1].x0 - nodes[0].x0\n        arr.forEach((_, i) => {\n            svg.append('line')\n                .style('stroke', 'var(--border)')\n                .attr('stroke-width', 2)\n                .attr('x1', minWidthApart * (i + 1) - 20)\n                .attr('y1', 0)\n                .attr('x2', minWidthApart * (i + 1) - 20)\n                .attr('y2', height)\n        })\n    }\n}\n\nexport function renderPaths(\n    canvasRef: RefObject<HTMLDivElement>,\n    canvasWidth: number,\n    canvasHeight: number,\n    paths: { links: PathNode[]; nodes: any[] },\n    pathsFilter: PathsFilter,\n    funnelPathsFilter: FunnelPathsFilter,\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void {\n    if (!paths || paths.nodes.length === 0) {\n        return\n    }\n\n    const maxLayer = paths.links.reduce((prev, curr) => {\n        // @ts-expect-error - sometimes target is an object instead of string\n        const currNum = curr.target.name || curr.target\n        return Math.max(prev, Number(currNum.match(/[^_]*/)))\n    }, 0)\n\n    const minWidth = canvasWidth > FALLBACK_CANVAS_WIDTH || maxLayer < 3 ? canvasWidth : FALLBACK_CANVAS_WIDTH\n\n    const width = maxLayer > 5 && canvasWidth ? (minWidth / 5) * maxLayer : minWidth\n    const height = canvasHeight\n\n    const svg = createCanvas(canvasRef, width, height)\n    const sankey = createSankey(width, height)\n    const { nodes, links } = sankey({\n        nodes: paths.nodes.map((d) => ({ ...d })),\n        links: paths.links.map((d) => ({ ...d })),\n    })\n\n    setNodeCards(nodes.map((node: PathNodeData) => ({ ...node, visible: node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT })))\n\n    appendPathNodes(svg, nodes, pathsFilter, funnelPathsFilter, setNodeCards)\n    appendDropoffs(svg)\n    appendPathLinks(svg, links, nodes, setNodeCards)\n    addChartAxisLines(svg, height, nodes, maxLayer)\n}\n","export const createDefaultPluginSource = (name: string): Record<string, any> => ({\n    'index.ts': `// Learn more about plugins at: https://posthog.com/docs/apps/build\n\n// Processes each event, optionally transforming it\nexport function processEvent(event, { config }) {\n    // Some events (such as $identify) don't have properties\n    if (event.properties) {\n        event.properties['hello'] = \\`Hello \\${config.name}\\`\n    }\n    // Return the event to be ingested, or return null to discard\n    return event\n}\n\n// Runs when the plugin is loaded, allows for preparing it as needed\nexport function setupPlugin (meta) {\n    console.log(\\`The date is \\${new Date().toDateString()}\\`)\n}`,\n    'frontend.tsx': `import React from \"react\"\n\nexport const scene = {\n    title: \"My Stuff\",\n    component: function MyStuff({ config }) {\n        return (\n            <div>\n                <h1>My Favourite Links</h1>\n                <ul>\n                    <li>\n                        <a href=\"https://news.ycombinator.com\">The NEWS</a>\n                    </li>\n                </ul>\n                <h1>My Favourite Cow</h1>\n                <img src=\"https://media.giphy.com/media/RYKFEEjtYpxL2/giphy.gif\" />\n            </div>\n        )\n    },\n}\n`,\n    'plugin.json': JSON.stringify(\n        {\n            name: name ?? 'My Plugin',\n            config: [\n                {\n                    markdown: 'Specify your config here',\n                },\n                {\n                    key: 'name',\n                    name: 'Person to greet',\n                    type: 'string',\n                    hint: 'Used to personalise the property `hello`',\n                    default: 'world',\n                    required: false,\n                },\n            ],\n        },\n        null,\n        4\n    ),\n    'site.ts': \"export function inject({ config, posthog }) {\\n    console.log('Hello from PostHog-JS')\\n}\\n\",\n})\n","import {\n    addedNodeMutation,\n    customEvent,\n    EventType,\n    fullSnapshotEvent,\n    incrementalSnapshotEvent,\n    IncrementalSource,\n    metaEvent,\n    mutationData,\n    removedNodeMutation,\n} from '@rrweb/types'\nimport { captureMessage } from '@sentry/react'\nimport { isObject } from 'lib/utils'\nimport { PLACEHOLDER_SVG_DATA_IMAGE_URL } from 'scenes/session-recordings/player/rrweb'\n\nimport {\n    attributes,\n    documentNode,\n    elementNode,\n    fullSnapshotEvent as MobileFullSnapshotEvent,\n    keyboardEvent,\n    metaEvent as MobileMetaEvent,\n    MobileIncrementalSnapshotEvent,\n    MobileNodeMutation,\n    MobileNodeType,\n    NodeType,\n    serializedNodeWithId,\n    textNode,\n    wireframe,\n    wireframeButton,\n    wireframeCheckBox,\n    wireframeDiv,\n    wireframeImage,\n    wireframeInputComponent,\n    wireframeNavigationBar,\n    wireframePlaceholder,\n    wireframeProgress,\n    wireframeRadio,\n    wireframeRadioGroup,\n    wireframeRectangle,\n    wireframeSelect,\n    wireframeStatusBar,\n    wireframeText,\n    wireframeToggle,\n} from '../mobile.types'\nimport { makeNavigationBar, makeOpenKeyboardPlaceholder, makeStatusBar } from './screen-chrome'\nimport { ConversionContext, ConversionResult } from './types'\nimport {\n    asStyleString,\n    makeBodyStyles,\n    makeColorStyles,\n    makeDeterminateProgressStyles,\n    makeHTMLStyles,\n    makeIndeterminateProgressStyles,\n    makeMinimalStyles,\n    makePositionStyles,\n    makeStylesString,\n} from './wireframeStyle'\n\nexport const BACKGROUND = '#f3f4ef'\nconst FOREGROUND = '#35373e'\n\n/**\n * generates a sequence of ids\n * from 100 to 9,999,999\n * the transformer reserves ids in the range 0 to 9,999,999\n * we reserve a range of ids because we need nodes to have stable ids across snapshots\n * in order for incremental snapshots to work\n * some mobile elements have to be wrapped in other elements in order to be styled correctly\n * which means the web version of a mobile replay will use ids that don't exist in the mobile replay,\n * and we need to ensure they don't clash\n * -----\n * id is typed as a number in rrweb\n * and there's a few places in their code where rrweb uses a check for `id === -1` to bail out of processing\n * so, it's safest to assume that id is expected to be a positive integer\n */\nfunction* ids(): Generator<number> {\n    let i = 100\n    while (i < 9999999) {\n        yield i++\n    }\n}\n\nlet globalIdSequence = ids()\n\n// there are some fixed ids that we need to use for fixed elements or artificial mutations\nconst DOCUMENT_ID = 1\nconst HTML_DOC_TYPE_ID = 2\nconst HTML_ELEMENT_ID = 3\nconst HEAD_ID = 4\nconst BODY_ID = 5\n// the nav bar should always be the last item in the body so that it is at the top of the stack\nconst NAVIGATION_BAR_PARENT_ID = 7\nexport const NAVIGATION_BAR_ID = 8\n// the keyboard so that it is still before the nav bar\nconst KEYBOARD_PARENT_ID = 9\nexport const KEYBOARD_ID = 10\nexport const STATUS_BAR_PARENT_ID = 11\nexport const STATUS_BAR_ID = 12\n\nfunction isKeyboardEvent(x: unknown): x is keyboardEvent {\n    return isObject(x) && 'data' in x && isObject(x.data) && 'tag' in x.data && x.data.tag === 'keyboard'\n}\n\nexport function _isPositiveInteger(id: unknown): id is number {\n    return typeof id === 'number' && id > 0 && id % 1 === 0\n}\n\nfunction _isNullish(x: unknown): x is null | undefined {\n    return x === null || x === undefined\n}\n\nfunction isRemovedNodeMutation(x: addedNodeMutation | removedNodeMutation): x is removedNodeMutation {\n    return isObject(x) && 'id' in x\n}\n\nexport const makeCustomEvent = (\n    mobileCustomEvent: (customEvent | keyboardEvent) & {\n        timestamp: number\n        delay?: number\n    }\n): (customEvent | incrementalSnapshotEvent) & {\n    timestamp: number\n    delay?: number\n} => {\n    if (isKeyboardEvent(mobileCustomEvent)) {\n        // keyboard events are handled as incremental snapshots to add or remove a keyboard from the DOM\n        // TODO eventually we can pass something to makeIncrementalEvent here\n        const adds: addedNodeMutation[] = []\n        const removes = []\n        if (mobileCustomEvent.data.payload.open) {\n            const keyboardPlaceHolder = makeOpenKeyboardPlaceholder(mobileCustomEvent, {\n                timestamp: mobileCustomEvent.timestamp,\n                idSequence: globalIdSequence,\n            })\n            if (keyboardPlaceHolder) {\n                adds.push({\n                    parentId: KEYBOARD_PARENT_ID,\n                    nextId: null,\n                    node: keyboardPlaceHolder.result,\n                })\n                // mutations seem not to want a tree of nodes to add\n                // so even though `keyboardPlaceholder` is a tree with content\n                // we have to add the text content as well\n                adds.push({\n                    parentId: keyboardPlaceHolder.result.id,\n                    nextId: null,\n                    node: {\n                        type: NodeType.Text,\n                        id: globalIdSequence.next().value,\n                        textContent: 'keyboard',\n                    },\n                })\n            } else {\n                captureMessage('Failed to create keyboard placeholder', { extra: { mobileCustomEvent } })\n            }\n        } else {\n            removes.push({\n                parentId: KEYBOARD_PARENT_ID,\n                id: KEYBOARD_ID,\n            })\n        }\n        const mutation: mutationData = { adds, attributes: [], removes, source: IncrementalSource.Mutation, texts: [] }\n        return {\n            type: EventType.IncrementalSnapshot,\n            data: mutation,\n            timestamp: mobileCustomEvent.timestamp,\n        }\n    } else {\n        return mobileCustomEvent\n    }\n}\n\nexport const makeMetaEvent = (\n    mobileMetaEvent: MobileMetaEvent & {\n        timestamp: number\n    }\n): metaEvent & {\n    timestamp: number\n    delay?: number\n} => ({\n    type: EventType.Meta,\n    data: {\n        href: mobileMetaEvent.data.href || '', // the replay doesn't use the href, so we safely ignore any absence\n        // mostly we need width and height in order to size the viewport\n        width: mobileMetaEvent.data.width,\n        height: mobileMetaEvent.data.height,\n    },\n    timestamp: mobileMetaEvent.timestamp,\n})\n\nexport function makeDivElement(\n    wireframe: wireframeDiv,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const _id = _isPositiveInteger(wireframe.id) ? wireframe.id : context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: asStyleString([makeStylesString(wireframe), 'overflow:hidden', 'white-space:nowrap']),\n                'data-rrweb-id': _id,\n            },\n            id: _id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction makeTextElement(\n    wireframe: wireframeText,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (wireframe.type !== 'text') {\n        console.error('Passed incorrect wireframe type to makeTextElement')\n        return null\n    }\n\n    // because we might have to style the text, we always wrap it in a div\n    // and apply styles to that\n    const id = context.idSequence.next().value\n\n    const childNodes = [...children]\n    if (!_isNullish(wireframe.text)) {\n        childNodes.unshift({\n            type: NodeType.Text,\n            textContent: wireframe.text,\n            // since the text node is wrapped, we assign it a synthetic id\n            id,\n        })\n    }\n\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: asStyleString([makeStylesString(wireframe), 'overflow:hidden', 'white-space:normal']),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes,\n        },\n        context,\n    }\n}\n\nfunction makeWebViewElement(\n    wireframe: wireframe,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const labelledWireframe: wireframePlaceholder = { ...wireframe } as wireframePlaceholder\n    if ('url' in wireframe) {\n        labelledWireframe.label = wireframe.url\n    }\n\n    return makePlaceholderElement(labelledWireframe, children, context)\n}\n\nexport function makePlaceholderElement(\n    wireframe: wireframe,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const txt = 'label' in wireframe && wireframe.label ? wireframe.label : wireframe.type || 'PLACEHOLDER'\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe, {\n                    verticalAlign: 'center',\n                    horizontalAlign: 'center',\n                    backgroundColor: wireframe.style?.backgroundColor || BACKGROUND,\n                    color: wireframe.style?.color || FOREGROUND,\n                    backgroundImage: PLACEHOLDER_SVG_DATA_IMAGE_URL,\n                    backgroundSize: 'auto',\n                    backgroundRepeat: 'unset',\n                    ...context.styleOverride,\n                }),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: [\n                {\n                    type: NodeType.Text,\n                    // since the text node is wrapped, we assign it a synthetic id\n                    id: context.idSequence.next().value,\n                    textContent: txt,\n                },\n                ...children,\n            ],\n        },\n        context,\n    }\n}\n\nexport function dataURIOrPNG(src: string): string {\n    // replace all new lines in src\n    src = src.replace(/\\r?\\n|\\r/g, '')\n    if (!src.startsWith('data:image/')) {\n        return 'data:image/png;base64,' + src\n    }\n    return src\n}\n\nfunction makeImageElement(\n    wireframe: wireframeImage,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (!wireframe.base64) {\n        return makePlaceholderElement(wireframe, children, context)\n    }\n    const src = dataURIOrPNG(wireframe.base64)\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'img',\n            attributes: {\n                src: src,\n                width: wireframe.width,\n                height: wireframe.height,\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction inputAttributes<T extends wireframeInputComponent>(wireframe: T): attributes {\n    const attributes = {\n        style: makeStylesString(wireframe),\n        type: wireframe.inputType,\n        ...(wireframe.disabled ? { disabled: wireframe.disabled } : {}),\n        'data-rrweb-id': wireframe.id,\n    }\n\n    switch (wireframe.inputType) {\n        case 'checkbox':\n            return {\n                ...attributes,\n                style: null, // checkboxes are styled by being combined with a label\n                ...(wireframe.checked ? { checked: wireframe.checked } : {}),\n            }\n        case 'toggle':\n            return {\n                ...attributes,\n                style: null, // toggle are styled by being combined with a label\n                ...(wireframe.checked ? { checked: wireframe.checked } : {}),\n            }\n        case 'radio':\n            return {\n                ...attributes,\n                style: null, // radio buttons are styled by being combined with a label\n                ...(wireframe.checked ? { checked: wireframe.checked } : {}),\n                // radio value defaults to the string \"on\" if not specified\n                // we're not really submitting the form, so it doesn't matter 🤞\n                // radio name is used to correctly uncheck values when one is checked\n                // mobile doesn't really have it, and we will be checking based on snapshots,\n                // so we can ignore it for now\n            }\n        case 'button':\n            return {\n                ...attributes,\n            }\n        case 'text_area':\n            return {\n                ...attributes,\n                value: wireframe.value || '',\n            }\n        case 'progress':\n            return {\n                ...attributes,\n                // indeterminate when omitted\n                value: wireframe.value || null,\n                // defaults to 1 when omitted\n                max: wireframe.max || null,\n                type: null, // progress has no type attribute\n            }\n        default:\n            return {\n                ...attributes,\n                value: wireframe.value || '',\n            }\n    }\n}\n\nfunction makeButtonElement(\n    wireframe: wireframeButton,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const buttonText: textNode | null = wireframe.value\n        ? {\n              type: NodeType.Text,\n              textContent: wireframe.value,\n          }\n        : null\n\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'button',\n            attributes: inputAttributes(wireframe),\n            id: wireframe.id,\n            childNodes: buttonText ? [{ ...buttonText, id: context.idSequence.next().value }, ...children] : children,\n        },\n        context,\n    }\n}\n\nfunction makeSelectOptionElement(\n    option: string,\n    selected: boolean,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> {\n    const optionId = context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'option',\n            attributes: {\n                ...(selected ? { selected: selected } : {}),\n                'data-rrweb-id': optionId,\n            },\n            id: optionId,\n            childNodes: [\n                {\n                    type: NodeType.Text,\n                    textContent: option,\n                    id: context.idSequence.next().value,\n                },\n            ],\n        },\n        context,\n    }\n}\n\nfunction makeSelectElement(\n    wireframe: wireframeSelect,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const selectOptions: serializedNodeWithId[] = []\n    if (wireframe.options) {\n        let optionContext = context\n        for (let i = 0; i < wireframe.options.length; i++) {\n            const option = wireframe.options[i]\n            const conversion = makeSelectOptionElement(option, wireframe.value === option, optionContext)\n            selectOptions.push(conversion.result)\n            optionContext = conversion.context\n        }\n    }\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'select',\n            attributes: inputAttributes(wireframe),\n            id: wireframe.id,\n            childNodes: [...selectOptions, ...children],\n        },\n        context,\n    }\n}\n\nfunction groupRadioButtons(children: serializedNodeWithId[], radioGroupName: string): serializedNodeWithId[] {\n    return children.map((child) => {\n        if (child.type === NodeType.Element && child.tagName === 'input' && child.attributes.type === 'radio') {\n            return {\n                ...child,\n                attributes: {\n                    ...child.attributes,\n                    name: radioGroupName,\n                    'data-rrweb-id': child.id,\n                },\n            }\n        }\n        return child\n    })\n}\n\nfunction makeRadioGroupElement(\n    wireframe: wireframeRadioGroup,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const radioGroupName = 'radio_group_' + wireframe.id\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: groupRadioButtons(children, radioGroupName),\n        },\n        context,\n    }\n}\n\nfunction makeStar(title: string, path: string, context: ConversionContext): serializedNodeWithId {\n    const svgId = context.idSequence.next().value\n    const titleId = context.idSequence.next().value\n    const pathId = context.idSequence.next().value\n    return {\n        type: NodeType.Element,\n        tagName: 'svg',\n        isSVG: true,\n        attributes: {\n            style: asStyleString(['height: 100%', 'overflow-clip-margin: content-box', 'overflow:hidden']),\n            viewBox: '0 0 24 24',\n            fill: 'currentColor',\n            'data-rrweb-id': svgId,\n        },\n        id: svgId,\n        childNodes: [\n            {\n                type: NodeType.Element,\n                tagName: 'title',\n                isSVG: true,\n                attributes: {\n                    'data-rrweb-id': titleId,\n                },\n                id: titleId,\n                childNodes: [\n                    {\n                        type: NodeType.Text,\n                        textContent: title,\n                        id: context.idSequence.next().value,\n                    },\n                ],\n            },\n            {\n                type: NodeType.Element,\n                tagName: 'path',\n                isSVG: true,\n                attributes: {\n                    d: path,\n                    'data-rrweb-id': pathId,\n                },\n                id: pathId,\n                childNodes: [],\n            },\n        ],\n    }\n}\n\nfunction filledStar(context: ConversionContext): serializedNodeWithId {\n    return makeStar(\n        'filled star',\n        'M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z',\n        context\n    )\n}\n\nfunction halfStar(context: ConversionContext): serializedNodeWithId {\n    return makeStar(\n        'half-filled star',\n        'M12,15.4V6.1L13.71,10.13L18.09,10.5L14.77,13.39L15.76,17.67M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z',\n        context\n    )\n}\n\nfunction emptyStar(context: ConversionContext): serializedNodeWithId {\n    return makeStar(\n        'empty star',\n        'M12,15.39L8.24,17.66L9.23,13.38L5.91,10.5L10.29,10.13L12,6.09L13.71,10.13L18.09,10.5L14.77,13.38L15.76,17.66M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z',\n        context\n    )\n}\n\nfunction makeRatingBar(\n    wireframe: wireframeProgress,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    // max is the number of stars... and value is the number of stars to fill\n\n    // deliberate double equals, because we want to allow null and undefined\n    if (wireframe.value == null || wireframe.max == null) {\n        return makePlaceholderElement(wireframe, children, context)\n    }\n\n    const numberOfFilledStars = Math.floor(wireframe.value)\n    const numberOfHalfStars = wireframe.value - numberOfFilledStars > 0 ? 1 : 0\n    const numberOfEmptyStars = wireframe.max - numberOfFilledStars - numberOfHalfStars\n\n    const filledStars = Array(numberOfFilledStars)\n        .fill(undefined)\n        .map(() => filledStar(context))\n    const halfStars = Array(numberOfHalfStars)\n        .fill(undefined)\n        .map(() => halfStar(context))\n    const emptyStars = Array(numberOfEmptyStars)\n        .fill(undefined)\n        .map(() => emptyStar(context))\n\n    const ratingBarId = context.idSequence.next().value\n    const ratingBar = {\n        type: NodeType.Element,\n        tagName: 'div',\n        id: ratingBarId,\n        attributes: {\n            style: asStyleString([\n                makeColorStyles(wireframe),\n                'position: relative',\n                'display: flex',\n                'flex-direction: row',\n                'padding: 2px 4px',\n            ]),\n            'data-rrweb-id': ratingBarId,\n        },\n        childNodes: [...filledStars, ...halfStars, ...emptyStars],\n    } as serializedNodeWithId\n\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: [ratingBar, ...children],\n        },\n        context,\n    }\n}\n\nfunction makeProgressElement(\n    wireframe: wireframeProgress,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (wireframe.style?.bar === 'circular') {\n        // value needs to be expressed as a number between 0 and 100\n        const max = wireframe.max || 1\n        let value = wireframe.value || null\n        if (_isPositiveInteger(value) && value <= max) {\n            value = (value / max) * 100\n        } else {\n            value = null\n        }\n\n        const styleOverride = {\n            color: wireframe.style?.color || FOREGROUND,\n            backgroundColor: wireframe.style?.backgroundColor || BACKGROUND,\n        }\n\n        // if not _isPositiveInteger(value) then we render a spinner,\n        // so we need to add a style element with the spin keyframe\n        const stylingChildren: serializedNodeWithId[] = _isPositiveInteger(value)\n            ? []\n            : [\n                  {\n                      type: NodeType.Element,\n                      tagName: 'style',\n                      attributes: {\n                          type: 'text/css',\n                      },\n                      id: context.idSequence.next().value,\n                      childNodes: [\n                          {\n                              type: NodeType.Text,\n                              textContent: `@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`,\n                              id: context.idSequence.next().value,\n                          },\n                      ],\n                  },\n              ]\n\n        const wrappingDivId = context.idSequence.next().value\n        return {\n            result: {\n                type: NodeType.Element,\n                tagName: 'div',\n                attributes: {\n                    style: makeMinimalStyles(wireframe),\n                    'data-rrweb-id': wireframe.id,\n                },\n                id: wireframe.id,\n                childNodes: [\n                    {\n                        type: NodeType.Element,\n                        tagName: 'div',\n                        attributes: {\n                            // with no provided value we render a spinner\n                            style: _isPositiveInteger(value)\n                                ? makeDeterminateProgressStyles(wireframe, styleOverride)\n                                : makeIndeterminateProgressStyles(wireframe, styleOverride),\n                            'data-rrweb-id': wrappingDivId,\n                        },\n                        id: wrappingDivId,\n                        childNodes: stylingChildren,\n                    },\n                    ...children,\n                ],\n            },\n            context,\n        }\n    } else if (wireframe.style?.bar === 'rating') {\n        return makeRatingBar(wireframe, children, context)\n    } else {\n        return {\n            result: {\n                type: NodeType.Element,\n                tagName: 'progress',\n                attributes: inputAttributes(wireframe),\n                id: wireframe.id,\n                childNodes: children,\n            },\n            context,\n        }\n    }\n}\n\nfunction makeToggleParts(wireframe: wireframeToggle, context: ConversionContext): serializedNodeWithId[] {\n    const togglePosition = wireframe.checked ? 'right' : 'left'\n    const defaultColor = wireframe.checked ? '#1d4aff' : BACKGROUND\n    const sliderPartId = context.idSequence.next().value\n    const handlePartId = context.idSequence.next().value\n    return [\n        {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                'data-toggle-part': 'slider',\n                style: asStyleString([\n                    'position:absolute',\n                    'top:33%',\n                    'left:5%',\n                    'display:inline-block',\n                    'width:75%',\n                    'height:33%',\n                    'opacity: 0.2',\n                    'border-radius:7.5%',\n                    `background-color:${wireframe.style?.color || defaultColor}`,\n                ]),\n                'data-rrweb-id': sliderPartId,\n            },\n            id: sliderPartId,\n            childNodes: [],\n        },\n        {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                'data-toggle-part': 'handle',\n                style: asStyleString([\n                    'position:absolute',\n                    'top:1.5%',\n                    `${togglePosition}:5%`,\n                    'display:flex',\n                    'align-items:center',\n                    'justify-content:center',\n                    'width:40%',\n                    'height:75%',\n                    'cursor:inherit',\n                    'border-radius:50%',\n                    `background-color:${wireframe.style?.color || defaultColor}`,\n                    `border:2px solid ${wireframe.style?.borderColor || wireframe.style?.color || defaultColor}`,\n                ]),\n                'data-rrweb-id': handlePartId,\n            },\n            id: handlePartId,\n            childNodes: [],\n        },\n    ]\n}\n\nfunction makeToggleElement(\n    wireframe: wireframeToggle,\n    context: ConversionContext\n): ConversionResult<\n    elementNode & {\n        id: number\n    }\n> | null {\n    const isLabelled = 'label' in wireframe\n    const wrappingDivId = context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                // if labelled take up available space, otherwise use provided positioning\n                style: isLabelled ? asStyleString(['height:100%', 'flex:1']) : makePositionStyles(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: [\n                {\n                    type: NodeType.Element,\n                    tagName: 'div',\n                    attributes: {\n                        // relative position, fills parent\n                        style: asStyleString(['position:relative', 'width:100%', 'height:100%']),\n                        'data-rrweb-id': wrappingDivId,\n                    },\n                    id: wrappingDivId,\n                    childNodes: makeToggleParts(wireframe, context),\n                },\n            ],\n        },\n        context,\n    }\n}\n\nfunction makeLabelledInput(\n    wireframe: wireframeCheckBox | wireframeRadio | wireframeToggle,\n    theInputElement: serializedNodeWithId,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> {\n    const theLabel: serializedNodeWithId = {\n        type: NodeType.Text,\n        textContent: wireframe.label || '',\n        id: context.idSequence.next().value,\n    }\n\n    const orderedChildren = wireframe.inputType === 'toggle' ? [theLabel, theInputElement] : [theInputElement, theLabel]\n\n    const labelId = context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'label',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': labelId,\n            },\n            id: labelId,\n            childNodes: orderedChildren,\n        },\n        context,\n    }\n}\n\nfunction makeInputElement(\n    wireframe: wireframeInputComponent,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (!wireframe.inputType) {\n        return null\n    }\n\n    if (wireframe.inputType === 'button') {\n        return makeButtonElement(wireframe, children, context)\n    }\n\n    if (wireframe.inputType === 'select') {\n        return makeSelectElement(wireframe, children, context)\n    }\n\n    if (wireframe.inputType === 'progress') {\n        return makeProgressElement(wireframe, children, context)\n    }\n\n    const theInputElement: ConversionResult<serializedNodeWithId> | null =\n        wireframe.inputType === 'toggle'\n            ? makeToggleElement(wireframe, context)\n            : {\n                  result: {\n                      type: NodeType.Element,\n                      tagName: 'input',\n                      attributes: inputAttributes(wireframe),\n                      id: wireframe.id,\n                      childNodes: children,\n                  },\n                  context,\n              }\n\n    if (!theInputElement) {\n        return null\n    }\n\n    if ('label' in wireframe) {\n        return makeLabelledInput(wireframe, theInputElement.result, theInputElement.context)\n    } else {\n        // when labelled no styles are needed, when un-labelled as here - we add the styling in.\n        ;(theInputElement.result as elementNode).attributes.style = makeStylesString(wireframe)\n        return theInputElement\n    }\n}\n\nfunction makeRectangleElement(\n    wireframe: wireframeRectangle,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction chooseConverter<T extends wireframe>(\n    wireframe: T\n): (\n    wireframe: T,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n) => ConversionResult<serializedNodeWithId> | null {\n    // in theory type is always present\n    // but since this is coming over the wire we can't really be sure,\n    // and so we default to div\n    const converterType: MobileNodeType = wireframe.type || 'div'\n    const converterMapping: Record<\n        MobileNodeType,\n        (wireframe: T, children: serializedNodeWithId[]) => ConversionResult<serializedNodeWithId> | null\n    > = {\n        // KLUDGE: TS can't tell that the wireframe type of each function is safe based on the converter type\n        text: makeTextElement as any,\n        image: makeImageElement as any,\n        rectangle: makeRectangleElement as any,\n        div: makeDivElement as any,\n        input: makeInputElement as any,\n        radio_group: makeRadioGroupElement as any,\n        web_view: makeWebViewElement as any,\n        placeholder: makePlaceholderElement as any,\n        status_bar: makeStatusBar as any,\n        navigation_bar: makeNavigationBar as any,\n    }\n    return converterMapping[converterType]\n}\n\nfunction convertWireframe(\n    wireframe: wireframe,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const children = convertWireframesFor(wireframe.childWireframes, context)\n    const converted = chooseConverter(wireframe)?.(wireframe, children.result, children.context)\n    return converted || null\n}\n\nfunction convertWireframesFor(\n    wireframes: wireframe[] | undefined,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId[]> {\n    if (!wireframes) {\n        return { result: [], context }\n    }\n\n    const result: serializedNodeWithId[] = []\n    for (const wireframe of wireframes) {\n        const converted = convertWireframe(wireframe, context)\n        if (converted) {\n            result.push(converted.result)\n            context = converted.context\n        }\n    }\n    return { result, context }\n}\n\nfunction isMobileIncrementalSnapshotEvent(x: unknown): x is MobileIncrementalSnapshotEvent {\n    const isIncrementalSnapshot = isObject(x) && 'type' in x && x.type === EventType.IncrementalSnapshot\n    if (!isIncrementalSnapshot) {\n        return false\n    }\n    const hasData = isObject(x) && 'data' in x\n    const data = hasData ? x.data : null\n\n    const hasMutationSource = isObject(data) && 'source' in data && data.source === IncrementalSource.Mutation\n\n    const adds = isObject(data) && 'adds' in data && Array.isArray(data.adds) ? data.adds : null\n    const updates = isObject(data) && 'updates' in data && Array.isArray(data.updates) ? data.updates : null\n\n    const hasUpdatedWireframe = !!updates && updates.length > 0 && isObject(updates[0]) && 'wireframe' in updates[0]\n    const hasAddedWireframe = !!adds && adds.length > 0 && isObject(adds[0]) && 'wireframe' in adds[0]\n\n    return hasMutationSource && (hasAddedWireframe || hasUpdatedWireframe)\n}\n\nfunction makeIncrementalAdd(add: MobileNodeMutation, context: ConversionContext): addedNodeMutation[] | null {\n    const converted = convertWireframe(add.wireframe, context)\n\n    if (!converted) {\n        return null\n    }\n\n    const addition: addedNodeMutation = {\n        parentId: add.parentId,\n        nextId: null,\n        node: converted.result,\n    }\n    const adds: addedNodeMutation[] = []\n    if (addition) {\n        const flattened = flattenMutationAdds(addition)\n        flattened.forEach((x) => adds.push(x))\n        return adds\n    } else {\n        return null\n    }\n}\n\n/**\n * When processing an update we remove the entire item, and then add it back in.\n */\nfunction makeIncrementalRemoveForUpdate(update: MobileNodeMutation): removedNodeMutation {\n    return {\n        parentId: update.parentId,\n        id: update.wireframe.id,\n    }\n}\n\nfunction isNode(x: unknown): x is serializedNodeWithId {\n    // KLUDGE: really we should check that x.type is valid, but we're safe enough already\n    return isObject(x) && 'type' in x && 'id' in x\n}\n\nfunction isNodeWithChildren(x: unknown): x is elementNode | documentNode {\n    return isNode(x) && 'childNodes' in x && Array.isArray(x.childNodes)\n}\n\n/**\n * when creating incremental adds we have to flatten the node tree structure\n * there's no point, then keeping those child nodes in place\n */\nfunction cloneWithoutChildren(converted: addedNodeMutation): addedNodeMutation {\n    const cloned = { ...converted }\n    const clonedNode: serializedNodeWithId = { ...converted.node }\n    if (isNodeWithChildren(clonedNode)) {\n        clonedNode.childNodes = []\n    }\n    cloned.node = clonedNode\n    return cloned\n}\n\nfunction flattenMutationAdds(converted: addedNodeMutation): addedNodeMutation[] {\n    const flattened: addedNodeMutation[] = []\n\n    flattened.push(cloneWithoutChildren(converted))\n\n    const node: unknown = converted.node\n    const newParentId = converted.node.id\n    if (isNodeWithChildren(node)) {\n        node.childNodes.forEach((child) => {\n            flattened.push(\n                cloneWithoutChildren({\n                    parentId: newParentId,\n                    nextId: null,\n                    node: child,\n                })\n            )\n            if (isNodeWithChildren(child)) {\n                flattened.push(...flattenMutationAdds({ parentId: newParentId, nextId: null, node: child }))\n            }\n        })\n    }\n    return flattened\n}\n\n/**\n * each update wireframe carries the entire tree because we don't want to diff on the client\n * that means that we might create multiple mutations for the same node\n * we only want to add it once, so we dedupe the mutations\n * the app guarantees that for a given ID that is present more than once in a single snapshot\n * every instance of that ID is identical\n * it might change in the next snapshot but for a single incremental snapshot there is one\n * and only one version of any given ID\n */\nfunction dedupeMutations<T extends addedNodeMutation | removedNodeMutation>(mutations: T[]): T[] {\n    // KLUDGE: it's slightly yucky to stringify everything but since synthetic nodes\n    // introduce a new id, we can't just compare the id\n    const seen = new Set<string>()\n\n    // in case later mutations are the ones we want to keep, we reverse the array\n    // this does help with the deduping, so, it's likely that the view for a single ID\n    // is not consistent over a snapshot, but it's cheap to reverse so :YOLO:\n    return mutations\n        .reverse()\n        .filter((mutation: addedNodeMutation | removedNodeMutation) => {\n            let toCompare: string\n            if (isRemovedNodeMutation(mutation)) {\n                toCompare = JSON.stringify(mutation)\n            } else {\n                // if this is a synthetic addition, then we need to ignore the id,\n                // since duplicates won't have duplicate ids\n                toCompare = JSON.stringify({\n                    ...mutation.node,\n                    id: 0,\n                })\n            }\n\n            if (seen.has(toCompare)) {\n                return false\n            } else {\n                seen.add(toCompare)\n                return true\n            }\n        })\n        .reverse()\n}\n\n/**\n * We want to ensure that any events don't use id = 0.\n * They must always represent a valid ID from the dom, so we swap in the body id when the id = 0.\n *\n * For \"removes\", we don't need to do anything, the id of the element to be removed remains valid. We won't try and remove other elements that we added during transformation in order to show that element.\n *\n * \"adds\" are converted from wireframes to nodes and converted to `incrementalSnapshotEvent.adds`\n *\n * \"updates\" are converted to a remove and an add.\n *\n */\nexport const makeIncrementalEvent = (\n    mobileEvent: (MobileIncrementalSnapshotEvent | incrementalSnapshotEvent) & {\n        timestamp: number\n        delay?: number\n    }\n): incrementalSnapshotEvent & {\n    timestamp: number\n    delay?: number\n} => {\n    const converted = mobileEvent as unknown as incrementalSnapshotEvent & {\n        timestamp: number\n        delay?: number\n    }\n    if ('id' in converted.data && converted.data.id === 0) {\n        converted.data.id = BODY_ID\n    }\n\n    if (isMobileIncrementalSnapshotEvent(mobileEvent)) {\n        const adds: addedNodeMutation[] = []\n        const removes: removedNodeMutation[] = mobileEvent.data.removes || []\n        if ('adds' in mobileEvent.data && Array.isArray(mobileEvent.data.adds)) {\n            const addsContext = {\n                timestamp: mobileEvent.timestamp,\n                idSequence: globalIdSequence,\n            }\n\n            mobileEvent.data.adds.forEach((add) => {\n                makeIncrementalAdd(add, addsContext)?.forEach((x) => adds.push(x))\n            })\n        }\n        if ('updates' in mobileEvent.data && Array.isArray(mobileEvent.data.updates)) {\n            const updatesContext = {\n                timestamp: mobileEvent.timestamp,\n                idSequence: globalIdSequence,\n            }\n            const updateAdditions: addedNodeMutation[] = []\n            mobileEvent.data.updates.forEach((update) => {\n                const removal = makeIncrementalRemoveForUpdate(update)\n                if (removal) {\n                    removes.push(removal)\n                }\n                makeIncrementalAdd(update, updatesContext)?.forEach((x) => updateAdditions.push(x))\n            })\n            dedupeMutations(updateAdditions).forEach((x) => adds.push(x))\n        }\n\n        converted.data = {\n            source: IncrementalSource.Mutation,\n            attributes: [],\n            texts: [],\n            adds: dedupeMutations(adds),\n            // TODO: this assumes that removes are processed before adds 🤞\n            removes: dedupeMutations(removes),\n        }\n    }\n\n    return converted\n}\n\nfunction makeKeyboardParent(): serializedNodeWithId {\n    return {\n        type: NodeType.Element,\n        tagName: 'div',\n        attributes: {\n            'data-render-reason': 'a fixed placeholder to contain the keyboard in the correct stacking position',\n            'data-rrweb-id': KEYBOARD_PARENT_ID,\n        },\n        id: KEYBOARD_PARENT_ID,\n        childNodes: [],\n    }\n}\n\nfunction makeStatusBarNode(\n    statusBar: wireframeStatusBar | undefined,\n    context: ConversionContext\n): serializedNodeWithId {\n    const childNodes = statusBar ? convertWireframesFor([statusBar], context).result : []\n    return {\n        type: NodeType.Element,\n        tagName: 'div',\n        attributes: {\n            'data-rrweb-id': STATUS_BAR_PARENT_ID,\n        },\n        id: STATUS_BAR_PARENT_ID,\n        childNodes,\n    }\n}\n\nfunction makeNavBarNode(\n    navigationBar: wireframeNavigationBar | undefined,\n    context: ConversionContext\n): serializedNodeWithId {\n    const childNodes = navigationBar ? convertWireframesFor([navigationBar], context).result : []\n    return {\n        type: NodeType.Element,\n        tagName: 'div',\n        attributes: {\n            'data-rrweb-id': NAVIGATION_BAR_PARENT_ID,\n        },\n        id: NAVIGATION_BAR_PARENT_ID,\n        childNodes,\n    }\n}\n\nfunction stripBarsFromWireframe(wireframe: wireframe): {\n    wireframe: wireframe | undefined\n    statusBar: wireframeStatusBar | undefined\n    navBar: wireframeNavigationBar | undefined\n} {\n    if (wireframe.type === 'status_bar') {\n        return { wireframe: undefined, statusBar: wireframe, navBar: undefined }\n    } else if (wireframe.type === 'navigation_bar') {\n        return { wireframe: undefined, statusBar: undefined, navBar: wireframe }\n    } else {\n        let statusBar: wireframeStatusBar | undefined\n        let navBar: wireframeNavigationBar | undefined\n        const wireframeToReturn: wireframe | undefined = { ...wireframe }\n        wireframeToReturn.childWireframes = []\n        for (const child of wireframe.childWireframes || []) {\n            const {\n                wireframe: childWireframe,\n                statusBar: childStatusBar,\n                navBar: childNavBar,\n            } = stripBarsFromWireframe(child)\n            statusBar = statusBar || childStatusBar\n            navBar = navBar || childNavBar\n            if (childWireframe) {\n                wireframeToReturn.childWireframes.push(childWireframe)\n            }\n        }\n        return { wireframe: wireframeToReturn, statusBar, navBar }\n    }\n}\n\n/**\n * We want to be able to place the status bar and navigation bar in the correct stacking order.\n * So, we lift them out of the tree, and return them separately.\n */\nexport function stripBarsFromWireframes(wireframes: wireframe[]): {\n    statusBar: wireframeStatusBar | undefined\n    navigationBar: wireframeNavigationBar | undefined\n    appNodes: wireframe[]\n} {\n    let statusBar: wireframeStatusBar | undefined\n    let navigationBar: wireframeNavigationBar | undefined\n    const copiedNodes: wireframe[] = []\n\n    wireframes.forEach((w) => {\n        const matches = stripBarsFromWireframe(w)\n        if (matches.statusBar) {\n            statusBar = matches.statusBar\n        }\n        if (matches.navBar) {\n            navigationBar = matches.navBar\n        }\n        if (matches.wireframe) {\n            copiedNodes.push(matches.wireframe)\n        }\n    })\n    return { statusBar, navigationBar, appNodes: copiedNodes }\n}\n\nexport const makeFullEvent = (\n    mobileEvent: MobileFullSnapshotEvent & {\n        timestamp: number\n        delay?: number\n    }\n): fullSnapshotEvent & {\n    timestamp: number\n    delay?: number\n} => {\n    // we can restart the id sequence on each full snapshot\n    globalIdSequence = ids()\n\n    if (!('wireframes' in mobileEvent.data)) {\n        return mobileEvent as unknown as fullSnapshotEvent & {\n            timestamp: number\n            delay?: number\n        }\n    }\n\n    const conversionContext = {\n        timestamp: mobileEvent.timestamp,\n        idSequence: globalIdSequence,\n    }\n\n    const { statusBar, navigationBar, appNodes } = stripBarsFromWireframes(mobileEvent.data.wireframes)\n\n    const nodeGroups = {\n        appNodes: convertWireframesFor(appNodes, conversionContext).result || [],\n        statusBarNode: makeStatusBarNode(statusBar, conversionContext),\n        navBarNode: makeNavBarNode(navigationBar, conversionContext),\n    }\n\n    return {\n        type: EventType.FullSnapshot,\n        timestamp: mobileEvent.timestamp,\n        data: {\n            node: {\n                type: NodeType.Document,\n                childNodes: [\n                    {\n                        type: NodeType.DocumentType,\n                        name: 'html',\n                        publicId: '',\n                        systemId: '',\n                        id: HTML_DOC_TYPE_ID,\n                    },\n                    {\n                        type: NodeType.Element,\n                        tagName: 'html',\n                        attributes: { style: makeHTMLStyles(), 'data-rrweb-id': HTML_ELEMENT_ID },\n                        id: HTML_ELEMENT_ID,\n                        childNodes: [\n                            {\n                                type: NodeType.Element,\n                                tagName: 'head',\n                                attributes: { 'data-rrweb-id': HEAD_ID },\n                                id: HEAD_ID,\n                                childNodes: [makeCSSReset(conversionContext)],\n                            },\n                            {\n                                type: NodeType.Element,\n                                tagName: 'body',\n                                attributes: { style: makeBodyStyles(), 'data-rrweb-id': BODY_ID },\n                                id: BODY_ID,\n                                childNodes: [\n                                    // in the order they should stack if they ever clash\n                                    // lower is higher in the stacking context\n                                    ...nodeGroups.appNodes,\n                                    makeKeyboardParent(),\n                                    nodeGroups.navBarNode,\n                                    nodeGroups.statusBarNode,\n                                ],\n                            },\n                        ],\n                    },\n                ],\n                id: DOCUMENT_ID,\n            },\n            initialOffset: {\n                top: 0,\n                left: 0,\n            },\n        },\n    }\n}\n\nfunction makeCSSReset(context: ConversionContext): serializedNodeWithId {\n    // we need to normalize CSS so browsers don't do unexpected things\n    return {\n        type: NodeType.Element,\n        tagName: 'style',\n        attributes: {\n            type: 'text/css',\n        },\n        id: context.idSequence.next().value,\n        childNodes: [\n            {\n                type: NodeType.Text,\n                textContent: `\n                    body {\n                      margin: unset;\n                    }\n                    input, button, select, textarea {\n                        font: inherit;\n                        margin: 0;\n                        padding: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        padding-block: 0 !important;\n                    }\n                    .input:focus {\n                        outline: none;\n                    }\n                    img {\n                      border-style: none;\n                    }\n                `,\n                id: context.idSequence.next().value,\n            },\n        ],\n    }\n}\n","import { actions, connect, kea, listeners, path, reducers } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\nimport { SessionRecordingPropertiesType, SessionRecordingType } from '~/types'\n\nimport type { sessionRecordingsListPropertiesLogicType } from './sessionRecordingsListPropertiesLogicType'\n\n// This logic is used to fetch properties for a list of recordings\n// It is used in a global way as the cached values can be re-used\nexport const sessionRecordingsListPropertiesLogic = kea<sessionRecordingsListPropertiesLogicType>([\n    path(() => ['scenes', 'session-recordings', 'playlist', 'sessionRecordingsListPropertiesLogic']),\n    connect(() => ({\n        actions: [eventUsageLogic, ['reportRecordingsListPropertiesFetched']],\n    })),\n\n    actions({\n        loadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n        maybeLoadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n    }),\n\n    loaders(({ actions }) => ({\n        recordingProperties: [\n            [] as SessionRecordingPropertiesType[],\n            {\n                loadPropertiesForSessions: async ({ sessions }, breakpoint) => {\n                    await breakpoint(100)\n\n                    const startTime = performance.now()\n                    const sessionIds = sessions.map((x) => x.id)\n\n                    const oldestTimestamp = sessions.map((x) => x.start_time).sort()[0]\n                    const newestTimestamp = sessions.map((x) => x.end_time).sort()[sessions.length - 1]\n\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$session_id as session_id, any(properties) as properties\n                                FROM events\n                                WHERE event IN ['$pageview', '$autocapture']\n                                AND session_id IN ${sessionIds}\n                                -- the timestamp range here is only to avoid querying too much of the events table\n                                -- we don't really care about the absolute value, \n                                -- but we do care about whether timezones have an odd impact\n                                -- so, we extend the range by a day on each side so that timezones don't cause issues\n                                AND timestamp >= ${dayjs(oldestTimestamp).subtract(1, 'day')}\n                                AND timestamp <= ${dayjs(newestTimestamp).add(1, 'day')}\n                                GROUP BY session_id`,\n                    }\n\n                    const response = await api.query(query)\n                    const loadTimeMs = performance.now() - startTime\n\n                    actions.reportRecordingsListPropertiesFetched(loadTimeMs)\n\n                    breakpoint()\n                    return (response.results || []).map(\n                        (x: any): SessionRecordingPropertiesType => ({\n                            id: x[0],\n                            properties: JSON.parse(x[1] || '{}'),\n                        })\n                    )\n                },\n            },\n        ],\n    })),\n\n    listeners(({ actions, values }) => ({\n        maybeLoadPropertiesForSessions: ({ sessions }) => {\n            const newSessions = sessions.filter((session) => !values.recordingPropertiesById[session.id])\n\n            if (newSessions.length > 0) {\n                actions.loadPropertiesForSessions(newSessions)\n            }\n        },\n    })),\n\n    reducers({\n        recordingPropertiesById: [\n            {} as Record<string, SessionRecordingPropertiesType['properties']>,\n            {\n                loadPropertiesForSessionsSuccess: (\n                    state,\n                    { recordingProperties }\n                ): Record<string, SessionRecordingPropertiesType['properties']> => {\n                    const newState = { ...state }\n                    recordingProperties.forEach((properties) => {\n                        newState[properties.id] = properties.properties\n                    })\n\n                    return newState\n                },\n            },\n        ],\n    }),\n])\n","import { Link } from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\nimport { CopyToClipboardInline } from 'lib/components/CopyToClipboard'\nimport { LemonBanner } from 'lib/lemon-ui/LemonBanner'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonInput } from 'lib/lemon-ui/LemonInput/LemonInput'\nimport { LemonModal } from 'lib/lemon-ui/LemonModal'\nimport { LemonTextArea } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\n\nimport { verifiedDomainsLogic } from './verifiedDomainsLogic'\n\nexport function ConfigureSAMLModal(): JSX.Element {\n    const { configureSAMLModalId, isSamlConfigSubmitting, samlConfig } = useValues(verifiedDomainsLogic)\n    const { setConfigureSAMLModalId } = useActions(verifiedDomainsLogic)\n    const { preflight } = useValues(preflightLogic)\n    const siteUrl = preflight?.site_url ?? window.location.origin\n\n    const samlReady = samlConfig.saml_acs_url && samlConfig.saml_entity_id && samlConfig.saml_x509_cert\n\n    const handleClose = (): void => {\n        setConfigureSAMLModalId(null)\n        // clean()\n    }\n\n    return (\n        <LemonModal onClose={handleClose} isOpen={!!configureSAMLModalId} title=\"\" simple>\n            <Form logic={verifiedDomainsLogic} formKey=\"samlConfig\" enableFormOnSubmit className=\"LemonModal__layout \">\n                <LemonModal.Header>\n                    <h3>Configure SAML authentication and provisioning</h3>\n                </LemonModal.Header>\n                <LemonModal.Content className=\"space-y-2\">\n                    <p>\n                        <Link to=\"https://posthog.com/docs/data/sso#setting-up-saml\" target=\"_blank\" targetBlankIcon>\n                            Read the docs\n                        </Link>\n                    </p>\n                    <LemonField label=\"ACS Consumer URL\" name=\"_ACSConsumerUrl\">\n                        <CopyToClipboardInline>{`${siteUrl}/complete/saml/`}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField label=\"RelayState\" name=\"_RelayState\">\n                        <CopyToClipboardInline>{configureSAMLModalId || 'unknown'}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField label=\"Audience / Entity ID\" name=\"_Audience\">\n                        <CopyToClipboardInline>{siteUrl}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField name=\"saml_acs_url\" label=\"SAML ACS URL\">\n                        <LemonInput className=\"ph-ignore-input\" placeholder=\"Your IdP's ACS or single sign-on URL.\" />\n                    </LemonField>\n                    <LemonField name=\"saml_entity_id\" label=\"SAML Entity ID\">\n                        <LemonInput className=\"ph-ignore-input\" placeholder=\"Entity ID provided by your IdP.\" />\n                    </LemonField>\n                    <LemonField name=\"saml_x509_cert\" label=\"SAML X.509 Certificate\">\n                        <LemonTextArea\n                            className=\"ph-ignore-input\"\n                            minRows={10}\n                            placeholder={`Enter the public certificate of your IdP. Keep all line breaks.\\n-----BEGIN CERTIFICATE-----\\nMIICVjCCAb+gAwIBAgIBADANBgkqhkiG9w0BAQ0FADBIMQswCQYDVQQGEwJ1czEL\\n-----END CERTIFICATE-----`}\n                        />\n                    </LemonField>\n                    {!samlReady && (\n                        <LemonBanner type=\"info\">\n                            SAML will not be enabled unless you enter all attributes above. However you can still\n                            settings as draft.\n                        </LemonBanner>\n                    )}\n                </LemonModal.Content>\n                <LemonModal.Footer>\n                    <LemonButton loading={isSamlConfigSubmitting} type=\"primary\" htmlType=\"submit\">\n                        Save settings\n                    </LemonButton>\n                </LemonModal.Footer>\n            </Form>\n        </LemonModal>\n    )\n}\n","import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, afterMount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl, router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { featureFlagLogic as enabledFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { hasFormErrors } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { Scene } from 'scenes/sceneTypes'\nimport { urls } from 'scenes/urls'\n\nimport { DataTableNode, HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\nimport {\n    Breadcrumb,\n    FeatureFlagFilters,\n    PropertyFilterType,\n    PropertyOperator,\n    Survey,\n    SurveyQuestionBase,\n    SurveyQuestionType,\n    SurveyUrlMatchType,\n} from '~/types'\n\nimport { defaultSurveyFieldValues, NEW_SURVEY, NewSurvey } from './constants'\nimport type { surveyLogicType } from './surveyLogicType'\nimport { surveysLogic } from './surveysLogic'\nimport { sanitizeHTML } from './utils'\n\nexport enum SurveyEditSection {\n    Steps = 'steps',\n    Widget = 'widget',\n    Presentation = 'presentation',\n    Appearance = 'appearance',\n    Customization = 'customization',\n    Targeting = 'targeting',\n}\nexport interface SurveyLogicProps {\n    /** Either a UUID or 'new'. */\n    id: string\n}\n\nexport interface SurveyMetricsQueries {\n    surveysShown: DataTableNode\n    surveysDismissed: DataTableNode\n}\n\nexport interface SurveyUserStats {\n    seen: number\n    dismissed: number\n    sent: number\n}\n\nexport interface SurveyRatingResults {\n    [key: number]: {\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveySingleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveyMultipleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n    }\n}\n\nexport interface SurveyOpenTextResults {\n    [key: number]: {\n        events: { distinct_id: string; properties: Record<string, any>; personProperties: Record<string, any> }[]\n    }\n}\n\nexport interface QuestionResultsReady {\n    [key: string]: boolean\n}\n\nconst getResponseField = (i: number): string => (i === 0 ? '$survey_response' : `$survey_response_${i}`)\n\nexport const surveyLogic = kea<surveyLogicType>([\n    props({} as SurveyLogicProps),\n    key(({ id }) => id),\n    path((key) => ['scenes', 'surveys', 'surveyLogic', key]),\n    connect(() => ({\n        actions: [\n            surveysLogic,\n            ['loadSurveys'],\n            eventUsageLogic,\n            [\n                'reportSurveyCreated',\n                'reportSurveyLaunched',\n                'reportSurveyEdited',\n                'reportSurveyArchived',\n                'reportSurveyStopped',\n                'reportSurveyResumed',\n                'reportSurveyViewed',\n            ],\n        ],\n        values: [enabledFlagLogic, ['featureFlags as enabledFlags'], surveysLogic, ['surveys']],\n    })),\n    actions({\n        setSurveyMissing: true,\n        editingSurvey: (editing: boolean) => ({ editing }),\n        setDefaultForQuestionType: (\n            idx: number,\n            type: SurveyQuestionType,\n            isEditingQuestion: boolean,\n            isEditingDescription: boolean,\n            isEditingThankYouMessage: boolean\n        ) => ({\n            idx,\n            type,\n            isEditingQuestion,\n            isEditingDescription,\n            isEditingThankYouMessage,\n        }),\n        archiveSurvey: true,\n        setWritingHTMLDescription: (writingHTML: boolean) => ({ writingHTML }),\n        setSurveyTemplateValues: (template: any) => ({ template }),\n        setSelectedQuestion: (idx: number | null) => ({ idx }),\n        setSelectedSection: (section: SurveyEditSection | null) => ({ section }),\n        resetTargeting: true,\n        setFlagPropertyErrors: (errors: any) => ({ errors }),\n    }),\n    loaders(({ props, actions, values }) => ({\n        survey: {\n            loadSurvey: async () => {\n                if (props.id && props.id !== 'new') {\n                    try {\n                        const survey = await api.surveys.get(props.id)\n                        actions.reportSurveyViewed(survey)\n                        return survey\n                    } catch (error: any) {\n                        if (error.status === 404) {\n                            actions.setSurveyMissing()\n                            return { ...NEW_SURVEY }\n                        }\n                        throw error\n                    }\n                }\n                if (props.id === 'new' && router.values.hashParams.fromTemplate) {\n                    return values.survey\n                } else {\n                    return { ...NEW_SURVEY }\n                }\n            },\n            createSurvey: async (surveyPayload: Partial<Survey>) => {\n                return await api.surveys.create(sanitizeQuestions(surveyPayload))\n            },\n            updateSurvey: async (surveyPayload: Partial<Survey>) => {\n                return await api.surveys.update(props.id, sanitizeQuestions(surveyPayload))\n            },\n            launchSurvey: async () => {\n                const startDate = dayjs()\n                return await api.surveys.update(props.id, { start_date: startDate.toISOString() })\n            },\n            stopSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: dayjs().toISOString() })\n            },\n            resumeSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: null })\n            },\n        },\n        surveyUserStats: {\n            loadSurveyUserStats: async (): Promise<SurveyUserStats> => {\n                const { survey } = values\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: hogql`\n                        SELECT\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey shown'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate}),\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey dismissed'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate}),\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey sent'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate})\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n                if (results && results[0]) {\n                    const [totalSeen, dismissed, sent] = results[0]\n                    const onlySeen = totalSeen - dismissed - sent\n                    return { seen: onlySeen < 0 ? 0 : onlySeen, dismissed, sent }\n                } else {\n                    return { seen: 0, dismissed: 0, sent: 0 }\n                }\n            },\n        },\n        surveyRatingResults: {\n            loadSurveyRatingResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyRatingResults> => {\n                const { survey } = values\n\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.Rating) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.Rating}`)\n                }\n\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT\n                            JSONExtractString(properties, '${getResponseField(questionIndex)}') AS survey_response,\n                            COUNT(survey_response)\n                        FROM events\n                        WHERE event = 'survey sent' \n                            AND properties.$survey_id = '${props.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                        GROUP BY survey_response\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                let total = 0\n                const dataSize = question.scale === 10 ? 11 : question.scale\n                const data = new Array(dataSize).fill(0)\n                results?.forEach(([value, count]) => {\n                    total += count\n\n                    const index = question.scale === 10 ? value : value - 1\n                    data[index] = count\n                })\n\n                return { ...values.surveyRatingResults, [questionIndex]: { total, data } }\n            },\n        },\n        surveySingleChoiceResults: {\n            loadSurveySingleChoiceResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveySingleChoiceResults> => {\n                const { survey } = values\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT\n                            JSONExtractString(properties, '${getResponseField(questionIndex)}') AS survey_response,\n                            COUNT(survey_response)\n                        FROM events\n                        WHERE event = 'survey sent' \n                            AND properties.$survey_id = '${props.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                        GROUP BY survey_response\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                const labels = results?.map((r) => r[0])\n                const data = results?.map((r) => r[1])\n                const total = data?.reduce((a, b) => a + b, 0)\n\n                return { ...values.surveySingleChoiceResults, [questionIndex]: { labels, data, total } }\n            },\n        },\n        surveyMultipleChoiceResults: {\n            loadSurveyMultipleChoiceResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyMultipleChoiceResults> => {\n                const { survey } = values\n\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.MultipleChoice) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.MultipleChoice}`)\n                }\n\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT \n                            count(),\n                            arrayJoin(JSONExtractArrayRaw(properties, '${getResponseField(questionIndex)}')) AS choice\n                        FROM events\n                        WHERE event == 'survey sent'\n                            AND properties.$survey_id == '${survey.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                        GROUP BY choice\n                        ORDER BY count() DESC\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                let { results } = responseJSON\n\n                // Remove outside quotes\n                results = results?.map((r) => {\n                    return [r[0], r[1].slice(1, r[1].length - 1)]\n                })\n\n                // Zero-fill choices that are not open-ended\n                question.choices.forEach((choice, idx) => {\n                    const isOpenChoice = idx == question.choices.length - 1 && question?.hasOpenChoice\n                    if (results?.length && !isOpenChoice && !results.some((r) => r[1] === choice)) {\n                        results.push([0, choice])\n                    }\n                })\n\n                const data = results?.map((r) => r[0])\n                const labels = results?.map((r) => r[1])\n\n                return { ...values.surveyMultipleChoiceResults, [questionIndex]: { labels, data } }\n            },\n        },\n        surveyOpenTextResults: {\n            loadSurveyOpenTextResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyOpenTextResults> => {\n                const { survey } = values\n\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.Open) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.Open}`)\n                }\n\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT distinct_id, properties, person.properties\n                        FROM events\n                        WHERE event == 'survey sent'\n                            AND properties.$survey_id == '${survey.id}'\n                            AND trim(JSONExtractString(properties, '${getResponseField(questionIndex)}')) != ''\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                        LIMIT 20\n                    `,\n                }\n\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                const events =\n                    results?.map((r) => {\n                        const distinct_id = r[0]\n                        const properties = JSON.parse(r[1])\n                        const personProperties = JSON.parse(r[2])\n                        return { distinct_id, properties, personProperties }\n                    }) || []\n\n                return { ...values.surveyOpenTextResults, [questionIndex]: { events } }\n            },\n        },\n    })),\n    listeners(({ actions, values }) => ({\n        createSurveySuccess: ({ survey }) => {\n            lemonToast.success(<>Survey {survey.name} created</>)\n            actions.loadSurveys()\n            router.actions.replace(urls.survey(survey.id))\n            actions.reportSurveyCreated(survey)\n        },\n        updateSurveySuccess: ({ survey }) => {\n            lemonToast.success(<>Survey {survey.name} updated</>)\n            actions.editingSurvey(false)\n            actions.reportSurveyEdited(survey)\n            actions.loadSurveys()\n        },\n        launchSurveySuccess: ({ survey }) => {\n            lemonToast.success(<>Survey {survey.name} launched</>)\n            actions.loadSurveys()\n            actions.reportSurveyLaunched(survey)\n        },\n        stopSurveySuccess: ({ survey }) => {\n            actions.loadSurveys()\n            actions.reportSurveyStopped(survey)\n        },\n        resumeSurveySuccess: ({ survey }) => {\n            actions.loadSurveys()\n            actions.reportSurveyResumed(survey)\n        },\n        archiveSurvey: () => {\n            actions.updateSurvey({ archived: true })\n        },\n        loadSurveySuccess: () => {\n            actions.loadSurveyUserStats()\n        },\n        resetTargeting: () => {\n            actions.setSurveyValue('linked_flag_id', NEW_SURVEY.linked_flag_id)\n            actions.setSurveyValue('targeting_flag_filters', NEW_SURVEY.targeting_flag_filters)\n            actions.setSurveyValue('linked_flag', NEW_SURVEY.linked_flag)\n            actions.setSurveyValue('targeting_flag', NEW_SURVEY.targeting_flag)\n            actions.setSurveyValue('conditions', NEW_SURVEY.conditions)\n            actions.setSurveyValue('remove_targeting_flag', true)\n        },\n        submitSurveyFailure: async () => {\n            // When errors occur, scroll to the error, but wait for errors to be set in the DOM first\n            if (hasFormErrors(values.flagPropertyErrors) || values.urlMatchTypeValidationError) {\n                actions.setSelectedSection(SurveyEditSection.Targeting)\n            } else {\n                actions.setSelectedSection(SurveyEditSection.Steps)\n            }\n            setTimeout(\n                () => document.querySelector(`.Field--error`)?.scrollIntoView({ block: 'center', behavior: 'smooth' }),\n                5\n            )\n        },\n    })),\n    reducers({\n        isEditingSurvey: [\n            false,\n            {\n                editingSurvey: (_, { editing }) => editing,\n            },\n        ],\n        surveyMissing: [\n            false,\n            {\n                setSurveyMissing: () => true,\n            },\n        ],\n        survey: [\n            { ...NEW_SURVEY } as NewSurvey | Survey,\n            {\n                setDefaultForQuestionType: (\n                    state,\n                    { idx, type, isEditingQuestion, isEditingDescription, isEditingThankYouMessage }\n                ) => {\n                    const question = isEditingQuestion\n                        ? state.questions[idx].question\n                        : defaultSurveyFieldValues[type].questions[0].question\n                    const description = isEditingDescription\n                        ? state.questions[idx].description\n                        : defaultSurveyFieldValues[type].questions[0].description\n                    const thankYouMessageHeader = isEditingThankYouMessage\n                        ? state.appearance.thankYouMessageHeader\n                        : defaultSurveyFieldValues[type].appearance.thankYouMessageHeader\n                    const newQuestions = [...state.questions]\n                    newQuestions[idx] = {\n                        ...state.questions[idx],\n                        ...(defaultSurveyFieldValues[type].questions[0] as SurveyQuestionBase),\n                        question,\n                        description,\n                    }\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                        appearance: {\n                            ...state.appearance,\n                            ...defaultSurveyFieldValues[type].appearance,\n                            thankYouMessageHeader,\n                        },\n                    }\n                },\n                setSurveyTemplateValues: (_, { template }) => {\n                    const newTemplateSurvey = { ...NEW_SURVEY, ...template }\n                    return newTemplateSurvey\n                },\n            },\n        ],\n        selectedQuestion: [\n            0 as number | null,\n            {\n                setSelectedQuestion: (_, { idx }) => idx,\n            },\n        ],\n        selectedSection: [\n            SurveyEditSection.Steps as SurveyEditSection | null,\n            {\n                setSelectedSection: (_, { section }) => section,\n            },\n        ],\n        surveyRatingResultsReady: [\n            {},\n            {\n                loadSurveyRatingResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveySingleChoiceResultsReady: [\n            {},\n            {\n                loadSurveySingleChoiceResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveyMultipleChoiceResultsReady: [\n            {},\n            {\n                loadSurveyMultipleChoiceResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveyOpenTextResultsReady: [\n            {},\n            {\n                loadSurveyOpenTextResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        writingHTMLDescription: [\n            false,\n            {\n                setWritingHTMLDescription: (_, { writingHTML }) => writingHTML,\n            },\n        ],\n        flagPropertyErrors: [\n            null as any,\n            {\n                setFlagPropertyErrors: (_, { errors }) => errors,\n            },\n        ],\n    }),\n    selectors({\n        isSurveyRunning: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(survey.start_date && !survey.end_date)\n            },\n        ],\n        hasTargetingSet: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                const hasLinkedFlag =\n                    !!survey.linked_flag_id || (survey.linked_flag && Object.keys(survey.linked_flag).length > 0)\n                const hasTargetingFlag =\n                    (survey.targeting_flag && Object.keys(survey.targeting_flag).length > 0) ||\n                    (survey.targeting_flag_filters && Object.keys(survey.targeting_flag_filters).length > 0)\n                const hasOtherConditions = survey.conditions && Object.keys(survey.conditions).length > 0\n                return !!hasLinkedFlag || !!hasTargetingFlag || !!hasOtherConditions\n            },\n        ],\n        breadcrumbs: [\n            (s) => [s.survey],\n            (survey: Survey): Breadcrumb[] => [\n                {\n                    key: Scene.Surveys,\n                    name: 'Surveys',\n                    path: urls.surveys(),\n                },\n                { key: [Scene.Survey, survey?.id || 'new'], name: survey.name },\n            ],\n        ],\n        dataTableQuery: [\n            (s) => [s.survey],\n            (survey): DataTableNode | null => {\n                if (survey.id === 'new') {\n                    return null\n                }\n                const createdAt = (survey as Survey).created_at\n                return {\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.EventsQuery,\n                        select: [\n                            '*',\n                            ...survey.questions.map((q, i) => {\n                                if (q.type === SurveyQuestionType.MultipleChoice) {\n                                    // Join array items into a string\n                                    return `coalesce(arrayStringConcat(JSONExtractArrayRaw(properties, '${getResponseField(\n                                        i\n                                    )}'), ', ')) -- ${q.question}`\n                                }\n\n                                return `coalesce(JSONExtractString(properties, '${getResponseField(i)}')) -- ${\n                                    q.question\n                                }`\n                            }),\n                            'timestamp',\n                            'person',\n                        ],\n                        orderBy: ['timestamp DESC'],\n                        where: [`event == 'survey sent'`],\n                        after: createdAt,\n                        properties: [\n                            {\n                                type: PropertyFilterType.Event,\n                                key: '$survey_id',\n                                operator: PropertyOperator.Exact,\n                                value: survey.id,\n                            },\n                        ],\n                    },\n                    propertiesViaUrl: true,\n                    showExport: true,\n                    showReload: true,\n                    showEventFilter: true,\n                    showPropertyFilter: true,\n                    showTimings: false,\n                }\n            },\n        ],\n        targetingFlagFilters: [\n            (s) => [s.survey],\n            (survey): FeatureFlagFilters | undefined => {\n                if (survey.targeting_flag_filters) {\n                    return {\n                        ...survey.targeting_flag_filters,\n                        groups: survey.targeting_flag_filters.groups,\n                        multivariate: null,\n                        payloads: {},\n                        super_groups: undefined,\n                    }\n                }\n                return survey.targeting_flag?.filters || undefined\n            },\n        ],\n        urlMatchTypeValidationError: [\n            (s) => [s.survey],\n            (survey): string | null => {\n                if (survey.conditions?.urlMatchType === SurveyUrlMatchType.Regex && survey.conditions.url) {\n                    try {\n                        new RegExp(survey.conditions.url)\n                    } catch (e: any) {\n                        return e.message\n                    }\n                }\n                return null\n            },\n        ],\n        surveyNPSScore: [\n            (s) => [s.surveyRatingResults],\n            (surveyRatingResults) => {\n                if (surveyRatingResults) {\n                    const questionIdx = Object.keys(surveyRatingResults)[0]\n                    const questionResults: number[] = surveyRatingResults[questionIdx].data\n                    if (questionResults.length === 11) {\n                        const promoters = questionResults.slice(9, 11).reduce((a, b) => a + b, 0)\n                        const passives = questionResults.slice(7, 9).reduce((a, b) => a + b, 0)\n                        const detractors = questionResults.slice(0, 7).reduce((a, b) => a + b, 0)\n                        const npsScore = ((promoters - detractors) / (promoters + passives + detractors)) * 100\n                        return npsScore.toFixed(1)\n                    }\n                }\n            },\n        ],\n    }),\n    forms(({ actions, props, values }) => ({\n        survey: {\n            defaults: { ...NEW_SURVEY } as NewSurvey | Survey,\n            errors: ({ name, questions }) => ({\n                // NOTE: When more validation errors are added, the submitSurveyFailure listener should be updated\n                // to scroll to the right error section\n                name: !name && 'Please enter a name.',\n                questions: questions.map((question) => ({\n                    question: !question.question && 'Please enter a question.',\n                    ...(question.type === SurveyQuestionType.Rating\n                        ? {\n                              display: !question.display && 'Please choose a display type.',\n                              scale: !question.scale && 'Please choose a scale.',\n                          }\n                        : {}),\n                })),\n                // release conditions controlled using a PureField in the form\n                targeting_flag_filters: values.flagPropertyErrors,\n                // controlled using a PureField in the form\n                urlMatchType: values.urlMatchTypeValidationError,\n            }),\n            submit: (surveyPayload) => {\n                if (props.id && props.id !== 'new') {\n                    actions.updateSurvey(surveyPayload)\n                } else {\n                    actions.createSurvey(surveyPayload)\n                }\n            },\n        },\n    })),\n    urlToAction(({ actions, props }) => ({\n        [urls.survey(props.id ?? 'new')]: (_, __, ___, { method }) => {\n            // If the URL was pushed (user clicked on a link), reset the scene's data.\n            // This avoids resetting form fields if you click back/forward.\n            if (method === 'PUSH') {\n                if (props.id) {\n                    actions.loadSurvey()\n                } else {\n                    actions.resetSurvey()\n                }\n            }\n        },\n    })),\n    actionToUrl(({ values }) => ({\n        setSurveyTemplateValues: () => {\n            const hashParams = router.values.hashParams\n            hashParams['fromTemplate'] = true\n\n            return [urls.survey(values.survey.id), router.values.searchParams, hashParams]\n        },\n    })),\n    afterMount(({ props, actions }) => {\n        if (props.id !== 'new') {\n            actions.loadSurvey()\n        }\n        if (props.id === 'new') {\n            actions.resetSurvey()\n        }\n    }),\n])\n\nfunction sanitizeQuestions(surveyPayload: Partial<Survey>): Partial<Survey> {\n    if (!surveyPayload.questions) {\n        return surveyPayload\n    }\n\n    const sanitizedThankYouHeader = sanitizeHTML(surveyPayload.appearance?.thankYouMessageHeader || '')\n    const sanitizedThankYouDescription = sanitizeHTML(surveyPayload.appearance?.thankYouMessageDescription || '')\n\n    return {\n        ...surveyPayload,\n        questions: surveyPayload.questions?.map((rawQuestion) => {\n            return {\n                ...rawQuestion,\n                description: sanitizeHTML(rawQuestion.description || ''),\n                question: sanitizeHTML(rawQuestion.question || ''),\n            }\n        }),\n        appearance: {\n            ...surveyPayload.appearance,\n            ...(sanitizedThankYouHeader && { thankYouMessageHeader: sanitizedThankYouHeader }),\n            ...(sanitizedThankYouDescription && { thankYouMessageDescription: sanitizedThankYouDescription }),\n        },\n    }\n}\n"],"names":[],"sourceRoot":""}