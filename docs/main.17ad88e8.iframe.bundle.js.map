{"version":3,"file":"main.17ad88e8.iframe.bundle.js","mappings":";;;;;;;;AA8HA;;;ACrFA;;;;;AAKA;AACA;AAIA;;;;;AC+FA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AAGA","sources":["webpack://posthog/./frontend/src/lib/components/AuthorizedUrlList/authorizedUrlListLogic.ts","webpack://posthog/./frontend/src/scenes/session-recordings/playlist/sessionRecordingsListPropertiesLogic.ts","webpack://posthog/./frontend/src/scenes/surveys/surveyLogic.tsx"],"sourcesContent":["import {\n    actions,\n    afterMount,\n    connect,\n    kea,\n    key,\n    listeners,\n    path,\n    props,\n    reducers,\n    selectors,\n    sharedListeners,\n} from 'kea'\nimport api from 'lib/api'\nimport { isDomain, isURL } from 'lib/utils'\nimport { ToolbarParams } from '~/types'\nimport { teamLogic } from 'scenes/teamLogic'\nimport Fuse from 'fuse.js'\nimport { encodeParams, urlToAction } from 'kea-router'\nimport { urls } from 'scenes/urls'\nimport { loaders } from 'kea-loaders'\nimport { forms } from 'kea-forms'\n\nimport type { authorizedUrlListLogicType } from './authorizedUrlListLogicType'\nimport { subscriptions } from 'kea-subscriptions'\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\n\nexport interface ProposeNewUrlFormType {\n    url: string\n}\n\nexport enum AuthorizedUrlListType {\n    TOOLBAR_URLS = 'TOOLBAR_URLS',\n    RECORDING_DOMAINS = 'RECORDING_DOMAINS',\n}\n\nexport const validateProposedUrl = (\n    proposedUrl: string,\n    currentUrls: string[],\n    onlyAllowDomains: boolean = false\n): string | undefined => {\n    if (!onlyAllowDomains && !isURL(proposedUrl)) {\n        return 'Please enter a valid URL'\n    }\n\n    if (onlyAllowDomains && !isDomain(proposedUrl)) {\n        return \"Please enter a valid domain (URLs with a path aren't allowed)\"\n    }\n\n    if (proposedUrl.indexOf('*') > -1 && !proposedUrl.match(/^(.*)\\*[^*]*\\.[^*]+\\.[^*]+$/)) {\n        return 'Wildcards can only be used for subdomains'\n    }\n\n    if (currentUrls.indexOf(proposedUrl) > -1) {\n        return `This ${onlyAllowDomains ? 'domains' : 'URL'} already is registered`\n    }\n\n    return\n}\n\n/** defaultIntent: whether to launch with empty intent (i.e. toolbar mode is default) */\nexport function appEditorUrl(appUrl: string, actionId?: number | null, defaultIntent?: boolean): string {\n    // See https://github.com/PostHog/posthog-js/blob/f7119c/src/extensions/toolbar.ts#L52 for where these params\n    // are passed. `appUrl` is an extra `redirect_to_site` param.\n    const params: ToolbarParams & { appUrl: string } = {\n        userIntent: defaultIntent ? undefined : actionId ? 'edit-action' : 'add-action',\n        // Make sure to pass the app url, otherwise the api_host will be used by\n        // the toolbar, which isn't correct when used behind a reverse proxy as\n        // we require e.g. SSO login to the app, which will not work when placed\n        // behind a proxy unless we register each domain with the OAuth2 client.\n        apiURL: window.location.origin,\n        appUrl,\n        ...(actionId ? { actionId } : {}),\n    }\n    return '/api/user/redirect_to_site/' + encodeParams(params, '?')\n}\n\nexport const NEW_URL = 'https://'\n\nexport interface KeyedAppUrl {\n    url: string\n    type: 'authorized' | 'suggestion'\n    originalIndex: number\n}\n\nexport interface AuthorizedUrlListLogicProps {\n    actionId: number | null\n    type: AuthorizedUrlListType\n}\nexport const authorizedUrlListLogic = kea<authorizedUrlListLogicType>([\n    path((key) => ['lib', 'components', 'AuthorizedUrlList', 'authorizedUrlListLogic', key]),\n    key((props) => `${props.type}-${props.actionId}`),\n    props({} as AuthorizedUrlListLogicProps),\n    connect({\n        values: [teamLogic, ['currentTeam', 'currentTeamId']],\n        actions: [teamLogic, ['updateCurrentTeam']],\n    }),\n    actions(() => ({\n        setAuthorizedUrls: (authorizedUrls: string[]) => ({ authorizedUrls }),\n        addUrl: (url: string, launch?: boolean) => ({ url, launch }),\n        newUrl: true,\n        removeUrl: (index: number) => ({ index }),\n        updateUrl: (index: number, url: string) => ({ index, url }),\n        launchAtUrl: (url: string) => ({ url }),\n        setSearchTerm: (term: string) => ({ term }),\n        setEditUrlIndex: (originalIndex: number | null) => ({ originalIndex }),\n        cancelProposingUrl: true,\n    })),\n    loaders(({ values, props }) => ({\n        suggestions: {\n            __default: [] as string[],\n            loadSuggestions: async () => {\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: hogql`select properties.$current_url, count()\n                        from events\n                           where event = '$pageview'\n                           and timestamp >= now() - interval 3 day \n                            and timestamp <= now()\n                         group by properties.$current_url\n                         order by count() desc\n                        limit 25`,\n                }\n\n                const response = await api.query(query)\n                const result = response.results as [string, number][]\n\n                if (result && result.length === 0) {\n                    return []\n                }\n                const suggestedDomains: string[] = []\n\n                result.forEach(([url]) => {\n                    if (url) {\n                        try {\n                            const parsedUrl = new URL(url)\n                            const urlWithoutPath = parsedUrl.protocol + '//' + parsedUrl.host\n                            // Have we already added this domain?\n                            if (suggestedDomains.indexOf(urlWithoutPath) > -1) {\n                                return\n                            }\n                            // Is this domain already in the list of urls?\n                            const existingUrls =\n                                props.type === AuthorizedUrlListType.RECORDING_DOMAINS\n                                    ? values.currentTeam?.recording_domains\n                                    : values.currentTeam?.app_urls\n                            if (\n                                existingUrls &&\n                                existingUrls.filter((url) => url.indexOf(urlWithoutPath) > -1).length > 0\n                            ) {\n                                return\n                            }\n                            suggestedDomains.push(urlWithoutPath)\n                        } catch (error) {\n                            return\n                        }\n                    }\n                })\n\n                return suggestedDomains.slice(0, 20)\n            },\n        },\n    })),\n    subscriptions(({ props, actions }) => ({\n        currentTeam: (currentTeam) => {\n            actions.setAuthorizedUrls(\n                (props.type === AuthorizedUrlListType.RECORDING_DOMAINS\n                    ? currentTeam.recording_domains\n                    : currentTeam.app_urls) || []\n            )\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadSuggestions()\n    }),\n    forms(({ values, actions }) => ({\n        proposedUrl: {\n            defaults: { url: '' } as ProposeNewUrlFormType,\n            errors: ({ url }) => ({\n                url: validateProposedUrl(url, values.authorizedUrls, values.onlyAllowDomains),\n            }),\n            submit: async ({ url }) => {\n                if (values.editUrlIndex !== null && values.editUrlIndex >= 0) {\n                    actions.updateUrl(values.editUrlIndex, url)\n                } else {\n                    actions.addUrl(url)\n                }\n            },\n        },\n    })),\n    reducers(() => ({\n        showProposedURLForm: [\n            false as boolean,\n            {\n                newUrl: () => true,\n                submitProposedUrlSuccess: () => false,\n                cancelProposingUrl: () => false,\n            },\n        ],\n        authorizedUrls: [\n            [] as string[],\n            {\n                setAuthorizedUrls: (_, { authorizedUrls }) => authorizedUrls,\n                addUrl: (state, { url }) => state.concat([url]),\n                updateUrl: (state, { index, url }) => Object.assign([...state], { [index]: url }),\n                removeUrl: (state, { index }) => {\n                    const newUrls = [...state]\n                    newUrls.splice(index, 1)\n                    return newUrls\n                },\n            },\n        ],\n        suggestions: [\n            [],\n            {\n                addUrl: (state, { url }) => [...state].filter((item) => url !== item),\n            },\n        ],\n        searchTerm: [\n            '',\n            {\n                setSearchTerm: (_, { term }) => term,\n            },\n        ],\n        editUrlIndex: [\n            null as number | null,\n            {\n                setEditUrlIndex: (_, { originalIndex }) => originalIndex,\n                removeUrl: (editUrlIndex, { index }) =>\n                    editUrlIndex && index < editUrlIndex\n                        ? editUrlIndex - 1\n                        : index === editUrlIndex\n                        ? null\n                        : editUrlIndex,\n                newUrl: () => -1,\n                updateUrl: () => null,\n                addUrl: () => null,\n                cancelProposingUrl: () => null,\n            },\n        ],\n    })),\n    sharedListeners(({ values, props }) => ({\n        saveUrls: async () => {\n            if (props.type === AuthorizedUrlListType.RECORDING_DOMAINS) {\n                await teamLogic.asyncActions.updateCurrentTeam({ recording_domains: values.authorizedUrls })\n            } else {\n                await teamLogic.asyncActions.updateCurrentTeam({ app_urls: values.authorizedUrls })\n            }\n        },\n    })),\n    listeners(({ sharedListeners, values, actions }) => ({\n        setEditUrlIndex: () => {\n            actions.setProposedUrlValue('url', values.urlToEdit)\n        },\n        newUrl: () => {\n            actions.setProposedUrlValue('url', NEW_URL)\n        },\n        addUrl: [\n            sharedListeners.saveUrls,\n            ({ url, launch }) => {\n                if (launch) {\n                    actions.launchAtUrl(url)\n                }\n            },\n        ],\n        removeUrl: sharedListeners.saveUrls,\n        updateUrl: sharedListeners.saveUrls,\n        launchAtUrl: ({ url }) => {\n            window.location.href = values.launchUrl(url)\n        },\n        cancelProposingUrl: () => {\n            actions.resetProposedUrl()\n        },\n        submitProposedUrlSuccess: () => {\n            actions.setEditUrlIndex(null)\n            actions.resetProposedUrl()\n        },\n    })),\n    selectors({\n        urlToEdit: [\n            (s) => [s.authorizedUrls, s.editUrlIndex],\n            (authorizedUrls, editUrlIndex) => {\n                if (editUrlIndex === null || editUrlIndex === -1) {\n                    return NEW_URL\n                }\n                return authorizedUrls[editUrlIndex]\n            },\n        ],\n        urlsKeyed: [\n            (s) => [s.authorizedUrls, s.suggestions, s.searchTerm],\n            (authorizedUrls, suggestions, searchTerm): KeyedAppUrl[] => {\n                const keyedUrls = authorizedUrls\n                    .map((url, index) => ({\n                        url,\n                        type: 'authorized',\n                        originalIndex: index,\n                    }))\n                    .concat(\n                        suggestions.map((url, index) => ({\n                            url,\n                            type: 'suggestion',\n                            originalIndex: index,\n                        }))\n                    ) as KeyedAppUrl[]\n\n                if (!searchTerm) {\n                    return keyedUrls\n                }\n\n                return new Fuse(keyedUrls, {\n                    keys: ['url'],\n                    threshold: 0.3,\n                })\n                    .search(searchTerm)\n                    .map((result) => result.item)\n            },\n        ],\n        launchUrl: [(_, p) => [p.actionId], (actionId) => (url: string) => appEditorUrl(url, actionId, !actionId)],\n        isAddUrlFormVisible: [(s) => [s.editUrlIndex], (editUrlIndex) => editUrlIndex === -1],\n        onlyAllowDomains: [(_, p) => [p.type], (type) => type === AuthorizedUrlListType.RECORDING_DOMAINS],\n    }),\n    urlToAction(({ actions }) => ({\n        [urls.toolbarLaunch()]: (_, searchParams) => {\n            if (searchParams.addNew) {\n                actions.newUrl()\n            }\n        },\n    })),\n])\n","import { connect, kea, path, reducers, actions, listeners } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { SessionRecordingPropertiesType, SessionRecordingType } from '~/types'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport type { sessionRecordingsListPropertiesLogicType } from './sessionRecordingsListPropertiesLogicType'\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { dayjs } from 'lib/dayjs'\nimport { hogql } from '~/queries/utils'\n\n// This logic is used to fetch properties for a list of recordings\n// It is used in a global way as the cached values can be re-used\nexport const sessionRecordingsListPropertiesLogic = kea<sessionRecordingsListPropertiesLogicType>([\n    path(() => ['scenes', 'session-recordings', 'playlist', 'sessionRecordingsListPropertiesLogic']),\n    connect(() => ({\n        actions: [eventUsageLogic, ['reportRecordingsListPropertiesFetched']],\n    })),\n\n    actions({\n        loadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n        maybeLoadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n    }),\n\n    loaders(({ actions }) => ({\n        recordingProperties: [\n            [] as SessionRecordingPropertiesType[],\n            {\n                loadPropertiesForSessions: async ({ sessions }, breakpoint) => {\n                    await breakpoint(100)\n\n                    const startTime = performance.now()\n                    const sessionIds = sessions.map((x) => x.id)\n\n                    const oldestTimestamp = sessions.map((x) => x.start_time).sort()[0]\n                    const newestTimestamp = sessions.map((x) => x.end_time).sort()[sessions.length - 1]\n\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$session_id as session_id, any(properties) as properties\n                                FROM events\n                                WHERE event IN ['$pageview', '$autocapture']\n                                AND session_id IN ${sessionIds}\n                                -- the timestamp range here is only to avoid querying too much of the events table\n                                -- we don't really care about the absolute value, \n                                -- but we do care about whether timezones have an odd impact\n                                -- so, we extend the range by a day on each side so that timezones don't cause issues\n                                AND timestamp >= ${dayjs(oldestTimestamp).subtract(1, 'day')}\n                                AND timestamp <= ${dayjs(newestTimestamp).add(1, 'day')}\n                                GROUP BY session_id`,\n                    }\n\n                    const response = await api.query(query)\n                    const loadTimeMs = performance.now() - startTime\n\n                    actions.reportRecordingsListPropertiesFetched(loadTimeMs)\n\n                    breakpoint()\n                    return (response.results || []).map(\n                        (x: any): SessionRecordingPropertiesType => ({\n                            id: x[0],\n                            properties: JSON.parse(x[1] || '{}'),\n                        })\n                    )\n                },\n            },\n        ],\n    })),\n\n    listeners(({ actions, values }) => ({\n        maybeLoadPropertiesForSessions: ({ sessions }) => {\n            const newSessions = sessions.filter((session) => !values.recordingPropertiesById[session.id])\n\n            if (newSessions.length > 0) {\n                actions.loadPropertiesForSessions(newSessions)\n            }\n        },\n    })),\n\n    reducers({\n        recordingPropertiesById: [\n            {} as Record<string, SessionRecordingPropertiesType['properties']>,\n            {\n                loadPropertiesForSessionsSuccess: (\n                    state,\n                    { recordingProperties }\n                ): Record<string, SessionRecordingPropertiesType['properties']> => {\n                    const newState = { ...state }\n                    recordingProperties.forEach((properties) => {\n                        newState[properties.id] = properties.properties\n                    })\n\n                    return newState\n                },\n            },\n        ],\n    }),\n])\n","import { lemonToast } from '@posthog/lemon-ui'\nimport { kea, path, props, key, listeners, afterMount, reducers, actions, selectors, connect } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { urls } from 'scenes/urls'\nimport {\n    Breadcrumb,\n    ChartDisplayType,\n    PropertyFilterType,\n    PropertyOperator,\n    Survey,\n    SurveyQuestionBase,\n    SurveyQuestionType,\n    SurveyUrlMatchType,\n    RatingSurveyQuestion,\n} from '~/types'\nimport type { surveyLogicType } from './surveyLogicType'\nimport { DataTableNode, InsightVizNode, HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\nimport { surveysLogic } from './surveysLogic'\nimport { dayjs } from 'lib/dayjs'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { featureFlagLogic } from 'scenes/feature-flags/featureFlagLogic'\nimport { featureFlagLogic as enabledFlagLogic } from 'lib/logic/featureFlagLogic'\nimport {\n    defaultSurveyFieldValues,\n    SURVEY_EVENT_NAME,\n    SURVEY_RESPONSE_PROPERTY,\n    NEW_SURVEY,\n    NewSurvey,\n} from './constants'\nimport { sanitize } from 'dompurify'\n\nexport interface SurveyLogicProps {\n    id: string | 'new'\n}\n\nexport interface SurveyMetricsQueries {\n    surveysShown: DataTableNode\n    surveysDismissed: DataTableNode\n}\n\nexport interface SurveyUserStats {\n    seen: number\n    dismissed: number\n    sent: number\n}\n\nexport interface SurveyRatingResults {\n    [key: string]: number[]\n}\n\nexport interface SurveyRatingResultsReady {\n    [key: string]: boolean\n}\n\nexport const surveyLogic = kea<surveyLogicType>([\n    props({} as SurveyLogicProps),\n    key(({ id }) => id),\n    path((key) => ['scenes', 'surveys', 'surveyLogic', key]),\n    connect(() => ({\n        actions: [\n            surveysLogic,\n            ['loadSurveys'],\n            eventUsageLogic,\n            [\n                'reportSurveyCreated',\n                'reportSurveyLaunched',\n                'reportSurveyEdited',\n                'reportSurveyArchived',\n                'reportSurveyStopped',\n                'reportSurveyResumed',\n                'reportSurveyViewed',\n            ],\n        ],\n        values: [enabledFlagLogic, ['featureFlags as enabledFlags']],\n    })),\n    actions({\n        setSurveyMissing: true,\n        editingSurvey: (editing: boolean) => ({ editing }),\n        setDefaultForQuestionType: (\n            idx: number,\n            type: SurveyQuestionType,\n            isEditingQuestion: boolean,\n            isEditingDescription: boolean,\n            isEditingThankYouMessage: boolean\n        ) => ({\n            idx,\n            type,\n            isEditingQuestion,\n            isEditingDescription,\n            isEditingThankYouMessage,\n        }),\n        archiveSurvey: true,\n        setCurrentQuestionIndexAndType: (idx: number, type: SurveyQuestionType) => ({ idx, type }),\n        setWritingHTMLDescription: (writingHTML: boolean) => ({ writingHTML }),\n    }),\n    loaders(({ props, actions, values }) => ({\n        survey: {\n            loadSurvey: async () => {\n                if (props.id && props.id !== 'new') {\n                    try {\n                        const survey = await api.surveys.get(props.id)\n                        actions.reportSurveyViewed(survey)\n                        return survey\n                    } catch (error: any) {\n                        actions.setSurveyMissing()\n                        throw error\n                    }\n                }\n                return { ...NEW_SURVEY }\n            },\n            createSurvey: async (surveyPayload: Partial<Survey>) => {\n                return await api.surveys.create(sanitizeQuestions(surveyPayload))\n            },\n            updateSurvey: async (surveyPayload: Partial<Survey>) => {\n                return await api.surveys.update(props.id, sanitizeQuestions(surveyPayload))\n            },\n            launchSurvey: async () => {\n                const startDate = dayjs()\n                return await api.surveys.update(props.id, { start_date: startDate.toISOString() })\n            },\n            stopSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: dayjs().toISOString() })\n            },\n            resumeSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: null })\n            },\n        },\n        surveyUserStats: {\n            loadSurveyUserStats: async (): Promise<SurveyUserStats> => {\n                const { survey } = values\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: hogql`\n                        SELECT\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey shown'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate}),\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey dismissed'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate}),\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey sent'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate})\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n                if (results && results[0]) {\n                    const [totalSeen, dismissed, sent] = results[0]\n                    const onlySeen = totalSeen - dismissed - sent\n                    return { seen: onlySeen < 0 ? 0 : onlySeen, dismissed, sent }\n                } else {\n                    return { seen: 0, dismissed: 0, sent: 0 }\n                }\n            },\n        },\n        surveyRatingResults: {\n            loadSurveyRatingResults: async ({\n                questionIndex,\n                question,\n            }: {\n                questionIndex: number\n                question: RatingSurveyQuestion\n            }): Promise<{ [key: string]: number[] }> => {\n                const { survey } = values\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const surveyResponseField =\n                    questionIndex === 0 ? '$survey_response' : `$survey_response_${questionIndex}`\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT properties.${surveyResponseField} AS survey_response, COUNT(survey_response)\n                        FROM events\n                        WHERE event = 'survey sent' \n                            AND properties.$survey_id = '${props.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                        GROUP BY survey_response\n                    `,\n                }\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                const resultArr = new Array(question.scale).fill(0)\n                results?.forEach(([value, count]) => {\n                    resultArr[value - 1] = count\n                })\n\n                return { ...values.surveyRatingResults, [`question_${questionIndex}`]: resultArr }\n            },\n        },\n    })),\n    listeners(({ actions }) => ({\n        createSurveySuccess: ({ survey }) => {\n            lemonToast.success(<>Survey {survey.name} created</>)\n            actions.loadSurveys()\n            router.actions.replace(urls.survey(survey.id))\n            actions.reportSurveyCreated(survey)\n        },\n        updateSurveySuccess: ({ survey }) => {\n            lemonToast.success(<>Survey {survey.name} updated</>)\n            actions.editingSurvey(false)\n            actions.reportSurveyEdited(survey)\n            actions.loadSurveys()\n        },\n        launchSurveySuccess: ({ survey }) => {\n            lemonToast.success(<>Survey {survey.name} launched</>)\n            actions.loadSurveys()\n            actions.reportSurveyLaunched(survey)\n        },\n        stopSurveySuccess: ({ survey }) => {\n            actions.loadSurveys()\n            actions.reportSurveyStopped(survey)\n        },\n        resumeSurveySuccess: ({ survey }) => {\n            actions.loadSurveys()\n            actions.reportSurveyResumed(survey)\n        },\n        archiveSurvey: async () => {\n            actions.updateSurvey({ archived: true })\n        },\n        loadSurveySuccess: ({ survey }) => {\n            actions.setCurrentQuestionIndexAndType(0, survey.questions[0].type)\n            actions.loadSurveyUserStats()\n        },\n    })),\n    reducers({\n        isEditingSurvey: [\n            false,\n            {\n                editingSurvey: (_, { editing }) => editing,\n            },\n        ],\n        surveyMissing: [\n            false,\n            {\n                setSurveyMissing: () => true,\n            },\n        ],\n        survey: [\n            { ...NEW_SURVEY } as NewSurvey | Survey,\n            {\n                setDefaultForQuestionType: (\n                    state,\n                    { idx, type, isEditingQuestion, isEditingDescription, isEditingThankYouMessage }\n                ) => {\n                    const question = isEditingQuestion\n                        ? state.questions[idx].question\n                        : defaultSurveyFieldValues[type].questions[0].question\n                    const description = isEditingDescription\n                        ? state.questions[idx].description\n                        : defaultSurveyFieldValues[type].questions[0].description\n                    const thankYouMessageHeader = isEditingThankYouMessage\n                        ? state.appearance.thankYouMessageHeader\n                        : defaultSurveyFieldValues[type].appearance.thankYouMessageHeader\n                    const newQuestions = [...state.questions]\n                    newQuestions[idx] = {\n                        ...state.questions[idx],\n                        ...(defaultSurveyFieldValues[type].questions[0] as SurveyQuestionBase),\n                        question,\n                        description,\n                    }\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                        appearance: {\n                            ...state.appearance,\n                            ...defaultSurveyFieldValues[type].appearance,\n                            thankYouMessageHeader,\n                        },\n                    }\n                },\n            },\n        ],\n        currentQuestionIndexAndType: [\n            { idx: 0, type: SurveyQuestionType.Open } as { idx: number; type: SurveyQuestionType },\n            {\n                setCurrentQuestionIndexAndType: (_, { idx, type }) => ({ idx, type }),\n            },\n        ],\n        surveyRatingResultsReady: [\n            {},\n            {\n                loadSurveyRatingResultsSuccess: (state, { payload }) => {\n                    return { ...state, [`question_${payload?.questionIndex}`]: true }\n                },\n            },\n        ],\n        writingHTMLDescription: [\n            false,\n            {\n                setWritingHTMLDescription: (_, { writingHTML }) => writingHTML,\n            },\n        ],\n    }),\n    selectors({\n        isSurveyRunning: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(survey.start_date && !survey.end_date)\n            },\n        ],\n        breadcrumbs: [\n            (s) => [s.survey],\n            (survey: Survey): Breadcrumb[] => [\n                {\n                    name: 'Surveys',\n                    path: urls.surveys(),\n                },\n                ...(survey?.name ? [{ name: survey.name }] : []),\n            ],\n        ],\n        surveyResponseProperty: [\n            (s) => [s.currentQuestionIndexAndType],\n            (currentQuestionIndexAndType): string => {\n                return currentQuestionIndexAndType.idx === 0\n                    ? SURVEY_RESPONSE_PROPERTY\n                    : `${SURVEY_RESPONSE_PROPERTY}_${currentQuestionIndexAndType.idx}`\n            },\n        ],\n        dataTableQuery: [\n            (s) => [s.survey, s.surveyResponseProperty],\n            (survey, surveyResponseProperty): DataTableNode | null => {\n                if (survey.id === 'new') {\n                    return null\n                }\n                const createdAt = (survey as Survey).created_at\n                return {\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.EventsQuery,\n                        select: ['*', `properties.${surveyResponseProperty}`, 'timestamp', 'person'],\n                        orderBy: ['timestamp DESC'],\n                        where: [`event == 'survey sent'`],\n                        after: createdAt,\n                        properties: [\n                            {\n                                type: PropertyFilterType.Event,\n                                key: '$survey_id',\n                                operator: PropertyOperator.Exact,\n                                value: survey.id,\n                            },\n                        ],\n                    },\n                    propertiesViaUrl: true,\n                    showExport: true,\n                    showReload: true,\n                    showEventFilter: true,\n                    showPropertyFilter: true,\n                    showTimings: false,\n                }\n            },\n        ],\n        surveyMetricsQueries: [\n            (s) => [s.survey],\n            (survey): SurveyMetricsQueries | null => {\n                const surveyId = survey.id\n                if (surveyId === 'new') {\n                    return null\n                }\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const surveysShownHogqlQuery = `select count(distinct person.id) as 'survey shown' from events where event == 'survey shown' and properties.$survey_id == '${surveyId}' and timestamp >= '${startDate}' and timestamp <= '${endDate}' `\n                const surveysDismissedHogqlQuery = `select count(distinct person.id) as 'survey dismissed' from events where event == 'survey dismissed' and properties.$survey_id == '${surveyId}' and timestamp >= '${startDate}' and timestamp <= '${endDate}'`\n                return {\n                    surveysShown: {\n                        kind: NodeKind.DataTableNode,\n                        source: {\n                            kind: NodeKind.HogQLQuery,\n                            query: surveysShownHogqlQuery,\n                        },\n                        showTimings: false,\n                    },\n                    surveysDismissed: {\n                        kind: NodeKind.DataTableNode,\n                        source: {\n                            kind: NodeKind.HogQLQuery,\n                            query: surveysDismissedHogqlQuery,\n                        },\n                        showTimings: false,\n                    },\n                }\n            },\n        ],\n        surveyRatingQuery: [\n            (s) => [s.survey, s.surveyResponseProperty],\n            (survey, surveyResponseProperty): InsightVizNode | null => {\n                if (survey.id === 'new') {\n                    return null\n                }\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                return {\n                    kind: NodeKind.InsightVizNode,\n                    source: {\n                        kind: NodeKind.TrendsQuery,\n                        dateRange: {\n                            date_from: startDate,\n                            date_to: endDate,\n                        },\n                        properties: [\n                            {\n                                type: PropertyFilterType.Event,\n                                key: '$survey_id',\n                                operator: PropertyOperator.Exact,\n                                value: survey.id,\n                            },\n                        ],\n                        series: [{ event: SURVEY_EVENT_NAME, kind: NodeKind.EventsNode }],\n                        trendsFilter: { display: ChartDisplayType.ActionsBarValue },\n                        breakdown: { breakdown: surveyResponseProperty, breakdown_type: 'event' },\n                    },\n                    showTable: true,\n                }\n            },\n        ],\n        surveyMultipleChoiceQuery: [\n            (s) => [s.survey, s.surveyResponseProperty, s.currentQuestionIndexAndType],\n            (survey, surveyResponseProperty, currentQuestionIndexAndType): DataTableNode | null => {\n                if (survey.id === 'new') {\n                    return null\n                }\n\n                const startDate = dayjs((survey as Survey).created_at).format('YYYY-MM-DD')\n                const endDate = survey.end_date\n                    ? dayjs(survey.end_date).add(1, 'day').format('YYYY-MM-DD')\n                    : dayjs().add(1, 'day').format('YYYY-MM-DD')\n\n                const singleChoiceQuery = `select count(), properties.${surveyResponseProperty} as choice from events where event == 'survey sent' and properties.$survey_id == '${survey.id}' and timestamp >= '${startDate}' and timestamp <= '${endDate}' group by choice order by count() desc`\n                const multipleChoiceQuery = `select count(), arrayJoin(JSONExtractArrayRaw(properties, '${surveyResponseProperty}')) as choice from events where event == 'survey sent' and properties.$survey_id == '${survey.id}' and timestamp >= '${startDate}' and timestamp <= '${endDate}'  group by choice order by count() desc`\n                return {\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.HogQLQuery,\n                        query:\n                            currentQuestionIndexAndType.type === SurveyQuestionType.SingleChoice\n                                ? singleChoiceQuery\n                                : multipleChoiceQuery,\n                    },\n                    showTimings: false,\n                }\n            },\n        ],\n        hasTargetingFlag: [\n            (s) => [s.survey],\n            (survey): boolean => {\n                return !!survey.targeting_flag || !!survey.targeting_flag_filters\n            },\n        ],\n        urlMatchTypeValidationError: [\n            (s) => [s.survey],\n            (survey): string | null => {\n                if (survey.conditions?.urlMatchType === SurveyUrlMatchType.Regex && survey.conditions.url) {\n                    try {\n                        new RegExp(survey.conditions.url)\n                    } catch (e: any) {\n                        return e.message\n                    }\n                }\n                return null\n            },\n        ],\n    }),\n    forms(({ actions, props, values }) => ({\n        survey: {\n            defaults: { ...NEW_SURVEY } as NewSurvey | Survey,\n            errors: ({ name, questions }) => ({\n                name: !name && 'Please enter a name.',\n                questions: questions.map((question) => ({\n                    question: !question.question && 'Please enter a question.',\n                    ...(question.type === SurveyQuestionType.Link\n                        ? { link: !question.link && 'Please enter a url for the link.' }\n                        : {}),\n                    ...(question.type === SurveyQuestionType.Rating\n                        ? {\n                              display: !question.display && 'Please choose a display type.',\n                              scale: !question.scale && 'Please choose a scale.',\n                          }\n                        : {}),\n                })),\n                // controlled using a PureField in the form\n                urlMatchType: values.urlMatchTypeValidationError,\n            }),\n            submit: async (surveyPayload) => {\n                let surveyPayloadWithTargetingFlagFilters = surveyPayload\n                const flagLogic = featureFlagLogic({ id: values.survey.targeting_flag?.id || 'new' })\n                if (values.hasTargetingFlag) {\n                    const targetingFlag = flagLogic.values.featureFlag\n                    surveyPayloadWithTargetingFlagFilters = {\n                        ...surveyPayload,\n                        ...{ targeting_flag_filters: targetingFlag.filters },\n                    }\n                }\n                if (props.id && props.id !== 'new') {\n                    actions.updateSurvey(surveyPayloadWithTargetingFlagFilters)\n                } else {\n                    actions.createSurvey(surveyPayloadWithTargetingFlagFilters)\n                }\n            },\n        },\n    })),\n    urlToAction(({ actions, props }) => ({\n        [urls.survey(props.id ?? 'new')]: (_, __, ___, { method }) => {\n            // If the URL was pushed (user clicked on a link), reset the scene's data.\n            // This avoids resetting form fields if you click back/forward.\n            if (method === 'PUSH') {\n                if (props.id) {\n                    actions.loadSurvey()\n                } else {\n                    actions.resetSurvey()\n                }\n            }\n        },\n    })),\n    afterMount(async ({ props, actions }) => {\n        if (props.id !== 'new') {\n            await actions.loadSurvey()\n        }\n        if (props.id === 'new') {\n            await actions.resetSurvey()\n        }\n    }),\n])\n\nfunction sanitizeQuestions(surveyPayload: Partial<Survey>): Partial<Survey> {\n    if (!surveyPayload.questions) {\n        return surveyPayload\n    }\n    return {\n        ...surveyPayload,\n        questions: surveyPayload.questions?.map((rawQuestion) => {\n            return {\n                ...rawQuestion,\n                description: sanitize(rawQuestion.description || ''),\n                question: sanitize(rawQuestion.question || ''),\n            }\n        }),\n    }\n}\n"],"names":[],"sourceRoot":""}