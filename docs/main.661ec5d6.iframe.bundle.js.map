{"version":3,"file":"main.661ec5d6.iframe.bundle.js","mappings":";AA8PA;AACA;AA+GA;AAAA;;;;;;;AC9UA;ACmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACgLA;;;;;;;;;ACYA;AA+JA;AACA;AACA;AACA;AACA;AACA;;;;AC/XA;;;;AAoBA;;AAEA;ACsEA;AAAA;ACpFA;AASA;AAOA;AAuBA;AAaA;AAOA;AA+eA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AC5eA;AC1EA;AAAA;AC8NA;AACA;AACA;AACA;AACA;ACrEA;AACA;AAMA;AACA;AAMA;AACA;;;;;;AC7LA;ACmRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAmDA;AACA;AACA;AACA;AACA;AACA;AACA;AClVA;AACA;AACA;AC+CA;ACumBA;AACA;AC0gBA;AAAA;AC/qCA;AAqBA;AAMA;AASA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AAEA;AAEA;AACA;AAUA;AACA;AACA;AACA;AA6BA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAUA;AACA;AACA;AACA;AAuBA;AAMA;AASA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AAsBA;AAMA;AASA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AASA;AACA;AACA;AACA;AA2BA;AAMA;AASA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AASA;AACA;AACA;AACA;AA+BA;AAMA;AASA;AACA;AAEA;AACA;AAOA;AAKA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA8BA;AACA;AACA;AAuBA;AACA;AACA;AAsBA;AACA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AASA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AA2BA;AACA;AACA;AAIA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtpBA;ACmLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACnKA;;;;;;;;ACnEA;;;;;;;;;;;;;ACMA;ACaA;AACA;AACA;AACA;AACA;AChBA;AACA;AAQA;AAEA;AACA;AACA;AC0zCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChmCA;AACA;AACA;;AAEA;;;AAKA;AACA;;AAEA;;;;;;;AAyFA;AACA;AACA;AACA;ACpSA;AAAA;;;;;;;;;;;;;AChDA;AACA;;;;;AAKA;AACA;AACA;AC2EA;AC3EA;AAAA;AAAA;ACjCA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC0kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoWA;AA4BA;AAeA;AACA;AACA;ACt7BA;AACA;AACA;AACA;AAIA;AACA;AACA;AAsIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AACA;AACA;AChQA;AASA;AASA;AACA;AACA;AC8GA;AAAA;AAKA;AAAA;AAMA;AAAA;AAUA;AAAA","sources":["webpack://@posthog/storybook/common/hogvm/typescript/src/stl/print.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/ReverseProxyChecker/reverseProxyCheckerLogic.ts","webpack://@posthog/storybook/../../frontend/src/layout/panel-layout/ProjectDropdownMenu.tsx","webpack://@posthog/storybook/../../frontend/src/lib/components/Alerts/views/EditAlertModal.tsx","webpack://@posthog/storybook/../../frontend/src/lib/components/AuthorizedUrlList/authorizedUrlListLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/Metalytics/metalyticsLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/Support/SupportForm.tsx","webpack://@posthog/storybook/../../frontend/src/lib/components/Support/supportLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/VersionChecker/versionCheckerLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/lemon-ui/LemonTextArea/LemonTextAreaMarkdown.tsx","webpack://@posthog/storybook/../../frontend/src/lib/monaco/CodeEditor.tsx","webpack://@posthog/storybook/../../frontend/src/lib/ui/Button/ButtonPrimitives.tsx","webpack://@posthog/storybook/../../frontend/src/lib/utils/cssEscape.ts","webpack://@posthog/storybook/../../frontend/src/queries/examples.ts","webpack://@posthog/storybook/../../frontend/src/scenes/insights/filters/RetentionCumulativeButton.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/paths/renderPaths.ts","webpack://@posthog/storybook/../../frontend/src/scenes/billing/billingLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/experiments/experimentLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/feature-flags/FeatureFlagSnippets.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/notebooks/Nodes/NotebookNodeReplayTimestamp.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/notebooks/Notebook/SlashCommands.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/components/replayActiveHoursHeatMapLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/components/replayActiveScreensTableLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/components/replayActiveUsersTableLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/player/controller/UserActivity.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/player/sidebar/PlayerSidebarSessionSummary.tsx","webpack://@posthog/storybook/../../ee/frontend/mobile-replay/transformer/transformers.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/player/sessionRecordingDataLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/player/share/playerShareLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/playlist/sessionRecordingsListPropertiesLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/settings/environment/ManagedReverseProxy.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/settings/organization/VerifiedDomains/ConfigureSAMLModal.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/surveys/SurveySQLHelper.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/surveys/surveyLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/surveys/utils.ts","webpack://@posthog/storybook/../../products/early_access_features/frontend/InstructionsModal.tsx","webpack://@posthog/storybook/../../products/llm_observability/frontend/llmObservabilityPlaygroundLogic.ts"],"sourcesContent":["import { isHogAST, isHogCallable, isHogClosure, isHogDate, isHogDateTime, isHogError } from '../objects'\nimport { convertJSToHog } from '../utils'\n\nconst escapeCharsMap: Record<string, string> = {\n    '\\b': '\\\\b',\n    '\\f': '\\\\f',\n    '\\r': '\\\\r',\n    '\\n': '\\\\n',\n    '\\t': '\\\\t',\n    '\\0': '\\\\0',\n    '\\v': '\\\\v',\n    '\\\\': '\\\\\\\\',\n}\n\nconst singlequoteEscapeCharsMap: Record<string, string> = {\n    ...escapeCharsMap,\n    \"'\": \"\\\\'\",\n}\n\nconst backquoteEscapeCharsMap: Record<string, string> = {\n    ...escapeCharsMap,\n    '`': '\\\\`',\n}\n\nexport function escapeString(value: string): string {\n    return `'${value\n        .split('')\n        .map((c) => singlequoteEscapeCharsMap[c] || c)\n        .join('')}'`\n}\n\nexport function escapeIdentifier(identifier: string | number): string {\n    if (typeof identifier === 'number') {\n        return identifier.toString()\n    }\n    if (/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(identifier)) {\n        return identifier\n    }\n    return `\\`${identifier\n        .split('')\n        .map((c) => backquoteEscapeCharsMap[c] || c)\n        .join('')}\\``\n}\n\nexport function printHogValue(obj: any, marked: Set<any> | undefined = undefined): string {\n    if (!marked) {\n        marked = new Set()\n    }\n    if (typeof obj === 'object' && obj !== null && obj !== undefined) {\n        if (\n            marked.has(obj) &&\n            !isHogDateTime(obj) &&\n            !isHogDate(obj) &&\n            !isHogError(obj) &&\n            !isHogClosure(obj) &&\n            !isHogCallable(obj) &&\n            !isHogAST(obj)\n        ) {\n            return 'null'\n        }\n        marked.add(obj)\n        try {\n            if (Array.isArray(obj)) {\n                if ((obj as any).__isHogTuple) {\n                    if (obj.length < 2) {\n                        return `tuple(${obj.map((o) => printHogValue(o, marked)).join(', ')})`\n                    }\n                    return `(${obj.map((o) => printHogValue(o, marked)).join(', ')})`\n                }\n                return `[${obj.map((o) => printHogValue(o, marked)).join(', ')}]`\n            }\n            if (isHogDateTime(obj)) {\n                const millis = String(obj.dt)\n                return `DateTime(${millis}${millis.includes('.') ? '' : '.0'}, ${escapeString(obj.zone)})`\n            }\n            if (isHogDate(obj)) {\n                return `Date(${obj.year}, ${obj.month}, ${obj.day})`\n            }\n            if (isHogError(obj)) {\n                return `${String(obj.type)}(${escapeString(obj.message)}${\n                    obj.payload ? `, ${printHogValue(obj.payload, marked)}` : ''\n                })`\n            }\n            if (isHogClosure(obj)) {\n                return printHogValue(obj.callable, marked)\n            }\n            if (isHogCallable(obj)) {\n                return `fn<${escapeIdentifier(obj.name ?? 'lambda')}(${printHogValue(obj.argCount)})>`\n            }\n            if (isHogAST(obj)) {\n                return `sql(${new HogQLPrinter(false, marked).print(obj)})`\n            }\n            if (obj instanceof Map) {\n                return `{${Array.from(obj.entries())\n                    .map(([key, value]) => `${printHogValue(key, marked)}: ${printHogValue(value, marked)}`)\n                    .join(', ')}}`\n            }\n            return `{${Object.entries(obj)\n                .map(([key, value]) => `${printHogValue(key, marked)}: ${printHogValue(value, marked)}`)\n                .join(', ')}}`\n        } finally {\n            marked.delete(obj)\n        }\n    } else if (typeof obj === 'boolean') {\n        return obj ? 'true' : 'false'\n    } else if (obj === null || obj === undefined) {\n        return 'null'\n    } else if (typeof obj === 'string') {\n        return escapeString(obj)\n    }\n    return obj.toString()\n}\n\nexport function printHogStringOutput(obj: any): string {\n    if (typeof obj === 'string') {\n        return obj\n    }\n    return printHogValue(obj)\n}\n\ntype ASTNode = Map<string, any> | null\n\n// Note: this printer currently is experimental and used for debugging/printing SQL only.\n// When making queries via run(query), we send the AST nodes directly to the server.\nexport class HogQLPrinter {\n    private stack: ASTNode[] = []\n    private indentLevel: number = -1\n    private tabSize: number = 4\n    private pretty: boolean\n    private marked: Set<any>\n\n    constructor(pretty: boolean = false, marked: Set<any> | undefined = undefined) {\n        this.pretty = pretty\n        this.marked = marked || new Set()\n    }\n\n    private indent(extra: number = 0): string {\n        return ' '.repeat(this.tabSize * (this.indentLevel + extra))\n    }\n\n    public print(node: ASTNode): string {\n        return this.visit(node)\n    }\n\n    private visit(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        if (!(node instanceof Map)) {\n            if (isHogAST(node)) {\n                node = convertJSToHog(node)\n            } else {\n                return this.escapeValue(node)\n            }\n        }\n\n        this.stack.push(node)\n        this.indentLevel += 1\n\n        let result: string\n        const nodeType = node?.get('__hx_ast') as string | undefined\n\n        if (!nodeType) {\n            throw new Error('Node type is missing or undefined.')\n        }\n\n        switch (nodeType) {\n            case 'SelectQuery':\n                result = this.visitSelectQuery(node)\n                break\n            case 'SelectSetQuery':\n                result = this.visitSelectSetQuery(node)\n                break\n            case 'Call':\n                result = this.visitCall(node)\n                break\n            case 'Constant':\n                result = this.visitConstant(node)\n                break\n            case 'Field':\n                result = this.visitField(node)\n                break\n            case 'Alias':\n                result = this.visitAlias(node)\n                break\n            case 'And':\n                result = this.visitAnd(node)\n                break\n            case 'Or':\n                result = this.visitOr(node)\n                break\n            case 'Not':\n                result = this.visitNot(node)\n                break\n            case 'CompareOperation':\n                result = this.visitCompareOperation(node)\n                break\n            case 'Tuple':\n                result = this.visitTuple(node)\n                break\n            case 'Array':\n                result = this.visitArray(node)\n                break\n            case 'Lambda':\n                result = this.visitLambda(node)\n                break\n            case 'OrderExpr':\n                result = this.visitOrderExpr(node)\n                break\n            case 'ArithmeticOperation':\n                result = this.visitArithmeticOperation(node)\n                break\n            case 'Asterisk':\n                result = this.visitAsterisk(node)\n                break\n            case 'JoinExpr':\n                result = this.visitJoinExpr(node)\n                break\n            case 'JoinConstraint':\n                result = this.visitJoinConstraint(node)\n                break\n            case 'WindowExpr':\n                result = this.visitWindowExpr(node)\n                break\n            case 'WindowFunction':\n                result = this.visitWindowFunction(node)\n                break\n            case 'WindowFrameExpr':\n                result = this.visitWindowFrameExpr(node)\n                break\n            case 'SampleExpr':\n                result = this.visitSampleExpr(node)\n                break\n            case 'RatioExpr':\n                result = this.visitRatioExpr(node)\n                break\n            default:\n                throw new Error(`Unknown AST node type: ${nodeType}`)\n        }\n\n        this.indentLevel -= 1\n        this.stack.pop()\n\n        return result\n    }\n\n    private visitSelectQuery(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const isTopLevelQuery = this.stack.length <= 1\n\n        const selectNodes = node.get('select') as ASTNode[] | undefined\n        const selectExpressions = selectNodes ? selectNodes.map((expr) => this.visit(expr)) : []\n        const space = this.pretty ? `\\n${this.indent(1)}` : ' '\n        const comma = this.pretty ? `,\\n${this.indent(1)}` : ', '\n\n        const clauses: string[] = [\n            `SELECT${node.get('distinct') ? ' DISTINCT' : ''}${space}${selectExpressions.join(comma)}`,\n        ]\n\n        if (node.has('select_from')) {\n            const fromExpr = this.visitJoinExpression(node.get('select_from'))\n            if (fromExpr) {\n                clauses.push(`FROM${space}${fromExpr}`)\n            }\n        }\n\n        if (node.has('prewhere')) {\n            const prewhereExpr = this.visit(node.get('prewhere'))\n            if (prewhereExpr) {\n                clauses.push(`PREWHERE${space}${prewhereExpr}`)\n            }\n        }\n\n        if (node.has('where')) {\n            const whereExpr = this.visit(node.get('where'))\n            if (whereExpr) {\n                clauses.push(`WHERE${space}${whereExpr}`)\n            }\n        }\n\n        if (\n            node.has('group_by') &&\n            Array.isArray(node.get('group_by')) &&\n            (node.get('group_by') as ASTNode[]).length > 0\n        ) {\n            const groupByExpressions = (node.get('group_by') as ASTNode[]).map((expr) => this.visit(expr))\n            clauses.push(`GROUP BY${space}${groupByExpressions.join(comma)}`)\n        }\n\n        if (node.has('having')) {\n            const havingExpr = this.visit(node.get('having'))\n            if (havingExpr) {\n                clauses.push(`HAVING${space}${havingExpr}`)\n            }\n        }\n\n        if (\n            node.has('order_by') &&\n            Array.isArray(node.get('order_by')) &&\n            (node.get('order_by') as ASTNode[]).length > 0\n        ) {\n            const orderByExpressions = (node.get('order_by') as ASTNode[]).map((expr) => this.visit(expr))\n            clauses.push(`ORDER BY${space}${orderByExpressions.join(comma)}`)\n        }\n\n        if (node.has('limit')) {\n            const limitExpr = this.visit(node.get('limit'))\n            if (limitExpr) {\n                clauses.push(`LIMIT ${limitExpr}`)\n            }\n            if (node.get('limit_with_ties')) {\n                clauses.push('WITH TIES')\n            }\n            if (node.has('offset')) {\n                const offsetExpr = this.visit(node.get('offset'))\n                if (offsetExpr) {\n                    clauses.push(`OFFSET ${offsetExpr}`)\n                }\n            }\n        }\n\n        if (node.has('window_exprs')) {\n            const windowExprs = node.get('window_exprs') as Map<string, ASTNode> | undefined\n            if (windowExprs) {\n                const windowExpressions = Array.from(windowExprs.entries())\n                    .map(([name, expr]) => `${escapeIdentifier(name)} AS (${this.visit(expr)})`)\n                    .join(comma)\n                if (windowExpressions) {\n                    clauses.push(`WINDOW${space}${windowExpressions}`)\n                }\n            }\n        }\n\n        let response = this.pretty ? clauses.map((clause) => `${this.indent()}${clause}`).join('\\n') : clauses.join(' ')\n\n        if (!isTopLevelQuery) {\n            response = `(${response})`\n        }\n\n        return response\n    }\n\n    private visitSelectSetQuery(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        this.indentLevel -= 1\n        const initialSelectQuery = node.get('initial_select_query') as ASTNode\n        let result = this.visit(initialSelectQuery)\n\n        if (this.pretty) {\n            result = result.trim()\n        }\n\n        const subsequentQueries = node.get('subsequent_select_queries') as {\n            select_query: ASTNode\n            set_operator: string\n        }[]\n        if (subsequentQueries) {\n            for (const expr of subsequentQueries) {\n                const query = this.visit(expr.select_query)\n                const trimmedQuery = this.pretty ? query.trim() : query\n\n                if (expr.set_operator) {\n                    if (this.pretty) {\n                        result += `\\n${this.indent(1)}${expr.set_operator}\\n${this.indent(1)}`\n                    } else {\n                        result += ` ${expr.set_operator} `\n                    }\n                }\n                result += trimmedQuery\n            }\n        }\n        this.indentLevel += 1\n\n        if (this.stack.length > 1) {\n            return `(${result.trim()})`\n        }\n        return result\n    }\n\n    // Helper method to handle join expressions in the FROM clause\n    private visitJoinExpression(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const nodeType = node.get('__hx_ast') as string\n\n        if (nodeType === 'JoinExpr') {\n            return this.visitJoinExpr(node)\n        }\n        // If it's not a JoinExpr, treat it as a regular table or subquery\n        return this.visit(node)\n    }\n\n    private visitJoinExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const joinParts: string[] = []\n\n        // Handle the initial table or subquery\n        const initialTable = this.visit(node.get('table'))\n\n        // Add alias if present\n        if (node.has('alias') && node.get('alias') !== initialTable) {\n            joinParts.push(`${initialTable} AS ${escapeIdentifier(node.get('alias'))}`)\n        } else {\n            joinParts.push(initialTable)\n        }\n\n        // Process the chain of joins via next_join\n        let currentJoin = node.get('next_join') as ASTNode | undefined\n        while (currentJoin) {\n            const joinType = currentJoin.get('join_type') || 'JOIN'\n            const table = this.visit(currentJoin.get('table'))\n            const constraint = currentJoin.get('constraint') as ASTNode | undefined\n            const constraintClause = constraint ? `${constraint.get('constraint_type')} ${this.visit(constraint)}` : ''\n\n            // Add alias if present\n            let tableWithAlias = table\n            if (currentJoin.has('alias') && currentJoin.get('alias') !== table) {\n                tableWithAlias = `${table} AS ${escapeIdentifier(currentJoin.get('alias'))}`\n            }\n\n            joinParts.push(`${joinType} ${tableWithAlias} ${constraintClause}`.trim())\n\n            currentJoin = currentJoin.get('next_join') as ASTNode | undefined\n        }\n\n        return joinParts.join(' ')\n    }\n\n    private visitJoinConstraint(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        return this.visit(node.get('expr'))\n    }\n\n    private visitCall(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const name = node.get('name') as string\n        const args = (node.get('args') as ASTNode[])?.map((arg) => this.visit(arg)) || []\n        return `${name}(${args.join(', ')})`\n    }\n\n    private visitConstant(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const value = node.get('value')\n        return this.escapeValue(value)\n    }\n\n    private visitField(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const chain = node.get('chain') as Array<string | number>\n        if (chain.length === 1 && chain[0] === '*') {\n            return '*'\n        }\n        return chain.map((identifier) => this.escapeIdentifierOrIndex(identifier)).join('.')\n    }\n\n    private visitAlias(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        if (node.get('hidden')) {\n            return this.visit(node.get('expr'))\n        }\n        let expr = node.get('expr') as ASTNode\n        while (expr && expr instanceof Map && expr.get('__hx_ast') === 'Alias' && expr.get('hidden')) {\n            expr = expr.get('expr')\n        }\n        const inside = this.visit(expr)\n        const alias = escapeIdentifier(node.get('alias') as string)\n        return `${inside} AS ${alias}`\n    }\n\n    private visitAnd(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const exprs = node.get('exprs') as ASTNode[] | undefined\n        if (!exprs || exprs.length === 0) {\n            return ''\n        }\n        if (exprs.length === 1) {\n            return this.visit(exprs[0])\n        }\n        const expressions = exprs.map((expr) => this.visit(expr))\n        return `and(${expressions.join(', ')})`\n    }\n\n    private visitOr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const exprs = node.get('exprs') as ASTNode[] | undefined\n        if (!exprs || exprs.length === 0) {\n            return ''\n        }\n        if (exprs.length === 1) {\n            return this.visit(exprs[0])\n        }\n        const expressions = exprs.map((expr) => this.visit(expr))\n        return `or(${expressions.join(', ')})`\n    }\n\n    private visitNot(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        return `not(${this.visit(node.get('expr'))})`\n    }\n\n    private visitCompareOperation(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const left = this.visit(node.get('left'))\n        const right = this.visit(node.get('right'))\n        const op = node.get('op') as string\n        const opMap: { [key: string]: string } = {\n            '==': 'equals',\n            '!=': 'notEquals',\n            '<': 'less',\n            '>': 'greater',\n            '<=': 'lessOrEquals',\n            '>=': 'greaterOrEquals',\n            in: 'in',\n            'not in': 'notIn',\n            like: 'like',\n            'not like': 'notLike',\n            ilike: 'ilike',\n            'not ilike': 'notILike',\n            '=~': 'match',\n            '!~': 'match',\n            '=~*': 'match',\n            '!~*': 'match',\n        }\n\n        const functionName = opMap[op] || op\n        if (op === '!~*') {\n            return `not(${functionName}(${left}, concat('(?i)', ${right})))`\n        }\n        if (op === '=~*') {\n            return `${functionName}(${left}, concat('(?i)', ${right}))`\n        }\n        if (op === '!~') {\n            return `not(${functionName}(${left}, ${right}))`\n        }\n        return `${functionName}(${left}, ${right})`\n    }\n\n    private visitTuple(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const exprs = node.get('exprs') as ASTNode[] | undefined\n        if (!exprs) {\n            return ''\n        }\n        const expressions = exprs.map((expr) => this.visit(expr))\n        return `tuple(${expressions.join(', ')})`\n    }\n\n    private visitArray(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const exprs = node.get('exprs') as ASTNode[] | undefined\n        if (!exprs) {\n            return ''\n        }\n        const expressions = exprs.map((expr) => this.visit(expr))\n        return `[${expressions.join(', ')}]`\n    }\n\n    private visitLambda(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const args = node.get('args') as string[] | undefined\n        if (!args || args.length === 0) {\n            throw new Error('Lambdas require at least one argument')\n        }\n        const escapedArgs = args.map((arg) => escapeIdentifier(arg))\n        const argList = escapedArgs.length === 1 ? escapedArgs[0] : `(${escapedArgs.join(', ')})`\n        return `${argList} -> ${this.visit(node.get('expr'))}`\n    }\n\n    private visitOrderExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        return `${this.visit(node.get('expr'))} ${node.get('order')}`\n    }\n\n    private visitArithmeticOperation(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const left = this.visit(node.get('left'))\n        const right = this.visit(node.get('right'))\n        const op = node.get('op') as string\n        switch (op) {\n            case '+':\n                return `plus(${left}, ${right})`\n            case '-':\n                return `minus(${left}, ${right})`\n            case '*':\n                return `multiply(${left}, ${right})`\n            case '/':\n                return `divide(${left}, ${right})`\n            case '%':\n                return `modulo(${left}, ${right})`\n            default:\n                throw new Error(`Unknown ArithmeticOperation operator: ${op}`)\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    private visitAsterisk(_: ASTNode): string {\n        return '*'\n    }\n\n    private visitWindowExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const parts: string[] = []\n        if (\n            node.has('partition_by') &&\n            Array.isArray(node.get('partition_by')) &&\n            (node.get('partition_by') as ASTNode[]).length > 0\n        ) {\n            const partitions = (node.get('partition_by') as ASTNode[]).map((expr) => this.visit(expr)).join(', ')\n            parts.push(`PARTITION BY ${partitions}`)\n        }\n        if (\n            node.has('order_by') &&\n            Array.isArray(node.get('order_by')) &&\n            (node.get('order_by') as ASTNode[]).length > 0\n        ) {\n            const orders = (node.get('order_by') as ASTNode[]).map((expr) => this.visit(expr)).join(', ')\n            parts.push(`ORDER BY ${orders}`)\n        }\n        if (node.has('frame_method')) {\n            const frameMethod = node.get('frame_method') as string\n            if (node.has('frame_start') && node.has('frame_end')) {\n                parts.push(\n                    `${frameMethod} BETWEEN ${this.visitWindowFrameExpr(\n                        node.get('frame_start')\n                    )} AND ${this.visitWindowFrameExpr(node.get('frame_end'))}`\n                )\n            } else if (node.has('frame_start')) {\n                parts.push(`${frameMethod} ${this.visitWindowFrameExpr(node.get('frame_start'))}`)\n            }\n        }\n        return parts.join(' ')\n    }\n\n    private visitWindowFunction(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const name = node.get('name') as string\n        const exprs = node.has('exprs')\n            ? (node.get('exprs') as ASTNode[]).map((expr) => this.visit(expr)).join(', ')\n            : ''\n        const args = node.has('args')\n            ? `(${(node.get('args') as ASTNode[]).map((arg) => this.visit(arg)).join(', ')})`\n            : ''\n        let over = ''\n        if (node.has('over_expr')) {\n            over = `(${this.visit(node.get('over_expr'))})`\n        } else if (node.has('over_identifier')) {\n            over = escapeIdentifier(node.get('over_identifier') as string)\n        } else {\n            over = '()'\n        }\n        return `${name}(${exprs})${args} OVER ${over}`\n    }\n\n    private visitWindowFrameExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const frameType = node.get('frame_type') as string\n        const frameValue = node.has('frame_value') ? node.get('frame_value').toString() : 'UNBOUNDED'\n        return `${frameValue} ${frameType}`\n    }\n\n    private visitSampleExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const sampleValue = this.visitRatioExpr(node.get('sample_value'))\n        const offsetClause = node.has('offset_value') ? ` OFFSET ${this.visitRatioExpr(node.get('offset_value'))}` : ''\n        return `SAMPLE ${sampleValue}${offsetClause}`\n    }\n\n    private visitRatioExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        if (node.has('right')) {\n            return `${this.visit(node.get('left'))}/${this.visit(node.get('right'))}`\n        }\n        return this.visit(node.get('left'))\n    }\n\n    private escapeIdentifierOrIndex(name: string | number): string {\n        if (typeof name === 'number' && /^\\d+$/.test(name.toString())) {\n            return name.toString()\n        }\n        return escapeIdentifier(name.toString())\n    }\n\n    private escapeValue(value: any): string {\n        return printHogValue(value, this.marked)\n    }\n}\n","import { kea, listeners, path } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\n\nimport { ActivationTask } from '~/layout/navigation-3000/sidepanel/panels/activation/activationLogic'\nimport { activationLogic } from '~/layout/navigation-3000/sidepanel/panels/activation/activationLogic'\nimport { hogql } from '~/queries/utils'\n\nimport type { reverseProxyCheckerLogicType } from './reverseProxyCheckerLogicType'\n\nconst CHECK_INTERVAL_MS = 1000 * 60 * 60 // 1 hour\n\nexport const reverseProxyCheckerLogic = kea<reverseProxyCheckerLogicType>([\n    path(['components', 'ReverseProxyChecker', 'reverseProxyCheckerLogic']),\n    loaders(({ values, cache }) => ({\n        hasReverseProxy: [\n            false as boolean | null,\n            {\n                loadHasReverseProxy: async () => {\n                    if (cache.lastCheckedTimestamp > Date.now() - CHECK_INTERVAL_MS) {\n                        return values.hasReverseProxy\n                    }\n\n                    cache.lastCheckedTimestamp = Date.now()\n\n                    const query = hogql`\n                        SELECT DISTINCT properties.$lib_custom_api_host AS lib_custom_api_host\n                        FROM events\n                        WHERE timestamp >= now() - INTERVAL 1 DAY \n                        AND timestamp <= now()\n                        AND properties.$lib_custom_api_host IS NOT NULL\n                        AND event IN ('$pageview', '$screen')\n                        LIMIT 10`\n\n                    const res = await api.queryHogQL(query)\n                    return !!res.results?.find((x) => !!x[0])\n                },\n            },\n        ],\n    })),\n    listeners(({ values }) => ({\n        loadHasReverseProxySuccess: () => {\n            if (values.hasReverseProxy) {\n                activationLogic.findMounted()?.actions.markTaskAsCompleted(ActivationTask.SetUpReverseProxy)\n            }\n        },\n    })),\n])\n","import { IconCheck, IconChevronRight, IconGear, IconPlusSmall } from '@posthog/icons'\nimport { LemonSnack, Link } from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { upgradeModalLogic } from 'lib/components/UpgradeModal/upgradeModalLogic'\nimport { IconBlank } from 'lib/lemon-ui/icons'\nimport { ButtonGroupPrimitive, ButtonPrimitive } from 'lib/ui/Button/ButtonPrimitives'\nimport { Combobox } from 'lib/ui/Combobox/Combobox'\nimport { Label } from 'lib/ui/Label/Label'\nimport {\n    PopoverPrimitive,\n    PopoverPrimitiveContent,\n    PopoverPrimitiveTrigger,\n} from 'lib/ui/PopoverPrimitive/PopoverPrimitive'\nimport { getProjectSwitchTargetUrl } from 'lib/utils/router-utils'\nimport { organizationLogic } from 'scenes/organizationLogic'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { isAuthenticatedTeam, teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { globalModalsLogic } from '~/layout/GlobalModals'\nimport { navigationLogic } from '~/layout/navigation/navigationLogic'\nimport { AvailableFeature, TeamBasicType } from '~/types'\n\nexport function ProjectName({ team }: { team: TeamBasicType }): JSX.Element {\n    return (\n        <div className=\"flex items-center max-w-full\">\n            <span className=\"truncate\">{team.name}</span>\n            {team.is_demo ? <LemonSnack className=\"ml-2 text-xs shrink-0\">Demo</LemonSnack> : null}\n        </div>\n    )\n}\n\nexport function ProjectDropdownMenu(): JSX.Element | null {\n    const { preflight } = useValues(preflightLogic)\n    const { guardAvailableFeature } = useValues(upgradeModalLogic)\n    const { closeAccountPopover } = useActions(navigationLogic)\n    const { showCreateProjectModal } = useActions(globalModalsLogic)\n    const { currentTeam } = useValues(teamLogic)\n    const { currentOrganization, projectCreationForbiddenReason } = useValues(organizationLogic)\n\n    return isAuthenticatedTeam(currentTeam) ? (\n        <PopoverPrimitive>\n            <PopoverPrimitiveTrigger asChild>\n                <ButtonPrimitive\n                    data-attr=\"tree-navbar-project-dropdown-button\"\n                    className=\"flex-1 min-w-0 max-w-fit\"\n                    size=\"sm\"\n                >\n                    <span className=\"truncate font-semibold\">{currentTeam.name ?? 'Project'}</span>\n                    <IconChevronRight\n                        className={`\n                        size-3 \n                        text-secondary \n                        rotate-90 \n                        group-data-[state=open]/button-primitive:rotate-270 \n                        transition-transform \n                        duration-200 \n                        prefers-reduced-motion:transition-none\n                    `}\n                    />\n                </ButtonPrimitive>\n            </PopoverPrimitiveTrigger>\n            <PopoverPrimitiveContent\n                align=\"start\"\n                className=\"w-[var(--project-panel-inner-width)] max-w-[var(--project-panel-inner-width)]\"\n            >\n                <Combobox>\n                    <Combobox.Search placeholder=\"Filter projects...\" />\n                    <Combobox.Content className=\"max-h-[calc(90vh-100px)]\">\n                        <Label intent=\"menu\" className=\"px-2\">\n                            Projects\n                        </Label>\n                        <div className=\"-mx-1 my-1 h-px bg-border-primary shrink-0\" />\n\n                        <Combobox.Empty>No projects found</Combobox.Empty>\n\n                        <Combobox.Group value={[currentTeam.name]}>\n                            <ButtonGroupPrimitive fullWidth>\n                                <Combobox.Item asChild>\n                                    <ButtonPrimitive\n                                        menuItem\n                                        active\n                                        hasSideActionRight\n                                        tooltip={`Current project: ${currentTeam.name}`}\n                                        tooltipPlacement=\"right\"\n                                        data-attr=\"tree-navbar-project-dropdown-current-project-button\"\n                                        className=\"pr-12\"\n                                    >\n                                        <IconCheck className=\"text-tertiary\" />\n                                        <ProjectName team={currentTeam} />\n                                    </ButtonPrimitive>\n                                </Combobox.Item>\n\n                                <Combobox.Item asChild>\n                                    <Link\n                                        buttonProps={{\n                                            iconOnly: true,\n                                            isSideActionRight: true,\n                                        }}\n                                        tooltip={`View settings for project: ${currentTeam.name}`}\n                                        tooltipPlacement=\"right\"\n                                        to={urls.project(currentTeam.id, urls.settings('project'))}\n                                        data-attr=\"tree-navbar-project-dropdown-current-project-settings-button\"\n                                    >\n                                        <IconGear className=\"text-tertiary\" />\n                                    </Link>\n                                </Combobox.Item>\n                            </ButtonGroupPrimitive>\n                        </Combobox.Group>\n\n                        {currentOrganization?.teams &&\n                            currentOrganization.teams\n                                .filter((team) => team.id !== currentTeam?.id)\n                                .sort((teamA, teamB) => teamA.name.localeCompare(teamB.name))\n                                .map((team) => {\n                                    const relativeOtherProjectPath = getProjectSwitchTargetUrl(\n                                        location.pathname,\n                                        team.id,\n                                        currentTeam?.project_id,\n                                        team.project_id\n                                    )\n\n                                    return (\n                                        <Combobox.Group value={[team.name]} key={team.id}>\n                                            <ButtonGroupPrimitive menuItem fullWidth>\n                                                <Combobox.Item asChild>\n                                                    <Link\n                                                        buttonProps={{\n                                                            menuItem: true,\n                                                            hasSideActionRight: true,\n                                                            className: 'pr-12',\n                                                        }}\n                                                        tooltip={`Switch to project: ${team.name}`}\n                                                        tooltipPlacement=\"right\"\n                                                        to={relativeOtherProjectPath}\n                                                        data-attr=\"tree-navbar-project-dropdown-other-project-button\"\n                                                    >\n                                                        <IconBlank />\n                                                        <ProjectName team={team} />\n                                                    </Link>\n                                                </Combobox.Item>\n\n                                                <Combobox.Item asChild>\n                                                    <Link\n                                                        buttonProps={{\n                                                            iconOnly: true,\n                                                            isSideActionRight: true,\n                                                        }}\n                                                        tooltip={`View settings for project: ${team.name}`}\n                                                        tooltipPlacement=\"right\"\n                                                        to={urls.project(team.id, urls.settings('project'))}\n                                                        data-attr=\"tree-navbar-project-dropdown-other-project-settings-button\"\n                                                    >\n                                                        <IconGear />\n                                                    </Link>\n                                                </Combobox.Item>\n                                            </ButtonGroupPrimitive>\n                                        </Combobox.Group>\n                                    )\n                                })}\n\n                        {preflight?.can_create_org && (\n                            <Combobox.Item\n                                asChild\n                                onClick={() =>\n                                    guardAvailableFeature(AvailableFeature.ORGANIZATIONS_PROJECTS, () => {\n                                        closeAccountPopover()\n                                        showCreateProjectModal()\n                                    })\n                                }\n                            >\n                                <ButtonPrimitive\n                                    menuItem\n                                    data-attr=\"new-project-button\"\n                                    tooltip=\"Create a new project\"\n                                    tooltipPlacement=\"right\"\n                                    className=\"shrink-0\"\n                                    disabled={!!projectCreationForbiddenReason}\n                                >\n                                    <IconPlusSmall className=\"text-tertiary\" />\n                                    New project\n                                </ButtonPrimitive>\n                            </Combobox.Item>\n                        )}\n                    </Combobox.Content>\n                </Combobox>\n            </PopoverPrimitiveContent>\n        </PopoverPrimitive>\n    ) : null\n}\n","import { IconInfo } from '@posthog/icons'\nimport {\n    LemonBanner,\n    LemonCheckbox,\n    LemonCollapse,\n    LemonInput,\n    LemonSegmentedButton,\n    LemonSelect,\n    SpinnerOverlay,\n    Tooltip,\n} from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { Form, Group } from 'kea-forms'\nimport { AlertStateIndicator } from 'lib/components/Alerts/views/ManageAlertsModal'\nimport { MemberSelectMultiple } from 'lib/components/MemberSelectMultiple'\nimport { TZLabel } from 'lib/components/TZLabel'\nimport { UserActivityIndicator } from 'lib/components/UserActivityIndicator/UserActivityIndicator'\nimport { dayjs } from 'lib/dayjs'\nimport { IconChevronLeft } from 'lib/lemon-ui/icons'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonModal } from 'lib/lemon-ui/LemonModal'\nimport { alphabet, formatDate } from 'lib/utils'\nimport { useCallback } from 'react'\nimport { trendsDataLogic } from 'scenes/trends/trendsDataLogic'\n\nimport {\n    AlertCalculationInterval,\n    AlertConditionType,\n    AlertState,\n    InsightThresholdType,\n} from '~/queries/schema/schema-general'\nimport { InsightLogicProps, InsightShortId, QueryBasedInsightModel } from '~/types'\n\nimport { alertFormLogic, canCheckOngoingInterval } from '../alertFormLogic'\nimport { alertLogic } from '../alertLogic'\nimport { SnoozeButton } from '../SnoozeButton'\nimport { AlertType } from '../types'\nimport { AlertDestinationSelector } from './AlertDestinationSelector'\n\nfunction alertCalculationIntervalToLabel(interval: AlertCalculationInterval): string {\n    switch (interval) {\n        case AlertCalculationInterval.HOURLY:\n            return 'hour'\n        case AlertCalculationInterval.DAILY:\n            return 'day'\n        case AlertCalculationInterval.WEEKLY:\n            return 'week'\n        case AlertCalculationInterval.MONTHLY:\n            return 'month'\n    }\n}\n\nexport function AlertStateTable({ alert }: { alert: AlertType }): JSX.Element | null {\n    if (!alert.checks || alert.checks.length === 0) {\n        return null\n    }\n\n    return (\n        <div className=\"bg-primary p-4 mt-10 rounded-lg\">\n            <div className=\"flex flex-row gap-2 items-center mb-2\">\n                <h3 className=\"m-0\">Current status: </h3>\n                <AlertStateIndicator alert={alert} />\n                <h3 className=\"m-0\">\n                    {alert.snoozed_until && ` until ${formatDate(dayjs(alert?.snoozed_until), 'MMM D, HH:mm')}`}\n                </h3>\n            </div>\n            <table className=\"w-full table-auto border-spacing-2 border-collapse\">\n                <thead>\n                    <tr className=\"text-left\">\n                        <th>Status</th>\n                        <th className=\"text-right\">Time</th>\n                        <th className=\"text-right pr-4\">Value</th>\n                        <th>Targets notified</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    {alert.checks.map((check) => (\n                        <tr key={check.id}>\n                            <td>{check.state}</td>\n                            <td className=\"text-right\">\n                                <TZLabel time={check.created_at} />\n                            </td>\n                            <td className=\"text-right pr-4\">{check.calculated_value}</td>\n                            <td>{check.targets_notified ? 'Yes' : 'No'}</td>\n                        </tr>\n                    ))}\n                </tbody>\n            </table>\n        </div>\n    )\n}\n\ninterface EditAlertModalProps {\n    isOpen: boolean | undefined\n    alertId?: AlertType['id']\n    insightId: QueryBasedInsightModel['id']\n    insightShortId: InsightShortId\n    onEditSuccess: (alertId?: AlertType['id'] | undefined) => void\n    onClose?: () => void\n    insightLogicProps?: InsightLogicProps\n}\n\nexport function EditAlertModal({\n    isOpen,\n    alertId,\n    insightId,\n    insightShortId,\n    onClose,\n    onEditSuccess,\n    insightLogicProps,\n}: EditAlertModalProps): JSX.Element {\n    const _alertLogic = alertLogic({ alertId })\n    const { alert, alertLoading } = useValues(_alertLogic)\n    const { loadAlert } = useActions(_alertLogic)\n\n    // need to reload edited alert as well\n    const _onEditSuccess = useCallback(\n        (alertId: AlertType['id'] | undefined) => {\n            if (alertId) {\n                loadAlert()\n            }\n            onEditSuccess(alertId)\n        },\n        [loadAlert, onEditSuccess]\n    )\n\n    const formLogicProps = {\n        alert,\n        insightId,\n        onEditSuccess: _onEditSuccess,\n        insightVizDataLogicProps: insightLogicProps,\n    }\n    const formLogic = alertFormLogic(formLogicProps)\n    const { alertForm, isAlertFormSubmitting, alertFormChanged } = useValues(formLogic)\n    const { deleteAlert, snoozeAlert, clearSnooze } = useActions(formLogic)\n    const { setAlertFormValue } = useActions(formLogic)\n\n    const trendsLogic = trendsDataLogic({ dashboardItemId: insightShortId })\n    const {\n        alertSeries,\n        isNonTimeSeriesDisplay,\n        isBreakdownValid,\n        formulaNodes,\n        interval: trendInterval,\n    } = useValues(trendsLogic)\n\n    const creatingNewAlert = alertForm.id === undefined\n    // can only check ongoing interval for absolute value/increase alerts with upper threshold\n    const can_check_ongoing_interval = canCheckOngoingInterval(alertForm)\n\n    return (\n        <LemonModal onClose={onClose} isOpen={isOpen} width={600} simple title=\"\">\n            {alertLoading ? (\n                <SpinnerOverlay />\n            ) : (\n                <Form\n                    logic={alertFormLogic}\n                    props={formLogicProps}\n                    formKey=\"alertForm\"\n                    enableFormOnSubmit\n                    className=\"LemonModal__layout\"\n                >\n                    <LemonModal.Header>\n                        <div className=\"flex items-center gap-2\">\n                            <LemonButton icon={<IconChevronLeft />} onClick={onClose} size=\"xsmall\" />\n\n                            <h3>{creatingNewAlert ? 'New' : 'Edit '} Alert</h3>\n                        </div>\n                    </LemonModal.Header>\n\n                    <LemonModal.Content>\n                        <div className=\"deprecated-space-y-8\">\n                            <div className=\"deprecated-space-y-4\">\n                                <div className=\"flex gap-4 items-center\">\n                                    <LemonField className=\"flex-auto\" name=\"name\">\n                                        <LemonInput placeholder=\"Alert name\" data-attr=\"alertForm-name\" />\n                                    </LemonField>\n                                    <LemonField name=\"enabled\">\n                                        <LemonCheckbox\n                                            checked={alertForm?.enabled}\n                                            data-attr=\"alertForm-enabled\"\n                                            fullWidth\n                                            label=\"Enabled\"\n                                        />\n                                    </LemonField>\n                                </div>\n                                {alert?.created_by ? (\n                                    <UserActivityIndicator\n                                        at={alert.created_at}\n                                        by={alert.created_by}\n                                        prefix=\"Created\"\n                                    />\n                                ) : null}\n                            </div>\n\n                            <div className=\"deprecated-space-y-6\">\n                                <h3>Definition</h3>\n                                <div className=\"deprecated-space-y-5\">\n                                    {isBreakdownValid && (\n                                        <LemonBanner type=\"warning\">\n                                            For trends with breakdown, the alert will fire if any of the breakdown\n                                            values breaches the threshold.\n                                        </LemonBanner>\n                                    )}\n                                    <div className=\"flex gap-4 items-center\">\n                                        <div>When</div>\n                                        <Group name={['config']}>\n                                            <LemonField name=\"series_index\" className=\"flex-auto\">\n                                                <LemonSelect\n                                                    fullWidth\n                                                    data-attr=\"alertForm-series-index\"\n                                                    options={\n                                                        formulaNodes?.length > 0\n                                                            ? formulaNodes.map(({ formula, custom_name }, index) => ({\n                                                                  label: `${\n                                                                      custom_name ? custom_name : 'Formula'\n                                                                  } (${formula})`,\n                                                                  value: index,\n                                                              }))\n                                                            : alertSeries?.map(\n                                                                  ({ custom_name, name, event }, index) => ({\n                                                                      label: isBreakdownValid\n                                                                          ? 'any breakdown value'\n                                                                          : `${alphabet[index]} - ${\n                                                                                custom_name ?? name ?? event\n                                                                            }`,\n                                                                      value: isBreakdownValid ? 0 : index,\n                                                                  })\n                                                              )\n                                                    }\n                                                    disabledReason={\n                                                        isBreakdownValid &&\n                                                        `For trends with breakdown, the alert will fire if any of the breakdown\n                                            values breaches the threshold.`\n                                                    }\n                                                />\n                                            </LemonField>\n                                        </Group>\n                                        <Group name={['condition']}>\n                                            <LemonField name=\"type\">\n                                                <LemonSelect\n                                                    fullWidth\n                                                    className=\"w-40\"\n                                                    data-attr=\"alertForm-condition\"\n                                                    options={[\n                                                        {\n                                                            label: 'has value',\n                                                            value: AlertConditionType.ABSOLUTE_VALUE,\n                                                        },\n                                                        {\n                                                            label: 'increases by',\n                                                            value: AlertConditionType.RELATIVE_INCREASE,\n                                                            disabledReason:\n                                                                isNonTimeSeriesDisplay &&\n                                                                'This condition is only supported for time series trends',\n                                                        },\n                                                        {\n                                                            label: 'decreases by',\n                                                            value: AlertConditionType.RELATIVE_DECREASE,\n                                                            disabledReason:\n                                                                isNonTimeSeriesDisplay &&\n                                                                'This condition is only supported for time series trends',\n                                                        },\n                                                    ]}\n                                                />\n                                            </LemonField>\n                                        </Group>\n                                    </div>\n                                    <div className=\"flex gap-4 items-center\">\n                                        <div>less than</div>\n                                        <LemonField name=\"lower\">\n                                            <LemonInput\n                                                type=\"number\"\n                                                className=\"w-30\"\n                                                data-attr=\"alertForm-lower-threshold\"\n                                                value={\n                                                    alertForm.threshold.configuration.type ===\n                                                        InsightThresholdType.PERCENTAGE &&\n                                                    alertForm.threshold.configuration.bounds?.lower\n                                                        ? alertForm.threshold.configuration.bounds?.lower * 100\n                                                        : alertForm.threshold.configuration.bounds?.lower\n                                                }\n                                                onChange={(value) =>\n                                                    setAlertFormValue('threshold', {\n                                                        configuration: {\n                                                            type: alertForm.threshold.configuration.type,\n                                                            bounds: {\n                                                                ...alertForm.threshold.configuration.bounds,\n                                                                lower:\n                                                                    value &&\n                                                                    alertForm.threshold.configuration.type ===\n                                                                        InsightThresholdType.PERCENTAGE\n                                                                        ? value / 100\n                                                                        : value,\n                                                            },\n                                                        },\n                                                    })\n                                                }\n                                            />\n                                        </LemonField>\n                                        <div>or more than</div>\n                                        <LemonField name=\"upper\">\n                                            <LemonInput\n                                                type=\"number\"\n                                                className=\"w-30\"\n                                                data-attr=\"alertForm-upper-threshold\"\n                                                value={\n                                                    alertForm.threshold.configuration.type ===\n                                                        InsightThresholdType.PERCENTAGE &&\n                                                    alertForm.threshold.configuration.bounds?.upper\n                                                        ? alertForm.threshold.configuration.bounds?.upper * 100\n                                                        : alertForm.threshold.configuration.bounds?.upper\n                                                }\n                                                onChange={(value) =>\n                                                    setAlertFormValue('threshold', {\n                                                        configuration: {\n                                                            type: alertForm.threshold.configuration.type,\n                                                            bounds: {\n                                                                ...alertForm.threshold.configuration.bounds,\n                                                                upper:\n                                                                    value &&\n                                                                    alertForm.threshold.configuration.type ===\n                                                                        InsightThresholdType.PERCENTAGE\n                                                                        ? value / 100\n                                                                        : value,\n                                                            },\n                                                        },\n                                                    })\n                                                }\n                                            />\n                                        </LemonField>\n                                        {alertForm.condition.type !== AlertConditionType.ABSOLUTE_VALUE && (\n                                            <Group name={['threshold', 'configuration']}>\n                                                <LemonField name=\"type\">\n                                                    <LemonSegmentedButton\n                                                        options={[\n                                                            {\n                                                                value: InsightThresholdType.PERCENTAGE,\n                                                                label: '%',\n                                                                tooltip: 'Percent',\n                                                            },\n                                                            {\n                                                                value: InsightThresholdType.ABSOLUTE,\n                                                                label: '#',\n                                                                tooltip: 'Absolute number',\n                                                            },\n                                                        ]}\n                                                    />\n                                                </LemonField>\n                                            </Group>\n                                        )}\n                                    </div>\n                                    <div className=\"flex gap-4 items-center\">\n                                        <div>Run alert every</div>\n                                        <LemonField name=\"calculation_interval\">\n                                            <LemonSelect\n                                                fullWidth\n                                                className=\"w-28\"\n                                                data-attr=\"alertForm-calculation-interval\"\n                                                options={Object.values(AlertCalculationInterval).map((interval) => ({\n                                                    label: alertCalculationIntervalToLabel(interval),\n                                                    value: interval,\n                                                }))}\n                                            />\n                                        </LemonField>\n                                        <div>\n                                            and check {alertForm?.config.check_ongoing_interval ? 'current' : 'last'}\n                                        </div>\n                                        <LemonSelect\n                                            fullWidth\n                                            className=\"w-28\"\n                                            data-attr=\"alertForm-trend-interval\"\n                                            disabledReason={\n                                                <>\n                                                    To change the interval being checked, edit and <b>save</b> the\n                                                    interval which the insight is 'grouped by'\n                                                </>\n                                            }\n                                            value={trendInterval ?? 'day'}\n                                            options={[\n                                                {\n                                                    label: trendInterval ?? 'day',\n                                                    value: trendInterval ?? 'day',\n                                                },\n                                            ]}\n                                        />\n                                    </div>\n                                </div>\n                            </div>\n\n                            <div>\n                                <h3>Notification</h3>\n                                <div className=\"flex gap-4 items-center mt-2\">\n                                    <div>E-mail</div>\n                                    <div className=\"flex-auto\">\n                                        <MemberSelectMultiple\n                                            value={alertForm.subscribed_users?.map((u) => u.id) ?? []}\n                                            idKey=\"id\"\n                                            onChange={(value) => setAlertFormValue('subscribed_users', value)}\n                                        />\n                                    </div>\n                                </div>\n\n                                <h4 className=\"mt-4\">CDP Destinations</h4>\n                                <div className=\"mt-2\">\n                                    {alertId ? (\n                                        <div className=\"flex flex-col\">\n                                            <AlertDestinationSelector alertId={alertId} />\n                                        </div>\n                                    ) : (\n                                        <div className=\"text-muted-alt\">\n                                            Save alert first to add destinations (e.g. Slack, Webhooks)\n                                        </div>\n                                    )}\n                                </div>\n                            </div>\n\n                            <div className=\"deprecated-space-y-2\">\n                                <LemonCollapse\n                                    panels={[\n                                        {\n                                            key: 'advanced',\n                                            header: 'Advanced options',\n                                            content: (\n                                                <div className=\"space-y-2\">\n                                                    <Group name={['config']}>\n                                                        <div className=\"flex gap-1\">\n                                                            <LemonField name=\"check_ongoing_interval\">\n                                                                <LemonCheckbox\n                                                                    checked={\n                                                                        can_check_ongoing_interval &&\n                                                                        alertForm?.config.check_ongoing_interval\n                                                                    }\n                                                                    data-attr=\"alertForm-check-ongoing-interval\"\n                                                                    fullWidth\n                                                                    label=\"Check ongoing period\"\n                                                                    disabledReason={\n                                                                        !can_check_ongoing_interval &&\n                                                                        'Can only alert for ongoing period when checking for absolute value/increase above a set upper threshold.'\n                                                                    }\n                                                                />\n                                                            </LemonField>\n                                                            <Tooltip\n                                                                title={`Checks the insight value for the ongoing period (current week/month) that hasn't yet completed. Use this if you want to be alerted right away when the insight value rises/increases above threshold`}\n                                                                placement=\"right\"\n                                                                delayMs={0}\n                                                            >\n                                                                <IconInfo />\n                                                            </Tooltip>\n                                                        </div>\n                                                    </Group>\n                                                    <LemonField name=\"skip_weekend\">\n                                                        <LemonCheckbox\n                                                            checked={\n                                                                (alertForm?.calculation_interval ===\n                                                                    AlertCalculationInterval.DAILY ||\n                                                                    alertForm?.calculation_interval ===\n                                                                        AlertCalculationInterval.HOURLY) &&\n                                                                alertForm?.skip_weekend\n                                                            }\n                                                            data-attr=\"alertForm-skip-weekend\"\n                                                            fullWidth\n                                                            label=\"Skip checking on weekends\"\n                                                            disabledReason={\n                                                                alertForm?.calculation_interval !==\n                                                                    AlertCalculationInterval.DAILY &&\n                                                                alertForm?.calculation_interval !==\n                                                                    AlertCalculationInterval.HOURLY &&\n                                                                'Can only skip weekend checking for hourly/daily alerts'\n                                                            }\n                                                        />\n                                                    </LemonField>\n                                                </div>\n                                            ),\n                                        },\n                                    ]}\n                                />\n                            </div>\n                        </div>\n\n                        {alert && <AlertStateTable alert={alert} />}\n                    </LemonModal.Content>\n\n                    <LemonModal.Footer>\n                        <div className=\"flex-1\">\n                            <div className=\"flex gap-2\">\n                                {!creatingNewAlert ? (\n                                    <LemonButton type=\"secondary\" status=\"danger\" onClick={deleteAlert}>\n                                        Delete alert\n                                    </LemonButton>\n                                ) : null}\n                                {!creatingNewAlert && alert?.state === AlertState.FIRING ? (\n                                    <SnoozeButton onChange={snoozeAlert} value={alert?.snoozed_until} />\n                                ) : null}\n                                {!creatingNewAlert && alert?.state === AlertState.SNOOZED ? (\n                                    <LemonButton\n                                        type=\"secondary\"\n                                        status=\"default\"\n                                        onClick={clearSnooze}\n                                        tooltip={`Currently snoozed until ${formatDate(\n                                            dayjs(alert?.snoozed_until),\n                                            'MMM D, HH:mm'\n                                        )}`}\n                                    >\n                                        Clear snooze\n                                    </LemonButton>\n                                ) : null}\n                            </div>\n                        </div>\n                        <LemonButton\n                            type=\"primary\"\n                            htmlType=\"submit\"\n                            loading={isAlertFormSubmitting}\n                            disabledReason={!alertFormChanged && 'No changes to save'}\n                        >\n                            {creatingNewAlert ? 'Create alert' : 'Save'}\n                        </LemonButton>\n                    </LemonModal.Footer>\n                </Form>\n            )}\n        </LemonModal>\n    )\n}\n","import {\n    actions,\n    afterMount,\n    connect,\n    kea,\n    key,\n    listeners,\n    path,\n    props,\n    reducers,\n    selectors,\n    sharedListeners,\n} from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { encodeParams, urlToAction } from 'kea-router'\nimport { subscriptions } from 'kea-subscriptions'\nimport api from 'lib/api'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { isDomain, isURL } from 'lib/utils'\nimport { apiHostOrigin } from 'lib/utils/apiHost'\nimport { copyToClipboard } from 'lib/utils/copyToClipboard'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { hogql } from '~/queries/utils'\nimport { ExperimentIdType, ToolbarParams, ToolbarUserIntent } from '~/types'\n\nimport type { authorizedUrlListLogicType } from './authorizedUrlListLogicType'\n\nexport interface ProposeNewUrlFormType {\n    url: string\n}\n\nexport enum AuthorizedUrlListType {\n    TOOLBAR_URLS = 'TOOLBAR_URLS',\n    RECORDING_DOMAINS = 'RECORDING_DOMAINS',\n    WEB_ANALYTICS = 'WEB_ANALYTICS',\n    WEB_EXPERIMENTS = 'WEB_EXPERIMENTS',\n}\n\n/**\n * Firefox does not allow you construct a new URL with e.g. https://*.example.com (which is to be fair more standards compliant than Chrome)\n * when used to probe for e.g. for authorized urls we only care if the proposed URL has a path so we can safely replace the wildcard with a character\n */\nexport function sanitizePossibleWildCardedURL(url: string): URL {\n    const deWildCardedURL = url.replace(/\\*/g, 'x')\n    return new URL(deWildCardedURL)\n}\n\n/**\n * Checks if the URL has a wildcard (*) in the port position e.g. http://localhost:*\n */\nexport function hasWildcardInPort(input: unknown): boolean {\n    if (!input || typeof input !== 'string') {\n        return false\n    }\n    // This regex matches URLs with a wildcard (*) in the port position\n    const portWildcardRegex = /^(https?:\\/\\/[^:/]+):\\*(.*)$/\n    return portWildcardRegex.test(input.trim())\n}\n\nexport const validateProposedUrl = (\n    proposedUrl: string,\n    currentUrls: string[],\n    onlyAllowDomains: boolean = false,\n    allowWildCards: boolean = true\n): string | undefined => {\n    if (!isURL(proposedUrl)) {\n        return 'Please enter a valid URL'\n    }\n\n    if (hasWildcardInPort(proposedUrl)) {\n        return 'Wildcards are not allowed in the port position'\n    }\n\n    if (onlyAllowDomains && !isDomain(sanitizePossibleWildCardedURL(proposedUrl))) {\n        return \"Please enter a valid domain (URLs with a path aren't allowed)\"\n    }\n\n    const hasWildCard = proposedUrl.indexOf('*') > -1\n    if (hasWildCard && allowWildCards === false) {\n        return 'Wildcards are not allowed'\n    }\n\n    if (\n        hasWildCard &&\n        !/^https?:\\/\\/((\\*\\.)?localhost|localhost)(:\\d+)?$/.test(proposedUrl) && // Allow http://*.localhost and localhost with ports\n        !proposedUrl.match(/^(.*)\\*[^*]*\\.[^*]+\\.[^*]+$/)\n    ) {\n        return 'Wildcards can only be used for subdomains'\n    }\n\n    if (currentUrls.indexOf(proposedUrl) > -1) {\n        return `This ${onlyAllowDomains ? 'domains' : 'URL'} already is registered`\n    }\n\n    return\n}\n\nfunction buildToolbarParams(options?: {\n    actionId?: number | null\n    experimentId?: ExperimentIdType\n    userIntent?: ToolbarUserIntent\n}): ToolbarParams {\n    return {\n        userIntent:\n            options?.userIntent ??\n            (options?.actionId ? 'edit-action' : options?.experimentId ? 'edit-experiment' : 'add-action'),\n        // Make sure to pass the app url, otherwise the api_host will be used by\n        // the toolbar, which isn't correct when used behind a reverse proxy as\n        // we require e.g. SSO login to the app, which will not work when placed\n        // behind a proxy unless we register each domain with the OAuth2 client.\n        apiURL: apiHostOrigin(),\n        ...(options?.actionId ? { actionId: options.actionId } : {}),\n        ...(options?.experimentId ? { experimentId: options.experimentId } : {}),\n    }\n}\n\n/** defaultIntent: whether to launch with empty intent (i.e. toolbar mode is default) */\nexport function appEditorUrl(\n    appUrl: string,\n    options?: {\n        actionId?: number | null\n        experimentId?: ExperimentIdType\n        userIntent?: ToolbarUserIntent\n        generateOnly?: boolean\n    }\n): string {\n    const params = buildToolbarParams(options) as Record<string, unknown>\n    // See https://github.com/PostHog/posthog-js/blob/f7119c/src/extensions/toolbar.ts#L52 for where these params\n    // are passed. `appUrl` is an extra `redirect_to_site` param.\n    params['appUrl'] = appUrl\n    params['generateOnly'] = options?.generateOnly\n    return '/api/user/redirect_to_site/' + encodeParams(params, '?')\n}\n\nexport const checkUrlIsAuthorized = (url: string | URL, authorizedUrls: string[]): boolean => {\n    try {\n        const parsedUrl = typeof url === 'string' ? sanitizePossibleWildCardedURL(url) : url\n        const urlWithoutPath = parsedUrl.protocol + '//' + parsedUrl.host\n        // Is this domain already in the list of urls?\n        const exactMatch =\n            authorizedUrls.filter((authorizedUrl) => authorizedUrl.indexOf(urlWithoutPath) > -1).length > 0\n\n        if (exactMatch) {\n            return true\n        }\n\n        const wildcardMatch = !!authorizedUrls.find((authorizedUrl) => {\n            // Matches something like `https://*.example.com` against the urlWithoutPath\n            const regex = new RegExp(authorizedUrl.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'))\n            return urlWithoutPath.match(regex)\n        })\n\n        if (wildcardMatch) {\n            return true\n        }\n    } catch {\n        // Ignore invalid URLs\n    }\n\n    return false\n}\n\nexport interface SuggestedDomain {\n    url: string\n    count: number\n}\n\nexport const filterNotAuthorizedUrls = (\n    suggestions: SuggestedDomain[],\n    authorizedUrls: string[]\n): SuggestedDomain[] => {\n    const suggestedDomains: SuggestedDomain[] = []\n\n    suggestions.forEach(({ url, count }) => {\n        const parsedUrl = sanitizePossibleWildCardedURL(url)\n        const urlWithoutPath = parsedUrl.protocol + '//' + parsedUrl.host\n        // Have we already added this domain?\n        if (suggestedDomains.some((sd) => sd.url === urlWithoutPath)) {\n            return\n        }\n\n        if (!checkUrlIsAuthorized(parsedUrl, authorizedUrls)) {\n            suggestedDomains.push({ url: urlWithoutPath, count })\n        }\n    })\n\n    return suggestedDomains\n}\n\nexport const NEW_URL = 'https://'\n\nexport interface KeyedAppUrl {\n    url: string\n    type: 'authorized' | 'suggestion'\n    originalIndex: number\n    // how many seen in the last three days\n    count?: number\n}\n\nexport interface AuthorizedUrlListLogicProps {\n    actionId: number | null\n    experimentId: ExperimentIdType | null\n    type: AuthorizedUrlListType\n    allowWildCards?: boolean\n}\n\nexport const defaultAuthorizedUrlProperties = {\n    actionId: null,\n    experimentId: null,\n}\n\nexport const authorizedUrlListLogic = kea<authorizedUrlListLogicType>([\n    path((key) => ['lib', 'components', 'AuthorizedUrlList', 'authorizedUrlListLogic', key]),\n    key((props) => `${props.type}-${props.experimentId}-${props.actionId}`), // Some will be undefined but that's ok, this avoids experiment/action with same ID sharing same store\n    props({} as AuthorizedUrlListLogicProps),\n    connect(() => ({\n        values: [teamLogic, ['currentTeam', 'currentTeamId']],\n        actions: [teamLogic, ['updateCurrentTeam']],\n    })),\n    actions(() => ({\n        setAuthorizedUrls: (authorizedUrls: string[]) => ({ authorizedUrls }),\n        addUrl: (url: string, launch?: boolean) => ({ url, launch }),\n        newUrl: true,\n        removeUrl: (index: number) => ({ index }),\n        updateUrl: (index: number, url: string) => ({ index, url }),\n        launchAtUrl: (url: string) => ({ url }),\n        setEditUrlIndex: (originalIndex: number | null) => ({ originalIndex }),\n        cancelProposingUrl: true,\n        copyLaunchCode: (url: string) => ({ url }),\n    })),\n    loaders(({ values, props }) => ({\n        suggestions: {\n            __default: [] as SuggestedDomain[],\n            loadSuggestions: async () => {\n                const query = hogql`\n                    select properties.$current_url, count()\n                    from events\n                        where event = '$pageview'\n                        and timestamp >= now() - interval 3 day \n                        and timestamp <= now()\n                        and properties.$current_url is not null\n                        group by properties.$current_url\n                        order by count() desc\n                    limit 25`\n\n                const response = await api.queryHogQL(query)\n                const result = response.results as [string, number][]\n\n                if (result && result.length === 0) {\n                    return []\n                }\n\n                const suggestedDomains = filterNotAuthorizedUrls(\n                    result.map(([url, count]) => ({ url, count })),\n                    values.authorizedUrls\n                )\n\n                return suggestedDomains.slice(0, 20)\n            },\n        },\n        manualLaunchParams: {\n            loadManualLaunchParams: async (url: string): Promise<string | undefined> => {\n                const response = await api.get(\n                    appEditorUrl(url, {\n                        ...(props?.actionId ? { actionId: props.actionId } : {}),\n                        ...(props?.experimentId ? { experimentId: props.experimentId } : {}),\n                        generateOnly: true,\n                    })\n                )\n\n                let decoded: string | undefined = undefined\n                try {\n                    if (response?.toolbarParams) {\n                        decoded = decodeURIComponent(response.toolbarParams)\n                    }\n                } catch {\n                    lemonToast.error('Failed to generate toolbar params')\n                }\n                return decoded\n            },\n        },\n    })),\n    subscriptions(({ props, actions }) => ({\n        currentTeam: (currentTeam) => {\n            actions.setAuthorizedUrls(\n                (props.type === AuthorizedUrlListType.RECORDING_DOMAINS\n                    ? currentTeam.recording_domains\n                    : currentTeam.app_urls) || []\n            )\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadSuggestions()\n    }),\n    forms(({ values, actions, props }) => ({\n        proposedUrl: {\n            defaults: { url: '' } as ProposeNewUrlFormType,\n            errors: ({ url }) => ({\n                // default to allowing wildcards because that was the original behavior\n                url: validateProposedUrl(\n                    url,\n                    values.authorizedUrls,\n                    values.onlyAllowDomains,\n                    props.allowWildCards ?? true\n                ),\n            }),\n            submit: async ({ url }) => {\n                if (values.editUrlIndex !== null && values.editUrlIndex >= 0) {\n                    actions.updateUrl(values.editUrlIndex, url)\n                } else {\n                    actions.addUrl(url)\n                }\n            },\n        },\n    })),\n    reducers(() => ({\n        showProposedURLForm: [\n            false as boolean,\n            {\n                newUrl: () => true,\n                submitProposedUrlSuccess: () => false,\n                cancelProposingUrl: () => false,\n            },\n        ],\n        authorizedUrls: [\n            [] as string[],\n            {\n                setAuthorizedUrls: (_, { authorizedUrls }) => authorizedUrls,\n                addUrl: (state, { url }) => (!state.includes(url) ? state.concat([url]) : state),\n                updateUrl: (state, { index, url }) => Object.assign([...state], { [index]: url }),\n                removeUrl: (state, { index }) => {\n                    const newUrls = [...state]\n                    newUrls.splice(index, 1)\n                    return newUrls\n                },\n            },\n        ],\n        suggestions: [\n            [],\n            {\n                addUrl: (state, { url }) => [...state].filter((sd) => url !== sd.url),\n            },\n        ],\n        editUrlIndex: [\n            null as number | null,\n            {\n                setEditUrlIndex: (_, { originalIndex }) => originalIndex,\n                removeUrl: (editUrlIndex, { index }) =>\n                    editUrlIndex && index < editUrlIndex\n                        ? editUrlIndex - 1\n                        : index === editUrlIndex\n                        ? null\n                        : editUrlIndex,\n                newUrl: () => -1,\n                updateUrl: () => null,\n                addUrl: () => null,\n                cancelProposingUrl: () => null,\n            },\n        ],\n    })),\n    sharedListeners(({ values, props }) => ({\n        saveUrls: async () => {\n            if (props.type === AuthorizedUrlListType.RECORDING_DOMAINS) {\n                await teamLogic.asyncActions.updateCurrentTeam({ recording_domains: values.authorizedUrls })\n            } else {\n                await teamLogic.asyncActions.updateCurrentTeam({ app_urls: values.authorizedUrls })\n            }\n        },\n    })),\n    listeners(({ sharedListeners, values, actions }) => ({\n        setEditUrlIndex: () => {\n            actions.setProposedUrlValue('url', values.urlToEdit)\n        },\n        newUrl: () => {\n            actions.setProposedUrlValue('url', NEW_URL)\n        },\n        addUrl: [\n            sharedListeners.saveUrls,\n            ({ url, launch }) => {\n                if (launch) {\n                    actions.launchAtUrl(url)\n                }\n            },\n        ],\n        removeUrl: sharedListeners.saveUrls,\n        updateUrl: sharedListeners.saveUrls,\n        launchAtUrl: ({ url }) => {\n            window.location.href = values.launchUrl(url)\n        },\n        cancelProposingUrl: () => {\n            actions.resetProposedUrl()\n        },\n        submitProposedUrlSuccess: () => {\n            actions.setEditUrlIndex(null)\n            actions.resetProposedUrl()\n        },\n        copyLaunchCode: ({ url }) => {\n            actions.loadManualLaunchParams(url)\n        },\n        loadManualLaunchParamsSuccess: async ({ manualLaunchParams }) => {\n            if (manualLaunchParams) {\n                const templateScript = `\n                if (!window?.posthog) {\n                    console.warn('PostHog must be added to the window object on this page, for this to work. This is normally done in the loaded callback of your posthog init code.')\n                } else {\n                    window.posthog.loadToolbar(${manualLaunchParams})\n                }\n                `\n                await copyToClipboard(templateScript, 'code to paste into the console')\n            }\n        },\n    })),\n    selectors({\n        urlToEdit: [\n            (s) => [s.authorizedUrls, s.editUrlIndex],\n            (authorizedUrls, editUrlIndex) => {\n                if (editUrlIndex === null || editUrlIndex === -1) {\n                    return NEW_URL\n                }\n                return authorizedUrls[editUrlIndex]\n            },\n        ],\n        urlsKeyed: [\n            (s) => [s.authorizedUrls, s.suggestions],\n            (authorizedUrls, suggestions): KeyedAppUrl[] => {\n                const keyedUrls = authorizedUrls\n                    .map((url, index) => ({\n                        url,\n                        type: 'authorized',\n                        originalIndex: index,\n                    }))\n                    .concat(\n                        suggestions.map(({ url, count }, index) => ({\n                            url,\n                            type: 'suggestion',\n                            originalIndex: index,\n                            count,\n                        }))\n                    ) as KeyedAppUrl[]\n\n                return keyedUrls\n            },\n        ],\n        launchUrl: [\n            (_, p) => [p.actionId, p.experimentId],\n            (actionId, experimentId) => (url: string) => {\n                if (experimentId) {\n                    return appEditorUrl(url, {\n                        experimentId,\n                    })\n                }\n\n                return appEditorUrl(url, {\n                    actionId,\n                })\n            },\n        ],\n        isAddUrlFormVisible: [(s) => [s.editUrlIndex], (editUrlIndex) => editUrlIndex === -1],\n        onlyAllowDomains: [(_, p) => [p.type], (type) => type === AuthorizedUrlListType.RECORDING_DOMAINS],\n\n        checkUrlIsAuthorized: [\n            (s) => [s.authorizedUrls],\n            (authorizedUrls) => (url: string) => {\n                return checkUrlIsAuthorized(url, authorizedUrls)\n            },\n        ],\n    }),\n    urlToAction(({ actions }) => ({\n        [urls.toolbarLaunch()]: (_, searchParams) => {\n            if (searchParams.addNew) {\n                actions.newUrl()\n            }\n        },\n    })),\n])\n","import { connect, kea, path, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { subscriptions } from 'kea-subscriptions'\nimport api from 'lib/api'\nimport { membersLogic } from 'scenes/organization/membersLogic'\n\nimport { sidePanelContextLogic } from '~/layout/navigation-3000/sidepanel/panels/sidePanelContextLogic'\nimport { SidePanelSceneContext } from '~/layout/navigation-3000/sidepanel/types'\nimport { hogql } from '~/queries/utils'\n\nimport type { metalyticsLogicType } from './metalyticsLogicType'\n\nexport const metalyticsLogic = kea<metalyticsLogicType>([\n    path(['lib', 'components', 'metalytics', 'metalyticsLogic']),\n    connect(() => ({\n        values: [sidePanelContextLogic, ['sceneSidePanelContext'], membersLogic, ['members']],\n    })),\n\n    loaders(({ values }) => ({\n        viewCount: [\n            null as { views: number; users: number } | null,\n            {\n                loadViewCount: async () => {\n                    const query = hogql`\n                        SELECT SUM(count) AS count, COUNT(DISTINCT app_source_id) AS unique_users\n                        FROM app_metrics\n                        WHERE app_source = 'metalytics'\n                        AND instance_id = ${values.instanceId}`\n\n                    // NOTE: I think this gets cached heavily - how to correctly invalidate?\n                    const response = await api.queryHogQL(query, { refresh: 'force_blocking' })\n                    const result = response.results as number[][]\n                    return {\n                        views: result[0][0],\n                        users: result[0][1],\n                    }\n                },\n            },\n        ],\n        recentUsers: [\n            [] as string[],\n            {\n                loadUsersLast30days: async () => {\n                    const query = hogql`\n                        SELECT DISTINCT app_source_id\n                        FROM app_metrics\n                        WHERE app_source = 'metalytics'\n                        AND instance_id = ${values.instanceId}\n                        AND timestamp >= NOW() - INTERVAL 30 DAY\n                        ORDER BY timestamp DESC`\n\n                    const response = await api.queryHogQL(query, { refresh: 'force_blocking' })\n                    return response.results.map((result) => result[0]) as string[]\n                },\n            },\n        ],\n    })),\n\n    selectors({\n        instanceId: [\n            (s) => [s.sceneSidePanelContext],\n            (sidePanelContext: SidePanelSceneContext) =>\n                sidePanelContext?.activity_item_id\n                    ? `${sidePanelContext.activity_scope}:${sidePanelContext.activity_item_id}`\n                    : null,\n        ],\n        scope: [\n            (s) => [s.sceneSidePanelContext],\n            (sidePanelContext: SidePanelSceneContext) => sidePanelContext?.activity_scope,\n        ],\n\n        recentUserMembers: [\n            (s) => [s.recentUsers, s.members],\n            (recentUsers, members) => {\n                if (!members || !recentUsers) {\n                    return []\n                }\n                // Filter members whose IDs match the recentUsers array\n                const filteredMembers = members.filter((member) => recentUsers.includes(String(member.user.id)))\n                return filteredMembers\n            },\n        ],\n    }),\n\n    subscriptions(({ actions }) => ({\n        instanceId: async (instanceId) => {\n            if (instanceId) {\n                actions.loadViewCount()\n                actions.loadUsersLast30days()\n\n                await api.create('/api/projects/@current/metalytics/', {\n                    metric_name: 'viewed',\n                    instance_id: instanceId,\n                })\n            }\n        },\n    })),\n])\n","import { IconBug, IconInfo, IconQuestion } from '@posthog/icons'\nimport {\n    LemonBanner,\n    LemonInput,\n    LemonSegmentedButton,\n    LemonSegmentedButtonOption,\n    lemonToast,\n    Link,\n    Tooltip,\n} from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\nimport { useUploadFiles } from 'lib/hooks/useUploadFiles'\nimport { IconFeedback } from 'lib/lemon-ui/icons'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonFileInput } from 'lib/lemon-ui/LemonFileInput/LemonFileInput'\nimport { LemonSelect } from 'lib/lemon-ui/LemonSelect/LemonSelect'\nimport { LemonTextArea } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { useEffect, useRef } from 'react'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport {\n    SEVERITY_LEVEL_TO_NAME,\n    SUPPORT_TICKET_TEMPLATES,\n    supportLogic,\n    SupportTicketKind,\n    TARGET_AREA_TO_NAME,\n} from './supportLogic'\n\nconst SUPPORT_TICKET_OPTIONS: LemonSegmentedButtonOption<SupportTicketKind>[] = [\n    {\n        value: 'support',\n        label: 'Question',\n        icon: <IconQuestion />,\n    },\n    {\n        value: 'feedback',\n        label: 'Feedback',\n        icon: <IconFeedback />,\n    },\n    {\n        value: 'bug',\n        label: 'Bug',\n        icon: <IconBug />,\n    },\n]\n\nconst SUPPORT_TICKET_KIND_TO_PROMPT: Record<SupportTicketKind, string> = {\n    bug: \"What's the bug?\",\n    feedback: 'What feedback do you have?',\n    support: 'What can we help you with?',\n}\n\nexport function SupportForm(): JSX.Element | null {\n    const { sendSupportRequest, focusedField } = useValues(supportLogic)\n    const { setSendSupportRequestValue, setFocusedField } = useActions(supportLogic)\n    const { objectStorageAvailable } = useValues(preflightLogic)\n    // the support model can be shown when logged out, file upload is not offered to anonymous users\n    const { user } = useValues(userLogic)\n    // only allow authentication issues for logged out users\n\n    const dropRef = useRef<HTMLDivElement>(null)\n    const nameInputRef = useRef<HTMLInputElement>(null)\n    const emailInputRef = useRef<HTMLInputElement>(null)\n    const messageInputRef = useRef<HTMLTextAreaElement>(null)\n    // Track which fields have been initialized (had cursor positioned at end)\n    const initializedFields = useRef<Record<string, boolean>>({})\n\n    const handlePaste = (e: React.ClipboardEvent<HTMLDivElement>): void => {\n        const items = e.clipboardData?.items\n        if (!items) {\n            return\n        }\n\n        // Convert DataTransferItemList to array for iteration\n        const itemsArray = Array.from(items)\n        for (const item of itemsArray) {\n            if (item.type.startsWith('image/')) {\n                const file = item.getAsFile()\n                if (file) {\n                    setFilesToUpload([...filesToUpload, file])\n                }\n            }\n        }\n    }\n\n    // Restore focus to the appropriate field after re-renders\n    // Only position cursor at the end on first focus for each field\n    useEffect(() => {\n        if (focusedField === 'name' && nameInputRef.current) {\n            nameInputRef.current.focus()\n            // Position cursor at the end of the text only on first focus\n            if (!initializedFields.current['name'] && nameInputRef.current.value !== undefined) {\n                const length = nameInputRef.current.value.length\n                nameInputRef.current.setSelectionRange(length, length)\n                initializedFields.current['name'] = true\n            }\n        } else if (focusedField === 'email' && emailInputRef.current) {\n            emailInputRef.current.focus()\n            // Position cursor at the end of the text only on first focus\n            if (!initializedFields.current['email'] && emailInputRef.current.value !== undefined) {\n                const length = emailInputRef.current.value.length\n                emailInputRef.current.setSelectionRange(length, length)\n                initializedFields.current['email'] = true\n            }\n        } else if (focusedField === 'message' && messageInputRef.current) {\n            messageInputRef.current.focus()\n            // Position cursor at the end of the text only on first focus\n            if (!initializedFields.current['message'] && messageInputRef.current.value !== undefined) {\n                const length = messageInputRef.current.value.length\n                messageInputRef.current.setSelectionRange(length, length)\n                initializedFields.current['message'] = true\n            }\n        }\n    }, [focusedField, sendSupportRequest])\n\n    const { setFilesToUpload, filesToUpload, uploading } = useUploadFiles({\n        onUpload: (url, fileName) => {\n            setSendSupportRequestValue('message', sendSupportRequest.message + `\\n\\nAttachment \"${fileName}\": ${url}`)\n        },\n        onError: (detail) => {\n            lemonToast.error(`Error uploading image: ${detail}`)\n        },\n    })\n\n    const changeKind = (kind: SupportTicketKind): void => {\n        setSendSupportRequestValue('kind', kind)\n        if (kind === 'bug') {\n            setSendSupportRequestValue('severity_level', 'medium')\n        } else {\n            setSendSupportRequestValue('severity_level', 'low')\n        }\n    }\n\n    return (\n        <Form\n            logic={supportLogic}\n            formKey=\"sendSupportRequest\"\n            id=\"support-modal-form\"\n            enableFormOnSubmit\n            className=\"deprecated-space-y-4\"\n        >\n            {!user && (\n                <>\n                    <LemonField name=\"name\" label=\"Name\">\n                        <LemonInput\n                            data-attr=\"name\"\n                            placeholder=\"Jane\"\n                            ref={nameInputRef}\n                            onFocus={() => setFocusedField('name')}\n                            onBlur={() => setFocusedField(null)}\n                        />\n                    </LemonField>\n                    <LemonField name=\"email\" label=\"Email\">\n                        <LemonInput\n                            data-attr=\"email\"\n                            placeholder=\"your@email.com\"\n                            ref={emailInputRef}\n                            onFocus={() => setFocusedField('email')}\n                            onBlur={() => setFocusedField(null)}\n                        />\n                    </LemonField>\n                </>\n            )}\n            <LemonField name=\"kind\" label=\"Message type\">\n                <LemonSegmentedButton onChange={changeKind} fullWidth options={SUPPORT_TICKET_OPTIONS} />\n            </LemonField>\n            <LemonField name=\"target_area\" label=\"Topic\">\n                <LemonSelect\n                    disabledReason={\n                        !user\n                            ? 'Please login to your account before opening a ticket unrelated to authentication issues.'\n                            : null\n                    }\n                    fullWidth\n                    options={TARGET_AREA_TO_NAME}\n                />\n            </LemonField>\n            {sendSupportRequest.target_area === 'error_tracking' && (\n                <LemonBanner type=\"warning\">\n                    This topic is for our Error Tracking <i>product</i>. If you're reporting an error in PostHog please\n                    choose the relevant topic so your submission is sent to the correct team.\n                </LemonBanner>\n            )}\n            <LemonField\n                name=\"message\"\n                label={sendSupportRequest.kind ? SUPPORT_TICKET_KIND_TO_PROMPT[sendSupportRequest.kind] : 'Content'}\n            >\n                {(props) => (\n                    <div ref={dropRef} className=\"flex flex-col gap-2\" onPaste={handlePaste}>\n                        <LemonTextArea\n                            placeholder={SUPPORT_TICKET_TEMPLATES[sendSupportRequest.kind] ?? 'Type your message here'}\n                            data-attr=\"support-form-content-input\"\n                            minRows={5}\n                            ref={messageInputRef}\n                            onFocus={() => setFocusedField('message')}\n                            onBlur={() => setFocusedField(null)}\n                            {...props}\n                        />\n                        {objectStorageAvailable && !!user && (\n                            <LemonFileInput\n                                accept=\"image/*\"\n                                multiple={false}\n                                alternativeDropTargetRef={dropRef}\n                                onChange={setFilesToUpload}\n                                loading={uploading}\n                                value={filesToUpload}\n                            />\n                        )}\n                    </div>\n                )}\n            </LemonField>\n            <div className=\"flex gap-2 flex-col\">\n                <div className=\"flex justify-between items-center\">\n                    <label className=\"LemonLabel\">\n                        Severity level\n                        <Tooltip title=\"Severity levels help us prioritize your request.\">\n                            <span>\n                                <IconInfo className=\"opacity-75\" />\n                            </span>\n                        </Tooltip>\n                    </label>\n                    <Link target=\"_blank\" to=\"https://posthog.com/docs/support-options#severity-levels\">\n                        Definitions\n                    </Link>\n                </div>\n                <LemonField name=\"severity_level\">\n                    <LemonSelect\n                        fullWidth\n                        options={Object.entries(SEVERITY_LEVEL_TO_NAME).map(([key, value]) => ({\n                            label: value,\n                            value: key,\n                        }))}\n                    />\n                </LemonField>\n            </div>\n        </Form>\n    )\n}\n","import { actions, connect, kea, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { urlToAction } from 'kea-router'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'\nimport { uuid } from 'lib/utils'\nimport posthog from 'posthog-js'\nimport { billingLogic } from 'scenes/billing/billingLogic'\nimport { organizationLogic } from 'scenes/organizationLogic'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { sidePanelStateLogic } from '~/layout/navigation-3000/sidepanel/sidePanelStateLogic'\nimport {\n    AvailableFeature,\n    BillingPlan,\n    OrganizationBasicType,\n    Region,\n    SidePanelTab,\n    TeamPublicType,\n    UserType,\n} from '~/types'\n\nimport type { supportLogicType } from './supportLogicType'\nimport { openSupportModal } from './SupportModal'\n\nexport function getPublicSupportSnippet(\n    cloudRegion: Region | null | undefined,\n    currentOrganization: OrganizationBasicType | null,\n    currentTeam: TeamPublicType | null,\n    includeCurrentLocation = true\n): string {\n    if (!cloudRegion) {\n        return ''\n    }\n    return (\n        (includeCurrentLocation ? getCurrentLocationLink() : '') +\n        getSessionReplayLink() +\n        `\\nAdmin: http://go/adminOrg${cloudRegion}/${currentOrganization?.id} (project ID ${currentTeam?.id})`\n    ).trimStart()\n}\n\nfunction getCurrentLocationLink(): string {\n    const cleanedCurrentUrl = window.location.href.replace(/panel=support[^&]*(&)?/, '').replace(/#$/, '')\n    return `\\nLocation: ${cleanedCurrentUrl}`\n}\n\nfunction getSessionReplayLink(): string {\n    const replayUrl = posthog\n        .get_session_replay_url({ withTimestamp: true, timestampLookBack: 30 })\n        .replace(window.location.origin + '/replay/', 'http://go/session/')\n    return `\\nSession: ${replayUrl}`\n}\n\nfunction getErrorTrackingLink(): string {\n    const filterGroup = encodeURIComponent(\n        JSON.stringify({\n            type: 'AND',\n            values: [\n                {\n                    type: 'AND',\n                    values: [\n                        {\n                            key: '$session_id',\n                            value: [posthog.get_session_id()],\n                            operator: 'exact',\n                            type: 'event',\n                        },\n                    ],\n                },\n            ],\n        })\n    )\n\n    return `\\nExceptions: https://us.posthog.com/project/2/error_tracking?filterGroup=${filterGroup}`\n}\n\nfunction getDjangoAdminLink(\n    user: UserType | null,\n    cloudRegion: Region | null | undefined,\n    currentOrganization: OrganizationBasicType | null,\n    currentTeam: TeamPublicType | null\n): string {\n    if (!user || !cloudRegion) {\n        return ''\n    }\n    const link = `http://go/admin${cloudRegion}/${user.email}`\n    return `\\nAdmin: ${link} (organization ID ${currentOrganization?.id}: ${currentOrganization?.name}, project ID ${currentTeam?.id}: ${currentTeam?.name})`\n}\n\nfunction getBillingAdminLink(currentOrganization: OrganizationBasicType | null): string {\n    if (!currentOrganization) {\n        return ''\n    }\n    return `\\nBilling admin: http://go/billing/${currentOrganization.id}`\n}\n\nconst SUPPORT_TICKET_KIND_TO_TITLE: Record<SupportTicketKind, string> = {\n    support: 'Contact support',\n    feedback: 'Give feedback',\n    bug: 'Report a bug',\n}\n\nexport const TARGET_AREA_TO_NAME = [\n    {\n        title: 'General',\n        options: [\n            {\n                value: 'billing',\n                'data-attr': `support-form-target-area-billing`,\n                label: 'Billing',\n            },\n            {\n                value: 'cohorts',\n                'data-attr': `support-form-target-area-cohorts`,\n                label: 'Cohorts',\n            },\n            {\n                value: 'data_ingestion',\n                'data-attr': `support-form-target-area-data_ingestion`,\n                label: 'Data ingestion',\n            },\n            {\n                value: 'data_management',\n                'data-attr': `support-form-target-area-data_management`,\n                label: 'Data management (incl. events, actions, properties)',\n            },\n            {\n                value: 'login',\n                'data-attr': `support-form-target-area-login`,\n                label: 'Authentication (incl. login, sign-up, invites)',\n            },\n            {\n                value: 'mobile',\n                'data-attr': `support-form-target-area-mobile`,\n                label: 'Mobile',\n            },\n            {\n                value: 'notebooks',\n                'data-attr': `support-form-target-area-notebooks`,\n                label: 'Notebooks',\n            },\n            {\n                value: 'onboarding',\n                'data-attr': `support-form-target-area-onboarding`,\n                label: 'Onboarding',\n            },\n            {\n                value: 'sdk',\n                'data-attr': `support-form-target-area-onboarding`,\n                label: 'SDK / Implementation',\n            },\n        ],\n    },\n    {\n        title: 'Individual product',\n        options: [\n            {\n                value: 'analytics',\n                'data-attr': `support-form-target-area-analytics`,\n                label: 'Product analytics (incl. insights, dashboards, annotations)',\n            },\n            {\n                value: 'batch_exports',\n                'data-attr': `support-form-target-area-batch_exports`,\n                label: 'Destinations (batch exports)',\n            },\n            {\n                value: 'cdp_destinations',\n                'data-attr': `support-form-target-area-cdp_destinations`,\n                label: 'Destinations (real-time)',\n            },\n            {\n                value: 'data_warehouse',\n                'data-attr': `support-form-target-area-data_warehouse`,\n                label: 'Data warehouse (sources)',\n            },\n            {\n                value: 'error_tracking',\n                'data-attr': `support-form-target-area-error_tracking`,\n                label: 'Error tracking',\n            },\n            {\n                value: 'experiments',\n                'data-attr': `support-form-target-area-experiments`,\n                label: 'Experiments',\n            },\n            {\n                value: 'feature_flags',\n                'data-attr': `support-form-target-area-feature_flags`,\n                label: 'Feature flags',\n            },\n            {\n                value: 'group_analytics',\n                'data-attr': `support-form-target-area-group-analytics`,\n                label: 'Group analytics',\n            },\n            {\n                value: 'llm-observability',\n                'data-attr': `support-form-target-area-llm-observability`,\n                label: 'LLM observability',\n            },\n            {\n                value: 'max-ai',\n                'data-attr': `support-form-target-area-max-ai`,\n                label: 'Max AI',\n            },\n            {\n                value: 'messaging',\n                'data-attr': `support-form-target-area-messaging`,\n                label: 'Messaging',\n            },\n            {\n                value: 'revenue_analytics',\n                'data-attr': `support-form-target-area-revenue-analytics`,\n                label: 'Revenue analytics',\n            },\n            {\n                value: 'session_replay',\n                'data-attr': `support-form-target-area-session_replay`,\n                label: 'Session replay (incl. recordings)',\n            },\n            {\n                value: 'surveys',\n                'data-attr': `support-form-target-area-surveys`,\n                label: 'Surveys',\n            },\n            {\n                value: 'toolbar',\n                'data-attr': `support-form-target-area-toolbar`,\n                label: 'Toolbar (incl. heatmaps)',\n            },\n            {\n                value: 'web_analytics',\n                'data-attr': `support-form-target-area-web_analytics`,\n                label: 'Web analytics',\n            },\n        ],\n    },\n]\n\nexport const SEVERITY_LEVEL_TO_NAME = {\n    critical: 'Outage, data loss, or data breach',\n    high: 'Feature is not working at all',\n    medium: 'Feature not working as expected',\n    low: 'Question or feature request',\n}\n\nexport const SUPPORT_KIND_TO_SUBJECT = {\n    bug: 'Bug Report',\n    feedback: 'Feedback',\n    support: 'Support Ticket',\n}\n\nexport type SupportTicketTargetArea =\n    | 'experiments'\n    | 'apps'\n    | 'login'\n    | 'billing'\n    | 'onboarding'\n    | 'cohorts'\n    | 'data_management'\n    | 'notebooks'\n    | 'data_warehouse'\n    | 'feature_flags'\n    | 'analytics'\n    | 'session_replay'\n    | 'toolbar'\n    | 'surveys'\n    | 'web_analytics'\n    | 'error_tracking'\n    | 'cdp_destinations'\n    | 'data_ingestion'\n    | 'batch_exports'\n    | 'messaging'\nexport type SupportTicketSeverityLevel = keyof typeof SEVERITY_LEVEL_TO_NAME\nexport type SupportTicketKind = keyof typeof SUPPORT_KIND_TO_SUBJECT\n\nexport const getLabelBasedOnTargetArea = (target_area: SupportTicketTargetArea): null | string => {\n    for (const category of TARGET_AREA_TO_NAME) {\n        for (const option of category.options) {\n            if (option.value === target_area) {\n                return option.label\n            }\n        }\n    }\n    return null // Return null if the value is not found\n}\n\nexport const URL_PATH_TO_TARGET_AREA: Record<string, SupportTicketTargetArea> = {\n    insights: 'analytics',\n    recordings: 'session_replay',\n    replay: 'session_replay',\n    dashboard: 'analytics',\n    feature_flags: 'feature_flags',\n    experiments: 'experiments',\n    'web-performance': 'session_replay',\n    events: 'analytics',\n    'data-management': 'data_management',\n    cohorts: 'cohorts',\n    annotations: 'analytics',\n    persons: 'analytics',\n    groups: 'analytics',\n    app: 'apps',\n    toolbar: 'session_replay',\n    warehouse: 'data_warehouse',\n    surveys: 'surveys',\n    web: 'web_analytics',\n    destination: 'cdp_destinations',\n    destinations: 'cdp_destinations',\n    transformation: 'cdp_destinations',\n    transformations: 'cdp_destinations',\n    source: 'data_warehouse',\n    sources: 'data_warehouse',\n    messaging: 'messaging',\n    billing: 'billing',\n}\n\nexport const SUPPORT_TICKET_TEMPLATES = {\n    bug: 'Please describe the bug you saw, and how to reproduce it.\\n\\nIf the bug appeared on a specific insight or dashboard, please include a link to it.',\n    feedback:\n        \"If your request is due to a problem, please describe the problem as best you can.\\n\\nPlease also describe the solution you'd like to see, and any alternatives you considered.\\n\\nYou can add images below to help illustrate your request, if needed!\",\n    support:\n        \"Please explain as fully as possible what you're aiming to do, and what you'd like help with.\\n\\nIf your question involves an existing insight or dashboard, please include a link to it.\",\n}\n\nexport function getURLPathToTargetArea(pathname: string): SupportTicketTargetArea | null {\n    const pathParts = pathname.split('/')\n\n    if (pathname.includes('pipeline/destinations/') && !pathname.includes('/hog-')) {\n        return 'batch_exports'\n    }\n\n    for (const part of pathParts) {\n        if (URL_PATH_TO_TARGET_AREA[part]) {\n            return URL_PATH_TO_TARGET_AREA[part]\n        }\n    }\n\n    return null\n}\n\nexport type SupportFormLogicProps = {\n    onClose?: () => void\n}\n\nexport type SupportFormFields = {\n    name: string\n    email: string\n    kind: SupportTicketKind\n    target_area: SupportTicketTargetArea | null\n    severity_level: SupportTicketSeverityLevel | null\n    message: string\n    isEmailFormOpen?: boolean | 'true' | 'false'\n}\n\nexport const supportLogic = kea<supportLogicType>([\n    props({} as SupportFormLogicProps),\n    path(['lib', 'components', 'support', 'supportLogic']),\n    connect(() => ({\n        values: [\n            userLogic,\n            ['user'],\n            preflightLogic,\n            ['preflight'],\n            sidePanelStateLogic,\n            ['sidePanelAvailable'],\n            userLogic,\n            ['hasAvailableFeature'],\n            billingLogic,\n            ['billing'],\n            organizationLogic,\n            ['isCurrentOrganizationNew'],\n        ],\n        actions: [sidePanelStateLogic, ['openSidePanel', 'setSidePanelOptions']],\n    })),\n    actions(() => ({\n        closeSupportForm: true,\n        openSupportForm: (values: Partial<SupportFormFields>) => values,\n        submitZendeskTicket: (form: SupportFormFields) => form,\n        updateUrlParams: true,\n        openEmailForm: true,\n        closeEmailForm: true,\n        setFocusedField: (field: string | null) => ({ field }),\n    })),\n    reducers(() => ({\n        isSupportFormOpen: [\n            false,\n            {\n                openSupportForm: () => true,\n                closeSupportForm: () => false,\n            },\n        ],\n        isEmailFormOpen: [\n            false,\n            {\n                openEmailForm: () => true,\n                closeEmailForm: () => false,\n            },\n        ],\n        focusedField: [\n            null as string | null,\n            {\n                setFocusedField: (_, { field }) => field,\n                // Reset focused field when form is closed\n                closeSupportForm: () => null,\n            },\n        ],\n    })),\n    forms(({ actions, values }) => ({\n        sendSupportRequest: {\n            defaults: {\n                name: '',\n                email: '',\n                kind: 'support',\n                severity_level: null,\n                target_area: null,\n                message: '',\n            } as SupportFormFields,\n            errors: ({ name, email, message, kind, target_area, severity_level }) => {\n                return {\n                    name: !values.user ? (!name ? 'Please enter your name' : '') : '',\n                    email: !values.user ? (!email ? 'Please enter your email' : '') : '',\n                    message: !message ? 'Please enter a message' : '',\n                    kind: !kind ? 'Please choose' : undefined,\n                    severity_level: !severity_level ? 'Please choose' : undefined,\n                    target_area: !target_area ? 'Please choose' : undefined,\n                }\n            },\n            submit: async (formValues) => {\n                // name must be present for zendesk to accept the ticket\n                formValues.name = values.user?.first_name ?? formValues.name ?? 'name not set'\n                formValues.email = values.user?.email ?? formValues.email ?? ''\n                actions.submitZendeskTicket(formValues)\n                // Form closing and resetting is now handled in submitZendeskTicket listener\n                // based on success/failure of the submission\n            },\n        },\n    })),\n    selectors({\n        title: [\n            (s) => [s.sendSupportRequest ?? null],\n            (sendSupportRequest) =>\n                sendSupportRequest.kind\n                    ? SUPPORT_TICKET_KIND_TO_TITLE[sendSupportRequest.kind]\n                    : 'Leave a message with PostHog',\n        ],\n    }),\n    listeners(({ actions, props, values }) => ({\n        updateUrlParams: async () => {\n            // Only include non-text fields in the URL parameters\n            // This prevents focus loss when typing in text fields\n            const panelOptions = [\n                values.sendSupportRequest.kind ?? '',\n                values.sendSupportRequest.target_area ?? '',\n                values.sendSupportRequest.severity_level ?? '',\n                values.isEmailFormOpen ?? 'false',\n                // Explicitly exclude message, name, and email fields\n            ].join(':')\n\n            if (panelOptions !== ':') {\n                actions.setSidePanelOptions(panelOptions)\n            }\n        },\n        openSupportForm: async ({\n            name,\n            email,\n            isEmailFormOpen,\n            kind,\n            target_area,\n            severity_level,\n            message,\n        }: Partial<SupportFormFields>) => {\n            let area = target_area ?? getURLPathToTargetArea(window.location.pathname)\n            if (!userLogic.values.user) {\n                area = 'login'\n            }\n            kind = kind ?? 'support'\n            actions.resetSendSupportRequest({\n                name: name ?? '',\n                email: email ?? '',\n                kind,\n                target_area: area,\n                severity_level: severity_level ?? null,\n                message: message ?? '',\n            })\n\n            if (isEmailFormOpen === 'true' || isEmailFormOpen === true) {\n                actions.openEmailForm()\n            } else {\n                actions.closeEmailForm()\n            }\n\n            if (values.sidePanelAvailable) {\n                const panelOptions = [kind ?? '', area ?? ''].join(':')\n                actions.openSidePanel(SidePanelTab.Support, panelOptions === ':' ? undefined : panelOptions)\n            } else {\n                openSupportModal()\n            }\n\n            actions.updateUrlParams()\n        },\n        submitZendeskTicket: async ({ name, email, kind, target_area, severity_level, message }: SupportFormFields) => {\n            const zendesk_ticket_uuid = uuid()\n            const subject =\n                SUPPORT_KIND_TO_SUBJECT[kind ?? 'support'] +\n                ': ' +\n                (target_area\n                    ? getLabelBasedOnTargetArea(target_area) ?? `${target_area} (feature preview)`\n                    : 'General') +\n                ' (' +\n                zendesk_ticket_uuid +\n                ')'\n            const cloudRegion = preflightLogic.values.preflight?.region\n\n            const billing = billingLogic.values.billing\n            const billingPlan = billingLogic.values.billingPlan\n\n            let planLevelTag = 'plan_free'\n\n            const knownEnterpriseOrgIds = ['018713f3-8d56-0000-32fa-75ce97e6662f']\n            const isKnownEnterpriseOrg = knownEnterpriseOrgIds.includes(userLogic?.values?.user?.organization?.id || '')\n\n            const isNewOrganization = values.isCurrentOrganizationNew\n\n            const hasBoostTrial = billing?.trial?.status === 'active' && (billing.trial?.target as any) === 'boost'\n            const hasScaleTrial = billing?.trial?.status === 'active' && (billing.trial?.target as any) === 'scale'\n            const hasEnterpriseTrial = billing?.trial?.status === 'active' && billing.trial?.target === 'enterprise'\n\n            if (isKnownEnterpriseOrg || hasEnterpriseTrial || billingPlan === BillingPlan.Enterprise) {\n                planLevelTag = 'plan_enterprise'\n            } else if (isNewOrganization) {\n                planLevelTag = 'plan_onboarding'\n            } else if (hasScaleTrial) {\n                planLevelTag = 'plan_scale'\n            } else if (hasBoostTrial) {\n                planLevelTag = 'plan_boost'\n            } else if (billingPlan) {\n                switch (billingPlan) {\n                    case BillingPlan.Scale:\n                        planLevelTag = 'plan_scale'\n                        break\n                    case BillingPlan.Boost:\n                        planLevelTag = 'plan_boost'\n                        break\n                    case BillingPlan.Teams:\n                        planLevelTag = 'plan_teams_legacy'\n                        break\n                    case BillingPlan.Paid:\n                        planLevelTag = 'plan_pay-as-you-go'\n                        break\n                    case BillingPlan.Free:\n                        planLevelTag = 'plan_free'\n                        break\n                }\n            }\n\n            const payload = {\n                request: {\n                    requester: { name: name, email: email },\n                    subject: subject,\n                    tags: [planLevelTag],\n                    custom_fields: [\n                        {\n                            id: 22084126888475,\n                            value: severity_level,\n                        },\n                        {\n                            id: 22129191462555,\n                            value: posthog.get_distinct_id(),\n                        },\n                        {\n                            id: 27242745654043,\n                            value: target_area ?? '',\n                        },\n                        {\n                            id: 27031528411291,\n                            value: userLogic?.values?.user?.organization?.id ?? '',\n                        },\n                        {\n                            id: 26073267652251,\n                            value: values.hasAvailableFeature(AvailableFeature.PRIORITY_SUPPORT)\n                                ? 'priority_support'\n                                : values.hasAvailableFeature(AvailableFeature.EMAIL_SUPPORT)\n                                ? 'email_support'\n                                : 'free_support',\n                        },\n                    ],\n                    comment: {\n                        body:\n                            message +\n                            `\\n\\n-----` +\n                            `\\nKind: ${kind}` +\n                            `\\nTarget area: ${target_area}` +\n                            `\\nReport event: http://go/ticketByUUID/${zendesk_ticket_uuid}` +\n                            getSessionReplayLink() +\n                            getErrorTrackingLink() +\n                            getCurrentLocationLink() +\n                            getDjangoAdminLink(\n                                userLogic.values.user,\n                                cloudRegion,\n                                organizationLogic.values.currentOrganization,\n                                teamLogic.values.currentTeam\n                            ) +\n                            (target_area === 'billing' || target_area === 'login' || target_area === 'onboarding'\n                                ? getBillingAdminLink(organizationLogic.values.currentOrganization)\n                                : '') +\n                            (cloudRegion && teamLogic.values.currentTeam\n                                ? '\\nPersons-on-events mode for project: ' +\n                                  (teamLogic.values.currentTeam.modifiers?.personsOnEventsMode ??\n                                      teamLogic.values.currentTeam.default_modifiers?.personsOnEventsMode ??\n                                      'unknown')\n                                : ''),\n                    },\n                },\n            }\n\n            try {\n                const zendeskRequestBody = JSON.stringify(payload, undefined, 4)\n\n                // First attempt with standard fetch (unchanged from original)\n                const response = await fetch('https://posthoghelp.zendesk.com/api/v2/requests.json', {\n                    method: 'POST',\n                    body: zendeskRequestBody,\n                    headers: { 'Content-Type': 'application/json' },\n                })\n\n                // If the fetch request fails, try the Beacon API as a fallback\n                if (!response.ok) {\n                    console.warn('Fetch attempt to submit support ticket failed, trying Beacon API as fallback')\n\n                    // Detect Firefox\n                    const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1\n\n                    // Try Beacon API\n                    const beaconSuccess = navigator.sendBeacon(\n                        'https://posthoghelp.zendesk.com/api/v2/requests.json',\n                        zendeskRequestBody\n                    )\n\n                    if (beaconSuccess) {\n                        // Track success\n                        const properties = {\n                            zendesk_ticket_uuid,\n                            kind,\n                            target_area,\n                            message,\n                            submission_method: 'beacon',\n                            browser: isFirefox ? 'firefox' : 'other',\n                        }\n                        posthog.capture('support_ticket', properties)\n                        lemonToast.success(\n                            \"Got the message! If we have follow-up information for you, we'll reply via email.\"\n                        )\n                        // Only close and reset the form on success\n                        actions.closeSupportForm()\n                        actions.resetSendSupportRequest()\n                        return\n                    }\n\n                    // If both fetch and beacon fail, show the original error message\n                    const error = new Error(`There was an error creating the support ticket with zendesk.`)\n                    const extra: Record<string, any> = { zendeskBody: zendeskRequestBody }\n                    Object.entries(payload).forEach(([key, value]) => {\n                        extra[`payload_${key}`] = value\n                    })\n                    const body = await response.text()\n                    const contexts = {\n                        response: {\n                            status_code: response.status,\n                            data: body,\n                            body_size: body?.length,\n                        },\n                    }\n                    posthog.captureException(error, {\n                        ...extra,\n                        ...contexts,\n                    })\n                    lemonToast.error(\n                        `Oops, the message couldn't be sent. Please change your browser's privacy level to the standard or default level, then try again. (E.g. In Firefox: Settings > Privacy & Security > Standard)`,\n                        { hideButton: true }\n                    )\n                    // Don't close the form or reset the data so user can try again\n                    return\n                }\n\n                const json = await response.json()\n\n                const zendesk_ticket_id = json.request.id\n                const zendesk_ticket_link = `https://posthoghelp.zendesk.com/agent/tickets/${zendesk_ticket_id}`\n                const properties = {\n                    zendesk_ticket_uuid,\n                    kind,\n                    target_area,\n                    message,\n                    zendesk_ticket_id,\n                    zendesk_ticket_link,\n                }\n                posthog.capture('support_ticket', properties)\n                lemonToast.success(\"Got the message! If we have follow-up information for you, we'll reply via email.\")\n                // Only close and reset the form on success\n                actions.closeSupportForm()\n                actions.resetSendSupportRequest()\n            } catch (e) {\n                posthog.captureException(e)\n\n                // More helpful error message\n                // Use the same error message regardless of browser\n                lemonToast.error(\n                    `Oops, the message couldn't be sent. Please change your browser's privacy level to the standard or default level, then try again. (E.g. In Firefox: Settings > Privacy & Security > Standard)`,\n                    { hideButton: true }\n                )\n                // Don't close the form or reset the data so user can try again\n            }\n        },\n\n        closeSupportForm: () => {\n            // Reset the form when closing so Cancel button clears the data\n            actions.resetSendSupportRequest()\n            props.onClose?.()\n        },\n\n        setSendSupportRequestValue: ({ name }) => {\n            // Only update URL params for non-text fields to prevent focus loss during typing\n            if (name !== 'message' && name !== 'name' && name !== 'email') {\n                actions.updateUrlParams()\n            }\n        },\n    })),\n\n    urlToAction(({ actions, values }) => ({\n        '*': (_, _search, hashParams) => {\n            if (values.isSupportFormOpen) {\n                return\n            }\n\n            const [panel, ...panelOptions] = (hashParams['panel'] ?? '').split(':')\n\n            if (panel === SidePanelTab.Support) {\n                const [kind, area, severity, isEmailFormOpen] = panelOptions\n\n                actions.openSupportForm({\n                    kind: Object.keys(SUPPORT_KIND_TO_SUBJECT).includes(kind) ? kind : null,\n                    target_area: getLabelBasedOnTargetArea(area) ? area : null,\n                    severity_level: Object.keys(SEVERITY_LEVEL_TO_NAME).includes(severity) ? severity : null,\n                    isEmailFormOpen: isEmailFormOpen ?? 'false',\n                })\n                return\n            }\n\n            // Legacy supportModal param\n            if ('supportModal' in hashParams) {\n                const [kind, area, severity] = (hashParams['supportModal'] || '').split(':')\n\n                actions.openSupportForm({\n                    kind: Object.keys(SUPPORT_KIND_TO_SUBJECT).includes(kind) ? kind : null,\n                    target_area: Object.keys(TARGET_AREA_TO_NAME).includes(area) ? area : null,\n                    severity_level: Object.keys(SEVERITY_LEVEL_TO_NAME).includes(severity) ? severity : null,\n                })\n            }\n        },\n    })),\n])\n","import { actions, afterMount, kea, key, listeners, path, props, reducers, sharedListeners } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { isNotNil } from 'lib/utils'\nimport {\n    diffVersions,\n    highestVersion,\n    isEqualVersion,\n    parseVersion,\n    SemanticVersion,\n    tryParseVersion,\n    versionToString,\n} from 'lib/utils/semver'\n\nimport { hogql } from '~/queries/utils'\n\nimport type { versionCheckerLogicType } from './versionCheckerLogicType'\n\n// If you would like to deprecate all posthog-js versions older than a specific version\n// (i.e. after fixing an important bug) please edit\n// https://github.com/PostHog/posthog-js/blob/main/deprecation.json\n\nconst CHECK_INTERVAL_MS = 1000 * 60 * 60 * 6 // 6 hour\n\nexport type SDKVersion = {\n    version: SemanticVersion\n    timestamp?: string\n}\n\nexport type SDKVersionWarning = {\n    latestUsedVersion: string\n    latestAvailableVersion: string\n    numVersionsBehind?: number\n    level: 'warning' | 'info' | 'error'\n}\n\nexport interface PosthogJSDeprecation {\n    deprecateBeforeVersion?: string\n    deprecateOlderThanDays?: number\n}\n\nexport interface AvailableVersions {\n    sdkVersions?: SemanticVersion[]\n    deprecation?: PosthogJSDeprecation\n}\n\nexport interface VersionCheckerLogicProps {\n    teamId: number | null\n}\n\nexport const versionCheckerLogic = kea<versionCheckerLogicType>([\n    props({ teamId: null } as VersionCheckerLogicProps),\n    key(({ teamId }) => teamId || 'no-team-id'),\n    path((key) => ['components', 'VersionChecker', 'versionCheckerLogic', key]),\n    actions({\n        setVersionWarning: (versionWarning: SDKVersionWarning | null) => ({ versionWarning }),\n        setSdkVersions: (sdkVersions: SDKVersion[]) => ({ sdkVersions }),\n    }),\n    loaders(({ values }) => ({\n        availableVersions: [\n            {} as AvailableVersions,\n            {\n                loadAvailableVersions: async (): Promise<AvailableVersions> => {\n                    // Make both requests simultaneously and don't return until both have finished, to avoid a flash\n                    // of partial results in the UI.\n                    const availableVersionsPromise: Promise<SemanticVersion[]> = fetch(\n                        'https://api.github.com/repos/posthog/posthog-js/tags'\n                    )\n                        .then((r) => r.json())\n                        .then((r) => r.map((x: any) => tryParseVersion(x.name)).filter(isNotNil))\n                    const deprecationPromise: Promise<PosthogJSDeprecation> = fetch(\n                        'https://raw.githubusercontent.com/PostHog/posthog-js/main/deprecation.json'\n                    ).then((r) => r.json())\n                    const settled = await Promise.allSettled([availableVersionsPromise, deprecationPromise])\n                    const availableVersions = settled[0].status === 'fulfilled' ? settled[0].value : []\n                    const deprecation = settled[1].status === 'fulfilled' ? settled[1].value : {}\n                    // if one or more of the requests failed, merge in the previous value if we have one\n                    return {\n                        ...values.availableVersions,\n                        sdkVersions: availableVersions,\n                        deprecation: deprecation,\n                    }\n                },\n            },\n        ],\n        usedVersions: [\n            null as SDKVersion[] | null,\n            {\n                loadUsedVersions: async () => {\n                    const query = hogql`\n                        SELECT properties.$lib_version AS lib_version, max(timestamp) AS latest_timestamp, count(lib_version) as count\n                        FROM events\n                        WHERE timestamp >= now() - INTERVAL 1 DAY \n                        AND timestamp <= now()\n                        AND properties.$lib = 'web'\n                        GROUP BY lib_version\n                        ORDER BY latest_timestamp DESC\n                        limit 10`\n\n                    const res = await api.queryHogQL(query, { refresh: 'force_blocking' })\n\n                    return (\n                        res.results\n                            ?.map((x) => {\n                                const version = tryParseVersion(x[0])\n                                if (!version) {\n                                    return null\n                                }\n                                return {\n                                    version,\n                                    timestamp: x[1],\n                                }\n                            })\n                            .filter(isNotNil) ?? null\n                    )\n                },\n            },\n        ],\n    })),\n\n    reducers({\n        lastCheckTimestamp: [\n            0,\n            { persist: true },\n            {\n                loadUsedVersionsSuccess: () => Date.now(),\n            },\n        ],\n        versionWarning: [\n            null as SDKVersionWarning | null,\n            // bumping cache key due to an incorrect tag being cached on 2024-02-12\n            { persist: true, prefix: '2024-02-12' },\n            {\n                setVersionWarning: (_, { versionWarning }) => versionWarning,\n            },\n        ],\n    }),\n\n    sharedListeners(({ values, actions }) => ({\n        checkForVersionWarning: () => {\n            if (!values.usedVersions?.length) {\n                return\n            }\n            const { deprecation, sdkVersions } = values.availableVersions\n\n            // We want the highest semantic version to be the latest used one, rather than\n            // the one with the latest timestamp, because secondary installations can spew old versions\n            const latestUsedVersion = highestVersion(values.usedVersions.map((v) => v.version))\n\n            // the latest version published on github\n            const latestAvailableVersion = sdkVersions?.[0]\n\n            // the version where, anything before this deprecated (i.e. this version is allowed, before it is not)\n            const deprecateBeforeVersion = deprecation?.deprecateBeforeVersion\n                ? parseVersion(deprecation.deprecateBeforeVersion)\n                : null\n\n            let warning: SDKVersionWarning | null = null\n\n            if (deprecateBeforeVersion) {\n                const diff = diffVersions(deprecateBeforeVersion, latestUsedVersion)\n                // if they are behind the deprecatedBeforeVersion by any amount, show an error\n                if (diff && diff.diff > 0) {\n                    warning = {\n                        latestUsedVersion: versionToString(latestUsedVersion),\n                        latestAvailableVersion: versionToString(latestAvailableVersion || deprecateBeforeVersion),\n                        level: 'error',\n                    }\n                }\n            }\n\n            if (!warning && sdkVersions && latestAvailableVersion) {\n                const diff = diffVersions(latestAvailableVersion, latestUsedVersion)\n\n                if (diff && diff.diff > 0) {\n                    // there's a difference between the latest used version and the latest available version\n\n                    let numVersionsBehind = sdkVersions.findIndex((v) => isEqualVersion(v, latestUsedVersion))\n                    if (numVersionsBehind === -1) {\n                        // if we couldn't find the versions, use the length of the list as a fallback\n                        numVersionsBehind = sdkVersions.length - 1\n                    }\n                    if (numVersionsBehind < diff.diff) {\n                        // we might have deleted versions, but if the actual diff is X then we must be at least X versions behind\n                        numVersionsBehind = diff.diff\n                    }\n\n                    let level: 'warning' | 'info' | 'error' | undefined\n                    if (diff.kind === 'major') {\n                        level = 'info' // it is desirable to be on the latest major version, but not critical\n                    } else if (diff.kind === 'minor') {\n                        level = numVersionsBehind >= 40 ? 'warning' : undefined\n                    }\n\n                    if (level === undefined && numVersionsBehind >= 50) {\n                        level = 'error'\n                    }\n\n                    // we check if there is a \"latest user version string\" to avoid returning odd data in unexpected cases\n                    if (level && !!versionToString(latestUsedVersion).trim().length) {\n                        warning = {\n                            latestUsedVersion: versionToString(latestUsedVersion),\n                            latestAvailableVersion: versionToString(latestAvailableVersion),\n                            level,\n                            numVersionsBehind,\n                        }\n                    }\n                }\n            }\n\n            actions.setVersionWarning(warning)\n        },\n    })),\n\n    listeners(({ sharedListeners }) => ({\n        loadAvailableVersionsSuccess: sharedListeners.checkForVersionWarning,\n        loadUsedVersionsSuccess: sharedListeners.checkForVersionWarning,\n    })),\n\n    afterMount(({ actions, values }) => {\n        if (values.lastCheckTimestamp < Date.now() - CHECK_INTERVAL_MS) {\n            actions.loadAvailableVersions()\n            actions.loadUsedVersions()\n        }\n    }),\n])\n","import { useValues } from 'kea'\nimport { TextContent } from 'lib/components/Cards/TextCard/TextCard'\nimport { useUploadFiles } from 'lib/hooks/useUploadFiles'\nimport { IconMarkdown, IconTools } from 'lib/lemon-ui/icons'\nimport { LemonFileInput } from 'lib/lemon-ui/LemonFileInput'\nimport { LemonTabs } from 'lib/lemon-ui/LemonTabs'\nimport { LemonTextArea, LemonTextAreaProps } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { Link } from 'lib/lemon-ui/Link'\nimport { Tooltip } from 'lib/lemon-ui/Tooltip'\nimport posthog from 'posthog-js'\nimport React, { useRef, useState } from 'react'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\n\nexport const LemonTextAreaMarkdown = React.forwardRef<HTMLTextAreaElement, LemonTextAreaProps>(\n    function LemonTextAreaMarkdown({ value, onChange, className, ...editAreaProps }, ref): JSX.Element {\n        const { objectStorageAvailable } = useValues(preflightLogic)\n\n        const [isPreviewShown, setIsPreviewShown] = useState(false)\n        const dropRef = useRef<HTMLDivElement>(null)\n\n        const { setFilesToUpload, filesToUpload, uploading } = useUploadFiles({\n            onUpload: (url, fileName) => {\n                onChange?.(value + `\\n\\n![${fileName}](${url})`)\n                posthog.capture('markdown image uploaded', { name: fileName })\n            },\n            onError: (detail) => {\n                posthog.capture('markdown image upload failed', { error: detail })\n                lemonToast.error(`Error uploading image: ${detail}`)\n            },\n        })\n\n        return (\n            <LemonTabs\n                activeKey={isPreviewShown ? 'preview' : 'write'}\n                onChange={(key) => setIsPreviewShown(key === 'preview')}\n                className={className}\n                tabs={[\n                    {\n                        key: 'write',\n                        label: 'Write',\n                        content: (\n                            <div ref={dropRef} className=\"LemonTextMarkdown flex flex-col gap-y-1 rounded\">\n                                <LemonTextArea\n                                    ref={ref}\n                                    {...editAreaProps}\n                                    autoFocus\n                                    value={value}\n                                    onChange={onChange}\n                                />\n                                <div className=\"text-secondary inline-flex items-center gap-x-1\">\n                                    <IconMarkdown className=\"text-2xl\" />\n                                    <span>Markdown formatting support</span>\n                                </div>\n                                {objectStorageAvailable ? (\n                                    <LemonFileInput\n                                        accept={'image/*'}\n                                        multiple={false}\n                                        alternativeDropTargetRef={dropRef}\n                                        onChange={setFilesToUpload}\n                                        loading={uploading}\n                                        value={filesToUpload}\n                                    />\n                                ) : (\n                                    <div className=\"text-secondary inline-flex items-center gap-x-1\">\n                                        <Tooltip title=\"Enable object storage to add images by dragging and dropping.\">\n                                            <span>\n                                                <IconTools className=\"text-xl mr-1\" />\n                                            </span>\n                                        </Tooltip>\n                                        <span>\n                                            Add external images using{' '}\n                                            <Link to=\"https://www.markdownguide.org/basic-syntax/#images-1\">\n                                                {' '}\n                                                Markdown image links\n                                            </Link>\n                                            .\n                                        </span>\n                                    </div>\n                                )}\n                            </div>\n                        ),\n                    },\n                    {\n                        key: 'preview',\n                        label: 'Preview',\n                        content: value ? (\n                            <TextContent text={value} className=\"LemonTextArea--preview\" />\n                        ) : (\n                            <i>Nothing to preview</i>\n                        ),\n                    },\n                ]}\n            />\n        )\n    }\n)\n","import './CodeEditor.scss'\n\nimport MonacoEditor, { DiffEditor as MonacoDiffEditor, type EditorProps, loader, Monaco } from '@monaco-editor/react'\nimport { BuiltLogic, useMountedLogic, useValues } from 'kea'\nimport { Spinner } from 'lib/lemon-ui/Spinner'\nimport { codeEditorLogic } from 'lib/monaco/codeEditorLogic'\nimport { codeEditorLogicType } from 'lib/monaco/codeEditorLogicType'\nimport { findNextFocusableElement, findPreviousFocusableElement } from 'lib/monaco/domUtils'\nimport { initHogLanguage } from 'lib/monaco/languages/hog'\nimport { initHogJsonLanguage } from 'lib/monaco/languages/hogJson'\nimport { initHogQLLanguage } from 'lib/monaco/languages/hogQL'\nimport { initHogTemplateLanguage } from 'lib/monaco/languages/hogTemplate'\nimport { initLiquidLanguage } from 'lib/monaco/languages/liquid'\nimport { inStorybookTestRunner } from 'lib/utils'\nimport { editor, editor as importedEditor, IDisposable } from 'monaco-editor'\nimport * as monaco from 'monaco-editor'\nimport { useEffect, useMemo, useRef, useState } from 'react'\n\nimport { themeLogic } from '~/layout/navigation-3000/themeLogic'\nimport { AnyDataNode, HogLanguage, HogQLMetadataResponse, NodeKind } from '~/queries/schema/schema-general'\n\nif (loader) {\n    loader.config({ monaco })\n}\n\nexport interface CodeEditorProps extends Omit<EditorProps, 'loading' | 'theme'> {\n    queryKey?: string\n    autocompleteContext?: string\n    onPressCmdEnter?: (value: string, selectionType: 'selection' | 'full') => void\n    /** Pressed up in an empty code editor, likely to edit the previous message in a list */\n    onPressUpNoValue?: () => void\n    autoFocus?: boolean\n    sourceQuery?: AnyDataNode\n    globals?: Record<string, any>\n    schema?: Record<string, any> | null\n    onMetadata?: (metadata: HogQLMetadataResponse | null) => void\n    onMetadataLoading?: (loading: boolean) => void\n    onError?: (error: string | null) => void\n    /** The original value to compare against - renders it in diff mode */\n    originalValue?: string\n}\nlet codeEditorIndex = 0\n\nexport function initModel(model: editor.ITextModel, builtCodeEditorLogic: BuiltLogic<codeEditorLogicType>): void {\n    ;(model as any).codeEditorLogic = builtCodeEditorLogic\n}\n\nfunction initEditor(\n    monaco: Monaco,\n    editor: importedEditor.IStandaloneCodeEditor,\n    editorProps: Omit<CodeEditorProps, 'options' | 'onMount' | 'queryKey' | 'value'>,\n    options: editor.IStandaloneEditorConstructionOptions,\n    builtCodeEditorLogic: BuiltLogic<codeEditorLogicType>\n): void {\n    // This gives autocomplete access to the specific editor\n    const model = editor.getModel()\n    if (model) {\n        initModel(model, builtCodeEditorLogic)\n    }\n\n    if (editorProps?.language === 'hog') {\n        initHogLanguage(monaco)\n    }\n    if (editorProps?.language === 'hogQL' || editorProps?.language === 'hogQLExpr') {\n        initHogQLLanguage(monaco, editorProps.language as HogLanguage)\n    }\n    if (editorProps?.language === 'hogTemplate') {\n        initHogTemplateLanguage(monaco)\n    }\n    if (editorProps?.language === 'hogJson') {\n        initHogJsonLanguage(monaco)\n    }\n    if (editorProps?.language === 'liquid') {\n        initLiquidLanguage(monaco)\n    }\n    if (options.tabFocusMode || editorProps.onPressUpNoValue) {\n        editor.onKeyDown((evt) => {\n            if (options.tabFocusMode) {\n                if (evt.keyCode === monaco.KeyCode.Tab && !evt.metaKey && !evt.ctrlKey) {\n                    const selection = editor.getSelection()\n                    if (\n                        selection &&\n                        (selection.startColumn !== selection.endColumn ||\n                            selection.startLineNumber !== selection.endLineNumber)\n                    ) {\n                        return\n                    }\n                    evt.preventDefault()\n                    evt.stopPropagation()\n\n                    const element: HTMLElement | null = evt.target?.parentElement?.parentElement?.parentElement ?? null\n                    if (!element) {\n                        return\n                    }\n                    const nextElement = evt.shiftKey\n                        ? findPreviousFocusableElement(element)\n                        : findNextFocusableElement(element)\n\n                    if (nextElement && 'focus' in nextElement) {\n                        nextElement.focus()\n                    }\n                }\n            }\n            if (editorProps.onPressUpNoValue) {\n                if (\n                    evt.keyCode === monaco.KeyCode.UpArrow &&\n                    !evt.metaKey &&\n                    !evt.ctrlKey &&\n                    editor.getValue() === ''\n                ) {\n                    evt.preventDefault()\n                    evt.stopPropagation()\n                    editorProps.onPressUpNoValue()\n                }\n            }\n        })\n    }\n}\n\nexport function CodeEditor({\n    queryKey,\n    options,\n    onMount,\n    value,\n    onPressCmdEnter,\n    autoFocus,\n    globals,\n    sourceQuery,\n    schema,\n    onError,\n    onMetadata,\n    onMetadataLoading,\n    originalValue,\n    ...editorProps\n}: CodeEditorProps): JSX.Element {\n    const { isDarkModeOn } = useValues(themeLogic)\n    const scrollbarRendering = !inStorybookTestRunner() ? 'auto' : 'hidden'\n    const [monacoAndEditor, setMonacoAndEditor] = useState(\n        null as [Monaco, importedEditor.IStandaloneCodeEditor] | null\n    )\n    const [monaco, editor] = monacoAndEditor ?? []\n\n    const [realKey] = useState(() => codeEditorIndex++)\n    const builtCodeEditorLogic = codeEditorLogic({\n        key: queryKey ?? `new/${realKey}`,\n        query: value ?? '',\n        language: editorProps.language ?? 'text',\n        globals,\n        sourceQuery,\n        monaco: monaco,\n        editor: editor,\n        onError,\n        onMetadata,\n        onMetadataLoading,\n        metadataFilters: sourceQuery?.kind === NodeKind.HogQLQuery ? sourceQuery.filters : undefined,\n    })\n    useMountedLogic(builtCodeEditorLogic)\n\n    // Create DIV with .monaco-editor inside <body> for monaco's popups.\n    // Without this monaco's tooltips will be mispositioned if inside another modal or popup.\n    const monacoRoot = useMemo(() => {\n        const body = (typeof document !== 'undefined' && document.getElementsByTagName('body')[0]) || null\n        const monacoRoot = document.createElement('div')\n        monacoRoot.classList.add('monaco-editor')\n        monacoRoot.style.zIndex = 'var(--z-tooltip)'\n        body?.appendChild(monacoRoot)\n        return monacoRoot\n    }, [])\n    useEffect(() => {\n        return () => {\n            monacoRoot?.remove()\n        }\n    }, [])\n\n    useEffect(() => {\n        if (!monaco) {\n            return\n        }\n        monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n            jsx: editorProps?.path?.endsWith('.tsx')\n                ? monaco.languages.typescript.JsxEmit.React\n                : monaco.languages.typescript.JsxEmit.Preserve,\n            esModuleInterop: true,\n        })\n    }, [monaco, editorProps.path])\n\n    useEffect(() => {\n        if (!monaco) {\n            return\n        }\n        monaco.languages.json.jsonDefaults.setDiagnosticsOptions({\n            validate: true,\n            schemas: schema\n                ? [\n                      {\n                          uri: 'http://internal/node-schema.json',\n                          fileMatch: ['*'],\n                          schema: schema,\n                      },\n                  ]\n                : [],\n        })\n    }, [monaco, schema])\n\n    // Using useRef, not useState, as we don't want to reload the component when this changes.\n    const monacoDisposables = useRef([] as IDisposable[])\n    useEffect(() => {\n        return () => {\n            monacoDisposables.current.forEach((d) => d?.dispose())\n        }\n    }, [])\n\n    const editorOptions: editor.IStandaloneEditorConstructionOptions = {\n        minimap: {\n            enabled: false,\n        },\n        scrollBeyondLastLine: false,\n        automaticLayout: true,\n        fixedOverflowWidgets: true,\n        glyphMargin: false,\n        folding: true,\n        wordWrap: 'off',\n        lineNumbers: 'on',\n        tabFocusMode: false,\n        overviewRulerBorder: true,\n        hideCursorInOverviewRuler: false,\n        overviewRulerLanes: 3,\n        overflowWidgetsDomNode: monacoRoot,\n        ...options,\n        padding: { bottom: 8, top: 8 },\n        scrollbar: {\n            vertical: scrollbarRendering,\n            horizontal: scrollbarRendering,\n            ...options?.scrollbar,\n        },\n    }\n\n    const editorOnMount = (editor: importedEditor.IStandaloneCodeEditor, monaco: Monaco): void => {\n        setMonacoAndEditor([monaco, editor])\n        initEditor(monaco, editor, editorProps, options ?? {}, builtCodeEditorLogic)\n\n        // Override Monaco's suggestion widget styling to prevent truncation\n        const overrideSuggestionWidgetStyling = (): void => {\n            const style = document.createElement('style')\n            style.textContent = `\n            .monaco-editor .suggest-widget .monaco-list .monaco-list-row.string-label>.contents>.main>.left>.monaco-icon-label {\n               flex-shrink: 0;\n            }\n\n            `\n            document.head.appendChild(style)\n        }\n\n        // Apply styling immediately and also when suggestion widget appears\n        overrideSuggestionWidgetStyling()\n\n        // Monitor for suggestion widget creation and apply styling\n        const observer = new MutationObserver(() => {\n            const suggestWidget = document.querySelector('.monaco-editor .suggest-widget')\n            if (suggestWidget) {\n                overrideSuggestionWidgetStyling()\n            }\n        })\n        observer.observe(document.body, { childList: true, subtree: true })\n\n        // Clean up observer\n        monacoDisposables.current.push({\n            dispose: () => observer.disconnect(),\n        })\n\n        if (onPressCmdEnter) {\n            monacoDisposables.current.push(\n                editor.addAction({\n                    id: 'saveAndRunPostHog',\n                    label: 'Save and run query',\n                    keybindings: [monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter],\n                    run: () => {\n                        const selection = editor.getSelection()\n                        const model = editor.getModel()\n                        if (selection && model) {\n                            const highlightedText = model.getValueInRange(selection)\n                            onPressCmdEnter(highlightedText, 'selection')\n                            return\n                        }\n\n                        onPressCmdEnter(editor.getValue(), 'full')\n                    },\n                })\n            )\n        }\n        if (autoFocus) {\n            editor.focus()\n            const model = editor.getModel()\n            if (model) {\n                editor.setPosition({\n                    column: model.getLineContent(model.getLineCount()).length + 1,\n                    lineNumber: model.getLineCount(),\n                })\n            }\n        }\n\n        onMount?.(editor, monaco)\n    }\n\n    if (originalValue) {\n        // If originalValue is provided, we render a diff editor instead\n        return (\n            <MonacoDiffEditor\n                key={queryKey}\n                loading={<Spinner />}\n                theme={isDarkModeOn ? 'vs-dark' : 'vs-light'}\n                original={originalValue}\n                modified={value}\n                options={{\n                    ...editorOptions,\n                    renderSideBySide: false,\n                    acceptSuggestionOnEnter: 'on',\n                    renderGutterMenu: false,\n                }}\n                {...editorProps}\n            />\n        )\n    }\n\n    return (\n        <MonacoEditor // eslint-disable-line react/forbid-elements\n            key={queryKey}\n            theme={isDarkModeOn ? 'vs-dark' : 'vs-light'}\n            loading={<Spinner />}\n            value={value}\n            options={editorOptions}\n            onMount={editorOnMount}\n            {...editorProps}\n        />\n    )\n}\n","import './ButtonPrimitives.scss'\n\nimport { cva, type VariantProps } from 'cva'\nimport { Tooltip, TooltipProps } from 'lib/lemon-ui/Tooltip/Tooltip'\nimport { cn } from 'lib/utils/css-classes'\nimport React, { createContext, forwardRef, ReactNode, useContext } from 'react'\n\n/* -------------------------------------------------------------------------- */\n/*                           Props & Contexts & Hooks                         */\n/* -------------------------------------------------------------------------- */\n\ntype ButtonVariant = 'default' | 'outline'\n\nexport type ButtonSize = 'sm' | 'base' | 'lg' | 'fit' | 'base-tall'\n\ninterface ButtonGroupContextValue {\n    sizeContext: ButtonSize\n    variantContext: ButtonVariant\n}\n\nconst ButtonContext = createContext<ButtonGroupContextValue | null>(null)\n\nfunction useButtonGroupContext(): ButtonGroupContextValue | null {\n    const context = useContext(ButtonContext)\n    return context\n}\n\ntype ButtonGroupProps = {\n    children: ReactNode\n    className?: string\n    groupVariant?: ButtonVariant\n} & VariantProps<typeof buttonPrimitiveVariants>\n\ntype ButtonBaseProps = {\n    iconOnly?: boolean\n    showDivider?: boolean\n    disabled?: boolean\n    active?: boolean\n    tooltip?: TooltipProps['title']\n    tooltipDocLink?: TooltipProps['docLink']\n    tooltipPlacement?: TooltipProps['placement']\n    buttonWrapper?: (button: JSX.Element) => JSX.Element\n} & VariantProps<typeof buttonPrimitiveVariants>\n\n/* -------------------------------------------------------------------------- */\n/*                              Button Group Variants                         */\n/* -------------------------------------------------------------------------- */\n\n/* -------------------------------------------------------------------------- */\n/*                              Button Group Component                        */\n/* -------------------------------------------------------------------------- */\n\nexport const ButtonGroupPrimitive = forwardRef<HTMLDivElement, ButtonGroupProps>((props, ref) => {\n    const {\n        className,\n        groupVariant = 'default',\n        variant = 'default',\n        size = 'base',\n        fullWidth = false,\n        children,\n        ...rest\n    } = props\n    const Comp = 'div'\n\n    const setContext: ButtonGroupContextValue = {\n        variantContext: variant,\n        sizeContext: size,\n    }\n\n    let buttonHeight = 'button-primitive--height-base'\n    switch (size) {\n        case 'sm':\n            buttonHeight = 'button-primitive--height-sm'\n            break\n        case 'base-tall':\n            buttonHeight = 'button-primitive--height-base-tall'\n            break\n        case 'lg':\n            buttonHeight = 'button-primitive--height-lg'\n            break\n        case 'fit':\n            buttonHeight = ''\n            break\n    }\n\n    return (\n        <ButtonContext.Provider value={setContext}>\n            <Comp\n                className={cn(\n                    'button-primitive-group',\n                    buttonPrimitiveVariants({\n                        size: 'fit',\n                        variant: groupVariant,\n                        fullWidth,\n                        isGroup: true,\n                        className,\n                    }),\n                    buttonHeight\n                )}\n                ref={ref}\n                {...rest}\n            >\n                {children}\n            </Comp>\n        </ButtonContext.Provider>\n    )\n})\n\nButtonGroupPrimitive.displayName = 'ButtonGroupPrimitive'\n\n/* -------------------------------------------------------------------------- */\n/*                              Button Base Component                         */\n/* -------------------------------------------------------------------------- */\n\nexport interface ButtonPrimitiveProps extends ButtonBaseProps, React.ButtonHTMLAttributes<HTMLButtonElement> {}\n\nexport const buttonPrimitiveVariants = cva({\n    base: 'button-primitive group/button-primitive',\n    variants: {\n        variant: {\n            // Bordereless variant (aka posthog tertiary button)\n            default: 'button-primitive--variant-default',\n            // Outline variant (aka posthog secondary button)\n            outline: 'button-primitive--variant-outline',\n        },\n        size: {\n            sm: `button-primitive--size-sm button-primitive--height-sm text-sm`,\n            base: `button-primitive--size-base button-primitive--height-base text-sm`,\n            'base-tall': `button-primitive--size-base-tall button-primitive--height-base-tall text-sm`,\n            lg: `button-primitive--size-lg button-primitive--height-lg text-base`,\n            fit: 'px-0',\n        },\n        iconOnly: {\n            true: 'icon-only p-0 justify-center items-center shrink-0',\n            false: '',\n        },\n        fullWidth: {\n            true: 'button-primitive--full-width',\n            false: '',\n        },\n        isGroup: {\n            true: '',\n            false: 'gap-1.5',\n        },\n        active: {\n            true: 'button-primitive--active',\n            false: '',\n        },\n        menuItem: {\n            true: 'rounded-sm button-primitive--full-width justify-start shrink-0',\n            false: '',\n        },\n        truncate: {\n            true: 'truncate',\n            false: '',\n        },\n        disabled: {\n            true: 'disabled:opacity-50',\n            false: '',\n        },\n        hasSideActionRight: {\n            true: 'rounded-md',\n            false: '',\n        },\n        isSideActionRight: {\n            true: 'absolute right-0 -top-px -bottom-px rounded-l-none',\n        },\n    },\n    defaultVariants: {\n        variant: 'default',\n        size: 'base',\n        fullWidth: false,\n        isGroup: false,\n        menuItem: false,\n    },\n    compoundVariants: [\n        {\n            hasSideActionRight: true,\n            size: 'sm',\n            className: `\n                pr-[calc(var(--button-height-sm)+var(--button-padding-x-sm))]\n            `,\n        },\n        {\n            hasSideActionRight: true,\n            size: 'base',\n            className: `\n                pr-[calc(var(--button-height-base)+var(--button-padding-x-base))]\n            `,\n        },\n        {\n            hasSideActionRight: true,\n            size: 'lg',\n            className: `\n                pr-[calc(var(--button-height-lg)+var(--button-padding-x-lg))]\n            `,\n        },\n    ],\n})\n\nexport const ButtonPrimitive = forwardRef<HTMLButtonElement, ButtonPrimitiveProps>((props, ref) => {\n    const {\n        className,\n        variant,\n        size,\n        fullWidth,\n        children,\n        iconOnly,\n        menuItem,\n        disabled,\n        active,\n        buttonWrapper,\n        hasSideActionRight,\n        isSideActionRight,\n        tooltip,\n        tooltipPlacement,\n        tooltipDocLink,\n        ...rest\n    } = props\n    // If inside a ButtonGroup, use the context values, otherwise use props\n    const context = useButtonGroupContext()\n    const effectiveSize = context?.sizeContext || size\n    const effectiveVariant = context?.variantContext || variant\n\n    let buttonComponent: JSX.Element = React.createElement(\n        'button',\n        {\n            className: cn(\n                buttonPrimitiveVariants({\n                    variant: effectiveVariant,\n                    size: effectiveSize,\n                    fullWidth,\n                    iconOnly,\n                    menuItem,\n                    disabled,\n                    hasSideActionRight,\n                    isSideActionRight,\n                    className,\n                })\n            ),\n            ref,\n            disabled,\n            ...rest,\n            'aria-disabled': disabled,\n            'data-active': active,\n        },\n        children\n    )\n\n    if (tooltip || tooltipDocLink) {\n        buttonComponent = (\n            <Tooltip title={tooltip} placement={tooltipPlacement} docLink={tooltipDocLink}>\n                {buttonComponent}\n            </Tooltip>\n        )\n    }\n\n    if (buttonWrapper) {\n        buttonComponent = buttonWrapper(buttonComponent)\n    }\n\n    return buttonComponent\n})\n\nButtonPrimitive.displayName = 'ButtonPrimitive'\n","/*!\n we used to use https://mths.be/cssescape v1.5.1 by @mathias | MIT license\n but the `finder` dependency has always been using `CSS.escape` from the browser\n and nobody has ever pointed out an error\n cssEscape function was only for IE11 users\n and they mustn't be using this anyway\n */\nexport const cssEscape = CSS.escape\n","// This file contains example queries, used in storybook and in the /query interface.\nimport { RETENTION_FIRST_TIME } from 'lib/constants'\n\nimport { defaultDataTableColumns } from '~/queries/nodes/DataTable/utils'\nimport {\n    ActionsNode,\n    CalendarHeatmapQuery,\n    DataTableNode,\n    DataVisualizationNode,\n    EventsNode,\n    EventsQuery,\n    FunnelsQuery,\n    HogQLQuery,\n    HogQuery,\n    InsightVizNode,\n    LifecycleQuery,\n    Node,\n    NodeKind,\n    PathsQuery,\n    PersonsNode,\n    RetentionQuery,\n    StickinessQuery,\n    TrendsQuery,\n    WebStatsBreakdown,\n    WebVitalsMetric,\n    WebVitalsPathBreakdownQuery,\n    WebVitalsPercentile,\n    WebVitalsQuery,\n} from '~/queries/schema/schema-general'\nimport {\n    BaseMathType,\n    ChartDisplayType,\n    FilterLogicalOperator,\n    InsightType,\n    PropertyFilterType,\n    PropertyGroupFilter,\n    PropertyMathType,\n    PropertyOperator,\n    RetentionPeriod,\n    StepOrderValue,\n} from '~/types'\n\nimport { WEB_VITALS_THRESHOLDS } from './nodes/WebVitals/definitions'\nimport { setLatestVersionsOnQuery } from './utils'\n\nconst Events: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: defaultDataTableColumns(NodeKind.EventsQuery),\n    properties: [\n        { type: PropertyFilterType.Event, key: '$browser', operator: PropertyOperator.Exact, value: 'Chrome' },\n    ],\n    after: '-24h',\n    limit: 100,\n}\n\nconst EventsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: Events,\n}\nconst EventsTableFull: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: Events,\n}\n\nconst TotalEvents: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: ['count()'],\n}\n\nexport const TotalEventsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: TotalEvents,\n}\n\nconst PropertyFormulas: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: [\n        '1 + 2 + 3',\n        'event',\n        'person.created_at',\n        \"concat(properties['$browser'], ' 💚 ', properties['$geoip_city_name']) -- Browser 💚 City\",\n        \"'random string'\",\n    ],\n    limit: 100,\n}\n\nconst PropertyFormulasTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: PropertyFormulas,\n}\n\nconst EventAggregations: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: {\n        kind: NodeKind.EventsQuery,\n        select: [\n            \"concat(properties['$geoip_city_name'], ' ', 'Rocks') -- City\",\n            'event',\n            'count() + 100000 -- Inflamed total',\n            '1 + 2',\n        ],\n        orderBy: ['-count()'],\n    },\n}\n\nconst Persons: PersonsNode = {\n    kind: NodeKind.PersonsNode,\n    properties: [\n        { type: PropertyFilterType.Person, key: '$browser', operator: PropertyOperator.Exact, value: 'Chrome' },\n    ],\n}\n\nconst PersonsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    columns: defaultDataTableColumns(NodeKind.PersonsNode),\n    source: Persons,\n}\n\nconst PersonsTableFull: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    columns: defaultDataTableColumns(NodeKind.PersonsNode),\n    source: Persons,\n}\n\nconst properties: PropertyGroupFilter = {\n    type: FilterLogicalOperator.And,\n    values: [\n        {\n            type: FilterLogicalOperator.Or,\n            values: [\n                {\n                    type: PropertyFilterType.Event,\n                    key: '$current_url',\n                    operator: PropertyOperator.Exact,\n                    value: ['https://hedgebox.net/files/'],\n                },\n                {\n                    type: PropertyFilterType.Event,\n                    key: '$geoip_country_code',\n                    operator: PropertyOperator.Exact,\n                    value: ['US', 'AU'],\n                },\n            ],\n        },\n    ],\n}\n\nconst filterTestAccounts = false\nconst series: (EventsNode | ActionsNode)[] = [\n    {\n        kind: NodeKind.EventsNode,\n        name: '$pageview',\n        custom_name: 'Views',\n        event: '$pageview',\n        properties: [\n            {\n                type: PropertyFilterType.Event,\n                key: '$browser',\n                operator: PropertyOperator.Exact,\n                value: 'Chrome',\n            },\n            {\n                type: PropertyFilterType.Cohort,\n                key: 'id',\n                operator: PropertyOperator.In,\n                value: 2,\n            },\n        ],\n    },\n    // {\n    //     kind: NodeKind.ActionsNode,\n    //     id: 1,\n    //     name: 'Interacted with file',\n    //     custom_name: 'Interactions',\n    //     properties: [\n    //         {\n    //             type: PropertyFilterType.Event,\n    //             key: '$geoip_country_code',\n    //             operator: PropertyOperator.Exact,\n    //             value: ['US'],\n    //         },\n    //     ],\n    //     math: PropertyMathType.Average,\n    //     math_property: '$session_duration',\n    // },\n]\n\nconst InsightTrendsQuery: TrendsQuery = {\n    kind: NodeKind.TrendsQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    trendsFilter: {\n        display: ChartDisplayType.ActionsAreaGraph,\n    },\n    breakdownFilter: {\n        breakdown: '$geoip_country_code',\n        breakdown_type: 'event',\n    },\n}\n\nconst InsightCalendarHeatmapQuery: CalendarHeatmapQuery = {\n    kind: NodeKind.CalendarHeatmapQuery,\n    properties: [],\n    filterTestAccounts,\n    series,\n    dateRange: {\n        date_from: '-7d',\n    },\n}\n\nconst InsightFunnelsQuery: FunnelsQuery = {\n    kind: NodeKind.FunnelsQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    funnelsFilter: {\n        funnelOrderType: StepOrderValue.ORDERED,\n    },\n    breakdownFilter: {\n        breakdown: '$geoip_country_code',\n        breakdown_type: 'event',\n    },\n}\n\nconst InsightRetentionQuery: RetentionQuery = {\n    kind: NodeKind.RetentionQuery,\n    properties,\n    filterTestAccounts,\n    retentionFilter: {\n        // TODO: this should be typed as (EventsNode | ActionsNode)[] without math and properties\n        targetEntity: { type: 'events', id: '$pageview', name: '$pageview' },\n        returningEntity: { type: 'events', id: '$pageview', name: '$pageview' },\n    },\n}\n\nconst InsightPathsQuery: PathsQuery = {\n    kind: NodeKind.PathsQuery,\n    properties,\n    filterTestAccounts,\n    pathsFilter: {},\n}\n\nconst InsightStickinessQuery: StickinessQuery = {\n    kind: NodeKind.StickinessQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    stickinessFilter: {},\n}\n\nconst InsightLifecycleQuery: LifecycleQuery = {\n    kind: NodeKind.LifecycleQuery,\n    properties,\n    filterTestAccounts,\n    dateRange: {\n        date_from: '-7d',\n    },\n    series, // TODO: Visualization only supports one event or action\n}\n\nconst HogQLRaw: HogQLQuery = {\n    kind: NodeKind.HogQLQuery,\n    query: `   select event,\n          person.properties.email,\n          properties.$browser,\n          count()\n     from events\n    where {filters} -- replaced with global date and property filters\n      and person.properties.email is not null\n group by event,\n          properties.$browser,\n          person.properties.email\n order by count() desc\n    limit 100`,\n    filters: {\n        dateRange: {\n            date_from: '-24h',\n        },\n    },\n}\n\nconst HogQLForDataVisualization: HogQLQuery = {\n    kind: NodeKind.HogQLQuery,\n    query: `select toDate(timestamp) as timestamp, count()\nfrom events\nwhere timestamp >= now() - interval '7 days'\ngroup by timestamp\norder by timestamp asc\nlimit 100`,\n}\n\nconst HogQLForDataWarehouse: HogQLQuery = {\n    kind: NodeKind.HogQLQuery,\n    query: `select toDate(timestamp) as timestamp, count()\nfrom events\ngroup by timestamp\nlimit 100`,\n    explain: true,\n}\n\nconst DataWarehouse: DataVisualizationNode = {\n    kind: NodeKind.DataVisualizationNode,\n    source: HogQLForDataWarehouse,\n}\n\nconst HogQLTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: HogQLRaw,\n}\n\nconst DataVisualization: DataVisualizationNode = {\n    kind: NodeKind.DataVisualizationNode,\n    source: HogQLForDataVisualization,\n    tableSettings: {\n        columns: [\n            {\n                column: 'timestamp',\n                settings: {\n                    formatting: {\n                        prefix: '',\n                        suffix: '',\n                    },\n                },\n            },\n            {\n                column: 'count()',\n                settings: {\n                    formatting: {\n                        prefix: '',\n                        suffix: '',\n                    },\n                },\n            },\n        ],\n    },\n    chartSettings: { goalLines: undefined },\n}\n\nconst Hog: HogQuery = {\n    kind: NodeKind.HogQuery,\n    code: 'return 1 + 2;',\n}\n\nconst Hoggonacci: HogQuery = {\n    kind: NodeKind.HogQuery,\n    code: `fn fibonacci(number) {\n    if (number < 2) {\n        return number;\n    } else {\n        return fibonacci(number - 1) + fibonacci(number - 2);\n    }\n}\nreturn fibonacci(16);`,\n}\n\nconst WebVitals: WebVitalsQuery = {\n    kind: NodeKind.WebVitalsQuery,\n    properties: [],\n    dateRange: {\n        date_from: '-7d',\n    },\n    source: {\n        kind: NodeKind.TrendsQuery,\n        dateRange: {\n            date_from: '-7d',\n        },\n        interval: 'day',\n        series: (['INP', 'LCP', 'CLS', 'FCP'] as WebVitalsMetric[]).flatMap((name) =>\n            [PropertyMathType.P75, PropertyMathType.P90, PropertyMathType.P99].map((math) => ({\n                kind: NodeKind.EventsNode,\n                event: '$web_vitals',\n                name: '$web_vitals',\n                custom_name: name,\n                math: math,\n                math_property: `$web_vitals_${name}_value`,\n            }))\n        ),\n        trendsFilter: { display: ChartDisplayType.ActionsLineGraph },\n        filterTestAccounts,\n    },\n}\n\nconst WebVitalsPathBreakdown: WebVitalsPathBreakdownQuery = {\n    kind: NodeKind.WebVitalsPathBreakdownQuery,\n    properties: [],\n    dateRange: {\n        date_from: '-7d',\n    },\n    filterTestAccounts,\n    percentile: 'p90' as WebVitalsPercentile,\n    metric: 'CLS' as WebVitalsMetric,\n    doPathCleaning: true,\n    thresholds: [WEB_VITALS_THRESHOLDS['CLS'].good, WEB_VITALS_THRESHOLDS['CLS'].poor],\n}\n\nconst WebAnalyticsReferrerDomain: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: {\n        kind: NodeKind.WebStatsTableQuery,\n        properties: [],\n        breakdownBy: WebStatsBreakdown.InitialReferringDomain,\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        compareFilter: { compare: false },\n        limit: 10,\n        filterTestAccounts: false,\n        conversionGoal: null,\n    },\n}\n\nconst WebAnalyticsPath: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: {\n        kind: NodeKind.WebStatsTableQuery,\n        properties: [],\n        breakdownBy: WebStatsBreakdown.Page,\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        compareFilter: { compare: false },\n        limit: 10,\n        filterTestAccounts: false,\n        conversionGoal: null,\n    },\n}\n\nconst WebAnalyticsBrowser: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: {\n        kind: NodeKind.WebStatsTableQuery,\n        properties: [],\n        breakdownBy: WebStatsBreakdown.Browser,\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        compareFilter: { compare: false },\n        limit: 10,\n        filterTestAccounts: false,\n        conversionGoal: null,\n    },\n}\n\nconst WebAnalyticsWorldMap: InsightVizNode<TrendsQuery> = {\n    kind: NodeKind.InsightVizNode,\n    source: {\n        kind: NodeKind.TrendsQuery,\n        breakdownFilter: {\n            breakdown: '$geoip_country_code',\n            breakdown_type: 'event',\n        },\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        series: [\n            {\n                event: '$pageview',\n                name: 'Pageview',\n                kind: NodeKind.EventsNode,\n                math: BaseMathType.MonthlyActiveUsers, // Should be DAU, but it's not supported yet\n            },\n        ],\n        trendsFilter: { display: ChartDisplayType.WorldMap },\n        filterTestAccounts: false,\n        properties: [],\n    },\n}\n\nconst WebAnalyticsRetention: InsightVizNode<RetentionQuery> = {\n    kind: NodeKind.InsightVizNode,\n    source: {\n        kind: NodeKind.RetentionQuery,\n        properties: [],\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        filterTestAccounts: false,\n        retentionFilter: {\n            retentionType: RETENTION_FIRST_TIME,\n            retentionReference: 'total',\n            totalIntervals: 8,\n            period: RetentionPeriod.Week,\n        },\n    },\n    vizSpecificOptions: {\n        [InsightType.RETENTION]: {\n            hideLineGraph: true,\n            hideSizeColumn: false,\n            useSmallLayout: false,\n        },\n    },\n}\n\n/* a subset of examples including only those we can show all users and that don't use HogQL */\nexport const queryExamples: Record<string, Node> = {\n    Events,\n    EventsTable,\n    EventsTableFull,\n    TotalEventsTable,\n    PropertyFormulasTable,\n    EventAggregations,\n    Persons,\n    PersonsTable,\n    PersonsTableFull,\n    InsightTrendsQuery,\n    InsightTrends: { kind: NodeKind.InsightVizNode, source: InsightTrendsQuery } as InsightVizNode<TrendsQuery>,\n    InsightCalendarHeatmapQuery,\n    InsightCalendarHeatmap: {\n        kind: NodeKind.InsightVizNode,\n        source: InsightCalendarHeatmapQuery,\n    } as InsightVizNode<CalendarHeatmapQuery>,\n    InsightFunnelsQuery,\n    InsightFunnels: { kind: NodeKind.InsightVizNode, source: InsightFunnelsQuery } as InsightVizNode<FunnelsQuery>,\n    InsightRetentionQuery,\n    InsightRetention: {\n        kind: NodeKind.InsightVizNode,\n        source: InsightRetentionQuery,\n    } as InsightVizNode<RetentionQuery>,\n    InsightPathsQuery,\n    InsightPaths: { kind: NodeKind.InsightVizNode, source: InsightPathsQuery } as InsightVizNode<PathsQuery>,\n    InsightStickinessQuery,\n    InsightStickiness: {\n        kind: NodeKind.InsightVizNode,\n        source: InsightStickinessQuery,\n    } as InsightVizNode<StickinessQuery>,\n    InsightLifecycleQuery,\n    InsightLifecycle: {\n        kind: NodeKind.InsightVizNode,\n        source: InsightLifecycleQuery,\n    } as InsightVizNode<LifecycleQuery>,\n    WebVitals,\n    WebVitalsPathBreakdown,\n    WebAnalyticsWorldMap,\n    WebAnalyticsReferrerDomain,\n    WebAnalyticsPath,\n    WebAnalyticsBrowser,\n    WebAnalyticsRetention,\n}\n\nexport const stringifiedQueryExamples: Record<string, string> = Object.fromEntries(\n    Object.entries(queryExamples).map(([key, node]) => [key, JSON.stringify(node)])\n)\n\nexport const examples: Record<string, Node> = setLatestVersionsOnQuery({\n    ...queryExamples,\n    HogQLRaw,\n    HogQLTable,\n    DataVisualization,\n    HogQLForDataVisualization,\n    Hog,\n    Hoggonacci,\n    DataWarehouse,\n})\n\nexport const stringifiedExamples: Record<string, string> = Object.fromEntries(\n    Object.entries(examples).map(([key, node]) => [key, JSON.stringify(node)])\n)\n","import { LemonSegmentedButton } from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { insightLogic } from 'scenes/insights/insightLogic'\nimport { insightVizDataLogic } from 'scenes/insights/insightVizDataLogic'\n\nexport function RetentionCumulativeButton(): JSX.Element | null {\n    const { insightProps, canEditInsight } = useValues(insightLogic)\n\n    const { retentionFilter } = useValues(insightVizDataLogic(insightProps))\n    const { updateInsightFilter } = useActions(insightVizDataLogic(insightProps))\n\n    const cumulativeRetention = retentionFilter?.cumulative || false\n\n    if (!canEditInsight) {\n        return null\n    }\n\n    return (\n        <LemonSegmentedButton\n            value={cumulativeRetention ? 1 : 0}\n            onChange={(value: number) => {\n                updateInsightFilter({ cumulative: value === 1 })\n            }}\n            options={[\n                {\n                    value: 0,\n                    label: 'on',\n                    tooltip: 'Retention value is the percentage of users who come back on a specific period',\n                },\n                {\n                    value: 1,\n                    label: 'on or after',\n                    tooltip: `\n                    Retention value is the percentage of users who come back on a specific time period or any of the following time periods.\n                    Also known as rolling, or unbounded retention.\n                    For example, if a user comes back on day 7, they are counted in all previous retention periods.`,\n                },\n            ]}\n        />\n    )\n}\n","import * as d3 from 'd3'\nimport * as Sankey from 'd3-sankey'\nimport { D3Selector } from 'lib/hooks/useD3'\nimport { stripHTTP } from 'lib/utils'\nimport { Dispatch, RefObject, SetStateAction } from 'react'\n\nimport { FunnelPathsFilter, PathsFilter } from '~/queries/schema/schema-general'\n\nimport { FALLBACK_CANVAS_WIDTH, HIDE_PATH_CARD_HEIGHT } from './Paths'\nimport { isSelectedPathStartOrEnd, PathNodeData, PathTargetLink, roundedRect } from './pathUtils'\nimport { Paths } from './types'\n\nconst createCanvas = (canvasRef: RefObject<HTMLDivElement>, width: number, height: number): D3Selector => {\n    return d3\n        .select(canvasRef.current)\n        .append('svg')\n        .classed('Paths__canvas', true)\n        .style('background', 'var(--item-background)')\n        .style('width', `${width}px`)\n        .style('height', `${height}px`)\n}\n\nconst createSankeyGenerator = (width: number, height: number): Sankey.SankeyLayout<any, any, any> => {\n    // @ts-expect-error - d3 sankey typing things\n    return new Sankey.sankey()\n        .nodeId((d: PathNodeData) => d.name)\n        .nodeAlign(Sankey.sankeyJustify)\n        .nodeSort(null)\n        .nodeWidth(15)\n        .size([width, height])\n}\n\nconst appendPathNodes = (\n    svg: any,\n    nodes: PathNodeData[],\n    pathsFilter: PathsFilter,\n    funnelPathsFilter: FunnelPathsFilter,\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void => {\n    svg.append('g')\n        .selectAll('rect')\n        .data(nodes)\n        .join('rect')\n        .attr('x', (d: PathNodeData) => d.x0 + 1)\n        .attr('y', (d: PathNodeData) => d.y0)\n        .attr('height', (d: PathNodeData) => d.y1 - d.y0)\n        .attr('width', (d: PathNodeData) => d.x1 - d.x0 - 2)\n        .attr('fill', (d: PathNodeData) => {\n            let c\n            for (const link of d.sourceLinks) {\n                if (c === undefined) {\n                    c = link.color\n                } else if (c !== link.color) {\n                    c = null\n                }\n            }\n            if (c === undefined) {\n                for (const link of d.targetLinks) {\n                    if (c === undefined) {\n                        c = link.color\n                    } else if (c !== link.color) {\n                        c = null\n                    }\n                }\n            }\n            if (isSelectedPathStartOrEnd(pathsFilter, funnelPathsFilter, d)) {\n                return 'var(--paths-node-start-or-end)'\n            }\n            const startNodeColor = c && d3.color(c) ? d3.color(c) : 'var(--paths-node)'\n            return startNodeColor\n        })\n        .on('mouseover', (_event: MouseEvent, data: PathNodeData) => {\n            if (data.y1 - data.y0 > HIDE_PATH_CARD_HEIGHT) {\n                return\n            }\n            setNodeCards(\n                nodes.map((node: PathNodeData) =>\n                    node.index === data.index\n                        ? { ...node, visible: true }\n                        : { ...node, visible: node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT }\n                )\n            )\n        })\n        .append('title')\n        .text((d: PathNodeData) => `${stripHTTP(d.name)}\\n${d.value.toLocaleString()}`)\n}\n\nconst appendDropoffs = (svg: D3Selector): void => {\n    const dropOffGradient = svg\n        .append('defs')\n        .append('linearGradient')\n        .attr('id', 'dropoff-gradient')\n        .attr('gradientTransform', 'rotate(90)')\n\n    dropOffGradient.append('stop').attr('offset', '0%').attr('stop-color', 'var(--paths-dropoff)')\n\n    dropOffGradient.append('stop').attr('offset', '100%').attr('stop-color', 'var(--bg-surface-primary)')\n}\n\nconst appendPathLinks = (\n    svg: any,\n    links: PathNodeData[],\n    nodes: PathNodeData[],\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void => {\n    const link = svg\n        .append('g')\n        .attr('fill', 'none')\n        .selectAll('g')\n        .data(links)\n        .join('g')\n        .attr('stroke', 'var(--paths-link)')\n        .attr('opacity', 0.35)\n\n    link.append('path')\n        .attr('d', Sankey.sankeyLinkHorizontal())\n        .attr('id', (d: PathNodeData) => `path-${d.index}`)\n        .attr('stroke-width', (d: PathNodeData) => {\n            return Math.max(1, d.width)\n        })\n        .on('mouseover', (_event: MouseEvent, data: PathNodeData) => {\n            svg.select(`#path-${data.index}`).attr('stroke', 'var(--paths-link-hover)')\n            if (data?.source?.targetLinks.length === 0) {\n                return\n            }\n            const nodesToColor = [data.source]\n            const pathCardsToShow: number[] = []\n            while (nodesToColor.length > 0) {\n                const _node = nodesToColor.pop()\n                _node?.targetLinks.forEach((_link: PathTargetLink) => {\n                    svg.select(`#path-${_link.index}`).attr('stroke', 'var(--paths-link-hover)')\n                    nodesToColor.push(_link.source)\n                    pathCardsToShow.push(_link.source.index)\n                })\n            }\n            const pathCards = [data.target]\n            pathCardsToShow.push(data.target.index, data.source.index)\n            while (pathCards.length > 0) {\n                const node = pathCards.pop()\n                node?.sourceLinks.forEach((l: PathTargetLink) => {\n                    pathCards.push(l.target)\n                    pathCardsToShow.push(l.target.index)\n                })\n            }\n            setNodeCards(\n                nodes.map((node: PathNodeData) => ({\n                    ...node,\n\n                    visible: pathCardsToShow.includes(node.index) ? true : node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT,\n                }))\n            )\n        })\n        .on('mouseleave', () => {\n            svg.selectAll('path').attr('stroke', 'var(--paths-link)')\n        })\n\n    link.append('g')\n        .append('path')\n        .attr('d', (data: PathNodeData) => {\n            if (data.source.layer === 0) {\n                return\n            }\n            const _height =\n                data.source.y1 - data.source.y0 - data.source.sourceLinks.reduce((prev, curr) => prev + curr.width, 0)\n            return roundedRect(0, 0, 30, _height, Math.min(25, _height), false, true, false, false)\n        })\n        .attr('fill', 'url(#dropoff-gradient)')\n        .attr('stroke-width', 0)\n        .attr('transform', (data: PathNodeData) => {\n            return (\n                'translate(' +\n                Math.round(data.source.x1) +\n                ',' +\n                Math.round(data.source.y0 + data.source.sourceLinks.reduce((prev, curr) => prev + curr.width, 0)) +\n                ')'\n            )\n        })\n}\n\nconst addChartAxisLines = (svg: D3Selector, height: number, nodes: PathNodeData[], maxLayer: number): void => {\n    if (maxLayer > 5) {\n        const arr = [...Array(maxLayer)]\n        const minWidthApart = nodes[1].x0 - nodes[0].x0\n        arr.forEach((_, i) => {\n            svg.append('line')\n                .style('stroke', 'var(--border-primary)')\n                .attr('stroke-width', 2)\n                .attr('x1', minWidthApart * (i + 1) - 20)\n                .attr('y1', 0)\n                .attr('x2', minWidthApart * (i + 1) - 20)\n                .attr('y2', height)\n        })\n    }\n}\n\nexport function renderPaths(\n    canvasRef: RefObject<HTMLDivElement>,\n    canvasWidth: number,\n    canvasHeight: number,\n    paths: Paths,\n    pathsFilter: PathsFilter,\n    funnelPathsFilter: FunnelPathsFilter,\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void {\n    if (!paths || paths.nodes.length === 0) {\n        return\n    }\n\n    const maxLayer = paths.links.reduce((prev, curr) => {\n        return Math.max(prev, Number(curr.target.match(/[^_]*/)))\n    }, 0)\n\n    const minWidth = canvasWidth > FALLBACK_CANVAS_WIDTH || maxLayer < 3 ? canvasWidth : FALLBACK_CANVAS_WIDTH\n\n    const width = maxLayer > 5 && canvasWidth ? (minWidth / 5) * maxLayer : minWidth\n    const height = canvasHeight\n\n    const svg = createCanvas(canvasRef, width, height)\n    const sankey = createSankeyGenerator(width, height)\n\n    // clone the paths, as sankey mutates the data\n    const clonedPaths = structuredClone(paths)\n    const { nodes, links } = sankey(clonedPaths)\n\n    setNodeCards(nodes.map((node: PathNodeData) => ({ ...node, visible: node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT })))\n\n    appendPathNodes(svg, nodes, pathsFilter, funnelPathsFilter, setNodeCards)\n    appendDropoffs(svg)\n    appendPathLinks(svg, links, nodes, setNodeCards)\n    addChartAxisLines(svg, height, nodes, maxLayer)\n}\n","import { LemonDialog, lemonToast, Link } from '@posthog/lemon-ui'\nimport { actions, connect, kea, listeners, path, reducers, selectors } from 'kea'\nimport { capitalizeFirstLetter, FieldNamePath, forms } from 'kea-forms'\nimport { lazyLoaders } from 'kea-loaders'\nimport { router, urlToAction } from 'kea-router'\nimport api, { getJSONOrNull } from 'lib/api'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { dayjs } from 'lib/dayjs'\nimport { LemonBannerAction } from 'lib/lemon-ui/LemonBanner/LemonBanner'\nimport { lemonBannerLogic } from 'lib/lemon-ui/LemonBanner/lemonBannerLogic'\nimport { LemonButtonPropsBase } from 'lib/lemon-ui/LemonButton'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { pluralize } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport posthog from 'posthog-js'\nimport { organizationLogic } from 'scenes/organizationLogic'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport {\n    BillingPlan,\n    BillingPlanType,\n    BillingProductV2Type,\n    BillingType,\n    ProductKey,\n    StartupProgramLabel,\n} from '~/types'\n\nimport type { billingLogicType } from './billingLogicType'\nimport { DEFAULT_ESTIMATED_MONTHLY_CREDIT_AMOUNT_USD } from './CreditCTAHero'\n\nexport const ALLOCATION_THRESHOLD_ALERT = 0.85 // Threshold to show warning of event usage near limit\nexport const ALLOCATION_THRESHOLD_BLOCK = 1.2 // Threshold to block usage\n\nexport interface BillingAlertConfig {\n    status: 'info' | 'warning' | 'error'\n    title: string\n    message?: string\n    contactSupport?: boolean\n    buttonCTA?: string\n    dismissKey?: string\n    action?: LemonBannerAction\n    pathName?: string\n    onClose?: () => void\n}\n\nexport enum BillingAPIErrorCodes {\n    OPEN_INVOICES_ERROR = 'open_invoices_error',\n    NO_ACTIVE_PAYMENT_METHOD_ERROR = 'no_active_payment_method_error',\n    COULD_NOT_PAY_INVOICES_ERROR = 'could_not_pay_invoices_error',\n}\n\nexport interface UnsubscribeError {\n    detail: string | JSX.Element\n    link: JSX.Element\n}\n\nexport interface BillingError {\n    status: 'info' | 'warning' | 'error'\n    message: string\n    action: LemonButtonPropsBase\n}\n\nconst parseBillingResponse = (data: Partial<BillingType>): BillingType => {\n    if (data.billing_period) {\n        data.billing_period = {\n            current_period_start: dayjs(data.billing_period.current_period_start),\n            current_period_end: dayjs(data.billing_period.current_period_end),\n            interval: data.billing_period.interval,\n        }\n    }\n\n    data.free_trial_until = data.free_trial_until ? dayjs(data.free_trial_until) : undefined\n    data.amount_off_expires_at = data.amount_off_expires_at ? dayjs(data.amount_off_expires_at) : undefined\n    // If expiration is in the middle of the current period, we let it expire at the end of the period\n    if (\n        data.amount_off_expires_at &&\n        data.billing_period &&\n        data.amount_off_expires_at.isBefore(data.billing_period.current_period_end) &&\n        data.amount_off_expires_at.isAfter(data.billing_period.current_period_start)\n    ) {\n        data.amount_off_expires_at = data.billing_period.current_period_end\n    }\n\n    return data as BillingType\n}\n\nexport const billingLogic = kea<billingLogicType>([\n    path(['scenes', 'billing', 'billingLogic']),\n    actions({\n        setProductSpecificAlert: (productSpecificAlert: BillingAlertConfig | null) => ({ productSpecificAlert }),\n        setScrollToProductKey: (scrollToProductKey: ProductKey | null) => ({ scrollToProductKey }),\n        setShowLicenseDirectInput: (show: boolean) => ({ show }),\n        reportBillingAlertShown: (alertConfig: BillingAlertConfig) => ({ alertConfig }),\n        reportBillingAlertActionClicked: (alertConfig: BillingAlertConfig) => ({ alertConfig }),\n        reportCreditsFormSubmitted: (creditInput: number) => ({ creditInput }),\n        reportCreditsModalShown: true,\n        reportBillingShown: true,\n        registerInstrumentationProps: true,\n        reportCreditsCTAShown: (creditOverview: any) => ({ creditOverview }),\n        setRedirectPath: true,\n        setIsOnboarding: true,\n        determineBillingAlert: true,\n        setUnsubscribeError: (error: null | UnsubscribeError) => ({ error }),\n        resetUnsubscribeError: true,\n        setBillingAlert: (billingAlert: BillingAlertConfig | null) => ({ billingAlert }),\n        showPurchaseCreditsModal: (isOpen: boolean) => ({ isOpen }),\n        toggleCreditCTAHeroDismissed: (isDismissed: boolean) => ({ isDismissed }),\n        setComputedDiscount: (discount: number) => ({ discount }),\n        scrollToProduct: (productType: string) => ({ productType }),\n    }),\n    connect({\n        values: [\n            featureFlagLogic,\n            ['featureFlags'],\n            preflightLogic,\n            ['preflight'],\n            organizationLogic,\n            ['currentOrganization'],\n        ],\n        actions: [\n            userLogic,\n            ['loadUser'],\n            organizationLogic,\n            ['loadCurrentOrganization'],\n            eventUsageLogic,\n            ['reportProductUnsubscribed'],\n            lemonBannerLogic({ dismissKey: 'usage-limit-exceeded' }),\n            ['resetDismissKey as resetUsageLimitExceededKey'],\n            lemonBannerLogic({ dismissKey: 'usage-limit-approaching' }),\n            ['resetDismissKey as resetUsageLimitApproachingKey'],\n        ],\n    }),\n    reducers({\n        billingAlert: [\n            null as BillingAlertConfig | null,\n            {\n                setBillingAlert: (_, { billingAlert }) => billingAlert,\n            },\n        ],\n        scrollToProductKey: [\n            null as ProductKey | null,\n            {\n                setScrollToProductKey: (_, { scrollToProductKey }) => scrollToProductKey,\n            },\n        ],\n        productSpecificAlert: [\n            null as BillingAlertConfig | null,\n            {\n                setProductSpecificAlert: (_, { productSpecificAlert }) => productSpecificAlert,\n            },\n        ],\n        showLicenseDirectInput: [\n            false,\n            {\n                setShowLicenseDirectInput: (_, { show }) => show,\n            },\n        ],\n        redirectPath: [\n            '' as string,\n            {\n                setRedirectPath: () => {\n                    return window.location.pathname.includes('/onboarding')\n                        ? window.location.pathname + window.location.search\n                        : ''\n                },\n            },\n        ],\n        isOnboarding: [\n            false,\n            {\n                setIsOnboarding: () => window.location.pathname.includes('/onboarding'),\n            },\n        ],\n        unsubscribeError: [\n            null as null | UnsubscribeError,\n            {\n                resetUnsubscribeError: () => null,\n                setUnsubscribeError: (_, { error }) => error,\n            },\n        ],\n        timeRemainingInSeconds: [\n            0,\n            {\n                loadBillingSuccess: (_, { billing }) => {\n                    if (!billing?.billing_period) {\n                        return 0\n                    }\n                    const currentTime = dayjs()\n                    const periodEnd = dayjs(billing.billing_period.current_period_end)\n                    return periodEnd.diff(currentTime, 'second')\n                },\n            },\n        ],\n        timeTotalInSeconds: [\n            0,\n            {\n                loadBillingSuccess: (_, { billing }) => {\n                    if (!billing?.billing_period) {\n                        return 0\n                    }\n                    const periodStart = dayjs(billing.billing_period.current_period_start)\n                    const periodEnd = dayjs(billing.billing_period.current_period_end)\n                    return periodEnd.diff(periodStart, 'second')\n                },\n            },\n        ],\n        isPurchaseCreditsModalOpen: [\n            false,\n            {\n                showPurchaseCreditsModal: (_, { isOpen }) => isOpen,\n            },\n        ],\n        isCreditCTAHeroDismissed: [\n            false,\n            { persist: true },\n            {\n                toggleCreditCTAHeroDismissed: (_, { isDismissed }) => isDismissed,\n            },\n        ],\n        computedDiscount: [\n            0,\n            {\n                setComputedDiscount: (_, { discount }) => discount,\n            },\n        ],\n    }),\n    lazyLoaders(({ actions, values }) => ({\n        billing: [\n            null as BillingType | null,\n            {\n                loadBilling: async () => {\n                    // Note: this is a temporary flag to skip forecasting in the billing page\n                    // for customers running into performance issues until we have a more permanent fix\n                    // of splitting the billing and forecasting data.\n                    const skipForecasting = values.featureFlags[FEATURE_FLAGS.BILLING_SKIP_FORECASTING]\n                    const response = await api.get(\n                        'api/billing' + (skipForecasting ? '?include_forecasting=false' : '')\n                    )\n\n                    return parseBillingResponse(response)\n                },\n\n                updateBillingLimits: async (limits: { [key: string]: number | null }) => {\n                    try {\n                        const response = await api.update('api/billing', { custom_limits_usd: limits })\n                        lemonToast.success('Billing limits updated')\n                        actions.loadBilling()\n                        return parseBillingResponse(response)\n                    } catch (error: any) {\n                        lemonToast.error(\n                            'There was an error updating your billing limits. Please try again or contact support.'\n                        )\n                        throw error\n                    }\n                },\n\n                deactivateProduct: async (key: string, breakpoint) => {\n                    // clear upgrade params from URL\n                    // Note(@zach): This is not working properly. We need to look into this.\n                    const currentURL = new URL(window.location.href)\n                    currentURL.searchParams.delete('upgraded')\n                    currentURL.searchParams.delete('products')\n                    router.actions.push(currentURL.pathname + currentURL.search)\n\n                    actions.resetUnsubscribeError()\n                    try {\n                        const response = await api.getResponse('api/billing/deactivate?products=' + key)\n                        const jsonRes = await getJSONOrNull(response)\n\n                        lemonToast.success(\n                            \"You have been unsubscribed. We're sad to see you go. May the hedgehogs be ever in your favor.\"\n                        )\n                        actions.reportProductUnsubscribed(key)\n\n                        // Reload billing, user, and organization to get the updated available features\n                        actions.loadBilling()\n                        await breakpoint(2000) // Wait enough time for the organization to be updated\n                        actions.loadUser()\n                        actions.loadCurrentOrganization()\n\n                        return parseBillingResponse(jsonRes)\n                    } catch (error: any) {\n                        if (error.code) {\n                            if (error.code === BillingAPIErrorCodes.OPEN_INVOICES_ERROR) {\n                                actions.setUnsubscribeError({\n                                    detail: error.detail,\n                                    link: (\n                                        <Link to={values.billing?.stripe_portal_url} target=\"_blank\">\n                                            View invoices\n                                        </Link>\n                                    ),\n                                } as UnsubscribeError)\n                            } else if (error.code === BillingAPIErrorCodes.NO_ACTIVE_PAYMENT_METHOD_ERROR) {\n                                actions.setUnsubscribeError({\n                                    detail: error.detail,\n                                } as UnsubscribeError)\n                            } else if (error.code === BillingAPIErrorCodes.COULD_NOT_PAY_INVOICES_ERROR) {\n                                actions.setUnsubscribeError({\n                                    detail: error.detail,\n                                    link: (\n                                        <Link to={error.link || values.billing?.stripe_portal_url} target=\"_blank\">\n                                            {error.link ? 'View invoice' : 'View invoices'}\n                                        </Link>\n                                    ),\n                                } as UnsubscribeError)\n                            }\n                        } else {\n                            actions.setUnsubscribeError({\n                                detail:\n                                    typeof error.detail === 'string'\n                                        ? error.detail\n                                        : `We encountered a problem. Please try again or submit a support ticket.`,\n                            } as UnsubscribeError)\n                        }\n                        console.error(error)\n                        // This is a bit of a hack to prevent the page from re-rendering.\n                        return values.billing\n                    }\n                },\n            },\n        ],\n        billingError: [\n            null as BillingError | null,\n            {\n                loadInvoices: async () => {\n                    // First check to see if there are open invoices\n                    try {\n                        const res = await api.getResponse('api/billing/get_invoices?status=open')\n                        const jsonRes = await getJSONOrNull(res)\n                        const numOpenInvoices = jsonRes['count']\n                        if (numOpenInvoices > 0) {\n                            const viewInvoicesButton = {\n                                to:\n                                    numOpenInvoices == 1 && jsonRes['link']\n                                        ? jsonRes['link']\n                                        : values.billing?.stripe_portal_url,\n                                children: `View invoice${numOpenInvoices > 1 ? 's' : ''}`,\n                                targetBlank: true,\n                            }\n                            return {\n                                status: 'warning',\n                                message: `You have ${numOpenInvoices} open invoice${\n                                    numOpenInvoices > 1 ? 's' : ''\n                                }. Please pay ${\n                                    numOpenInvoices > 1 ? 'them' : 'it'\n                                } before adding items to your subscription.`,\n                                action: viewInvoicesButton,\n                            }\n                        }\n                    } catch (error: any) {\n                        console.error(error)\n                    }\n                    return null\n                },\n            },\n        ],\n        creditOverview: [\n            {\n                eligible: false,\n                estimated_monthly_credit_amount_usd: DEFAULT_ESTIMATED_MONTHLY_CREDIT_AMOUNT_USD,\n                status: 'none',\n                invoice_url: null,\n                collection_method: null,\n                cc_last_four: null,\n                email: null,\n            },\n            {\n                loadCreditOverview: async () => {\n                    // Check if the user is subscribed\n                    if (values.billing?.has_active_subscription) {\n                        const response = await api.get('api/billing/credits/overview')\n                        if (!values.creditForm.creditInput) {\n                            actions.setCreditFormValue(\n                                'creditInput',\n                                Math.round(\n                                    (response.estimated_monthly_credit_amount_usd ||\n                                        DEFAULT_ESTIMATED_MONTHLY_CREDIT_AMOUNT_USD) * 12\n                                )\n                            )\n                        }\n\n                        if (response.eligible && response.status === 'none') {\n                            actions.reportCreditsCTAShown(response)\n                        }\n                        return response\n                    }\n                    // Return default values if not subscribed\n                    return {\n                        eligible: false,\n                        estimated_monthly_credit_amount_usd: DEFAULT_ESTIMATED_MONTHLY_CREDIT_AMOUNT_USD,\n                        status: 'none',\n                        invoice_url: null,\n                        collection_method: null,\n                        cc_last_four: null,\n                        email: null,\n                    }\n                },\n            },\n        ],\n        products: [\n            [] as BillingProductV2Type[],\n            {\n                loadProducts: async () => {\n                    const response = await api.get('api/billing/available_products')\n                    return response\n                },\n            },\n        ],\n    })),\n    selectors({\n        upgradeLink: [(s) => [s.preflight], (): string => '/organization/billing'],\n        isUnlicensedDebug: [\n            (s) => [s.preflight, s.billing],\n            (preflight, billing): boolean => !!preflight?.is_debug && !billing?.billing_period,\n        ],\n        supportPlans: [\n            (s) => [s.billing],\n            (billing: BillingType): BillingPlanType[] => {\n                const platformAndSupportProduct = billing?.products?.find(\n                    (product) => product.type == ProductKey.PLATFORM_AND_SUPPORT\n                )\n                if (!platformAndSupportProduct?.plans) {\n                    return []\n                }\n\n                const addonPlans = platformAndSupportProduct?.addons?.map((addon) => addon.plans).flat()\n                const insertionIndex = Math.max(0, (platformAndSupportProduct?.plans?.length ?? 1) - 1)\n                const allPlans = platformAndSupportProduct?.plans?.slice(0) || []\n                allPlans.splice(insertionIndex, 0, ...addonPlans)\n                return allPlans\n            },\n        ],\n        hasSupportAddonPlan: [\n            (s) => [s.billing],\n            (billing: BillingType): boolean => {\n                return !!billing?.products\n                    ?.find((product) => product.type == ProductKey.PLATFORM_AND_SUPPORT)\n                    ?.addons.find((addon) => addon.plans.find((plan) => plan.current_plan))\n            },\n        ],\n        creditDiscount: [(s) => [s.computedDiscount], (computedDiscount) => computedDiscount || 0],\n        billingPlan: [\n            (s) => [s.billing],\n            (billing: BillingType | null): BillingPlan | null => billing?.billing_plan || null,\n        ],\n        startupProgramLabelCurrent: [\n            (s) => [s.billing],\n            (billing: BillingType | null): StartupProgramLabel | null => billing?.startup_program_label || null,\n        ],\n        startupProgramLabelPrevious: [\n            (s) => [s.billing],\n            (billing: BillingType | null): StartupProgramLabel | null =>\n                billing?.startup_program_label_previous || null,\n        ],\n        isAnnualPlanCustomer: [\n            (s) => [s.billing],\n            (billing: BillingType | null): boolean => billing?.is_annual_plan_customer || false,\n        ],\n        showBillingSummary: [\n            (s) => [s.billing, s.isOnboarding],\n            (billing: BillingType | null, isOnboarding: boolean): boolean => {\n                return !isOnboarding && !!billing?.billing_period\n            },\n        ],\n        showCreditCTAHero: [\n            (s) => [s.creditOverview, s.featureFlags],\n            (creditOverview, featureFlags): boolean => {\n                const isEligible = creditOverview.eligible || !!featureFlags[FEATURE_FLAGS.SELF_SERVE_CREDIT_OVERRIDE]\n                return isEligible && creditOverview.status !== 'paid'\n            },\n        ],\n        showBillingHero: [\n            (s) => [s.billing, s.billingPlan, s.showCreditCTAHero],\n            (billing: BillingType | null, billingPlan: BillingPlan | null, showCreditCTAHero: boolean): boolean => {\n                const platformAndSupportProduct = billing?.products?.find(\n                    (product) => product.type === ProductKey.PLATFORM_AND_SUPPORT\n                )\n                return !!billingPlan && !billing?.trial && !!platformAndSupportProduct && !showCreditCTAHero\n            },\n        ],\n        isManagedAccount: [\n            (s) => [s.billing],\n            (billing: BillingType): boolean => {\n                return !!(billing?.account_owner?.name || billing?.account_owner?.email)\n            },\n        ],\n        accountOwner: [\n            (s) => [s.billing],\n            (billing: BillingType): { name?: string; email?: string } | null => billing?.account_owner || null,\n        ],\n    }),\n    forms(({ actions, values }) => ({\n        activateLicense: {\n            defaults: { license: '' } as { license: string },\n            errors: ({ license }) => ({\n                license: !license ? 'Please enter your license key' : undefined,\n            }),\n            submit: async ({ license }, breakpoint) => {\n                await breakpoint(500)\n                try {\n                    await api.update('api/billing/license', {\n                        license,\n                    })\n\n                    // Reset the URL so we don't trigger the license submission again\n                    router.actions.replace(\n                        `/${values.isOnboarding ? 'ingestion' : 'organization'}/billing?success=true`\n                    )\n                    setTimeout(() => {\n                        window.location.reload() // Permissions, projects etc will be out of date at this point, so refresh\n                    }, 100)\n                } catch (e: any) {\n                    actions.setActivateLicenseManualErrors({\n                        license: e.detail || 'License could not be activated. Please contact support.',\n                    })\n                    throw e\n                }\n            },\n        },\n        creditForm: {\n            defaults: {\n                creditInput: '',\n                collectionMethod: 'charge_automatically',\n            },\n            submit: async ({ creditInput, collectionMethod }) => {\n                await api.create('api/billing/credits/purchase', {\n                    annual_amount_usd: +Math.round(+creditInput - +creditInput * values.creditDiscount),\n                    discount_percent: values.computedDiscount * 100,\n                    collection_method: collectionMethod,\n                })\n\n                actions.showPurchaseCreditsModal(false)\n                actions.loadCreditOverview()\n                actions.reportCreditsFormSubmitted(+creditInput)\n\n                LemonDialog.open({\n                    title: 'Your credit purchase has been submitted',\n                    width: 536,\n                    content:\n                        collectionMethod === 'send_invoice' ? (\n                            <>\n                                <p className=\"mb-4\">\n                                    The invoice for your credits has been created and it will be emailed to the email on\n                                    file.\n                                </p>\n                                <p>\n                                    Once the invoice is paid we will apply the credits to your account. Until the\n                                    invoice is paid you will be charged for usage as normal.\n                                </p>\n                            </>\n                        ) : (\n                            <>\n                                <p>\n                                    Your card will be charged soon and the credits will be applied to your account.\n                                    Please make sure your{' '}\n                                    <Link to={values.billing?.stripe_portal_url} target=\"_blank\">\n                                        card on file\n                                    </Link>{' '}\n                                    is up to date. You will receive an email when the credits are applied.\n                                </p>\n                            </>\n                        ),\n                })\n            },\n            errors: ({ creditInput, collectionMethod }) => ({\n                creditInput: !creditInput\n                    ? 'Please enter the amount of credits you want to purchase'\n                    : // This value is used because 3333 - 10% = 3000\n                    +creditInput < 3333\n                    ? 'Please enter a credit amount of at least $3,333'\n                    : undefined,\n                collectionMethod: !collectionMethod ? 'Please select a collection method' : undefined,\n            }),\n        },\n    })),\n    listeners(({ actions, values }) => ({\n        reportBillingShown: () => {\n            posthog.capture('billing v2 shown')\n        },\n        reportBillingAlertShown: ({ alertConfig }) => {\n            posthog.capture('billing alert shown', {\n                ...alertConfig,\n            })\n        },\n        reportBillingAlertActionClicked: ({ alertConfig }) => {\n            posthog.capture('billing alert action clicked', {\n                ...alertConfig,\n            })\n        },\n        reportCreditsModalShown: () => {\n            posthog.capture('credits modal shown')\n        },\n        reportCreditsFormSubmitted: ({ creditInput }) => {\n            posthog.capture('credits modal credit form submitted', {\n                credit_amount_usd: creditInput,\n            })\n        },\n        reportCreditsCTAShown: ({ creditOverview }) => {\n            posthog.capture('credits cta shown', {\n                eligible: creditOverview.eligible,\n                status: creditOverview.status,\n                estimated_monthly_credit_amount_usd:\n                    creditOverview.estimated_monthly_credit_amount_usd || DEFAULT_ESTIMATED_MONTHLY_CREDIT_AMOUNT_USD,\n            })\n        },\n        toggleCreditCTAHeroDismissed: ({ isDismissed }) => {\n            if (isDismissed) {\n                posthog.capture('credits cta hero dismissed')\n            }\n        },\n        loadBillingSuccess: async (_, breakpoint) => {\n            actions.registerInstrumentationProps()\n            actions.determineBillingAlert()\n            actions.loadCreditOverview()\n\n            // If the activation is successful, we reload the user/organization to get the updated available features\n            // activation can be triggered from the billing page or onboarding\n            if (\n                (router.values.location.pathname.includes('/organization/billing') ||\n                    router.values.location.pathname.includes('/onboarding')) &&\n                (router.values.searchParams['success'] || router.values.searchParams['upgraded'])\n            ) {\n                // Wait enough time for the organization to be updated\n                await breakpoint(1000)\n                actions.loadUser()\n                actions.loadCurrentOrganization()\n                // Clear the params from the billing page so we don't trigger the activation again\n                if (router.values.location.pathname.includes('/organization/billing')) {\n                    router.actions.replace('/organization/billing')\n                }\n            }\n        },\n        determineBillingAlert: () => {\n            // If we already have a billing alert, don't show another one\n            if (values.billingAlert) {\n                return\n            }\n\n            if (values.productSpecificAlert) {\n                actions.setBillingAlert(values.productSpecificAlert)\n                return\n            }\n\n            if (!values.billing || !values.preflight?.cloud) {\n                return\n            }\n\n            const trial = values.billing.trial\n            if (trial && trial.expires_at && dayjs(trial.expires_at).isAfter(dayjs())) {\n                if (trial.type === 'autosubscribe' || trial.status !== 'active') {\n                    // Only show for standard ones (managed by sales)\n                    return\n                }\n\n                const remainingDays = dayjs(trial.expires_at).diff(dayjs(), 'days')\n                const remainingHours = dayjs(trial.expires_at).diff(dayjs(), 'hours')\n                if (remainingHours > 72) {\n                    return\n                }\n\n                const contactEmail = values.billing.account_owner?.email || 'sales@posthog.com'\n                const contactName = values.billing.account_owner?.name || 'sales'\n                actions.setBillingAlert({\n                    status: 'info',\n                    title: `Your free trial for the ${capitalizeFirstLetter(trial.target)} plan will end in ${\n                        remainingHours < 24 ? pluralize(remainingHours, 'hour') : pluralize(remainingDays, 'day')\n                    }.`,\n                    message: `If you have any questions, please reach out to ${contactName} at ${contactEmail}.`,\n                })\n                return\n            }\n\n            if (values.billing.deactivated) {\n                actions.setBillingAlert({\n                    status: 'error',\n                    title: 'Your organization has been temporarily suspended.',\n                    message: 'Please contact support to reactivate it.',\n                    contactSupport: true,\n                })\n                return\n            }\n\n            const productOverLimit = values.billing.products?.find((x: BillingProductV2Type) => {\n                return x.percentage_usage > 1 && x.usage_key\n            })\n\n            if (productOverLimit) {\n                const hideProductFlag = `billing_hide_product_${productOverLimit?.type}`\n                const isHidden = values.featureFlags[hideProductFlag] === true\n                if (isHidden) {\n                    return\n                }\n                actions.setBillingAlert({\n                    status: 'error',\n                    title: 'Usage limit exceeded',\n                    message: `You have exceeded the usage limit for ${productOverLimit.name}. Please \n                        ${productOverLimit.subscribed ? 'increase your billing limit' : 'upgrade your plan'}\n                        or ${\n                            productOverLimit.name === 'Data warehouse'\n                                ? 'data will not be synced'\n                                : productOverLimit.name === 'Feature flags & Experiments'\n                                ? 'feature flags will not evaluate'\n                                : 'data loss may occur'\n                        }.`,\n                    dismissKey: 'usage-limit-exceeded',\n                })\n                return\n            }\n\n            actions.resetUsageLimitExceededKey()\n\n            const productApproachingLimit = values.billing.products?.find(\n                (x) => x.percentage_usage > ALLOCATION_THRESHOLD_ALERT\n            )\n\n            if (productApproachingLimit) {\n                const hideProductFlag = `billing_hide_product_${productApproachingLimit?.type}`\n                const isHidden = values.featureFlags[hideProductFlag] === true\n                if (isHidden) {\n                    return\n                }\n                actions.setBillingAlert({\n                    status: 'info',\n                    title: 'You will soon hit your usage limit',\n                    message: `You have currently used ${parseFloat(\n                        (productApproachingLimit.percentage_usage * 100).toFixed(2)\n                    )}% of your ${\n                        productApproachingLimit.usage_key && productApproachingLimit.usage_key.toLowerCase()\n                    } allocation.`,\n                    dismissKey: 'usage-limit-approaching',\n                })\n                return\n            }\n\n            actions.resetUsageLimitApproachingKey()\n        },\n        setCreditFormValue: ({ name, value }) => {\n            if (name === 'creditInput' || (name as FieldNamePath)?.[0] === 'creditInput') {\n                const spend = +value\n                let discount = 0\n                if (spend >= 100000) {\n                    discount = 0.35\n                } else if (spend >= 60000) {\n                    discount = 0.25\n                } else if (spend >= 20000) {\n                    discount = 0.2\n                } else if (spend >= 3000) {\n                    discount = 0.1\n                }\n                actions.setComputedDiscount(discount)\n            }\n        },\n        registerInstrumentationProps: async (_, breakpoint) => {\n            await breakpoint(100)\n            if (posthog && values.billing) {\n                const payload: { [key: string]: any } = {\n                    has_billing_plan: !!values.billing.has_active_subscription,\n                    free_trial_until: values.billing.free_trial_until?.toISOString(),\n                    customer_deactivated: values.billing.deactivated,\n                    current_total_amount_usd: values.billing.current_total_amount_usd,\n                }\n                if (values.billing.custom_limits_usd) {\n                    for (const product of Object.keys(values.billing.custom_limits_usd)) {\n                        payload[`custom_limits_usd.${product}`] = values.billing.custom_limits_usd[product]\n                    }\n                }\n                if (values.billing.products) {\n                    for (const product of values.billing.products) {\n                        const type = product.type.toLowerCase()\n                        payload[`percentage_usage.${type}`] = product.percentage_usage\n                        payload[`current_amount_usd.${type}`] = product.current_amount_usd\n                        payload[`unit_amount_usd.${type}`] = product.unit_amount_usd\n                        payload[`usage_limit.${type}`] = product.usage_limit\n                        payload[`current_usage.${type}`] = product.current_usage\n                        payload[`projected_usage.${type}`] = product.projected_usage\n                        payload[`free_allocation.${type}`] = product.free_allocation\n                    }\n                }\n                if (values.billing.billing_period) {\n                    payload['billing_period_start'] = values.billing.billing_period.current_period_start\n                    payload['billing_period_end'] = values.billing.billing_period.current_period_end\n                }\n                posthog.register(payload)\n            }\n        },\n        showPurchaseCreditsModal: ({ isOpen }) => {\n            if (isOpen) {\n                actions.reportCreditsModalShown()\n            }\n        },\n        scrollToProduct: ({ productType }) => {\n            const element = document.querySelector(`[data-attr=\"billing-product-addon-${productType}\"]`)\n            element?.scrollIntoView({\n                behavior: 'smooth',\n                block: 'center',\n            })\n        },\n    })),\n    urlToAction(({ actions }) => ({\n        // IMPORTANT: This needs to be above the \"*\" so it takes precedence\n        '/*/billing': (_params, _search, hash) => {\n            if (hash.license) {\n                actions.setShowLicenseDirectInput(true)\n                actions.setActivateLicenseValues({ license: hash.license })\n                actions.submitActivateLicense()\n            }\n            if (_search.products) {\n                const products = _search.products.split(',')\n                actions.setScrollToProductKey(products[0])\n            }\n            if (_search.billing_error) {\n                actions.setBillingAlert({\n                    status: 'error',\n                    title: 'Error',\n                    message: _search.billing_error,\n                    contactSupport: true,\n                })\n            }\n\n            actions.setRedirectPath()\n            actions.setIsOnboarding()\n        },\n        '*': () => {\n            actions.setRedirectPath()\n            actions.setIsOnboarding()\n        },\n    })),\n])\n","import { actions, connect, isBreakpoint, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { dayjs } from 'lib/dayjs'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { hasFormErrors, toParams } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { ProductIntentContext } from 'lib/utils/product-intents'\nimport { addProjectIdIfMissing } from 'lib/utils/router-utils'\nimport { billingLogic } from 'scenes/billing/billingLogic'\nimport {\n    indexToVariantKeyFeatureFlagPayloads,\n    featureFlagLogic as sceneFeatureFlagLogic,\n    validateFeatureFlagKey,\n    variantKeyToIndexFeatureFlagPayloads,\n} from 'scenes/feature-flags/featureFlagLogic'\nimport { featureFlagsLogic } from 'scenes/feature-flags/featureFlagsLogic'\nimport { funnelDataLogic } from 'scenes/funnels/funnelDataLogic'\nimport { insightDataLogic } from 'scenes/insights/insightDataLogic'\nimport { projectLogic } from 'scenes/projectLogic'\nimport { sceneLogic } from 'scenes/sceneLogic'\nimport { Scene } from 'scenes/sceneTypes'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { trendsDataLogic } from 'scenes/trends/trendsDataLogic'\nimport { urls } from 'scenes/urls'\n\nimport { activationLogic, ActivationTask } from '~/layout/navigation-3000/sidepanel/panels/activation/activationLogic'\nimport { refreshTreeItem } from '~/layout/panel-layout/ProjectTree/projectTreeLogic'\nimport { cohortsModel } from '~/models/cohortsModel'\nimport { groupsModel } from '~/models/groupsModel'\nimport { performQuery, QUERY_TIMEOUT_ERROR_MESSAGE } from '~/queries/query'\nimport {\n    AnyEntityNode,\n    CachedExperimentFunnelsQueryResponse,\n    CachedExperimentQueryResponse,\n    CachedExperimentTrendsQueryResponse,\n    CachedLegacyExperimentQueryResponse,\n    CachedNewExperimentQueryResponse,\n    ExperimentExposureCriteria,\n    ExperimentExposureQueryResponse,\n    ExperimentFunnelsQuery,\n    ExperimentMetric,\n    ExperimentMetricType,\n    ExperimentTrendsQuery,\n    FunnelsQuery,\n    InsightVizNode,\n    NodeKind,\n    TrendsQuery,\n} from '~/queries/schema/schema-general'\nimport { setLatestVersionsOnQuery } from '~/queries/utils'\nimport {\n    Breadcrumb,\n    BreakdownAttributionType,\n    BreakdownType,\n    CohortType,\n    CountPerActorMathType,\n    DashboardType,\n    Experiment,\n    ExperimentStatsMethod,\n    FeatureFlagType,\n    FunnelExperimentVariant,\n    InsightType,\n    MultivariateFlagVariant,\n    ProductKey,\n    ProjectTreeRef,\n    PropertyMathType,\n    TrendExperimentVariant,\n} from '~/types'\nimport {\n    EXPERIMENT_MAX_PRIMARY_METRICS,\n    EXPERIMENT_MAX_SECONDARY_METRICS,\n    EXPERIMENT_MIN_EXPOSURES_FOR_RESULTS,\n    MetricInsightId,\n} from './constants'\nimport {\n    conversionRateForVariant,\n    expectedRunningTime,\n    getSignificanceDetails,\n    minimumSampleSizePerVariant,\n    recommendedExposureForCountData,\n} from './legacyExperimentCalculations'\nimport type { experimentLogicType } from './experimentLogicType'\nimport { experimentsLogic } from './experimentsLogic'\nimport { holdoutsLogic } from './holdoutsLogic'\nimport { addExposureToMetric, compose, getInsight, getQuery } from './metricQueryUtils'\nimport { getDefaultMetricTitle } from './MetricsView/shared/utils'\nimport { modalsLogic } from './modalsLogic'\nimport { SharedMetric } from './SharedMetrics/sharedMetricLogic'\nimport { sharedMetricsLogic } from './SharedMetrics/sharedMetricsLogic'\nimport {\n    featureFlagEligibleForExperiment,\n    isLegacyExperiment,\n    percentageDistribution,\n    transformFiltersForWinningVariant,\n} from './utils'\n\nconst NEW_EXPERIMENT: Experiment = {\n    id: 'new',\n    name: '',\n    type: 'product',\n    feature_flag_key: '',\n    filters: {},\n    metrics: [],\n    metrics_secondary: [],\n    saved_metrics_ids: [],\n    saved_metrics: [],\n    parameters: {\n        feature_flag_variants: [\n            { key: 'control', rollout_percentage: 50 },\n            { key: 'test', rollout_percentage: 50 },\n        ],\n    },\n    secondary_metrics: [],\n    created_at: null,\n    created_by: null,\n    updated_at: null,\n    holdout_id: null,\n    exposure_criteria: {\n        filterTestAccounts: true,\n    },\n}\n\nexport const DEFAULT_MDE = 30\n\nexport const FORM_MODES = {\n    create: 'create',\n    duplicate: 'duplicate',\n    update: 'update',\n} as const\n\n/**\n * get the values of formModes as a union type\n * we don't really need formModes unless we need to do FORM_MODES[num]\n * this could be just an union type\n */\nexport type FormModes = (typeof FORM_MODES)[keyof typeof FORM_MODES]\n\nexport interface ExperimentLogicProps {\n    experimentId?: Experiment['id']\n    formMode?: FormModes\n}\n\ninterface MetricLoadingConfig {\n    metrics: any[]\n    experimentId: Experiment['id']\n    refresh?: boolean\n    onSetLegacyResults: (\n        results: (\n            | CachedLegacyExperimentQueryResponse\n            | CachedExperimentTrendsQueryResponse\n            | CachedExperimentFunnelsQueryResponse\n            | null\n        )[]\n    ) => void\n    onSetResults: (results: CachedNewExperimentQueryResponse[]) => void\n    onSetErrors: (errors: any[]) => void\n    onTimeout: (experimentId: Experiment['id'], metric: any) => void\n}\n\nconst loadMetrics = async ({\n    metrics,\n    experimentId,\n    refresh,\n    onSetLegacyResults,\n    onSetResults,\n    onSetErrors,\n    onTimeout,\n}: MetricLoadingConfig): Promise<void[]> => {\n    const legacyResults: (\n        | CachedLegacyExperimentQueryResponse\n        | CachedExperimentTrendsQueryResponse\n        | CachedExperimentFunnelsQueryResponse\n        | null\n    )[] = []\n\n    const results: CachedNewExperimentQueryResponse[] = []\n    const currentErrors = new Array(metrics.length).fill(null)\n\n    return await Promise.all(\n        metrics.map(async (metric, index) => {\n            try {\n                let queryWithExperimentId\n                if (metric.kind === NodeKind.ExperimentMetric) {\n                    queryWithExperimentId = {\n                        kind: NodeKind.ExperimentQuery,\n                        metric: metric,\n                        experiment_id: experimentId,\n                    }\n                } else {\n                    queryWithExperimentId = {\n                        ...metric,\n                        experiment_id: experimentId,\n                    }\n                }\n                const response = await performQuery(\n                    setLatestVersionsOnQuery(queryWithExperimentId),\n                    undefined,\n                    refresh ? 'force_async' : 'async'\n                )\n\n                // Convert ExperimentQuery responses to typed responses\n                if (\n                    metric.kind === NodeKind.ExperimentMetric ||\n                    queryWithExperimentId.kind === NodeKind.ExperimentQuery\n                ) {\n                    const typedResponse = convertToTypedExperimentResponse(response as CachedExperimentQueryResponse)\n                    if (typedResponse) {\n                        if (isLegacyExperimentResponse(typedResponse)) {\n                            legacyResults[index] = {\n                                ...typedResponse,\n                                fakeInsightId: Math.random().toString(36).substring(2, 15),\n                            } as CachedLegacyExperimentQueryResponse & { fakeInsightId: string }\n                        } else if (isNewExperimentResponse(typedResponse)) {\n                            results[index] = typedResponse\n                        }\n                    }\n                } else {\n                    // For trends/funnels queries, keep original response\n                    legacyResults[index] = {\n                        ...response,\n                        fakeInsightId: Math.random().toString(36).substring(2, 15),\n                    } as (CachedExperimentTrendsQueryResponse | CachedExperimentFunnelsQueryResponse) & {\n                        fakeInsightId: string\n                    }\n                }\n                onSetLegacyResults([...legacyResults])\n                onSetResults([...results])\n            } catch (error: any) {\n                const errorDetailMatch = error.detail?.match(/\\{.*\\}/)\n                const errorDetail = errorDetailMatch ? JSON.parse(errorDetailMatch[0]) : error.detail || error.message\n\n                currentErrors[index] = {\n                    detail: errorDetail,\n                    statusCode: error.status,\n                    hasDiagnostics: !!errorDetailMatch,\n                }\n                onSetErrors(currentErrors)\n\n                if (errorDetail === QUERY_TIMEOUT_ERROR_MESSAGE) {\n                    onTimeout(experimentId, metric)\n                }\n\n                legacyResults[index] = null\n                onSetLegacyResults([...legacyResults])\n                onSetResults([...results])\n            }\n        })\n    )\n}\n\n// Type guards to distinguish between legacy and new experiment responses\nexport function isLegacyExperimentResponse(\n    response: CachedExperimentQueryResponse\n): response is CachedLegacyExperimentQueryResponse {\n    return 'variants' in response && response.variants !== null\n}\n\nexport function isNewExperimentResponse(\n    response: CachedExperimentQueryResponse\n): response is CachedNewExperimentQueryResponse {\n    return 'baseline' in response && response.baseline !== null\n}\n\n// Union type for strongly typed experiment responses\nexport type TypedExperimentResponse = CachedLegacyExperimentQueryResponse | CachedNewExperimentQueryResponse\n\n// Utility function to convert generic response to typed response\nfunction convertToTypedExperimentResponse(response: CachedExperimentQueryResponse): TypedExperimentResponse | null {\n    if (isLegacyExperimentResponse(response)) {\n        return response\n    }\n\n    if (isNewExperimentResponse(response)) {\n        return response\n    }\n\n    // If response doesn't match either pattern, return null\n    return null\n}\n\nexport const experimentLogic = kea<experimentLogicType>([\n    props({} as ExperimentLogicProps),\n    key((props) => props.experimentId || 'new'),\n    path((key) => ['scenes', 'experiment', 'experimentLogic', key]),\n    connect(() => ({\n        values: [\n            projectLogic,\n            ['currentProjectId'],\n            groupsModel,\n            ['aggregationLabel', 'groupTypes', 'showGroupsOptions'],\n            sceneLogic,\n            ['activeScene'],\n            featureFlagLogic,\n            ['featureFlags'],\n            holdoutsLogic,\n            ['holdouts'],\n            billingLogic,\n            ['billing'],\n            // Hook the insight state to get the results for the sample size estimation\n            funnelDataLogic({ dashboardItemId: MetricInsightId.Funnels }),\n            ['results as funnelResults', 'conversionMetrics'],\n            trendsDataLogic({ dashboardItemId: MetricInsightId.Trends }),\n            ['results as trendResults'],\n            // Hook into the loading state of the metric insight\n            insightDataLogic({ dashboardItemId: MetricInsightId.Trends }),\n            ['insightDataLoading as trendMetricInsightLoading'],\n            insightDataLogic({ dashboardItemId: MetricInsightId.Funnels }),\n            ['insightDataLoading as funnelMetricInsightLoading'],\n            sharedMetricsLogic,\n            ['sharedMetrics'],\n        ],\n        actions: [\n            experimentsLogic,\n            ['updateExperiments', 'addToExperiments'],\n            eventUsageLogic,\n            [\n                'reportExperimentCreated',\n                'reportExperimentViewed',\n                'reportExperimentLaunched',\n                'reportExperimentCompleted',\n                'reportExperimentArchived',\n                'reportExperimentReset',\n                'reportExperimentExposureCohortCreated',\n                'reportExperimentVariantShipped',\n                'reportExperimentVariantScreenshotUploaded',\n                'reportExperimentResultsLoadingTimeout',\n                'reportExperimentReleaseConditionsViewed',\n                'reportExperimentHoldoutAssigned',\n                'reportExperimentSharedMetricAssigned',\n                'reportExperimentDashboardCreated',\n                'reportExperimentMetricTimeout',\n            ],\n            teamLogic,\n            ['addProductIntent'],\n            featureFlagsLogic,\n            ['updateFlag'],\n            modalsLogic,\n            [\n                'openPrimaryMetricModal',\n                'closePrimaryMetricModal',\n                'openSecondaryMetricModal',\n                'closeSecondaryMetricModal',\n                'openPrimarySharedMetricModal',\n                'openSecondarySharedMetricModal',\n                'closeStopExperimentModal',\n                'closeShipVariantModal',\n                'openReleaseConditionsModal',\n            ],\n        ],\n    })),\n    actions({\n        setExperimentMissing: true,\n        setExperiment: (experiment: Partial<Experiment>) => ({ experiment }),\n        createExperiment: (draft?: boolean, folder?: string | null) => ({ draft, folder }),\n        setExperimentType: (type?: string) => ({ type }),\n        addVariant: true,\n        removeVariant: (idx: number) => ({ idx }),\n        setEditExperiment: (editing: boolean) => ({ editing }),\n        setExposureAndSampleSize: (exposure: number, sampleSize: number) => ({ exposure, sampleSize }),\n        refreshExperimentResults: (forceRefresh?: boolean) => ({ forceRefresh }),\n        updateExperimentMetrics: true,\n        updateExperimentCollectionGoal: true,\n        updateExposureCriteria: true,\n        changeExperimentStartDate: (startDate: string) => ({ startDate }),\n        changeExperimentEndDate: (endDate: string) => ({ endDate }),\n        launchExperiment: true,\n        endExperiment: true,\n        archiveExperiment: true,\n        resetRunningExperiment: true,\n        updateExperimentVariantImages: (variantPreviewMediaIds: Record<string, string[]>) => ({\n            variantPreviewMediaIds,\n        }),\n        setExposureCriteria: (exposureCriteria: ExperimentExposureCriteria) => ({ exposureCriteria }),\n        setTabKey: (tabKey: string) => ({ tabKey }),\n        createExperimentDashboard: true,\n        setIsCreatingExperimentDashboard: (isCreating: boolean) => ({ isCreating }),\n        setUnmodifiedExperiment: (experiment: Experiment) => ({ experiment }),\n        restoreUnmodifiedExperiment: true,\n        setValidExistingFeatureFlag: (featureFlag: FeatureFlagType | null) => ({ featureFlag }),\n        setFeatureFlagValidationError: (error: string) => ({ error }),\n        validateFeatureFlag: (featureFlagKey: string) => ({ featureFlagKey }),\n        // METRICS\n        setMetric: ({\n            metricIdx,\n            name,\n            metric,\n            isSecondary = false,\n        }: {\n            metricIdx: number\n            name?: string\n            metric: ExperimentMetric\n            isSecondary?: boolean\n        }) => ({ metricIdx, name, metric, isSecondary }),\n        setTrendsMetric: ({\n            metricIdx,\n            name,\n            series,\n            filterTestAccounts,\n            isSecondary = false,\n        }: {\n            metricIdx: number\n            name?: string\n            series?: AnyEntityNode[]\n            filterTestAccounts?: boolean\n            isSecondary?: boolean\n        }) => ({ metricIdx, name, series, filterTestAccounts, isSecondary }),\n        setTrendsExposureMetric: ({\n            metricIdx,\n            name,\n            series,\n            filterTestAccounts,\n            isSecondary = false,\n        }: {\n            metricIdx: number\n            name?: string\n            series?: AnyEntityNode[]\n            filterTestAccounts?: boolean\n            isSecondary?: boolean\n        }) => ({ metricIdx, name, series, filterTestAccounts, isSecondary }),\n        setFunnelsMetric: ({\n            metricIdx,\n            name,\n            series,\n            filterTestAccounts,\n            breakdownAttributionType,\n            breakdownAttributionValue,\n            funnelWindowInterval,\n            funnelWindowIntervalUnit,\n            aggregation_group_type_index,\n            funnelAggregateByHogQL,\n            isSecondary,\n        }: {\n            metricIdx: number\n            name?: string\n            series?: AnyEntityNode[]\n            filterTestAccounts?: boolean\n            breakdownAttributionType?: BreakdownAttributionType\n            breakdownAttributionValue?: number\n            funnelWindowInterval?: number\n            funnelWindowIntervalUnit?: string\n            aggregation_group_type_index?: number\n            funnelAggregateByHogQL?: string\n            isSecondary?: boolean\n        }) => ({\n            metricIdx,\n            name,\n            series,\n            filterTestAccounts,\n            breakdownAttributionType,\n            breakdownAttributionValue,\n            funnelWindowInterval,\n            funnelWindowIntervalUnit,\n            aggregation_group_type_index,\n            funnelAggregateByHogQL,\n            isSecondary,\n        }),\n        addSharedMetricsToExperiment: (\n            sharedMetricIds: SharedMetric['id'][],\n            metadata: { type: 'primary' | 'secondary' }\n        ) => ({\n            sharedMetricIds,\n            metadata,\n        }),\n        removeSharedMetricFromExperiment: (sharedMetricId: SharedMetric['id']) => ({ sharedMetricId }),\n        duplicateMetric: ({ metricIndex, isSecondary }: { metricIndex: number; isSecondary: boolean }) => ({\n            metricIndex,\n            isSecondary,\n        }),\n        // METRICS RESULTS\n        setLegacyPrimaryMetricsResults: (\n            results: (\n                | CachedLegacyExperimentQueryResponse\n                | CachedExperimentTrendsQueryResponse\n                | CachedExperimentFunnelsQueryResponse\n                | null\n            )[]\n        ) => ({ results }),\n        setPrimaryMetricsResults: (results: CachedNewExperimentQueryResponse[]) => ({ results }),\n        setPrimaryMetricsResultsLoading: (loading: boolean) => ({ loading }),\n        loadPrimaryMetricsResults: (refresh?: boolean) => ({ refresh }),\n        setPrimaryMetricsResultsErrors: (errors: any[]) => ({ errors }),\n        setSecondaryMetricsResults: (results: CachedNewExperimentQueryResponse[]) => ({ results }),\n        loadSecondaryMetricsResults: (refresh?: boolean) => ({ refresh }),\n        setSecondaryMetricsResultsErrors: (errors: any[]) => ({ errors }),\n        setSecondaryMetricsResultsLoading: (loading: boolean) => ({ loading }),\n        setLegacySecondaryMetricsResults: (\n            results: (\n                | CachedLegacyExperimentQueryResponse\n                | CachedExperimentTrendsQueryResponse\n                | CachedExperimentFunnelsQueryResponse\n                | null\n            )[]\n        ) => ({ results }),\n        updateDistribution: (featureFlag: FeatureFlagType) => ({ featureFlag }),\n    }),\n    reducers({\n        experiment: [\n            { ...NEW_EXPERIMENT } as Experiment,\n            {\n                setExperiment: (state, { experiment }) => {\n                    return { ...state, ...experiment }\n                },\n                addVariant: (state) => {\n                    if (state?.parameters?.feature_flag_variants) {\n                        const newRolloutPercentages = percentageDistribution(\n                            state.parameters.feature_flag_variants.length + 1\n                        )\n                        const updatedRolloutPercentageVariants = state.parameters.feature_flag_variants.map(\n                            (variant: MultivariateFlagVariant, i: number) => ({\n                                ...variant,\n                                rollout_percentage: newRolloutPercentages[i],\n                            })\n                        )\n                        return {\n                            ...state,\n                            parameters: {\n                                ...state.parameters,\n                                feature_flag_variants: [\n                                    ...updatedRolloutPercentageVariants,\n                                    {\n                                        key: `test_group_${state.parameters.feature_flag_variants.length}`,\n                                        rollout_percentage: newRolloutPercentages[newRolloutPercentages.length - 1],\n                                    },\n                                ],\n                            },\n                        }\n                    }\n                    return state\n                },\n                removeVariant: (state, { idx }) => {\n                    if (!state) {\n                        return { ...NEW_EXPERIMENT }\n                    }\n                    const variants = [...(state.parameters?.feature_flag_variants || [])]\n                    variants.splice(idx, 1)\n                    const newRolloutPercentages = percentageDistribution(\n                        (state?.parameters?.feature_flag_variants || []).length - 1\n                    )\n                    const updatedVariants = variants.map((variant: MultivariateFlagVariant, i: number) => ({\n                        ...variant,\n                        rollout_percentage: newRolloutPercentages[i],\n                    }))\n\n                    return {\n                        ...state,\n                        parameters: {\n                            ...state.parameters,\n                            feature_flag_variants: updatedVariants,\n                        },\n                    }\n                },\n                setExposureCriteria: (\n                    state,\n                    { exposureCriteria }: { exposureCriteria: ExperimentExposureCriteria }\n                ) => {\n                    return {\n                        ...state,\n                        exposure_criteria: { ...state.exposure_criteria, ...exposureCriteria },\n                    }\n                },\n                setMetric: (state, { metricIdx, metric, isSecondary }) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n\n                    metrics[metricIdx] = metric\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n                setTrendsMetric: (state, { metricIdx, name, series, filterTestAccounts, isSecondary }) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n                    const metric = metrics[metricIdx]\n\n                    metrics[metricIdx] = {\n                        ...metric,\n                        ...(name !== undefined && { name }),\n                        count_query: {\n                            ...(metric as ExperimentTrendsQuery).count_query,\n                            ...(series && { series }),\n                            ...(filterTestAccounts !== undefined && { filterTestAccounts }),\n                        },\n                    } as ExperimentTrendsQuery\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n                setTrendsExposureMetric: (state, { metricIdx, name, series, filterTestAccounts, isSecondary }) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n                    const metric = metrics[metricIdx]\n\n                    metrics[metricIdx] = {\n                        ...metric,\n                        ...(name !== undefined && { name }),\n                        exposure_query: {\n                            ...(metric as ExperimentTrendsQuery).exposure_query,\n                            ...(series && { series }),\n                            ...(filterTestAccounts !== undefined && { filterTestAccounts }),\n                        },\n                    } as ExperimentTrendsQuery\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n                setFunnelsMetric: (\n                    state,\n                    {\n                        metricIdx,\n                        name,\n                        series,\n                        filterTestAccounts,\n                        breakdownAttributionType,\n                        breakdownAttributionValue,\n                        funnelWindowInterval,\n                        funnelWindowIntervalUnit,\n                        aggregation_group_type_index,\n                        funnelAggregateByHogQL,\n                        isSecondary,\n                    }\n                ) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n                    const metric = metrics[metricIdx]\n\n                    metrics[metricIdx] = {\n                        ...metric,\n                        ...(name !== undefined && { name }),\n                        funnels_query: {\n                            ...(metric as ExperimentFunnelsQuery).funnels_query,\n                            ...(series && { series }),\n                            ...(filterTestAccounts !== undefined && { filterTestAccounts }),\n                            ...(aggregation_group_type_index !== undefined && { aggregation_group_type_index }),\n                            funnelsFilter: {\n                                ...(metric as ExperimentFunnelsQuery).funnels_query.funnelsFilter,\n                                ...(breakdownAttributionType && { breakdownAttributionType }),\n                                ...(breakdownAttributionValue !== undefined && { breakdownAttributionValue }),\n                                ...(funnelWindowInterval !== undefined && { funnelWindowInterval }),\n                                ...(funnelWindowIntervalUnit && { funnelWindowIntervalUnit }),\n                                ...(funnelAggregateByHogQL !== undefined && { funnelAggregateByHogQL }),\n                            },\n                        },\n                    } as ExperimentFunnelsQuery\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n                duplicateMetric: (state, { metricIndex, isSecondary }) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n\n                    const originalMetric = metrics[metricIndex]\n\n                    if (!originalMetric) {\n                        return state\n                    }\n\n                    // Check if duplicating would exceed the 10 metric limit\n                    const currentMetricCount = metrics.length\n                    const sharedMetricsCount =\n                        state?.saved_metrics?.filter(\n                            (savedMetric) => savedMetric.metadata.type === (isSecondary ? 'secondary' : 'primary')\n                        ).length || 0\n                    const totalMetricCount = currentMetricCount + sharedMetricsCount\n\n                    if (\n                        totalMetricCount >=\n                        (!isSecondary ? EXPERIMENT_MAX_PRIMARY_METRICS : EXPERIMENT_MAX_SECONDARY_METRICS)\n                    ) {\n                        // Return state unchanged if limit would be exceeded\n                        return state\n                    }\n\n                    const name = originalMetric.name\n                        ? `${originalMetric.name} (copy)`\n                        : originalMetric.kind === NodeKind.ExperimentMetric\n                        ? `${getDefaultMetricTitle(originalMetric)} (copy)`\n                        : undefined\n\n                    const newMetric = { ...originalMetric, id: undefined, name }\n                    metrics.splice(metricIndex + 1, 0, newMetric)\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n            },\n        ],\n        experimentMissing: [\n            false,\n            {\n                setExperimentMissing: () => true,\n            },\n        ],\n        unmodifiedExperiment: [\n            null as Experiment | null,\n            {\n                setUnmodifiedExperiment: (_, { experiment }) => experiment,\n            },\n        ],\n        tabKey: [\n            'results',\n            {\n                setTabKey: (_, { tabKey }) => tabKey,\n            },\n        ],\n        // PRIMARY METRICS\n        legacyPrimaryMetricsResults: [\n            [] as (\n                | CachedLegacyExperimentQueryResponse\n                | CachedExperimentTrendsQueryResponse\n                | CachedExperimentFunnelsQueryResponse\n                | null\n            )[],\n            {\n                setLegacyPrimaryMetricsResults: (_, { results }) => results,\n            },\n        ],\n        primaryMetricsResults: [\n            [] as CachedNewExperimentQueryResponse[],\n            {\n                setPrimaryMetricsResults: (_, { results }) => results,\n                loadPrimaryMetricsResults: () => [],\n                loadExperiment: () => [],\n            },\n        ],\n        primaryMetricsResultsLoading: [\n            false,\n            {\n                setPrimaryMetricsResultsLoading: (_, { loading }) => loading,\n            },\n        ],\n        primaryMetricsResultsErrors: [\n            [] as any[],\n            {\n                setPrimaryMetricsResultsErrors: (_, { errors }) => errors,\n                loadPrimaryMetricsResults: () => [],\n                loadExperiment: () => [],\n            },\n        ],\n        // SECONDARY METRICS\n        legacySecondaryMetricsResults: [\n            [] as (\n                | CachedLegacyExperimentQueryResponse\n                | CachedExperimentTrendsQueryResponse\n                | CachedExperimentFunnelsQueryResponse\n                | null\n            )[],\n            {\n                setLegacySecondaryMetricsResults: (_, { results }) => results,\n            },\n        ],\n        secondaryMetricsResults: [\n            [] as CachedNewExperimentQueryResponse[],\n            {\n                setSecondaryMetricsResults: (_, { results }) => results,\n                loadSecondaryMetricsResults: () => [],\n                loadExperiment: () => [],\n            },\n        ],\n        secondaryMetricsResultsLoading: [\n            false,\n            {\n                setSecondaryMetricsResultsLoading: (_, { loading }) => loading,\n            },\n        ],\n        secondaryMetricsResultsErrors: [\n            [] as any[],\n            {\n                setSecondaryMetricsResultsErrors: (_, { errors }) => errors,\n                loadSecondaryMetricsResults: () => [],\n                loadExperiment: () => [],\n            },\n        ],\n        editingPrimaryMetricIndex: [\n            null as number | null,\n            {\n                openPrimaryMetricModal: (_, { index }) => index,\n                closePrimaryMetricModal: () => null,\n                updateExperimentMetrics: () => null,\n                setEditingPrimaryMetricIndex: (_, { index }) => index,\n            },\n        ],\n        editingSecondaryMetricIndex: [\n            null as number | null,\n            {\n                openSecondaryMetricModal: (_, { index }) => index,\n                closeSecondaryMetricModal: () => null,\n                updateExperimentMetrics: () => null,\n            },\n        ],\n        editingSharedMetricId: [\n            null as SharedMetric['id'] | null,\n            {\n                openPrimarySharedMetricModal: (_, { sharedMetricId }) => sharedMetricId,\n                openSecondarySharedMetricModal: (_, { sharedMetricId }) => sharedMetricId,\n                updateExperimentMetrics: () => null,\n            },\n        ],\n        isCreatingExperimentDashboard: [\n            false,\n            {\n                setIsCreatingExperimentDashboard: (_, { isCreating }) => isCreating,\n            },\n        ],\n        validExistingFeatureFlag: [\n            null as FeatureFlagType | null,\n            {\n                setValidExistingFeatureFlag: (_, { featureFlag }) => featureFlag,\n            },\n        ],\n        featureFlagValidationError: [\n            null as string | null,\n            {\n                setFeatureFlagValidationError: (_, { error }) => error,\n            },\n        ],\n    }),\n    listeners(({ values, actions, props }) => ({\n        createExperiment: async ({ draft, folder }) => {\n            const { recommendedRunningTime, recommendedSampleSize, minimumDetectableEffect } = values\n\n            actions.touchExperimentField('name')\n            actions.touchExperimentField('feature_flag_key')\n            values.experiment.parameters.feature_flag_variants.forEach((_, i) =>\n                actions.touchExperimentField(`parameters.feature_flag_variants.${i}.key`)\n            )\n\n            if (hasFormErrors(values.experimentErrors)) {\n                return\n            }\n\n            // Minimum Detectable Effect is calculated based on a loaded insight\n            // Terminate if the insight did not manage to load in time\n            if (!minimumDetectableEffect) {\n                eventUsageLogic.actions.reportExperimentInsightLoadFailed()\n                return lemonToast.error(\n                    'Failed to load insight. Experiment cannot be saved without this value. Try changing the experiment goal.'\n                )\n            }\n\n            let response: Experiment | null = null\n            const isUpdate = props.formMode === 'update'\n            try {\n                if (isUpdate) {\n                    response = await api.update(\n                        `api/projects/${values.currentProjectId}/experiments/${values.experimentId}`,\n                        {\n                            ...values.experiment,\n                            parameters: {\n                                ...values.experiment?.parameters,\n                                recommended_running_time: recommendedRunningTime,\n                                recommended_sample_size: recommendedSampleSize,\n                                minimum_detectable_effect: minimumDetectableEffect,\n                            },\n                            ...(!draft && { start_date: dayjs() }),\n                            // backwards compatibility: Remove any global properties set on the experiment.\n                            // These were used to change feature flag targeting, but this is controlled directly\n                            // on the feature flag now.\n                            filters: {\n                                events: [],\n                                actions: [],\n                                ...values.experiment.filters,\n                                properties: [],\n                            },\n                        }\n                    )\n\n                    if (response?.id) {\n                        actions.updateExperiments(response)\n                        actions.setEditExperiment(false)\n                        actions.loadExperimentSuccess(response)\n                        return\n                    }\n                } else {\n                    // Check if the new Bayesian stats method feature flag is enabled\n                    const useNewBayesianStatsMethod = values.featureFlags[FEATURE_FLAGS.NEW_BAYESIAN_STATS_METHOD]\n\n                    response = await api.create(`api/projects/${values.currentProjectId}/experiments`, {\n                        ...values.experiment,\n                        parameters:\n                            /**\n                             * only if we are creating a new experiment we need to reset\n                             * the recommended running time. If we are duplicating we want to\n                             * preserve this values.\n                             */\n                            props.formMode === FORM_MODES.create\n                                ? {\n                                      ...values.experiment?.parameters,\n                                      recommended_running_time: recommendedRunningTime,\n                                      recommended_sample_size: recommendedSampleSize,\n                                      minimum_detectable_effect: minimumDetectableEffect,\n                                  }\n                                : values.experiment?.parameters,\n                        // Set stats_config based on the feature flag if no existing stats_config\n                        ...(useNewBayesianStatsMethod &&\n                            !values.experiment.stats_config && {\n                                stats_config: {\n                                    method: ExperimentStatsMethod.Bayesian,\n                                    use_new_bayesian_method: true,\n                                },\n                            }),\n                        ...(!draft && { start_date: dayjs() }),\n                        ...(typeof folder === 'string' ? { _create_in_folder: folder } : {}),\n                    })\n\n                    if (response) {\n                        actions.reportExperimentCreated(response)\n                        actions.addProductIntent({\n                            product_type: ProductKey.EXPERIMENTS,\n                            intent_context: ProductIntentContext.EXPERIMENT_CREATED,\n                        })\n                        if (response.feature_flag?.id) {\n                            refreshTreeItem('feature_flag', String(response.feature_flag.id))\n                        }\n                    }\n                }\n            } catch (error: any) {\n                lemonToast.error(error.detail || 'Failed to create experiment')\n                return\n            }\n\n            if (response?.id) {\n                const experimentId = response.id\n                refreshTreeItem('experiment', String(experimentId))\n                router.actions.push(urls.experiment(experimentId))\n                actions.addToExperiments(response)\n                lemonToast.success(`Experiment ${isUpdate ? 'updated' : 'created'}`, {\n                    button: {\n                        label: 'View it',\n                        action: () => {\n                            router.actions.push(urls.experiment(experimentId))\n                        },\n                    },\n                })\n            }\n        },\n        setExperimentType: async ({ type }) => {\n            actions.setExperiment({ type: type })\n        },\n        loadExperimentSuccess: async ({ experiment }) => {\n            const duration = experiment?.start_date ? dayjs().diff(experiment.start_date, 'second') : null\n            experiment && actions.reportExperimentViewed(experiment, duration)\n\n            if (experiment?.start_date) {\n                actions.refreshExperimentResults()\n            }\n        },\n        launchExperiment: async () => {\n            const startDate = dayjs()\n            actions.updateExperiment({ start_date: startDate.toISOString() })\n            values.experiment && eventUsageLogic.actions.reportExperimentLaunched(values.experiment, startDate)\n            activationLogic.findMounted()?.actions.markTaskAsCompleted(ActivationTask.LaunchExperiment)\n        },\n        changeExperimentStartDate: async ({ startDate }) => {\n            actions.updateExperiment({ start_date: startDate })\n            values.experiment && eventUsageLogic.actions.reportExperimentStartDateChange(values.experiment, startDate)\n        },\n        changeExperimentEndDate: async ({ endDate }) => {\n            actions.updateExperiment({ end_date: endDate })\n            values.experiment && eventUsageLogic.actions.reportExperimentEndDateChange(values.experiment, endDate)\n        },\n        endExperiment: async () => {\n            const endDate = dayjs()\n            actions.updateExperiment({\n                end_date: endDate.toISOString(),\n                conclusion: values.experiment.conclusion,\n                conclusion_comment: values.experiment.conclusion_comment,\n            })\n            const duration = endDate.diff(values.experiment?.start_date, 'second')\n            values.experiment &&\n                actions.reportExperimentCompleted(\n                    values.experiment,\n                    endDate,\n                    duration,\n                    values.isPrimaryMetricSignificant(0)\n                )\n            actions.closeStopExperimentModal()\n        },\n        archiveExperiment: async () => {\n            actions.updateExperiment({ archived: true })\n            values.experiment && actions.reportExperimentArchived(values.experiment)\n        },\n        refreshExperimentResults: async ({ forceRefresh }) => {\n            actions.loadPrimaryMetricsResults(forceRefresh)\n            actions.loadSecondaryMetricsResults(forceRefresh)\n            actions.loadExposures(forceRefresh)\n        },\n        updateExperimentMetrics: async () => {\n            actions.updateExperiment({\n                metrics: values.experiment.metrics,\n                metrics_secondary: values.experiment.metrics_secondary,\n            })\n        },\n        updateExperimentCollectionGoal: async () => {\n            const { recommendedRunningTime, recommendedSampleSize, minimumDetectableEffect } = values\n\n            actions.updateExperiment({\n                parameters: {\n                    ...values.experiment?.parameters,\n                    recommended_running_time: recommendedRunningTime,\n                    recommended_sample_size: recommendedSampleSize,\n                    minimum_detectable_effect: minimumDetectableEffect || 0,\n                },\n            })\n        },\n        updateExposureCriteria: async () => {\n            actions.updateExperiment({\n                exposure_criteria: {\n                    ...values.experiment.exposure_criteria,\n                },\n            })\n            actions.refreshExperimentResults(true)\n        },\n        resetRunningExperiment: async () => {\n            actions.updateExperiment({\n                start_date: null,\n                end_date: null,\n                archived: false,\n                conclusion: null,\n                conclusion_comment: null,\n            })\n            values.experiment && actions.reportExperimentReset(values.experiment)\n            actions.setLegacyPrimaryMetricsResults([])\n            actions.setLegacySecondaryMetricsResults([])\n        },\n        updateExperimentSuccess: async ({ experiment, payload }) => {\n            actions.updateExperiments(experiment)\n            if (experiment.start_date) {\n                const forceRefresh = payload?.start_date !== undefined || payload?.end_date !== undefined\n                actions.refreshExperimentResults(forceRefresh)\n            }\n        },\n        createExposureCohortSuccess: ({ exposureCohort }) => {\n            if (exposureCohort && exposureCohort.id !== 'new') {\n                cohortsModel.actions.cohortCreated(exposureCohort)\n                actions.reportExperimentExposureCohortCreated(values.experiment, exposureCohort)\n                actions.setExperiment({ exposure_cohort: exposureCohort.id })\n                lemonToast.success('Exposure cohort created successfully', {\n                    button: {\n                        label: 'View cohort',\n                        action: () => router.actions.push(urls.cohort(exposureCohort.id)),\n                    },\n                })\n            }\n        },\n        shipVariantSuccess: ({ payload }) => {\n            lemonToast.success('The selected variant has been shipped')\n            actions.closeShipVariantModal()\n            if (payload.shouldStopExperiment && !values.isExperimentStopped) {\n                actions.endExperiment()\n            }\n            actions.loadExperiment()\n            actions.reportExperimentVariantShipped(values.experiment)\n        },\n        shipVariantFailure: ({ error }) => {\n            lemonToast.error(error)\n            actions.closeShipVariantModal()\n        },\n        updateExperimentVariantImages: async ({ variantPreviewMediaIds }) => {\n            try {\n                const updatedParameters = {\n                    ...values.experiment.parameters,\n                    variant_screenshot_media_ids: variantPreviewMediaIds,\n                }\n                await api.update(`api/projects/${values.currentProjectId}/experiments/${values.experimentId}`, {\n                    parameters: updatedParameters,\n                })\n                actions.setExperiment({\n                    parameters: updatedParameters,\n                })\n            } catch {\n                lemonToast.error('Failed to update experiment variant images')\n            }\n        },\n        updateDistribution: async ({ featureFlag }) => {\n            const { created_at, id, ...flag } = featureFlag\n\n            const preparedFlag = indexToVariantKeyFeatureFlagPayloads(flag)\n\n            const savedFlag = await api.update(\n                `api/projects/${values.currentProjectId}/feature_flags/${id}`,\n                preparedFlag\n            )\n\n            const updatedFlag = variantKeyToIndexFeatureFlagPayloads(savedFlag)\n            actions.updateFlag(updatedFlag)\n\n            actions.updateExperiment({\n                holdout_id: values.experiment.holdout_id,\n            })\n        },\n        addSharedMetricsToExperiment: async ({ sharedMetricIds, metadata }) => {\n            const existingMetricsIds = values.experiment.saved_metrics.map((sharedMetric) => ({\n                id: sharedMetric.saved_metric,\n                metadata: sharedMetric.metadata,\n            }))\n\n            const newMetricsIds = sharedMetricIds.map((id: SharedMetric['id']) => ({ id, metadata }))\n            newMetricsIds.forEach((metricId) => {\n                const metric = values.sharedMetrics.find((m: SharedMetric) => m.id === metricId.id)\n                if (metric) {\n                    actions.reportExperimentSharedMetricAssigned(values.experimentId, metric)\n                }\n            })\n            const combinedMetricsIds = [...existingMetricsIds, ...newMetricsIds]\n\n            await api.update(`api/projects/${values.currentProjectId}/experiments/${values.experimentId}`, {\n                saved_metrics_ids: combinedMetricsIds,\n            })\n\n            actions.loadExperiment()\n        },\n        removeSharedMetricFromExperiment: async ({ sharedMetricId }) => {\n            const sharedMetricsIds = values.experiment.saved_metrics\n                .filter((sharedMetric) => sharedMetric.saved_metric !== sharedMetricId)\n                .map((sharedMetric) => ({\n                    id: sharedMetric.saved_metric,\n                    metadata: sharedMetric.metadata,\n                }))\n            await api.update(`api/projects/${values.currentProjectId}/experiments/${values.experimentId}`, {\n                saved_metrics_ids: sharedMetricsIds,\n            })\n\n            actions.loadExperiment()\n        },\n        createExperimentDashboard: async () => {\n            actions.setIsCreatingExperimentDashboard(true)\n\n            /**\n             * create a query builder to transform the experiment metric into a query\n             * that can be used to create an insight\n             */\n            const queryBuilder = compose<\n                ExperimentMetric,\n                ExperimentMetric,\n                FunnelsQuery | TrendsQuery | undefined,\n                InsightVizNode | undefined\n            >(\n                addExposureToMetric({\n                    kind: NodeKind.EventsNode,\n                    event: '$pageview',\n                    custom_name: 'Placeholder for experiment exposure',\n                    properties: [],\n                }),\n                getQuery(),\n                getInsight()\n            )\n\n            try {\n                /**\n                 * get the experiment url for the dashboard description\n                 */\n                const experimentUrl =\n                    window.location.origin + addProjectIdIfMissing(urls.experiment(values.experimentId))\n\n                /**\n                 * create a new dashboard\n                 */\n                const dashboard: DashboardType = await api.create(\n                    `api/environments/${teamLogic.values.currentTeamId}/dashboards/`,\n                    {\n                        name: 'Experiment: ' + values.experiment.name,\n                        description: `Dashboard for [${experimentUrl}](${experimentUrl})`,\n                        filters: {\n                            date_from: values.experiment.start_date,\n                            date_to: values.experiment.end_date,\n                            properties: [],\n                            breakdown_filter: {\n                                breakdown: '$feature/' + values.experiment.feature_flag_key,\n                                breakdown_type: 'event' as BreakdownType,\n                            },\n                        },\n                    } as Partial<DashboardType>\n                )\n\n                /**\n                 * create a new insight for each metric, either primary or secondary\n                 * reverse the order of the metric because adding an insight to the dashboard\n                 * places it at the beginning of the list\n                 */\n                for (const type of ['secondary', 'primary']) {\n                    const singleMetrics =\n                        type === 'secondary' ? values.experiment.metrics_secondary : values.experiment.metrics\n                    const sharedMetrics = values.experiment?.saved_metrics.filter(\n                        (sharedMetric) => sharedMetric.metadata.type === type\n                    )\n                    const metrics = [\n                        ...singleMetrics,\n                        ...sharedMetrics.map((m) => ({ name: m.name, ...m.query })),\n                    ].reverse()\n\n                    for (const query of metrics) {\n                        const insightQuery = queryBuilder(query)\n\n                        await api.create(`api/projects/${projectLogic.values.currentProjectId}/insights`, {\n                            name: query.name || undefined,\n                            query: insightQuery,\n                            dashboards: [dashboard.id],\n                        })\n                    }\n                }\n\n                actions.reportExperimentDashboardCreated(values.experiment, dashboard.id)\n\n                const dashboardUrl = window.location.origin + addProjectIdIfMissing(urls.dashboard(dashboard.id))\n                actions.updateExperiment({\n                    description:\n                        (values.experiment.description ? values.experiment.description + `\\n\\n` : '') +\n                        `Dashboard: [${dashboardUrl}](${dashboardUrl})`,\n                })\n\n                lemonToast.success('Dashboard created successfully', {\n                    button: {\n                        label: 'View dashboard',\n                        action: () => router.actions.push(`/dashboard/${dashboard.id}`),\n                    },\n                })\n            } catch (error: any) {\n                if (!isBreakpoint(error)) {\n                    const message = error.code && error.detail ? `${error.code}: ${error.detail}` : error\n                    lemonToast.error(`Could not create dashboard: ${message}`)\n                }\n            }\n            actions.setIsCreatingExperimentDashboard(false)\n        },\n        restoreUnmodifiedExperiment: () => {\n            if (values.unmodifiedExperiment) {\n                actions.setExperiment(structuredClone(values.unmodifiedExperiment))\n            }\n        },\n        validateFeatureFlag: async ({ featureFlagKey }: { featureFlagKey: string }, breakpoint) => {\n            await breakpoint(200)\n            const response = await api.get(\n                `api/projects/${values.currentProjectId}/feature_flags/?${toParams({ search: featureFlagKey })}`\n            )\n            const existingErrors = {\n                // :KLUDGE: If there is no name error, we don't want to trigger the 'required' error early\n                name: undefined,\n                ...values.experimentErrors,\n            }\n            if (response.results.length > 0) {\n                const matchingFlag = response.results.find((flag: FeatureFlagType) => flag.key === featureFlagKey)\n                if (matchingFlag) {\n                    let isValid\n                    try {\n                        isValid = featureFlagEligibleForExperiment(matchingFlag)\n                    } catch {\n                        isValid = false\n                    }\n                    actions.setValidExistingFeatureFlag(isValid ? matchingFlag : null)\n                    actions.setFeatureFlagValidationError(\n                        isValid ? '' : 'Existing feature flag is not eligible for experiments.'\n                    )\n                    actions.setExperimentManualErrors({\n                        ...existingErrors,\n                        feature_flag_key: values.featureFlagValidationError || undefined,\n                    })\n                    return\n                }\n            }\n\n            actions.setValidExistingFeatureFlag(null)\n            actions.setFeatureFlagValidationError(validateFeatureFlagKey(featureFlagKey) || '')\n            actions.setExperimentManualErrors({\n                ...existingErrors,\n                feature_flag_key: values.featureFlagValidationError || undefined,\n            })\n        },\n        touchExperimentField: ({ key }) => {\n            // :KLUDGE: Persist the existing feature_flag_key validation when the field is blurred.\n            if (key === 'feature_flag_key') {\n                actions.setExperimentManualErrors({\n                    feature_flag_key: values.featureFlagValidationError || undefined,\n                })\n            }\n        },\n        loadPrimaryMetricsResults: async ({ refresh }: { refresh?: boolean }) => {\n            actions.setPrimaryMetricsResultsLoading(true)\n            actions.setLegacyPrimaryMetricsResults([])\n            actions.setPrimaryMetricsResults([])\n\n            let metrics = values.experiment?.metrics\n            const sharedMetrics = values.experiment?.saved_metrics\n                .filter((sharedMetric) => sharedMetric.metadata.type === 'primary')\n                .map((sharedMetric) => sharedMetric.query)\n            if (sharedMetrics) {\n                metrics = [...metrics, ...sharedMetrics]\n            }\n\n            await loadMetrics({\n                metrics,\n                experimentId: values.experimentId,\n                refresh,\n                onSetLegacyResults: actions.setLegacyPrimaryMetricsResults,\n                onSetResults: actions.setPrimaryMetricsResults,\n                onSetErrors: actions.setPrimaryMetricsResultsErrors,\n                onTimeout: actions.reportExperimentMetricTimeout,\n            })\n\n            actions.setPrimaryMetricsResultsLoading(false)\n        },\n        loadSecondaryMetricsResults: async ({ refresh }: { refresh?: boolean }) => {\n            actions.setSecondaryMetricsResultsLoading(true)\n            actions.setLegacySecondaryMetricsResults([])\n            actions.setSecondaryMetricsResults([])\n\n            let secondaryMetrics = values.experiment?.metrics_secondary\n            const sharedMetrics = values.experiment?.saved_metrics\n                .filter((sharedMetric) => sharedMetric.metadata.type === 'secondary')\n                .map((sharedMetric) => sharedMetric.query)\n            if (sharedMetrics) {\n                secondaryMetrics = [...secondaryMetrics, ...sharedMetrics]\n            }\n\n            await loadMetrics({\n                metrics: secondaryMetrics,\n                experimentId: values.experimentId,\n                refresh,\n                onSetLegacyResults: actions.setLegacySecondaryMetricsResults,\n                onSetResults: actions.setSecondaryMetricsResults,\n                onSetErrors: actions.setSecondaryMetricsResultsErrors,\n                onTimeout: actions.reportExperimentMetricTimeout,\n            })\n\n            actions.setSecondaryMetricsResultsLoading(false)\n        },\n        openReleaseConditionsModal: () => {\n            const numericFlagId = values.experiment.feature_flag?.id\n            if (numericFlagId) {\n                const logic = sceneFeatureFlagLogic.findMounted() || sceneFeatureFlagLogic({ id: numericFlagId })\n                if (logic) {\n                    logic.actions.loadFeatureFlag() // Access the loader through actions\n                }\n            }\n        },\n    })),\n    loaders(({ actions, props, values }) => ({\n        experiment: {\n            loadExperiment: async () => {\n                if (props.experimentId && props.experimentId !== 'new') {\n                    try {\n                        let response: Experiment = await api.get(\n                            `api/projects/${values.currentProjectId}/experiments/${props.experimentId}`\n                        )\n\n                        /**\n                         * if we are duplicating, we need to clear a lot of props to ensure that\n                         * the experiment will be in draft mode and available for launch\n                         */\n                        if (props.formMode === FORM_MODES.duplicate) {\n                            response = {\n                                ...response,\n                                name: `${response.name} (duplicate)`,\n                                parameters: {\n                                    ...response.parameters,\n                                    feature_flag_variants: NEW_EXPERIMENT.parameters.feature_flag_variants,\n                                },\n                                feature_flag: undefined,\n                                feature_flag_key: '',\n                                archived: false,\n                                start_date: undefined,\n                                end_date: undefined,\n                                conclusion: undefined,\n                                conclusion_comment: undefined,\n                                created_by: null,\n                                created_at: null,\n                                updated_at: null,\n                            }\n                        }\n\n                        actions.setUnmodifiedExperiment(structuredClone(response))\n                        return response\n                    } catch (error: any) {\n                        if (error.status === 404) {\n                            actions.setExperimentMissing()\n                        } else {\n                            throw error\n                        }\n                    }\n                }\n                return NEW_EXPERIMENT\n            },\n            updateExperiment: async (update: Partial<Experiment>) => {\n                const response: Experiment = await api.update(\n                    `api/projects/${values.currentProjectId}/experiments/${values.experimentId}`,\n                    update\n                )\n                refreshTreeItem('experiment', String(values.experimentId))\n                actions.setUnmodifiedExperiment(structuredClone(response))\n                return response\n            },\n        },\n        exposureCohort: [\n            null as CohortType | null,\n            {\n                createExposureCohort: async () => {\n                    if (props.experimentId && props.experimentId !== 'new' && props.experimentId !== 'web') {\n                        return (await api.experiments.createExposureCohort(props.experimentId)).cohort\n                    }\n                    return null\n                },\n            },\n        ],\n        featureFlag: [\n            null as FeatureFlagType | null,\n            {\n                shipVariant: async ({ selectedVariantKey, shouldStopExperiment }) => {\n                    if (!values.experiment.feature_flag) {\n                        throw new Error('Experiment does not have a feature flag linked')\n                    }\n\n                    const currentFlagFilters = values.experiment.feature_flag?.filters\n                    const newFilters = transformFiltersForWinningVariant(currentFlagFilters, selectedVariantKey)\n\n                    await api.update(\n                        `api/projects/${values.currentProjectId}/feature_flags/${values.experiment.feature_flag?.id}`,\n                        { filters: newFilters }\n                    )\n\n                    return shouldStopExperiment\n                },\n            },\n        ],\n        exposures: [\n            null as any,\n            {\n                loadExposures: async (refresh: boolean = false) => {\n                    const { experiment, usesNewQueryRunner } = values\n\n                    if (!usesNewQueryRunner) {\n                        return\n                    }\n\n                    const query = setLatestVersionsOnQuery({\n                        kind: NodeKind.ExperimentExposureQuery,\n                        experiment_id: props.experimentId,\n                        experiment_name: experiment.name,\n                        exposure_criteria: experiment.exposure_criteria,\n                        feature_flag: experiment.feature_flag,\n                        start_date: experiment.start_date,\n                        end_date: experiment.end_date,\n                        holdout: experiment.holdout,\n                    })\n                    return await performQuery(query, undefined, refresh ? 'force_async' : 'async')\n                },\n            },\n        ],\n    })),\n    selectors({\n        props: [() => [(_, props) => props], (props) => props],\n        experimentId: [\n            () => [(_, props) => props.experimentId ?? 'new'],\n            (experimentId): Experiment['id'] => experimentId,\n        ],\n        formMode: [() => [(_, props) => props.formMode], (action: FormModes) => action],\n        getInsightType: [\n            () => [],\n            () =>\n                (\n                    metric: ExperimentMetric | ExperimentTrendsQuery | ExperimentFunnelsQuery | undefined\n                ): InsightType => {\n                    return metric &&\n                        ((metric?.kind === NodeKind.ExperimentMetric &&\n                            metric.metric_type === ExperimentMetricType.MEAN) ||\n                            metric?.kind === NodeKind.ExperimentTrendsQuery)\n                        ? InsightType.TRENDS\n                        : InsightType.FUNNELS\n                },\n        ],\n        getExperimentMetricType: [\n            () => [],\n            () =>\n                (metric: ExperimentMetric | undefined): ExperimentMetricType => {\n                    return metric?.metric_type || ExperimentMetricType.MEAN\n                },\n        ],\n        isExperimentDraft: [\n            (s) => [s.experiment],\n            (experiment): boolean => {\n                return !experiment?.start_date && !experiment?.end_date && !experiment?.archived\n            },\n        ],\n        isExperimentRunning: [\n            (s) => [s.experiment],\n            (experiment): boolean => {\n                return !!experiment?.start_date\n            },\n        ],\n        isExperimentStopped: [\n            (s) => [s.experiment],\n            (experiment): boolean => {\n                return (\n                    !!experiment?.end_date &&\n                    dayjs().isSameOrAfter(dayjs(experiment.end_date), 'day') &&\n                    !experiment.archived\n                )\n            },\n        ],\n        breadcrumbs: [\n            (s) => [s.experiment, s.experimentId],\n            (experiment, experimentId): Breadcrumb[] => [\n                {\n                    key: Scene.Experiments,\n                    name: 'Experiments',\n                    path: urls.experiments(),\n                },\n                {\n                    key: [Scene.Experiment, experimentId],\n                    name: experiment?.name || '',\n                    onRename: async (name: string) => {\n                        // :KLUDGE: work around a type error when using asyncActions accessed via a callback passed to selectors()\n                        const logic = experimentLogic({ experimentId })\n                        await logic.asyncActions.updateExperiment({ name })\n                    },\n                },\n            ],\n        ],\n        projectTreeRef: [\n            () => [(_, props: ExperimentLogicProps) => props.experimentId],\n            (experimentId): ProjectTreeRef => {\n                return { type: 'experiment', ref: experimentId === 'new' ? null : String(experimentId) }\n            },\n        ],\n        variants: [\n            (s) => [s.experiment],\n            (experiment): MultivariateFlagVariant[] => {\n                return experiment?.parameters?.feature_flag_variants || []\n            },\n        ],\n        experimentMathAggregationForTrends: [\n            (s) => [s.experiment],\n            (experiment) => (): PropertyMathType | CountPerActorMathType | undefined => {\n                const query = experiment?.metrics?.[0] as ExperimentTrendsQuery\n                if (!query) {\n                    return undefined\n                }\n                const entities = query.count_query?.series || []\n\n                // Find out if we're using count per actor math aggregates averages per user\n                const userMathValue = entities.filter((entity) =>\n                    Object.values(CountPerActorMathType).includes(entity?.math as CountPerActorMathType)\n                )[0]?.math\n\n                // alternatively, if we're using property math\n                // remove 'sum' property math from the list of math types\n                // since we can handle that as a regular case\n                const targetValues = Object.values(PropertyMathType).filter((value) => value !== PropertyMathType.Sum)\n\n                const propertyMathValue = entities.filter((entity) =>\n                    (targetValues as readonly PropertyMathType[]).includes(entity?.math as PropertyMathType)\n                )[0]?.math\n\n                return (userMathValue ?? propertyMathValue) as PropertyMathType | CountPerActorMathType | undefined\n            },\n        ],\n        minimumDetectableEffect: [\n            (s) => [s.experiment],\n            (newExperiment): number => {\n                return newExperiment?.parameters?.minimum_detectable_effect ?? DEFAULT_MDE\n            },\n        ],\n        isPrimaryMetricSignificant: [\n            (s) => [s.legacyPrimaryMetricsResults],\n            (\n                    legacyPrimaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[]\n                ) =>\n                (metricIndex: number = 0): boolean => {\n                    const result = legacyPrimaryMetricsResults?.[metricIndex]\n                    if (!result) {\n                        return false\n                    }\n\n                    return result.significant || false\n                },\n        ],\n        isSecondaryMetricSignificant: [\n            (s) => [s.legacySecondaryMetricsResults],\n            (\n                    legacySecondaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[]\n                ) =>\n                (metricIndex: number = 0): boolean => {\n                    const result = legacySecondaryMetricsResults?.[metricIndex]\n                    if (!result) {\n                        return false\n                    }\n\n                    return result.significant || false\n                },\n        ],\n        significanceDetails: [\n            (s) => [s.legacyPrimaryMetricsResults],\n            (\n                    legacyPrimaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[]\n                ) =>\n                (metricIndex: number = 0): string => {\n                    const results = legacyPrimaryMetricsResults?.[metricIndex]\n                    return getSignificanceDetails(results)\n                },\n        ],\n        recommendedSampleSize: [\n            (s) => [s.conversionMetrics, s.variants, s.minimumDetectableEffect],\n            (conversionMetrics, variants, minimumDetectableEffect): number => {\n                const conversionRate = conversionMetrics.totalRate * 100\n                const sampleSizePerVariant = minimumSampleSizePerVariant(minimumDetectableEffect, conversionRate)\n                const sampleSize = sampleSizePerVariant * variants.length\n                return sampleSize\n            },\n        ],\n        recommendedRunningTime: [\n            (s) => [\n                s.experiment,\n                s.variants,\n                s.getInsightType,\n                s.firstPrimaryMetric,\n                s.funnelResults,\n                s.conversionMetrics,\n                s.trendResults,\n                s.minimumDetectableEffect,\n            ],\n            (\n                experiment,\n                variants,\n                getInsightType,\n                firstPrimaryMetric,\n                funnelResults,\n                conversionMetrics,\n                trendResults,\n                minimumDetectableEffect\n            ): number => {\n                if (getInsightType(firstPrimaryMetric) === InsightType.FUNNELS) {\n                    const currentDuration = dayjs().diff(dayjs(experiment?.start_date), 'hour')\n                    let funnelEntrants: number | undefined\n                    if (Array.isArray(funnelResults) && funnelResults[0]) {\n                        const firstFunnelEntry = funnelResults[0]\n\n                        funnelEntrants = Array.isArray(firstFunnelEntry)\n                            ? firstFunnelEntry[0].count\n                            : firstFunnelEntry.count\n                    }\n\n                    const conversionRate = conversionMetrics.totalRate * 100\n                    const sampleSizePerVariant = minimumSampleSizePerVariant(minimumDetectableEffect, conversionRate)\n                    const funnelSampleSize = sampleSizePerVariant * variants.length\n                    if (experiment?.start_date) {\n                        return expectedRunningTime(funnelEntrants || 1, funnelSampleSize || 0, currentDuration)\n                    }\n                    return expectedRunningTime(funnelEntrants || 1, funnelSampleSize || 0)\n                }\n\n                const trendCount = trendResults[0]?.count\n                const runningTime = recommendedExposureForCountData(minimumDetectableEffect, trendCount)\n                return runningTime\n            },\n        ],\n        tabularExperimentResults: [\n            (s) => [s.experiment, s.legacyPrimaryMetricsResults, s.legacySecondaryMetricsResults, s.getInsightType],\n            (\n                    experiment,\n                    legacyPrimaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    legacySecondaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    getInsightType\n                ) =>\n                (metricIndex: number = 0, isSecondary: boolean = false): any[] => {\n                    const tabularResults = []\n                    const metricType = isSecondary\n                        ? getInsightType(experiment.metrics_secondary[metricIndex])\n                        : getInsightType(experiment.metrics[metricIndex])\n                    const result = isSecondary\n                        ? legacySecondaryMetricsResults[metricIndex]\n                        : legacyPrimaryMetricsResults[metricIndex]\n\n                    if (result) {\n                        for (const variantObj of result.variants) {\n                            if (metricType === InsightType.FUNNELS) {\n                                const { key, success_count, failure_count } = variantObj as FunnelExperimentVariant\n                                tabularResults.push({ key, success_count, failure_count })\n                            } else if (metricType === InsightType.TRENDS) {\n                                const { key, count, exposure, absolute_exposure } = variantObj as TrendExperimentVariant\n                                tabularResults.push({ key, count, exposure, absolute_exposure })\n                            }\n                        }\n                    }\n\n                    if (experiment.feature_flag?.filters.multivariate?.variants) {\n                        for (const { key } of experiment.feature_flag.filters.multivariate.variants) {\n                            if (tabularResults.find((variantObj) => variantObj.key === key)) {\n                                continue\n                            }\n\n                            if (metricType === InsightType.FUNNELS) {\n                                tabularResults.push({ key, success_count: null, failure_count: null })\n                            } else if (metricType === InsightType.TRENDS) {\n                                tabularResults.push({ key, count: null, exposure: null, absolute_exposure: null })\n                            }\n                        }\n                    }\n\n                    return tabularResults\n                },\n        ],\n        sortedWinProbabilities: [\n            (s) => [s.legacyPrimaryMetricsResults],\n            (\n                    legacyPrimaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[]\n                ) =>\n                (metricIndex: number = 0) => {\n                    const result = legacyPrimaryMetricsResults?.[metricIndex]\n\n                    if (!result) {\n                        return []\n                    }\n\n                    return Object.keys(result.probability)\n                        .map((key) => ({\n                            key,\n                            winProbability: result.probability[key],\n                            conversionRate: conversionRateForVariant(result, key),\n                        }))\n                        .sort((a, b) => b.winProbability - a.winProbability)\n                },\n        ],\n        funnelResultsPersonsTotal: [\n            (s) => [s.experiment, s.legacyPrimaryMetricsResults, s.getInsightType],\n            (\n                    experiment,\n                    legacyPrimaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    getInsightType\n                ) =>\n                (metricIndex: number = 0): number => {\n                    const result = legacyPrimaryMetricsResults?.[metricIndex]\n\n                    if (getInsightType(experiment.metrics[metricIndex]) !== InsightType.FUNNELS || !result) {\n                        return 0\n                    }\n\n                    let sum = 0\n                    result.insight.forEach((variantResult) => {\n                        if (variantResult[0]?.count) {\n                            sum += variantResult[0].count\n                        }\n                    })\n                    return sum\n                },\n        ],\n        actualRunningTime: [\n            (s) => [s.experiment],\n            (experiment: Experiment): number => {\n                if (!experiment.start_date) {\n                    return 0\n                }\n\n                if (experiment.end_date) {\n                    return dayjs(experiment.end_date).diff(experiment.start_date, 'day')\n                }\n\n                return dayjs().diff(experiment.start_date, 'day')\n            },\n        ],\n        isSingleVariantShipped: [\n            (s) => [s.experiment],\n            (experiment: Experiment): boolean => {\n                const filters = experiment.feature_flag?.filters\n\n                return (\n                    !!filters &&\n                    Array.isArray(filters.groups?.[0]?.properties) &&\n                    filters.groups?.[0]?.properties?.length === 0 &&\n                    filters.groups?.[0]?.rollout_percentage === 100 &&\n                    (filters.multivariate?.variants?.some(({ rollout_percentage }) => rollout_percentage === 100) ||\n                        false)\n                )\n            },\n        ],\n        hasPrimaryMetricSet: [\n            (s) => [s.primaryMetricsLengthWithSharedMetrics],\n            (primaryMetricsLengthWithSharedMetrics): boolean => {\n                return primaryMetricsLengthWithSharedMetrics > 0\n            },\n        ],\n        firstPrimaryMetric: [\n            (s) => [s.experiment],\n            (experiment: Experiment): ExperimentMetric | ExperimentTrendsQuery | ExperimentFunnelsQuery | undefined => {\n                if (experiment.metrics.length) {\n                    return experiment.metrics[0]\n                }\n                const primaryMetric = experiment.saved_metrics.find((metric) => metric.metadata.type === 'primary')\n                if (primaryMetric) {\n                    return primaryMetric.query\n                }\n            },\n        ],\n        primaryMetricsLengthWithSharedMetrics: [\n            (s) => [s.experiment],\n            (experiment: Experiment): number => {\n                return (\n                    experiment.metrics.length +\n                    experiment.saved_metrics.filter((savedMetric) => savedMetric.metadata.type === 'primary').length\n                )\n            },\n        ],\n        secondaryMetricsLengthWithSharedMetrics: [\n            (s) => [s.experiment],\n            (experiment: Experiment): number => {\n                return (\n                    experiment.metrics_secondary.length +\n                    experiment.saved_metrics.filter((savedMetric) => savedMetric.metadata.type === 'secondary').length\n                )\n            },\n        ],\n        compatibleSharedMetrics: [\n            (s) => [s.sharedMetrics, s.usesNewQueryRunner],\n            (sharedMetrics: SharedMetric[], usesNewQueryRunner: boolean): SharedMetric[] => {\n                if (!sharedMetrics) {\n                    return []\n                }\n                if (usesNewQueryRunner) {\n                    return sharedMetrics.filter((metric) => metric.query.kind === NodeKind.ExperimentMetric)\n                }\n                return sharedMetrics.filter((metric) => metric.query.kind !== NodeKind.ExperimentMetric)\n            },\n        ],\n        usesNewQueryRunner: [\n            (s) => [s.experiment],\n            (experiment: Experiment): boolean => {\n                const hasLegacyMetrics = isLegacyExperiment(experiment)\n\n                const allMetrics = [...experiment.metrics, ...experiment.metrics_secondary, ...experiment.saved_metrics]\n                const hasExperimentMetrics = allMetrics.some((query) => query.kind === NodeKind.ExperimentMetric)\n\n                if (hasExperimentMetrics) {\n                    return true\n                }\n\n                if (hasLegacyMetrics) {\n                    return false\n                }\n\n                // If the experiment has no experiment metrics, we use the new query runner\n                return true\n            },\n        ],\n        hasMinimumExposureForResults: [\n            (s) => [s.exposures, s.usesNewQueryRunner],\n            (exposures: ExperimentExposureQueryResponse, usesNewQueryRunner: boolean): boolean => {\n                // Not relevant for old metrics\n                if (!usesNewQueryRunner) {\n                    return true\n                }\n\n                if (!exposures || !exposures.total_exposures) {\n                    return false\n                }\n\n                const total_experiment_exposures = Object.values(exposures.total_exposures).reduce(\n                    (acc, curr) => acc + curr,\n                    0\n                )\n\n                if (total_experiment_exposures < EXPERIMENT_MIN_EXPOSURES_FOR_RESULTS) {\n                    return false\n                }\n\n                return true\n            },\n        ],\n        exposureCriteria: [\n            (s) => [s.experiment],\n            (experiment: Experiment): ExperimentExposureCriteria | undefined => {\n                return experiment.exposure_criteria\n            },\n        ],\n        statsMethod: [\n            (s) => [s.experiment],\n            (experiment: Experiment): ExperimentStatsMethod => {\n                return experiment.stats_config?.method || ExperimentStatsMethod.Bayesian\n            },\n        ],\n    }),\n    forms(({ actions, values, props }) => ({\n        experiment: {\n            options: { showErrorsOnTouch: true },\n            defaults: { ...NEW_EXPERIMENT } as Experiment,\n            errors: ({ name, parameters }) => ({\n                name: !name && 'Please enter a name',\n                // feature_flag_key is handled asynchronously\n                parameters: {\n                    feature_flag_variants: parameters.feature_flag_variants?.map(({ key }) => ({\n                        key: !key.match?.(/^([A-z]|[a-z]|[0-9]|-|_)+$/)\n                            ? 'Only letters, numbers, hyphens (-) & underscores (_) are allowed.'\n                            : undefined,\n                    })),\n                },\n            }),\n            submit: () => {\n                if (\n                    values.experimentId &&\n                    ([FORM_MODES.create, FORM_MODES.duplicate] as FormModes[]).includes(props.formMode!)\n                ) {\n                    actions.createExperiment(true)\n                } else {\n                    actions.createExperiment(true, 'Unfiled/Experiments')\n                }\n            },\n        },\n    })),\n    urlToAction(({ actions, values }) => ({\n        '/experiments/:id': ({ id }, query, __, currentLocation, previousLocation) => {\n            const didPathChange = currentLocation.initial || currentLocation.pathname !== previousLocation?.pathname\n\n            actions.setEditExperiment(false)\n\n            if (id && didPathChange) {\n                const parsedId = id === 'new' ? 'new' : parseInt(id)\n                if (parsedId === 'new') {\n                    actions.resetExperiment({\n                        ...NEW_EXPERIMENT,\n                        metrics: query.metric ? [query.metric] : [],\n                        name: query.name ?? '',\n                    })\n                }\n                if (parsedId !== 'new' && parsedId === values.experimentId) {\n                    actions.loadExperiment()\n                    if (values.isExperimentRunning) {\n                        actions.loadExposures()\n                    }\n                }\n            }\n        },\n        '/experiments/:id/:formMode': ({ id }, _, __, currentLocation, previousLocation) => {\n            const didPathChange = currentLocation.initial || currentLocation.pathname !== previousLocation?.pathname\n\n            if (id && didPathChange) {\n                actions.loadExperiment()\n            }\n        },\n    })),\n])\n","import { useValues } from 'kea'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { apiHostOrigin } from 'lib/utils/apiHost'\nimport { teamLogic } from 'scenes/teamLogic'\n\nimport { GroupType } from '~/types'\n\nexport const UTM_TAGS = '?utm_medium=in-product&utm_campaign=feature-flag'\nexport interface FeatureFlagSnippet {\n    flagKey: string\n    multivariant?: boolean\n    groupType?: GroupType\n    localEvaluation?: boolean\n    payload?: boolean\n    remoteConfiguration?: boolean\n    encryptedPayload?: boolean\n    samplePropertyName?: string\n    instantlyAvailableProperties?: boolean\n}\n\nconst LOCAL_EVAL_REMINDER = `Remember to set a personal API key in the SDK to enable local evaluation.\n`\n\nconst REMOTE_CONFIG_REMINDER = `Must initialize SDK with a personal API key to enable remote configuration.`\nconst ENCRYPTED_PAYLOAD_REMINDER = `Encrypted payloads are automatically decrypted on the server before being sent to the client.`\n\nexport function NodeJSSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'await client.'\n    const flagFunction = payload ? 'getFeatureFlagPayload' : multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    if (remoteConfiguration) {\n        const reminder = REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n// ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.JavaScript} wrap>\n                    {`// ${reminder}\nconst remoteConfigPayload = await client.getRemoteConfigPayload('${flagKey}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n        // add group properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        groupProperties: { ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n        // add person properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        personProperties: {'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${\n        payload\n            ? `\n    undefined,`\n            : ''\n    }\n    {\n        groups: { '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n    }\n)`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${\n        payload\n            ? `\n    undefined,`\n            : ''\n    }\n    {${localEvalAddition}\n    }\n)`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n\n    const variableName = payload ? 'matchedFlagPayload' : multivariant ? 'enabledVariant' : 'isMyFlagEnabledForUser'\n\n    const conditional = multivariant ? `${variableName} === 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif (${conditional}) {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`\n\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`${\n                    localEvaluation ? '// ' + LOCAL_EVAL_REMINDER : ''\n                }const ${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function PHPSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHog::'\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n    // empty person properties\n    [],\n    // add group properties used in the flag to ensure the flag\n    // is evaluated locally, vs. going to our servers\n    [${groupType.group_type} =>  ['${propertyName}' => 'value', 'name' => 'xyz']]`\n            : `\n    // add person properties used in the flag to ensure the flag\n    // is evaluated locally, vs. going to our servers\n    ['${propertyName}' => 'value']`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',\n    // group types\n    ['${groupType.group_type}' => '<${groupType.name_singular || 'group'} ID>'],${localEvalAddition}\n)`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${localEvalAddition}\n)`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = multivariant ? '$enabledVariant' : '$isMyFlagEnabledForUser'\n\n    const conditional = multivariant ? `${variableName} === 'example-variant'` : `${variableName}`\n\n    return (\n        <>\n            <CodeSnippet language={Language.PHP} wrap>\n                {`${localEvaluation ? '// ' + LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}\n\nif (${conditional}) {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function GolangSnippet({\n    flagKey,\n    groupType,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    multivariant,\n    localEvaluation,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'client.'\n\n    const flagFunction = payload ? 'GetFeatureFlagPayload' : multivariant ? 'GetFeatureFlag' : 'IsFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    if (remoteConfiguration) {\n        const reminder = REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n// ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.Go} wrap>\n                    {`// ${reminder}\nremoteConfigPayload, err := ${clientSuffix}GetRemoteConfigPayload(\"${flagKey}\")`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n        // add group properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        groupProperties: map[string]Properties{\"${groupType.group_type}\": posthog.NewProperties().Set(\"${propertyName}\", \"value\").Set(\"name\", \"xyz\")}`\n            : `\n        // add person properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        PersonProperties: posthog.NewProperties().Set(\"${propertyName}\", \"value\")`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    FeatureFlagPayload{\n        Key:        \"${flagKey}\",\n        DistinctId: \"distinct-id\",\n        Groups:     Groups{'${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>'},${localEvalAddition}\n    }\n)`\n        : `${clientSuffix}${flagFunction}(\n    FeatureFlagPayload{\n        Key:        '${flagKey}',\n        DistinctId: \"distinct-id\",${localEvalAddition}\n    })`\n    const variableName = multivariant ? 'enabledVariant, err' : 'isMyFlagEnabledForUser, err'\n\n    const conditional = multivariant ? `enabledVariant == 'example-variant'` : `isMyFlagEnabledForUser`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Go} wrap>\n                {`${localEvaluation ? '// ' + LOCAL_EVAL_REMINDER : ''}${variableName} := ${flagSnippet}\n\nif ${conditional} {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function RubySnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n    const flagFunction = payload ? 'get_feature_flag_payload' : multivariant ? 'get_feature_flag' : 'is_feature_enabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    if (remoteConfiguration) {\n        const reminder = `# ` + REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n# ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.Ruby} wrap>\n                    {`${reminder}\nremote_config_payload = posthog.get_remote_config_payload('${flagKey}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n    # add group properties used in the flag to ensure the flag\n    # is evaluated locally, vs. going to our servers\n    group_properties: { ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n    # add person properties used in the flag to ensure the flag\n    # is evaluated locally, vs. going to our servers\n    person_properties: {'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',\n    groups: { '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n)`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${localEvalAddition}\n)`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = payload ? 'matched_flag_payload' : multivariant ? 'enabled_variant' : 'is_my_flag_enabled'\n\n    const conditional = multivariant ? `${variableName} == 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif ${conditional}\n    # Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\nend`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Ruby} wrap>\n                {`${localEvaluation ? '# ' + LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function PythonSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n    const flagFunction = payload ? 'get_feature_flag_payload' : multivariant ? 'get_feature_flag' : 'feature_enabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    if (remoteConfiguration) {\n        const reminder = `# ` + REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n# ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.Python} wrap>\n                    {`${reminder}\nremote_config_payload = posthog.get_remote_config_payload('${flagKey}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n    # add group properties used in the flag to ensure the flag\n    # is evaluated locally, vs. going to our servers\n    group_properties={ ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n    # add person properties used in the flag to ensure the flag\n    # is evaluated locally, vs. going to our servers\n    person_properties={'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',\n    groups={ '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n)`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${localEvalAddition}\n)`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = payload ? 'matched_flag_payload' : multivariant ? 'enabled_variant' : 'is_my_flag_enabled'\n\n    const conditional = multivariant ? `${variableName} == 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif ${conditional}:\n    # Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Python} wrap>\n                {`${localEvaluation ? '# ' + LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function CSharpSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n    const flagFunction = payload\n        ? 'GetFeatureFlagAsync'\n        : multivariant\n        ? 'GetFeatureFlagAsync'\n        : 'IsFeatureEnabledAsync'\n\n    const propertyName = samplePropertyName || 'isAuthorized'\n\n    if (remoteConfiguration) {\n        const reminder = `// ` + REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n// ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.CSharp} wrap>\n                    {`${reminder}\nvar remoteConfigPayload = await posthog.GetRemoteConfigPayloadAsync(\"${flagKey}\");`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalCommentAddition = localEvaluation\n        ? groupType\n            ? `// add group properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        `\n            : `// add person properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        `\n        : ''\n\n    const localEvalCodeAddition = localEvaluation\n        ? groupType\n            ? `{ [\"${propertyName}\"] = \"value\", [\"name\"] = \"xyz\" }`\n            : `\n    personProperties: new() { [\"${propertyName}\"] = \"value\" }`\n        : ''\n\n    const flagSnippet = groupType\n        ? `await ${clientSuffix}${flagFunction}(\n    \"${flagKey}\",\n    \"user distinct id\",\n    new FeatureFlagOptions\n    {\n        ${localEvalCommentAddition}Groups = [new Group(\"${groupType.group_type}\", \"<${\n              groupType.name_singular || 'group'\n          } ID>\")${localEvalCodeAddition}]\n    }\n);`\n        : localEvalCodeAddition\n        ? `await ${clientSuffix}${flagFunction}(\n    \"${flagKey}\",\n    \"user distinct id\",${localEvalCodeAddition}\n);`\n        : `await ${clientSuffix}${flagFunction}(\"${flagKey}\", \"user distinct id\");`\n    const variableName = payload ? 'matchedFlagPayload' : multivariant ? 'enabledVariant' : 'isMyFlagEnabled'\n\n    const conditional = multivariant ? `${variableName} == 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? `\nif (matchedFlagPayload is { Payload: {} payload })\n{\n    // The payload is a JsonDocument.\n    Console.WriteLine(payload.RootElement.GetRawText());\n}`\n        : `\n\nif (${conditional}) {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}\n`\n\n    return (\n        <>\n            <CodeSnippet language={Language.CSharp} wrap>\n                {`${\n                    localEvaluation ? '// ' + LOCAL_EVAL_REMINDER : ''\n                }var ${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function AndroidSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHog.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Kotlin} wrap>\n                {`${clientSuffix}getFeatureFlagPayload(\"${flagKey}\")`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == \"example-variant\"` : ''\n    return (\n        <CodeSnippet language={Language.Kotlin} wrap>\n            {`if (${clientSuffix}${flagFunction}(\"${flagKey}\")${variantSuffix}) {\n    // do something\n}\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function FlutterSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'await Posthog().'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Dart} wrap>\n                {`${clientSuffix}getFeatureFlagPayload('${flagKey}');`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n\n    return (\n        <CodeSnippet language={Language.Dart} wrap>\n            {`if (${clientSuffix}${flagFunction}('${flagKey}')${variantSuffix}) {\n  // do something\n}\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function iOSSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHogSDK.shared.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Swift} wrap>\n                {`${clientSuffix}getFeatureFlagPayload(\"${flagKey}\")`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? `as? String == \"example-variant\"` : ''\n    return (\n        <CodeSnippet language={Language.Swift} wrap>\n            {`if ${clientSuffix}${flagFunction}(\"${flagKey}\")${variantSuffix} {\n    // do something\n}`}\n        </CodeSnippet>\n    )\n}\n\nexport function ReactNativeSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.JSX} wrap>\n                {`${clientSuffix}getFeatureFlagPayload('${flagKey}')`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n    return (\n        <CodeSnippet language={Language.JSX} wrap>\n            {`// With a hook\nimport { useFeatureFlag } from 'posthog-react-native'\n\nconst MyComponent = () => {\n    const showFlaggedFeature = useFeatureFlag('${flagKey}')\n\n    if (showFlaggedFeature === undefined) {\n        // the response is undefined if the flags are being loaded\n        return null\n    }\n\n    return showFlaggedFeature ${variantSuffix} ? <Text>Testing feature 😄</Text> : <Text>Not Testing feature 😢</Text>\n}\n\n// Or calling on the method directly\n${clientSuffix}${flagFunction}('${flagKey}')\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function ReactSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const flagFunction = payload\n        ? 'useFeatureFlagPayload'\n        : multivariant\n        ? 'useFeatureFlagVariantKey'\n        : 'useFeatureFlagEnabled'\n\n    const variable = payload ? 'payload' : multivariant ? 'variant' : 'flagEnabled'\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n\n    return (\n        <CodeSnippet language={Language.JSX} wrap>\n            {`\nimport { ${flagFunction} } from 'posthog-js/react'\n\nfunction App() {\n    const ${variable} = ${flagFunction}('${flagKey}')\n\n    if (${variable}${variantSuffix}) {\n        // do something\n    }\n}`}\n        </CodeSnippet>\n    )\n}\n\nexport function APISnippet({ flagKey, groupType, remoteConfiguration }: FeatureFlagSnippet): JSX.Element {\n    const { currentTeam } = useValues(teamLogic)\n\n    const groupAddition = groupType\n        ? `,\n    \"groups\": { \"${groupType.group_type}\": \"<${groupType.name_singular || 'group'} ID>\" },`\n        : ''\n\n    if (remoteConfiguration) {\n        return (\n            <>\n                <CodeSnippet language={Language.Bash} wrap>\n                    {`curl ${apiHostOrigin()}/api/projects/${currentTeam?.id || ':projectId'}/feature_flags/${\n                        flagKey || ':featureFlagKey'\n                    }/remote_config/ \\\\\n-H 'Content-Type: application/json' \\\\\n-H 'Authorization: Bearer [personal_api_key]'`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    return (\n        <>\n            <CodeSnippet language={Language.Bash} wrap>\n                {`curl ${apiHostOrigin()}/flags/?v=2/ \\\\\n-X POST -H 'Content-Type: application/json' \\\\\n-d '{\n    \"api_key\": \"${currentTeam ? currentTeam.api_token : '[project_api_key]'}\",\n    \"distinct_id\": \"[user distinct id]\"${groupAddition}\n}'\n                `}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function JSSnippet({\n    flagKey,\n    multivariant,\n    payload,\n    groupType,\n    instantlyAvailableProperties,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    if (payload) {\n        return (\n            <>\n                <CodeSnippet language={Language.JavaScript} wrap>\n                    {`posthog.getFeatureFlagPayload('${flagKey ?? ''}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const propertyOverrideSnippet = `// Your flag depends on properties that are not instantly available. If you want\n// to make them available without waiting for server delays, send these properties for flag evaluation, like so:\n// Make sure to call this before evaluating flags. More info: https://posthog.com/docs/libraries/js#overriding-server-properties \nposthog.${\n        groupType\n            ? `setGroupPropertiesForFlags({ '${groupType.group_type}': {'${propertyName}': 'value'}})`\n            : `setPersonPropertiesForFlags({'${propertyName}': 'value'})`\n    }\n\n`\n\n    const clientSuffix = 'posthog.'\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`${instantlyAvailableProperties ? '' : propertyOverrideSnippet}// Ensure flags are loaded before usage.\n// You'll only need to call this on the code for when the first time a user visits.\n${clientSuffix}onFeatureFlags(function() {\n    // feature flags should be available at this point\n    if (${clientSuffix}${flagFunction}('${flagKey ?? ''}') ${variantSuffix}) {\n        // do something\n    }\n})\n\n// Otherwise, you can just do:\nif (${clientSuffix}${flagFunction}('${flagKey ?? ''}') ${variantSuffix}) {\n    // do something\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function JSBootstrappingSnippet(): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`// Initialise the posthog library with a distinct ID and feature flags for immediate loading\n// This avoids the delay between the library loading and feature flags becoming available to use.\n\nposthog.init('{project_api_key}', {\n    api_host: '${apiHostOrigin()}'\n    bootstrap:\n    {\n        distinctID: 'your-anonymous-id',\n        featureFlags: {\n    // input the flag values here from 'posthog.getAllFlags(distinct_id)' which you can find in the server-side libraries.\n        // example:\n            // 'flag-1': true,\n            // 'variant-flag': 'control',\n            // 'other-flag': false\n        },\n    }\n})\n            `}\n        </CodeSnippet>\n    )\n}\n","import { mergeAttributes, Node, NodeViewProps } from '@tiptap/core'\nimport { NodeViewWrapper, ReactNodeViewRenderer } from '@tiptap/react'\nimport { NotebookNodeType, NotebookTarget } from '~/types'\nimport { dayjs } from 'lib/dayjs'\nimport { JSONContent } from '../Notebook/utils'\nimport clsx from 'clsx'\nimport { urls } from 'scenes/urls'\nimport { LemonButton } from '@posthog/lemon-ui'\nimport { notebookLogic } from '../Notebook/notebookLogic'\nimport { useValues } from 'kea'\nimport { useMemo } from 'react'\nimport { openNotebook } from '~/models/notebooksModel'\n\nexport interface NotebookNodeReplayTimestampAttrs {\n    playbackTime?: number\n    sessionRecordingId: string\n    sourceNodeId?: string\n}\n\nconst Component = (props: NodeViewProps): JSX.Element => {\n    const { shortId, findNodeLogic, findNodeLogicById } = useValues(notebookLogic)\n    const { sessionRecordingId, playbackTime = 0, sourceNodeId } = props.node.attrs as NotebookNodeReplayTimestampAttrs\n\n    const relatedNodeInNotebook = useMemo(() => {\n        const logicById = sourceNodeId ? findNodeLogicById(sourceNodeId) : null\n\n        return logicById ?? findNodeLogic(NotebookNodeType.Recording, { id: sessionRecordingId })\n    }, [findNodeLogic])\n\n    const handlePlayInNotebook = (): void => {\n        // TODO: Figure out how to send this action info to the playlist OR the replay node...\n\n        relatedNodeInNotebook?.values.sendMessage('play-replay', {\n            sessionRecordingId,\n            time: playbackTime ?? 0,\n        })\n    }\n\n    return (\n        <NodeViewWrapper\n            as=\"span\"\n            className={clsx('NotebookRecordingTimestamp', props.selected && 'NotebookRecordingTimestamp--selected')}\n        >\n            <LemonButton\n                size=\"small\"\n                noPadding\n                active\n                onClick={\n                    relatedNodeInNotebook ? handlePlayInNotebook : () => openNotebook(shortId, NotebookTarget.Popover)\n                }\n                to={\n                    !relatedNodeInNotebook\n                        ? urls.replaySingle(sessionRecordingId) + `?t=${playbackTime / 1000}`\n                        : undefined\n                }\n            >\n                <span className=\"p-1\">{formatTimestamp(playbackTime)}</span>\n            </LemonButton>\n        </NodeViewWrapper>\n    )\n}\n\nexport const NotebookNodeReplayTimestamp = Node.create({\n    name: NotebookNodeType.ReplayTimestamp,\n    inline: true,\n    group: 'inline',\n    atom: true,\n\n    serializedText: (attrs: NotebookNodeReplayTimestampAttrs): string => {\n        // timestamp is not a block so `getText` does not add a separator.\n        // we need to add it manually\n        return `${attrs.playbackTime ? formatTimestamp(attrs.playbackTime) : '00:00'}:\\n`\n    },\n\n    addAttributes() {\n        return {\n            playbackTime: { default: null, keepOnSplit: false },\n            sessionRecordingId: { default: null, keepOnSplit: true, isRequired: true },\n            sourceNodeId: { default: null, keepOnSplit: true },\n        }\n    },\n\n    parseHTML() {\n        return [{ tag: NotebookNodeType.ReplayTimestamp }]\n    },\n\n    renderHTML({ HTMLAttributes }) {\n        return [NotebookNodeType.ReplayTimestamp, mergeAttributes(HTMLAttributes)]\n    },\n\n    addNodeView() {\n        return ReactNodeViewRenderer(Component)\n    },\n})\n\nexport function formatTimestamp(time: number): string {\n    return dayjs.duration(time, 'milliseconds').format('HH:mm:ss').replace(/^00:/, '').trim()\n}\n\nexport function buildTimestampCommentContent(attrs: NotebookNodeReplayTimestampAttrs): JSONContent {\n    return {\n        type: 'paragraph',\n        content: [\n            {\n                type: NotebookNodeType.ReplayTimestamp,\n                attrs,\n            },\n            { type: 'text', text: ' ' },\n        ],\n    }\n}\n","import {\n    IconCursor,\n    IconFunnels,\n    IconHogQL,\n    IconLifecycle,\n    IconPeople,\n    IconRetention,\n    IconRetentionHeatmap,\n    IconRewindPlay,\n    IconSquareRoot,\n    IconStickiness,\n    IconTrends,\n    IconUpload,\n    IconUserPaths,\n} from '@posthog/icons'\nimport { IconCode } from '@posthog/icons'\nimport { LemonButton, LemonDivider, lemonToast } from '@posthog/lemon-ui'\nimport { Extension } from '@tiptap/core'\nimport { ReactRenderer } from '@tiptap/react'\nimport Suggestion from '@tiptap/suggestion'\nimport Fuse from 'fuse.js'\nimport { useValues } from 'kea'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { IconBold, IconItalic } from 'lib/lemon-ui/icons'\nimport { Popover } from 'lib/lemon-ui/Popover'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { selectFiles } from 'lib/utils/file-utils'\nimport { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useState } from 'react'\n\nimport { KeyboardShortcut } from '~/layout/navigation-3000/components/KeyboardShortcut'\nimport { defaultDataTableColumns } from '~/queries/nodes/DataTable/utils'\nimport { NodeKind } from '~/queries/schema/schema-general'\nimport { BaseMathType, ChartDisplayType, FunnelVizType, NotebookNodeType, PathType, RetentionPeriod } from '~/types'\n\nimport { buildNodeEmbed } from '../Nodes/NotebookNodeEmbed'\nimport { buildInsightVizQueryContent, buildNodeQueryContent } from '../Nodes/NotebookNodeQuery'\nimport NotebookIconHeading from './NotebookIconHeading'\nimport { notebookLogic } from './notebookLogic'\nimport { EditorCommands, EditorRange } from './utils'\n\ntype SlashCommandConditionalProps =\n    | {\n          mode: 'add'\n          getPos: () => number\n          range?: never\n      }\n    | {\n          mode: 'slash'\n          getPos?: never\n          range: EditorRange\n      }\n\ntype SlashCommandsProps = SlashCommandConditionalProps & {\n    query?: string\n    decorationNode?: any\n    onClose?: () => void\n}\n\ntype SlashCommandsPopoverProps = SlashCommandsProps & {\n    visible: boolean\n    children?: JSX.Element\n}\n\ntype SlashCommandsRef = {\n    onKeyDown: (event: KeyboardEvent) => boolean\n}\n\ntype SlashCommandsItem = {\n    title: string\n    search?: string\n    icon?: JSX.Element\n    command: (chain: EditorCommands, pos: number | EditorRange) => EditorCommands | Promise<EditorCommands>\n}\n\nconst TEXT_CONTROLS: SlashCommandsItem[] = [\n    {\n        title: 'h1',\n        icon: <NotebookIconHeading level={1} />,\n        command: (chain) => chain.toggleHeading({ level: 1 }),\n    },\n    {\n        title: 'h2',\n        icon: <NotebookIconHeading level={2} />,\n        command: (chain) => chain.toggleHeading({ level: 2 }),\n    },\n    {\n        title: 'h3',\n        icon: <NotebookIconHeading level={3} />,\n        command: (chain) => chain.toggleHeading({ level: 3 }),\n    },\n    {\n        title: 'bold',\n        icon: <IconBold />,\n        command: (chain) => chain.toggleBold(),\n    },\n    {\n        title: 'italic',\n        icon: <IconItalic />,\n        command: (chain) => chain.toggleItalic(),\n    },\n]\n\nconst SLASH_COMMANDS: SlashCommandsItem[] = [\n    {\n        title: 'Trend',\n        search: 'graph trend insight',\n        icon: <IconTrends color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.TrendsQuery,\n                    filterTestAccounts: false,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            event: '$pageview',\n                            name: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                    interval: 'day',\n                    trendsFilter: {\n                        display: ChartDisplayType.ActionsLineGraph,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Funnel',\n        search: 'funnel insight',\n        icon: <IconFunnels color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.FunnelsQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                        },\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                        },\n                    ],\n                    funnelsFilter: {\n                        funnelVizType: FunnelVizType.Steps,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Retention',\n        search: 'retention insight',\n        icon: <IconRetention color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.RetentionQuery,\n                    retentionFilter: {\n                        period: RetentionPeriod.Day,\n                        totalIntervals: 11,\n                        targetEntity: {\n                            id: '$pageview',\n                            name: '$pageview',\n                            type: 'events',\n                        },\n                        returningEntity: {\n                            id: '$pageview',\n                            name: '$pageview',\n                            type: 'events',\n                        },\n                        retentionType: 'retention_first_time',\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Paths',\n        search: 'user paths insight',\n        icon: <IconUserPaths color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.PathsQuery,\n                    pathsFilter: {\n                        includeEventTypes: [PathType.PageView],\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Stickiness',\n        search: 'stickiness insight',\n        icon: <IconStickiness color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.StickinessQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                    stickinessFilter: {},\n                })\n            ),\n    },\n    {\n        title: 'Lifecycle',\n        search: 'lifecycle insight',\n        icon: <IconLifecycle color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.LifecycleQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                })\n            ),\n    },\n    {\n        title: 'SQL',\n        search: 'sql',\n        icon: <IconHogQL color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.HogQLQuery,\n                        query: `select event,\n        person.properties.email,\n        properties.$browser,\n        count()\n    from events\n    where {filters} -- replaced with global date and property filters\n    and person.properties.email is not null\ngroup by event,\n        properties.$browser,\n        person.properties.email\norder by count() desc\n    limit 100`,\n                        filters: {\n                            dateRange: {\n                                date_from: '-24h',\n                            },\n                        },\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Calendar Heatmap',\n        search: 'calendar heatmap insight',\n        icon: <IconRetentionHeatmap />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.CalendarHeatmapQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                        },\n                    ],\n                })\n            ),\n    },\n    {\n        title: 'Events',\n        search: 'data explore',\n        icon: <IconCursor />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.EventsQuery,\n                        select: defaultDataTableColumns(NodeKind.EventsQuery),\n                        properties: [],\n                        after: '-24h',\n                        limit: 100,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'People',\n        search: 'persons users',\n        icon: <IconPeople />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    columns: defaultDataTableColumns(NodeKind.ActorsQuery),\n                    source: {\n                        kind: NodeKind.ActorsQuery,\n                        properties: [],\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Session recordings',\n        search: 'video replay',\n        icon: <IconRewindPlay />,\n        command: (chain, pos) => chain.insertContentAt(pos, { type: NotebookNodeType.RecordingPlaylist, attrs: {} }),\n    },\n    {\n        title: 'Image',\n        search: 'picture gif',\n        icon: <IconUpload />,\n        command: async (chain, pos) => {\n            // Trigger upload followed by insert\n            try {\n                const files = await selectFiles({ contentType: 'image/*', multiple: false })\n\n                if (files.length) {\n                    return chain.insertContentAt(pos, { type: NotebookNodeType.Image, attrs: { file: files[0] } })\n                }\n            } catch {\n                lemonToast.error('Something went wrong when trying to select a file.')\n            }\n\n            return chain\n        },\n    },\n    {\n        title: 'Embedded iframe',\n        search: 'iframe embed',\n        icon: <IconCode />,\n        command: async (chain, pos) => {\n            return chain.insertContentAt(pos, buildNodeEmbed())\n        },\n    },\n    {\n        title: 'LaTeX',\n        search: 'latex math formula equation',\n        icon: <IconSquareRoot color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(pos, {\n                type: NotebookNodeType.Latex,\n                attrs: { content: '' }, // Default empty content\n            }),\n    },\n]\n\nexport const SlashCommands = forwardRef<SlashCommandsRef, SlashCommandsProps>(function SlashCommands(\n    { mode, range, getPos, onClose, query }: SlashCommandsProps,\n    ref\n): JSX.Element | null {\n    const { editor } = useValues(notebookLogic)\n    const { featureFlags } = useValues(featureFlagLogic)\n    // We start with 1 because the first item is the text controls\n    const [selectedIndex, setSelectedIndex] = useState(0)\n    const [selectedHorizontalIndex, setSelectedHorizontalIndex] = useState(0)\n\n    const calendarHeatmapInsightEnabled = featureFlags[FEATURE_FLAGS.CALENDAR_HEATMAP_INSIGHT]\n    const slashCommands = SLASH_COMMANDS.filter(\n        (command) => calendarHeatmapInsightEnabled || command.title !== 'Calendar Heatmap'\n    )\n\n    const allCommmands = [...TEXT_CONTROLS, ...slashCommands]\n\n    const fuse = useMemo(() => {\n        return new Fuse(allCommmands, {\n            keys: ['title', 'search'],\n            threshold: 0.3,\n        })\n    }, [allCommmands])\n\n    const filteredCommands = useMemo(() => {\n        if (!query) {\n            return allCommmands\n        }\n        return fuse.search(query).map((result) => result.item)\n    }, [query, fuse])\n\n    const filteredSlashCommands = useMemo(\n        () => filteredCommands.filter((item) => slashCommands.includes(item)),\n        [filteredCommands, slashCommands]\n    )\n\n    useEffect(() => {\n        setSelectedIndex(0)\n        setSelectedHorizontalIndex(0)\n    }, [query])\n\n    const execute = async (item: SlashCommandsItem): Promise<void> => {\n        if (editor) {\n            const selectedNode = editor.getSelectedNode()\n            const isTextNode = selectedNode === null || selectedNode.isText\n            const isTextCommand = TEXT_CONTROLS.map((c) => c.title).includes(item.title)\n\n            const position = mode === 'slash' ? range.from : getPos()\n            let chain = mode === 'slash' ? editor.deleteRange(range) : editor.chain()\n\n            if (!isTextNode && isTextCommand) {\n                chain = chain.insertContentAt(position, { type: 'paragraph' })\n            }\n\n            const partialCommand = await item.command(chain, position)\n            partialCommand.run()\n\n            onClose?.()\n        }\n    }\n\n    const onPressEnter = async (): Promise<void> => {\n        const command =\n            selectedIndex === -1 ? TEXT_CONTROLS[selectedHorizontalIndex] : filteredSlashCommands[selectedIndex]\n\n        await execute(command)\n    }\n    const onPressUp = (): void => {\n        setSelectedIndex(Math.max(selectedIndex - 1, -1))\n    }\n    const onPressDown = (): void => {\n        setSelectedIndex(Math.min(selectedIndex + 1, slashCommands.length - 1))\n    }\n\n    const onPressLeft = (): void => {\n        setSelectedHorizontalIndex(Math.max(selectedHorizontalIndex - 1, 0))\n    }\n    const onPressRight = (): void => {\n        setSelectedHorizontalIndex(Math.min(selectedHorizontalIndex + 1, TEXT_CONTROLS.length - 1))\n    }\n\n    const onKeyDown = useCallback(\n        (event: KeyboardEvent): boolean => {\n            const keyMappings = {\n                ArrowUp: onPressUp,\n                ArrowDown: onPressDown,\n                ArrowLeft: onPressLeft,\n                ArrowRight: onPressRight,\n                Enter: onPressEnter,\n            }\n\n            if (keyMappings[event.key]) {\n                keyMappings[event.key]()\n                return true\n            }\n\n            return false\n        },\n        [selectedIndex, selectedHorizontalIndex, filteredCommands]\n    )\n\n    // Expose the keydown handler to the tiptap extension\n    useImperativeHandle(ref, () => ({ onKeyDown }), [onKeyDown])\n\n    useEffect(() => {\n        if (mode !== 'add') {\n            return\n        }\n\n        // If not opened from a slash command, we want to add our own keyboard listeners\n        const keyDownListener = (event: KeyboardEvent): void => {\n            const preventDefault = onKeyDown(event)\n            if (preventDefault) {\n                event.preventDefault()\n            }\n        }\n\n        window.addEventListener('keydown', keyDownListener, true)\n\n        return () => window.removeEventListener('keydown', keyDownListener, true)\n    }, [onKeyDown, mode])\n\n    if (!editor) {\n        return null\n    }\n\n    return (\n        <div className=\"deprecated-space-y-px\">\n            <div className=\"flex items-center gap-1\">\n                {TEXT_CONTROLS.map((item, index) => (\n                    <LemonButton\n                        key={item.title}\n                        size=\"small\"\n                        active={selectedIndex === -1 && selectedHorizontalIndex === index}\n                        onClick={() => void execute(item)}\n                        icon={item.icon}\n                    />\n                ))}\n            </div>\n\n            <LemonDivider />\n\n            {filteredSlashCommands.map((item, index) => (\n                <LemonButton\n                    key={item.title}\n                    fullWidth\n                    icon={item.icon}\n                    active={index === selectedIndex}\n                    onClick={() => void execute(item)}\n                >\n                    {item.title}\n                </LemonButton>\n            ))}\n\n            {filteredSlashCommands.length === 0 && (\n                <div className=\"text-secondary p-1\">\n                    Nothing matching <code>/{query}</code>\n                </div>\n            )}\n\n            {mode === 'add' && (\n                <>\n                    <LemonDivider className=\"my-0\" />\n                    <div className=\"text-xs text-secondary p-1\">\n                        You can trigger this menu by typing <KeyboardShortcut forwardslash />\n                    </div>\n                </>\n            )}\n        </div>\n    )\n})\n\nexport const SlashCommandsPopover = forwardRef<SlashCommandsRef, SlashCommandsPopoverProps>(\n    function SlashCommandsPopover(\n        { visible = true, decorationNode, children, onClose, ...props }: SlashCommandsPopoverProps,\n        ref\n    ): JSX.Element | null {\n        return (\n            <Popover\n                placement=\"right-start\"\n                fallbackPlacements={['left-start', 'right-end']}\n                overlay={<SlashCommands ref={ref} onClose={onClose} {...props} />}\n                referenceElement={decorationNode}\n                visible={visible}\n                onClickOutside={onClose}\n            >\n                {children}\n            </Popover>\n        )\n    }\n)\n\nexport const SlashCommandsExtension = Extension.create({\n    name: 'slash-commands',\n\n    addProseMirrorPlugins() {\n        return [\n            Suggestion({\n                editor: this.editor,\n                char: '/',\n                startOfLine: true,\n                render: () => {\n                    let renderer: ReactRenderer<SlashCommandsRef>\n\n                    return {\n                        onStart: (props) => {\n                            renderer = new ReactRenderer(SlashCommandsPopover, {\n                                props: { ...props, mode: 'slash' },\n                                editor: props.editor,\n                            })\n                        },\n\n                        onUpdate(props) {\n                            renderer.updateProps(props)\n\n                            if (!props.clientRect) {\n                                return\n                            }\n                        },\n\n                        onKeyDown(props) {\n                            if (props.event.key === 'Escape') {\n                                renderer.destroy()\n                                return true\n                            }\n                            return renderer.ref?.onKeyDown(props.event) ?? false\n                        },\n\n                        onExit() {\n                            renderer.destroy()\n                        },\n                    }\n                },\n            }),\n        ]\n    },\n})\n","import { kea, key, listeners, path, props, selectors } from 'kea'\nimport { lazyLoaders } from 'kea-loaders'\nimport { router } from 'kea-router'\nimport api from 'lib/api'\nimport { Dayjs, now } from 'lib/dayjs'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport posthog from 'posthog-js'\nimport { urls } from 'scenes/urls'\nimport { CalendarHeatMapProps } from 'scenes/web-analytics/CalendarHeatMap/CalendarHeatMap'\n\nimport { hogql } from '~/queries/utils'\nimport { ReplayTabs } from '~/types'\n\nimport type { replayActiveHoursHeatMapLogicType } from './replayActiveHoursHeatMapLogicType'\n\nexport interface ReplayActiveHoursHeatMapLogicProps {\n    // we can show this component in different contexts, and key it accordingly\n    scene?: 'templates' | 'filters' | 'replay-home'\n}\n\nconst rowLabels = ['00:00 - 04:00', '04:00 - 08:00', '08:00 - 12:00', '12:00 - 16:00', '16:00 - 20:00', '20:00 - 00:00']\n\nconst columnLabels = (now: Dayjs): string[] => [\n    now.subtract(6, 'day').format('ddd D'),\n    now.subtract(5, 'day').format('ddd D'),\n    now.subtract(4, 'day').format('ddd D'),\n    now.subtract(3, 'day').format('ddd D'),\n    now.subtract(2, 'day').format('ddd D'),\n    now.subtract(1, 'day').format('ddd D'),\n    'Today',\n]\n\n// does not need to be on the logic yet, since it's stateless for now\nexport const getOnClickTooltip = (colIndex: number, rowIndex: number | undefined): string => {\n    const day = columnLabels(now())[colIndex]\n    const timeRange = rowIndex === undefined ? undefined : rowLabels[rowIndex]\n    return `View recordings for ${day}${timeRange ? ` ${timeRange}` : ''}`\n}\n\n// does not need to be on the logic yet, since it's stateless for now\nexport const onCellClick = (colIndex: number, rowIndex: number | undefined): void => {\n    const daysToSubtract = 6 - colIndex\n    let startDate = now().subtract(daysToSubtract, 'day').startOf('day').utc(true)\n    let endDate = startDate.clone()\n\n    if (rowIndex !== undefined) {\n        const startHour = rowIndex * 4\n        const endHour = startHour + 4\n        startDate = startDate.hour(startHour)\n        endDate = endDate.hour(endHour)\n    } else {\n        endDate = endDate.add(1, 'day')\n    }\n\n    posthog.capture('clicked_replay_active_hours_heatmap_cell', {\n        isColumnHeader: rowIndex == undefined,\n        isIndividualCell: rowIndex != undefined,\n    })\n\n    router.actions.push(\n        urls.replay(ReplayTabs.Home, {\n            date_from: startDate.toISOString(),\n            date_to: endDate.toISOString(),\n        })\n    )\n}\n\nexport const replayActiveHoursHeatMapLogic = kea<replayActiveHoursHeatMapLogicType>([\n    path(['scenes', 'session-recordings', 'components', 'replayActiveHoursHeatMapLogic']),\n    props({} as ReplayActiveHoursHeatMapLogicProps),\n    key((props) => props.scene || 'default'),\n    lazyLoaders(() => ({\n        recordingsPerHour: {\n            loadRecordingsPerHour: async (_, breakpoint): Promise<number[][]> => {\n                const q = hogql`\n                    SELECT hour_block,\n                           countIf(_toDate(mints) = today() - 6) AS \"Day -6\",\n                           countIf(_toDate(mints) = today() - 5) AS \"Day -5\",\n                           countIf(_toDate(mints) = today() - 4) AS \"Day -4\",\n                           countIf(_toDate(mints) = today() - 3) AS \"Day -3\",\n                           countIf(_toDate(mints) = today() - 2) AS \"Day -2\",\n                           countIf(_toDate(mints) = today() - 1) AS \"Day -1\",\n                           countIf(_toDate(mints) = today())     AS \"Day 0\"\n                    FROM (SELECT intDiv(toHour(mints), 4) * 4 AS real_hour_block,\n                                 mints\n                          FROM (SELECT min(min_first_timestamp) AS mints\n                                FROM raw_session_replay_events\n                                WHERE min_first_timestamp >= now() - INTERVAL 7 day\n                                  AND min_first_timestamp <= now()\n                                GROUP BY session_id\n                                having dateDiff('SECOND'\n                                     , min (min_first_timestamp)\n                                     , max (max_last_timestamp))\n                                     > 5)) AS data\n                             RIGHT JOIN (SELECT arrayJoin([0, 4, 8, 12, 16, 20]) AS hour_block) AS hours\n                                        ON data.real_hour_block = hours.hour_block\n                    GROUP BY hour_block\n                    ORDER BY hour_block`\n\n                const qResponse = await api.queryHogQL(q)\n\n                // this gives an array of arrays\n                // we're loading hours 0-4, 4-8, 8-12, 12-16, 16-20, 20-24\n                // so we get an array with 6 elements\n                // each of those has 8 values\n                // [0] is the hour block\n                // and then each of the other 7 values is the count for that day\n\n                breakpoint()\n\n                return qResponse.results as number[][]\n            },\n        },\n    })),\n    selectors(() => ({\n        calendarHeatmapProps: [\n            (s) => [s.recordingsPerHour],\n            (\n                recordingsPerHour: number[][]\n            ): Pick<CalendarHeatMapProps, 'rowLabels' | 'columnLabels' | 'processedData'> => {\n                if (!recordingsPerHour || recordingsPerHour.length === 0 || recordingsPerHour[0].length === 0) {\n                    return {\n                        rowLabels: [],\n                        columnLabels: [],\n                        processedData: {\n                            matrix: [],\n                            columnsAggregations: [],\n                            rowsAggregations: [],\n                            overallValue: 0,\n                            maxOverall: 0,\n                            minOverall: 0,\n                            maxRowAggregation: 0,\n                            minRowAggregation: 0,\n                            maxColumnAggregation: 0,\n                            minColumnAggregation: 0,\n                        },\n                    }\n                }\n\n                const dataWithoutHourBlock = recordingsPerHour.map((row) => row.slice(1))\n\n                const columnsAggregations = dataWithoutHourBlock.reduce((acc, row) => {\n                    row.forEach((value: number, index: number) => {\n                        acc[index] = (acc[index] || 0) + value\n                    })\n                    return acc\n                }, [])\n                const rowsAggregations = dataWithoutHourBlock.reduce((acc, row) => {\n                    // take each row and ignoring row[0]\n                    // gather a sum for each index in the row\n                    // so we end up with an array of numbers with length 6\n                    acc[row[0]] = (acc[row[0]] || 0) + row.reduce((a: number, b: number) => a + b, 0)\n                    return acc\n                }, [])\n                const processedData = {\n                    matrix: dataWithoutHourBlock,\n                    columnsAggregations: columnsAggregations,\n                    rowsAggregations: rowsAggregations,\n                    overallValue: columnsAggregations.reduce((a: number, b: number) => a + b, 0),\n                    maxOverall: dataWithoutHourBlock.reduce((acc, row) => {\n                        return Math.max(acc, ...row)\n                    }, 0),\n                    minOverall: dataWithoutHourBlock.reduce((acc, row) => {\n                        return Math.min(acc, ...row)\n                    }, 0),\n                    maxColumnAggregation: Math.max(...columnsAggregations),\n                    minColumnAggregation: Math.min(...columnsAggregations),\n                    maxRowAggregation: Math.max(...rowsAggregations),\n                    minRowAggregation: Math.min(...rowsAggregations),\n                }\n\n                return {\n                    rowLabels: rowLabels,\n                    columnLabels: columnLabels(now()),\n                    processedData: processedData,\n                }\n            },\n        ],\n        isClickable: [\n            (s) => [s.calendarHeatmapProps],\n            (calendarHeatmapProps) => (colIndex: number, rowIndex?: number) => {\n                const valueSource =\n                    rowIndex == undefined\n                        ? calendarHeatmapProps?.processedData.columnsAggregations\n                        : calendarHeatmapProps?.processedData.matrix[rowIndex]\n                return (valueSource[colIndex] ?? 0) > 0\n            },\n        ],\n    })),\n    listeners(() => ({\n        loadRecordingsPerHourFailed: async () => {\n            lemonToast.error('Failed to load recordings activity for heatmap')\n        },\n    })),\n])\n","import { defaults, kea, key, path, props } from 'kea'\nimport { lazyLoaders } from 'kea-loaders'\nimport api from 'lib/api'\n\nimport { hogql } from '~/queries/utils'\n\nimport type { replayActiveScreensTableLogicType } from './replayActiveScreensTableLogicType'\n\nexport interface ReplayActiveScreensTableLogicProps {\n    scene?: 'templates' | 'filters' | 'replay-home'\n}\n\nexport const replayActiveScreensTableLogic = kea<replayActiveScreensTableLogicType>([\n    path(['scenes', 'session-recordings', 'components', 'replayActiveScreensTableLogic']),\n    props({} as ReplayActiveScreensTableLogicProps),\n    key((props) => props.scene || 'default'),\n    defaults({\n        countedScreens: [] as { screen: string; count: number }[],\n    }),\n    lazyLoaders(() => ({\n        countedScreens: {\n            loadCountedScreens: async (_, breakpoint): Promise<{ screen: string; count: number }[]> => {\n                const q = hogql`\n                    select cutQueryString(cutFragment(url)) as u, count(distinct session_id) as c\n                    from (select session_id, arrayJoin(all_urls) as url\n                          from raw_session_replay_events\n                          where min_first_timestamp >= now() - toIntervalDay(7)\n                            and min_first_timestamp <= now())\n                    group by u\n                    order by c desc limit 10\n                `\n\n                const qResponse = await api.queryHogQL(q)\n\n                breakpoint()\n\n                return (qResponse.results || []).map((row) => {\n                    return {\n                        screen: row[0] as string,\n                        count: row[1] as number,\n                    }\n                }) as { screen: string; count: number }[]\n            },\n        },\n    })),\n])\n","import { defaults, kea, key, path, props } from 'kea'\nimport { lazyLoaders } from 'kea-loaders'\nimport api from 'lib/api'\n\nimport { hogql } from '~/queries/utils'\nimport { PersonType } from '~/types'\n\nimport type { replayActiveUsersTableLogicType } from './replayActiveUsersTableLogicType'\n\nexport interface ReplayActiveUsersTableLogicProps {\n    scene?: 'templates' | 'filters' | 'replay-home'\n}\n\nexport const replayActiveUsersTableLogic = kea<replayActiveUsersTableLogicType>([\n    path(['scenes', 'session-recordings', 'components', 'replayActiveUsersTableLogic']),\n    props({} as ReplayActiveUsersTableLogicProps),\n    key((props) => props.scene || 'default'),\n    defaults({\n        countedUsers: [] as { person: PersonType; count: number }[],\n    }),\n    lazyLoaders(() => ({\n        countedUsers: {\n            loadCountedUsers: async (_, breakpoint): Promise<{ person: PersonType; count: number }[]> => {\n                const q = hogql`\n                    select p, any (pp), count () as c\n                    from (\n                        select any (person_id) as p, any (person.properties) as pp\n                        from raw_session_replay_events\n                        where min_first_timestamp <= now()\n                        and min_first_timestamp >= now() - toIntervalDay(7)\n                        group by session_id\n                        having date_diff('second', min (min_first_timestamp), max (max_last_timestamp)) > 5000\n                        ) as q\n                    group by p\n                    order by c desc\n                        limit 10\n                `\n\n                const qResponse = await api.queryHogQL(q)\n\n                breakpoint()\n\n                return (qResponse.results || []).map((row) => {\n                    return {\n                        person: { id: row[0] as string, properties: JSON.parse(row[1]) as Record<string, any> },\n                        count: row[2] as number,\n                    }\n                }) as { person: PersonType; count: number }[]\n            },\n        },\n    })),\n])\n","import useSize from '@react-hook/size'\nimport { useValues } from 'kea'\nimport { cn } from 'lib/utils/css-classes'\nimport { MutableRefObject, useMemo, useRef } from 'react'\n\nimport useIsHovering from '~/lib/hooks/useIsHovering'\n\nimport { sessionRecordingPlayerLogic } from '../sessionRecordingPlayerLogic'\n\ninterface ActivityPoint {\n    x: number\n    y: number\n}\n\nexport function UserActivity({ hoverRef }: { hoverRef: MutableRefObject<HTMLDivElement | null> }): JSX.Element {\n    const { activityPerSecond } = useValues(sessionRecordingPlayerLogic)\n\n    const seekBarRef = useRef<HTMLDivElement | null>(null)\n    const [width, height] = useSize(seekBarRef)\n\n    const isHovering = useIsHovering(hoverRef)\n\n    const points: ActivityPoint[] = useMemo(() => {\n        return Object.entries(activityPerSecond.smoothedPoints).map(([second, activity]) => ({\n            x: (parseInt(second, 10) / activityPerSecond.durationSeconds) * width,\n            y: height - (Math.log(activity.y + 1) / Math.log(activityPerSecond.maxY + 1)) * height,\n        }))\n    }, [activityPerSecond, width, height])\n\n    const hasPoints = points.length > 0\n\n    return (\n        <div\n            className={cn(\n                'absolute bottom-0 w-full bg-gradient-to-t from-surface-primary via-surface-primary to-transparent from-0% via-96% to-100% transition-opacity duration-300',\n                {\n                    'opacity-0': !isHovering,\n                }\n            )}\n            ref={seekBarRef}\n            // if there are no points, we don't want to take up space\n            // eslint-disable-next-line react/forbid-dom-props\n            style={{ height: hasPoints ? '3rem' : '0' }}\n        >\n            <svg width=\"100%\" height=\"100%\" preserveAspectRatio=\"none\">\n                <path\n                    d={\n                        points.length\n                            ? `\n                        M 0,${height}\n                        ${points.map((point) => `L ${point.x},${point.y}`).join(' ')}\n                        L ${width},${height}\n                        Z\n                    `\n                            : ''\n                    }\n                    fill=\"var(--bg-fill-highlight-200)\"\n                    stroke=\"none\"\n                />\n            </svg>\n        </div>\n    )\n}\n","import {\n    IconAIText,\n    IconClock,\n    IconCollapse,\n    IconExpand,\n    IconKeyboard,\n    IconMagicWand,\n    IconPointer,\n    IconThumbsDown,\n    IconThumbsUp,\n    IconWarning,\n} from '@posthog/icons'\nimport { LemonBanner, LemonDivider, LemonTag, Link, Tooltip } from '@posthog/lemon-ui'\nimport clsx from 'clsx'\nimport { useActions, useValues } from 'kea'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { Spinner } from 'lib/lemon-ui/Spinner'\nimport React, { ReactNode, useEffect, useState } from 'react'\nimport { Transition } from 'react-transition-group'\nimport { ENTERED, ENTERING } from 'react-transition-group/Transition'\nimport { playerMetaLogic } from 'scenes/session-recordings/player/player-meta/playerMetaLogic'\nimport { sessionRecordingPlayerLogic } from 'scenes/session-recordings/player/sessionRecordingPlayerLogic'\nimport useResizeObserver from 'use-resize-observer'\n\nimport { playerInspectorLogic } from '../inspector/playerInspectorLogic'\nimport {\n    SegmentMeta,\n    SessionKeyAction,\n    SessionSegment,\n    SessionSegmentKeyActions,\n    SessionSegmentOutcome,\n} from '../player-meta/types'\n\nfunction formatEventMetaInfo(event: SessionKeyAction): JSX.Element {\n    return (\n        <pre className=\"m-0 p-0 font-mono text-xs whitespace-pre\">\n            {`Event: ${event.event}\n            Event type: ${event.event_type}\n            Issues: ${\n                [\n                    event.abandonment && 'Abandonment',\n                    event.confusion && 'Confusion',\n                    event.exception && `Exception (${event.exception})`,\n                ]\n                    .filter(Boolean)\n                    .join(', ') || 'None'\n            }\n            Timestamp: ${event.timestamp}\n            Milliseconds since start: ${event.milliseconds_since_start}\n            Window ID: ${event.window_id}\n            Current URL: ${event.current_url}`}\n        </pre>\n    )\n}\n\nfunction formatMsIntoTime(ms: number): string {\n    const seconds = Math.floor(ms / 1000)\n    const hours = Math.floor(seconds / 3600)\n    const minutes = Math.floor((seconds % 3600) / 60)\n    const remainingSeconds = seconds % 60\n\n    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${remainingSeconds\n        .toString()\n        .padStart(2, '0')}`\n}\n\nconst isValidTimestamp = (ms: unknown): ms is number => typeof ms === 'number' && !isNaN(ms) && ms >= 0\nconst isValidMetaNumber = (value: unknown): value is number => typeof value === 'number' && !isNaN(value) && value >= 0\n\ninterface SegmentMetaProps {\n    meta: SegmentMeta | null | undefined\n}\n\nfunction LoadingTimer({ operation }: { operation?: string }): JSX.Element {\n    const [elapsedSeconds, setElapsedSeconds] = useState(0)\n\n    useEffect(() => {\n        if (operation !== undefined) {\n            setElapsedSeconds(0) // Reset timer only when operation changes and is provided\n        }\n    }, [operation])\n\n    useEffect(() => {\n        const interval = setInterval(() => {\n            setElapsedSeconds((prev) => prev + 1)\n        }, 1000)\n\n        return () => clearInterval(interval)\n    }, []) // Keep this dependency array empty to avoid resetting interval\n\n    return <span className=\"font-mono text-xs text-muted\">{elapsedSeconds}s</span>\n}\n\ninterface SessionSegmentCollapseProps {\n    header: ReactNode\n    content: ReactNode\n    actionsPresent?: boolean\n    className?: string\n    isFailed?: boolean\n}\n\nfunction SessionSegmentCollapse({\n    header,\n    content,\n    actionsPresent,\n    className,\n    isFailed,\n}: SessionSegmentCollapseProps): JSX.Element {\n    const [isExpanded, setIsExpanded] = useState(false)\n    const { height: contentHeight, ref: contentRef } = useResizeObserver({ box: 'border-box' })\n\n    return (\n        <div className={clsx('LemonCollapse', className)}>\n            <div className=\"LemonCollapsePanel\" aria-expanded={isExpanded}>\n                <LemonButton\n                    fullWidth\n                    className={clsx(\n                        'LemonCollapsePanel__header hover:bg-primary-alt-highlight border-l-[5px]',\n                        !actionsPresent && 'LemonCollapsePanel__header--disabled',\n                        isFailed && 'border-l-danger'\n                    )}\n                    onClick={actionsPresent ? () => setIsExpanded(!isExpanded) : undefined}\n                    icon={isExpanded ? <IconCollapse /> : <IconExpand />}\n                    size=\"medium\"\n                    disabled={!actionsPresent}\n                >\n                    {header}\n                </LemonButton>\n                <Transition in={isExpanded} timeout={200} mountOnEnter unmountOnExit>\n                    {(status) => (\n                        <div\n                            className=\"LemonCollapsePanel__body\"\n                            // eslint-disable-next-line react/forbid-dom-props\n                            style={\n                                status === ENTERING || status === ENTERED\n                                    ? {\n                                          height: contentHeight,\n                                      }\n                                    : undefined\n                            }\n                            aria-busy={status.endsWith('ing')}\n                        >\n                            <div className=\"LemonCollapsePanel__content\" ref={contentRef}>\n                                {content}\n                            </div>\n                        </div>\n                    )}\n                </Transition>\n            </div>\n        </div>\n    )\n}\n\nfunction SegmentMetaTable({ meta }: SegmentMetaProps): JSX.Element | null {\n    if (!meta) {\n        return null\n    }\n\n    return (\n        <div className=\"grid grid-cols-2 gap-2 text-xs mt-2\">\n            <div className=\"flex items-center gap-1\">\n                <IconKeyboard className={meta.key_action_count && meta.key_action_count > 0 ? 'text-success' : ''} />\n                <span className=\"text-muted\">Key actions:</span>\n                {isValidMetaNumber(meta.key_action_count) && <span>{meta.key_action_count}</span>}\n            </div>\n            <div className=\"flex items-center gap-1\">\n                <IconWarning className={meta.failure_count && meta.failure_count > 0 ? 'text-danger' : ''} />\n                <span className=\"text-muted\">Issues:</span>\n                {isValidMetaNumber(meta.failure_count) && <span>{meta.failure_count}</span>}\n            </div>\n            <div className=\"flex items-center gap-1\">\n                <IconClock />\n                <span className=\"text-muted\">Duration:</span>\n                {isValidMetaNumber(meta.duration) && isValidMetaNumber(meta.duration_percentage) && (\n                    <span>\n                        {meta.duration === 0 ? (\n                            <span className=\"text-muted\">...</span>\n                        ) : (\n                            `${formatMsIntoTime(meta.duration * 1000)} (${(\n                                (meta.duration_percentage || 0) * 100\n                            ).toFixed(2)}%)`\n                        )}\n                    </span>\n                )}\n            </div>\n            <div className=\"flex items-center gap-1\">\n                <IconPointer />\n                <span className=\"text-muted\">Events:</span>\n                {isValidMetaNumber(meta.events_count) && isValidMetaNumber(meta.events_percentage) && (\n                    <span>\n                        {meta.events_count === 0 ? (\n                            <span className=\"text-muted\">...</span>\n                        ) : (\n                            `${meta.events_count} (${((meta.events_percentage || 0) * 100).toFixed(2)}%)`\n                        )}\n                    </span>\n                )}\n            </div>\n        </div>\n    )\n}\n\ninterface SessionSegmentViewProps {\n    segment: SessionSegment\n    segmentOutcome: SessionSegmentOutcome | undefined\n    keyActions: SessionSegmentKeyActions[]\n    onSeekToTime: (time: number) => void\n}\n\nfunction getIssueTags(event: SessionKeyAction): JSX.Element[] {\n    const tags: JSX.Element[] = []\n    if (event.abandonment) {\n        tags.push(\n            <LemonTag key=\"abandonment\" size=\"small\" type=\"warning\">\n                abandoned\n            </LemonTag>\n        )\n    }\n    if (event.confusion) {\n        tags.push(\n            <LemonTag key=\"confusion\" size=\"small\" type=\"warning\">\n                confusion\n            </LemonTag>\n        )\n    }\n    if (event.exception) {\n        tags.push(\n            <LemonTag key=\"exception\" size=\"small\" type={event.exception === 'blocking' ? 'danger' : 'warning'}>\n                {event.exception}\n            </LemonTag>\n        )\n    }\n    return tags\n}\n\nfunction SessionSegmentView({\n    segment,\n    segmentOutcome,\n    keyActions,\n    onSeekToTime,\n}: SessionSegmentViewProps): JSX.Element {\n    return (\n        <div key={segment.name} className=\"mb-4\">\n            <SessionSegmentCollapse\n                className=\"cursor-pointer\"\n                actionsPresent={keyActions && keyActions.length > 0}\n                isFailed={segmentOutcome && Object.keys(segmentOutcome).length > 0 && segmentOutcome.success === false}\n                header={\n                    <div className=\"py-2\">\n                        <div className=\"flex flex-row gap-2\">\n                            <h3 className=\"mb-1\">{segment.name}</h3>\n                            {segmentOutcome && Object.keys(segmentOutcome).length > 0 ? (\n                                <div>\n                                    {segmentOutcome.success ? null : (\n                                        <LemonTag size=\"small\" type=\"default\">\n                                            failed\n                                        </LemonTag>\n                                    )}\n                                </div>\n                            ) : (\n                                <Spinner />\n                            )}\n                        </div>\n                        {segmentOutcome && (\n                            <>\n                                <p className=\"text-sm font-normal mb-0\">{segmentOutcome.summary}</p>\n                            </>\n                        )}\n                        <SegmentMetaTable\n                            meta={segment.meta && Object.keys(segment.meta).length > 0 ? segment.meta : null}\n                        />\n                    </div>\n                }\n                content={\n                    <>\n                        {keyActions && keyActions.length > 0 ? (\n                            <>\n                                {keyActions?.map((segmentKeyActions) => (\n                                    <SessionSummaryKeyActions\n                                        key={segmentKeyActions.segment_index}\n                                        keyActions={segmentKeyActions}\n                                        segmentName={segment.name}\n                                        onSeekToTime={onSeekToTime}\n                                    />\n                                ))}\n                            </>\n                        ) : (\n                            <div className=\"text-muted-alt\">\n                                Waiting for key actions... <Spinner />\n                            </div>\n                        )}\n                    </>\n                }\n            />\n        </div>\n    )\n}\n\nfunction SessionSummaryKeyActions({\n    keyActions,\n    segmentName,\n    onSeekToTime,\n}: {\n    keyActions: SessionSegmentKeyActions\n    segmentName?: string | null\n    onSeekToTime: (time: number) => void\n}): JSX.Element {\n    const timeToSeeekTo = (ms: number): number => Math.max(ms - 4000, 0)\n    return (\n        <>\n            {keyActions.events?.map((event: SessionKeyAction, eventIndex: number, events: SessionKeyAction[]) =>\n                isValidTimestamp(event.milliseconds_since_start) ? (\n                    <div\n                        key={`${segmentName}-${eventIndex}`}\n                        className={clsx(\n                            'cursor-pointer py-2 px-2 hover:bg-primary-alt-highlight',\n                            // Avoid adding a border to the last event\n                            eventIndex !== events.length - 1 && 'border-b',\n                            (event.abandonment || event.confusion || event.exception) && 'bg-danger-highlight'\n                        )}\n                        onClick={() => {\n                            // Excessive check, required for type safety\n                            if (!isValidTimestamp(event.milliseconds_since_start)) {\n                                return\n                            }\n                            onSeekToTime(timeToSeeekTo(event.milliseconds_since_start))\n                        }}\n                    >\n                        <div className=\"flex flex-row gap-2\">\n                            <span className=\"text-muted-alt shrink-0 min-w-[4rem] font-mono text-xs\">\n                                {formatMsIntoTime(event.milliseconds_since_start)}\n                                <div className=\"flex flex-row gap-2 mt-1\">\n                                    {event.current_url ? (\n                                        <Link to={event.current_url} target=\"_blank\">\n                                            <Tooltip title={event.current_url} placement=\"top\">\n                                                <span className=\"font-mono text-xs text-muted-alt\">url</span>\n                                            </Tooltip>\n                                        </Link>\n                                    ) : null}\n                                    <Tooltip title={formatEventMetaInfo(event)} placement=\"top\">\n                                        <span className=\"font-mono text-xs text-muted-alt\">meta</span>\n                                    </Tooltip>\n                                </div>\n                            </span>\n\n                            <div className=\"flex flex-col\">\n                                <div className=\"text-xs break-words\">{event.description}</div>\n                                <div className=\"flex flex-wrap gap-1 mt-2\">\n                                    {event.milliseconds_since_start === 0 && (\n                                        <LemonTag size=\"small\" type=\"default\">\n                                            before start\n                                        </LemonTag>\n                                    )}\n                                    {getIssueTags(event).map((tag, i) => (\n                                        <React.Fragment key={i}>{tag}</React.Fragment>\n                                    ))}\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                ) : null\n            )}\n        </>\n    )\n}\n\ninterface SessionSummaryLoadingStateProps {\n    finished: boolean\n    operation?: string\n    counter?: number\n    name?: string\n    outOf?: number\n}\n\nfunction SessionSummaryLoadingState({ operation, counter, name, outOf }: SessionSummaryLoadingStateProps): JSX.Element {\n    return (\n        <div className=\"mb-4 grid grid-cols-[auto_1fr] gap-x-2\">\n            <Spinner className=\"text-2xl row-span-2 self-center\" />\n            <div className=\"flex items-center justify-between\">\n                <span className=\"text-muted\">\n                    {operation}&nbsp;\n                    {counter !== undefined && (\n                        <span className=\"font-semibold\">\n                            ({counter}\n                            {outOf ? ` out of ${outOf}` : ''})\n                        </span>\n                    )}\n                    {name ? ':' : ''}\n                </span>\n                <div className=\"flex items-center gap-1 ml-auto font-mono text-xs\">\n                    <LoadingTimer operation={operation} />\n                </div>\n            </div>\n            {name ? (\n                <div className=\"font-semibold\">{name}</div>\n            ) : (\n                // Empty div to maintain two rows for spinner alignment\n                <div />\n            )}\n        </div>\n    )\n}\n\nfunction SessionSummary(): JSX.Element {\n    const { logicProps } = useValues(sessionRecordingPlayerLogic)\n    const { seekToTime } = useActions(sessionRecordingPlayerLogic)\n    const { sessionSummary, summaryHasHadFeedback } = useValues(playerMetaLogic(logicProps))\n    const { sessionSummaryFeedback } = useActions(playerMetaLogic(logicProps))\n\n    const getSessionSummaryLoadingState = (): SessionSummaryLoadingStateProps => {\n        if (!sessionSummary) {\n            return {\n                finished: false,\n                operation: 'Researching the session...',\n            }\n        }\n        const segments = sessionSummary.segments || []\n        const hasSegmentsWithKeyActions = segments.some((segment) =>\n            sessionSummary.key_actions?.some(\n                (keyAction) => keyAction.segment_index === segment.index && keyAction.events?.length\n            )\n        )\n        const hasSegmentsWithOutcomes = segments.some((segment) =>\n            sessionSummary.segment_outcomes?.some((outcome) => outcome.segment_index === segment.index)\n        )\n        const allSegmentsHaveSuccess = segments.every((segment) =>\n            sessionSummary.segment_outcomes?.some(\n                (outcome) =>\n                    outcome.segment_index === segment.index && outcome.success !== null && outcome.success !== undefined\n            )\n        )\n        // If all segments have a success outcome, it means the data is fully loaded and loading state can be hidden\n        if (allSegmentsHaveSuccess) {\n            return {\n                finished: true,\n            }\n        }\n        // If some segments have outcomes already, it means we stream the success and summary of each segment\n        if (hasSegmentsWithOutcomes) {\n            return {\n                finished: false,\n                operation: 'Analyzing the success of each segment',\n            }\n        }\n        // If some segments have key actions already, it means we stream the key actions for each segment\n        if (hasSegmentsWithKeyActions) {\n            // Find first segment that has no key actions\n            const nextSegmentIndex = segments.findIndex(\n                (segment) =>\n                    !sessionSummary.key_actions?.some(\n                        (keyAction) => keyAction.segment_index === segment.index && keyAction.events?.length\n                    )\n            )\n            // If we found such segment, and it's the first one, take it as current\n            // If we don't find such segment, it means we are researching the last segment\n            let currentSegmentIndex\n            if (nextSegmentIndex === 0) {\n                currentSegmentIndex = 0\n            } else if (nextSegmentIndex === -1) {\n                currentSegmentIndex = segments.length - 1\n            } else {\n                currentSegmentIndex = nextSegmentIndex - 1\n            }\n            const currentSegment = segments[currentSegmentIndex]\n            return {\n                finished: false,\n                operation: 'Researching key actions for segments',\n                counter: currentSegmentIndex,\n                name: currentSegment?.name ?? undefined,\n                outOf: segments.length,\n            }\n        }\n        // If no segments have key actions or outcomes, it means we are researching the segments for the session\n        return {\n            finished: false,\n            operation: 'Researching segments for the session...',\n            counter: segments.length || undefined,\n        }\n    }\n\n    const sessionSummaryLoadingState = getSessionSummaryLoadingState()\n\n    return (\n        <div className=\"flex flex-col\">\n            {sessionSummary ? (\n                <>\n                    <h3 className=\"text-lg font-semibold mb-4 mt-2 flex items-center gap-2\">\n                        <IconAIText />\n                        AI Replay Research\n                        <LemonTag type=\"completion\" size=\"medium\">\n                            ALPHA\n                        </LemonTag>\n                    </h3>\n\n                    <div className=\"mb-2\">\n                        {sessionSummaryLoadingState.finished &&\n                        sessionSummary?.session_outcome &&\n                        sessionSummary.session_outcome.success !== null &&\n                        sessionSummary.session_outcome.success !== undefined &&\n                        sessionSummary.session_outcome.description ? (\n                            <LemonBanner\n                                type={sessionSummary.session_outcome.success ? 'success' : 'error'}\n                                className=\"mb-4\"\n                            >\n                                <div className=\"text-sm font-normal\">\n                                    <div>{sessionSummary.session_outcome.description}</div>\n                                </div>\n                            </LemonBanner>\n                        ) : (\n                            <div className=\"mb-4\">\n                                <SessionSummaryLoadingState\n                                    finished={sessionSummaryLoadingState.finished}\n                                    operation={sessionSummaryLoadingState.operation}\n                                    counter={sessionSummaryLoadingState.counter}\n                                    name={sessionSummaryLoadingState.name}\n                                    outOf={sessionSummaryLoadingState.outOf}\n                                />\n                            </div>\n                        )}\n                        <LemonDivider />\n                    </div>\n\n                    {sessionSummary?.segments?.map((segment) => {\n                        const matchingSegmentOutcome = sessionSummary?.segment_outcomes?.find(\n                            (outcome) => outcome.segment_index === segment.index\n                        )\n                        const matchingKeyActions = sessionSummary?.key_actions?.filter(\n                            (keyAction) => keyAction.segment_index === segment.index\n                        )\n                        return (\n                            <SessionSegmentView\n                                key={segment.name}\n                                segment={segment}\n                                segmentOutcome={matchingSegmentOutcome}\n                                keyActions={matchingKeyActions || []}\n                                onSeekToTime={seekToTime}\n                            />\n                        )\n                    })}\n\n                    <div className=\"text-right mb-2 mt-4\">\n                        <p>Is this a good summary?</p>\n                        <div className=\"flex flex-row gap-2 justify-end\">\n                            <LemonButton\n                                size=\"xsmall\"\n                                type=\"primary\"\n                                icon={<IconThumbsUp />}\n                                disabledReason={summaryHasHadFeedback ? 'Thanks for your feedback!' : undefined}\n                                onClick={() => {\n                                    sessionSummaryFeedback('good')\n                                }}\n                            />\n                            <LemonButton\n                                size=\"xsmall\"\n                                type=\"primary\"\n                                icon={<IconThumbsDown />}\n                                disabledReason={summaryHasHadFeedback ? 'Thanks for your feedback!' : undefined}\n                                onClick={() => {\n                                    sessionSummaryFeedback('bad')\n                                }}\n                            />\n                        </div>\n                    </div>\n                </>\n            ) : (\n                <div className=\"text-center text-muted-alt\">No summary available for this session</div>\n            )}\n        </div>\n    )\n}\n\nfunction LoadSessionSummaryButton(): JSX.Element {\n    const { logicProps } = useValues(sessionRecordingPlayerLogic)\n    const { sessionSummaryLoading, loading } = useValues(playerMetaLogic(logicProps))\n    const inspectorLogic = playerInspectorLogic(logicProps)\n    const { items: inspectorItems } = useValues(inspectorLogic)\n    const { summarizeSession } = useActions(playerMetaLogic(logicProps))\n\n    // We need $autocapture events to be able to generate a summary\n    const hasEvents = inspectorItems && inspectorItems.length > 0\n    const hasEnoughEvents =\n        hasEvents &&\n        inspectorItems?.some(\n            (item) =>\n                'data' in item &&\n                item.data &&\n                typeof item.data === 'object' &&\n                'event' in item.data &&\n                item.data.event === '$autocapture'\n        )\n\n    return (\n        <div className=\"space-y-2\">\n            <LemonButton\n                size=\"small\"\n                type=\"primary\"\n                icon={<IconMagicWand />}\n                fullWidth={true}\n                data-attr=\"load-session-summary\"\n                disabled={loading || !hasEnoughEvents}\n                disabledReason={sessionSummaryLoading ? 'Loading...' : undefined}\n                onClick={summarizeSession}\n            >\n                Use AI to summarise this session\n            </LemonButton>\n\n            {loading ? (\n                <div className=\"text-sm\">\n                    Checking on session events... <Spinner />\n                </div>\n            ) : (\n                !hasEnoughEvents && (\n                    <div>\n                        {hasEvents ? (\n                            <>\n                                <h4>No autocapture events found for this session</h4>\n                                <p className=\"text-sm mb-1\">\n                                    Please, ensure that Autocapture is enabled in project's settings, or try again in a\n                                    few minutes.\n                                </p>\n                            </>\n                        ) : (\n                            <>\n                                <h4>Session events are not available for summary yet</h4>\n                                <p className=\"text-sm mb-1\">Please, try again in a few minutes.</p>\n                            </>\n                        )}\n                    </div>\n                )\n            )}\n        </div>\n    )\n}\n\nexport function PlayerSidebarSessionSummary(): JSX.Element | null {\n    const { logicProps } = useValues(sessionRecordingPlayerLogic)\n    const { sessionSummary, sessionSummaryLoading } = useValues(playerMetaLogic(logicProps))\n\n    return (\n        <div className=\"rounded border bg-surface-primary px-2 py-1\">\n            {sessionSummaryLoading ? (\n                <>\n                    <div className=\"flex items-center justify-between\">\n                        <div>\n                            Researching the session... <Spinner />\n                        </div>\n                        <div className=\"flex items-center gap-1 ml-auto\">\n                            <LoadingTimer />\n                        </div>\n                    </div>\n                </>\n            ) : sessionSummary ? (\n                <SessionSummary />\n            ) : (\n                <LoadSessionSummaryButton />\n            )}\n        </div>\n    )\n}\n","import {\n    addedNodeMutation,\n    customEvent,\n    EventType,\n    fullSnapshotEvent,\n    incrementalSnapshotEvent,\n    IncrementalSource,\n    metaEvent,\n    mutationData,\n    removedNodeMutation,\n} from '@posthog/rrweb-types'\nimport { isObject } from 'lib/utils'\nimport posthog from 'posthog-js'\nimport { PLACEHOLDER_SVG_DATA_IMAGE_URL } from 'scenes/session-recordings/player/rrweb'\n\nimport {\n    attributes,\n    documentNode,\n    elementNode,\n    fullSnapshotEvent as MobileFullSnapshotEvent,\n    keyboardEvent,\n    metaEvent as MobileMetaEvent,\n    MobileIncrementalSnapshotEvent,\n    MobileNodeMutation,\n    MobileNodeType,\n    NodeType,\n    serializedNodeWithId,\n    textNode,\n    wireframe,\n    wireframeButton,\n    wireframeCheckBox,\n    wireframeDiv,\n    wireframeImage,\n    wireframeInputComponent,\n    wireframeNavigationBar,\n    wireframePlaceholder,\n    wireframeProgress,\n    wireframeRadio,\n    wireframeRadioGroup,\n    wireframeRectangle,\n    wireframeScreenshot,\n    wireframeSelect,\n    wireframeStatusBar,\n    wireframeText,\n    wireframeToggle,\n} from '../mobile.types'\nimport { makeNavigationBar, makeOpenKeyboardPlaceholder, makeStatusBar } from './screen-chrome'\nimport { ConversionContext, ConversionResult } from './types'\nimport {\n    asStyleString,\n    makeBodyStyles,\n    makeColorStyles,\n    makeDeterminateProgressStyles,\n    makeHTMLStyles,\n    makeIndeterminateProgressStyles,\n    makeMinimalStyles,\n    makePositionStyles,\n    makeStylesString,\n} from './wireframeStyle'\n\nexport const BACKGROUND = '#f3f4ef'\nconst FOREGROUND = '#35373e'\n\n/**\n * generates a sequence of ids\n * from 100 to 9,999,999\n * the transformer reserves ids in the range 0 to 9,999,999\n * we reserve a range of ids because we need nodes to have stable ids across snapshots\n * in order for incremental snapshots to work\n * some mobile elements have to be wrapped in other elements in order to be styled correctly\n * which means the web version of a mobile replay will use ids that don't exist in the mobile replay,\n * and we need to ensure they don't clash\n * -----\n * id is typed as a number in rrweb\n * and there's a few places in their code where rrweb uses a check for `id === -1` to bail out of processing\n * so, it's safest to assume that id is expected to be a positive integer\n */\nfunction* ids(): Generator<number> {\n    let i = 100\n    while (i < 9999999) {\n        yield i++\n    }\n}\n\nlet globalIdSequence = ids()\n\n// there are some fixed ids that we need to use for fixed elements or artificial mutations\nconst DOCUMENT_ID = 1\nconst HTML_DOC_TYPE_ID = 2\nconst HTML_ELEMENT_ID = 3\nconst HEAD_ID = 4\nconst BODY_ID = 5\n// the nav bar should always be the last item in the body so that it is at the top of the stack\nconst NAVIGATION_BAR_PARENT_ID = 7\nexport const NAVIGATION_BAR_ID = 8\n// the keyboard so that it is still before the nav bar\nconst KEYBOARD_PARENT_ID = 9\nexport const KEYBOARD_ID = 10\nexport const STATUS_BAR_PARENT_ID = 11\nexport const STATUS_BAR_ID = 12\n\nfunction isKeyboardEvent(x: unknown): x is keyboardEvent {\n    return isObject(x) && 'data' in x && isObject(x.data) && 'tag' in x.data && x.data.tag === 'keyboard'\n}\n\nexport function _isPositiveInteger(id: unknown): id is number {\n    return typeof id === 'number' && id > 0 && id % 1 === 0\n}\n\nfunction _isNullish(x: unknown): x is null | undefined {\n    return x === null || x === undefined\n}\n\nfunction isRemovedNodeMutation(x: addedNodeMutation | removedNodeMutation): x is removedNodeMutation {\n    return isObject(x) && 'id' in x\n}\n\nexport const makeCustomEvent = (\n    mobileCustomEvent: (customEvent | keyboardEvent) & {\n        timestamp: number\n        delay?: number\n    }\n): (customEvent | incrementalSnapshotEvent) & {\n    timestamp: number\n    delay?: number\n} => {\n    if (isKeyboardEvent(mobileCustomEvent)) {\n        // keyboard events are handled as incremental snapshots to add or remove a keyboard from the DOM\n        // TODO eventually we can pass something to makeIncrementalEvent here\n        const adds: addedNodeMutation[] = []\n        const removes = []\n        if (mobileCustomEvent.data.payload.open) {\n            const keyboardPlaceHolder = makeOpenKeyboardPlaceholder(mobileCustomEvent, {\n                timestamp: mobileCustomEvent.timestamp,\n                idSequence: globalIdSequence,\n            })\n            if (keyboardPlaceHolder) {\n                adds.push({\n                    parentId: KEYBOARD_PARENT_ID,\n                    nextId: null,\n                    node: keyboardPlaceHolder.result,\n                })\n                // mutations seem not to want a tree of nodes to add\n                // so even though `keyboardPlaceholder` is a tree with content\n                // we have to add the text content as well\n                adds.push({\n                    parentId: keyboardPlaceHolder.result.id,\n                    nextId: null,\n                    node: {\n                        type: NodeType.Text,\n                        id: globalIdSequence.next().value,\n                        textContent: 'keyboard',\n                    },\n                })\n            } else {\n                posthog.captureException(new Error('Failed to create keyboard placeholder'), { mobileCustomEvent })\n            }\n        } else {\n            removes.push({\n                parentId: KEYBOARD_PARENT_ID,\n                id: KEYBOARD_ID,\n            })\n        }\n        const mutation: mutationData = { adds, attributes: [], removes, source: IncrementalSource.Mutation, texts: [] }\n        return {\n            type: EventType.IncrementalSnapshot,\n            data: mutation,\n            timestamp: mobileCustomEvent.timestamp,\n        }\n    }\n    return mobileCustomEvent\n}\n\nexport const makeMetaEvent = (\n    mobileMetaEvent: MobileMetaEvent & {\n        timestamp: number\n    }\n): metaEvent & {\n    timestamp: number\n    delay?: number\n} => ({\n    type: EventType.Meta,\n    data: {\n        href: mobileMetaEvent.data.href || '', // the replay doesn't use the href, so we safely ignore any absence\n        // mostly we need width and height in order to size the viewport\n        width: mobileMetaEvent.data.width,\n        height: mobileMetaEvent.data.height,\n    },\n    timestamp: mobileMetaEvent.timestamp,\n})\n\nexport function makeDivElement(\n    wireframe: wireframeDiv,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const _id = _isPositiveInteger(wireframe.id) ? wireframe.id : context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: asStyleString([makeStylesString(wireframe), 'overflow:hidden', 'white-space:nowrap']),\n                'data-rrweb-id': _id,\n            },\n            id: _id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction makeTextElement(\n    wireframe: wireframeText,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (wireframe.type !== 'text') {\n        console.error('Passed incorrect wireframe type to makeTextElement')\n        return null\n    }\n\n    // because we might have to style the text, we always wrap it in a div\n    // and apply styles to that\n    const id = context.idSequence.next().value\n\n    const childNodes = [...children]\n    if (!_isNullish(wireframe.text)) {\n        childNodes.unshift({\n            type: NodeType.Text,\n            textContent: wireframe.text,\n            // since the text node is wrapped, we assign it a synthetic id\n            id,\n        })\n    }\n\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: asStyleString([makeStylesString(wireframe), 'overflow:hidden', 'white-space:normal']),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes,\n        },\n        context,\n    }\n}\n\nfunction makeWebViewElement(\n    wireframe: wireframe,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const labelledWireframe: wireframePlaceholder = { ...wireframe } as wireframePlaceholder\n    if ('url' in wireframe) {\n        labelledWireframe.label = wireframe.url\n    }\n\n    return makePlaceholderElement(labelledWireframe, children, context)\n}\n\nexport function makePlaceholderElement(\n    wireframe: wireframe,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const txt = 'label' in wireframe && wireframe.label ? wireframe.label : wireframe.type || 'PLACEHOLDER'\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe, {\n                    verticalAlign: 'center',\n                    horizontalAlign: 'center',\n                    backgroundColor: wireframe.style?.backgroundColor || BACKGROUND,\n                    color: wireframe.style?.color || FOREGROUND,\n                    backgroundImage: PLACEHOLDER_SVG_DATA_IMAGE_URL,\n                    backgroundSize: 'auto',\n                    backgroundRepeat: 'unset',\n                    ...context.styleOverride,\n                }),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: [\n                {\n                    type: NodeType.Text,\n                    // since the text node is wrapped, we assign it a synthetic id\n                    id: context.idSequence.next().value,\n                    textContent: txt,\n                },\n                ...children,\n            ],\n        },\n        context,\n    }\n}\n\nexport function dataURIOrPNG(src: string): string {\n    // replace all new lines in src\n    src = src.replace(/\\r?\\n|\\r/g, '')\n    if (!src.startsWith('data:image/')) {\n        return 'data:image/png;base64,' + src\n    }\n    return src\n}\n\nfunction makeImageElement(\n    wireframe: wireframeImage | wireframeScreenshot,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (!wireframe.base64) {\n        return makePlaceholderElement(wireframe, children, context)\n    }\n\n    const src = dataURIOrPNG(wireframe.base64)\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'img',\n            attributes: {\n                src: src,\n                width: wireframe.width,\n                height: wireframe.height,\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction inputAttributes<T extends wireframeInputComponent>(wireframe: T): attributes {\n    const attributes = {\n        style: makeStylesString(wireframe),\n        type: wireframe.inputType,\n        ...(wireframe.disabled ? { disabled: wireframe.disabled } : {}),\n        'data-rrweb-id': wireframe.id,\n    }\n\n    switch (wireframe.inputType) {\n        case 'checkbox':\n            return {\n                ...attributes,\n                style: null, // checkboxes are styled by being combined with a label\n                ...(wireframe.checked ? { checked: wireframe.checked } : {}),\n            }\n        case 'toggle':\n            return {\n                ...attributes,\n                style: null, // toggle are styled by being combined with a label\n                ...(wireframe.checked ? { checked: wireframe.checked } : {}),\n            }\n        case 'radio':\n            return {\n                ...attributes,\n                style: null, // radio buttons are styled by being combined with a label\n                ...(wireframe.checked ? { checked: wireframe.checked } : {}),\n                // radio value defaults to the string \"on\" if not specified\n                // we're not really submitting the form, so it doesn't matter 🤞\n                // radio name is used to correctly uncheck values when one is checked\n                // mobile doesn't really have it, and we will be checking based on snapshots,\n                // so we can ignore it for now\n            }\n        case 'button':\n            return {\n                ...attributes,\n            }\n        case 'text_area':\n            return {\n                ...attributes,\n                value: wireframe.value || '',\n            }\n        case 'progress':\n            return {\n                ...attributes,\n                // indeterminate when omitted\n                value: wireframe.value || null,\n                // defaults to 1 when omitted\n                max: wireframe.max || null,\n                type: null, // progress has no type attribute\n            }\n        default:\n            return {\n                ...attributes,\n                value: wireframe.value || '',\n            }\n    }\n}\n\nfunction makeButtonElement(\n    wireframe: wireframeButton,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const buttonText: textNode | null = wireframe.value\n        ? {\n              type: NodeType.Text,\n              textContent: wireframe.value,\n          }\n        : null\n\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'button',\n            attributes: inputAttributes(wireframe),\n            id: wireframe.id,\n            childNodes: buttonText ? [{ ...buttonText, id: context.idSequence.next().value }, ...children] : children,\n        },\n        context,\n    }\n}\n\nfunction makeSelectOptionElement(\n    option: string,\n    selected: boolean,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> {\n    const optionId = context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'option',\n            attributes: {\n                ...(selected ? { selected: selected } : {}),\n                'data-rrweb-id': optionId,\n            },\n            id: optionId,\n            childNodes: [\n                {\n                    type: NodeType.Text,\n                    textContent: option,\n                    id: context.idSequence.next().value,\n                },\n            ],\n        },\n        context,\n    }\n}\n\nfunction makeSelectElement(\n    wireframe: wireframeSelect,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const selectOptions: serializedNodeWithId[] = []\n    if (wireframe.options) {\n        let optionContext = context\n        for (let i = 0; i < wireframe.options.length; i++) {\n            const option = wireframe.options[i]\n            const conversion = makeSelectOptionElement(option, wireframe.value === option, optionContext)\n            selectOptions.push(conversion.result)\n            optionContext = conversion.context\n        }\n    }\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'select',\n            attributes: inputAttributes(wireframe),\n            id: wireframe.id,\n            childNodes: [...selectOptions, ...children],\n        },\n        context,\n    }\n}\n\nfunction groupRadioButtons(children: serializedNodeWithId[], radioGroupName: string): serializedNodeWithId[] {\n    return children.map((child) => {\n        if (child.type === NodeType.Element && child.tagName === 'input' && child.attributes.type === 'radio') {\n            return {\n                ...child,\n                attributes: {\n                    ...child.attributes,\n                    name: radioGroupName,\n                    'data-rrweb-id': child.id,\n                },\n            }\n        }\n        return child\n    })\n}\n\nfunction makeRadioGroupElement(\n    wireframe: wireframeRadioGroup,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const radioGroupName = 'radio_group_' + wireframe.id\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: groupRadioButtons(children, radioGroupName),\n        },\n        context,\n    }\n}\n\nfunction makeStar(title: string, path: string, context: ConversionContext): serializedNodeWithId {\n    const svgId = context.idSequence.next().value\n    const titleId = context.idSequence.next().value\n    const pathId = context.idSequence.next().value\n    return {\n        type: NodeType.Element,\n        tagName: 'svg',\n        isSVG: true,\n        attributes: {\n            style: asStyleString(['height: 100%', 'overflow-clip-margin: content-box', 'overflow:hidden']),\n            viewBox: '0 0 24 24',\n            fill: 'currentColor',\n            'data-rrweb-id': svgId,\n        },\n        id: svgId,\n        childNodes: [\n            {\n                type: NodeType.Element,\n                tagName: 'title',\n                isSVG: true,\n                attributes: {\n                    'data-rrweb-id': titleId,\n                },\n                id: titleId,\n                childNodes: [\n                    {\n                        type: NodeType.Text,\n                        textContent: title,\n                        id: context.idSequence.next().value,\n                    },\n                ],\n            },\n            {\n                type: NodeType.Element,\n                tagName: 'path',\n                isSVG: true,\n                attributes: {\n                    d: path,\n                    'data-rrweb-id': pathId,\n                },\n                id: pathId,\n                childNodes: [],\n            },\n        ],\n    }\n}\n\nfunction filledStar(context: ConversionContext): serializedNodeWithId {\n    return makeStar(\n        'filled star',\n        'M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z',\n        context\n    )\n}\n\nfunction halfStar(context: ConversionContext): serializedNodeWithId {\n    return makeStar(\n        'half-filled star',\n        'M12,15.4V6.1L13.71,10.13L18.09,10.5L14.77,13.39L15.76,17.67M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z',\n        context\n    )\n}\n\nfunction emptyStar(context: ConversionContext): serializedNodeWithId {\n    return makeStar(\n        'empty star',\n        'M12,15.39L8.24,17.66L9.23,13.38L5.91,10.5L10.29,10.13L12,6.09L13.71,10.13L18.09,10.5L14.77,13.38L15.76,17.66M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z',\n        context\n    )\n}\n\nfunction makeRatingBar(\n    wireframe: wireframeProgress,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    // max is the number of stars... and value is the number of stars to fill\n\n    // deliberate double equals, because we want to allow null and undefined\n    if (wireframe.value == null || wireframe.max == null) {\n        return makePlaceholderElement(wireframe, children, context)\n    }\n\n    const numberOfFilledStars = Math.floor(wireframe.value)\n    const numberOfHalfStars = wireframe.value - numberOfFilledStars > 0 ? 1 : 0\n    const numberOfEmptyStars = wireframe.max - numberOfFilledStars - numberOfHalfStars\n\n    const filledStars = Array(numberOfFilledStars)\n        .fill(undefined)\n        .map(() => filledStar(context))\n    const halfStars = Array(numberOfHalfStars)\n        .fill(undefined)\n        .map(() => halfStar(context))\n    const emptyStars = Array(numberOfEmptyStars)\n        .fill(undefined)\n        .map(() => emptyStar(context))\n\n    const ratingBarId = context.idSequence.next().value\n    const ratingBar = {\n        type: NodeType.Element,\n        tagName: 'div',\n        id: ratingBarId,\n        attributes: {\n            style: asStyleString([\n                makeColorStyles(wireframe),\n                'position: relative',\n                'display: flex',\n                'flex-direction: row',\n                'padding: 2px 4px',\n            ]),\n            'data-rrweb-id': ratingBarId,\n        },\n        childNodes: [...filledStars, ...halfStars, ...emptyStars],\n    } as serializedNodeWithId\n\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: [ratingBar, ...children],\n        },\n        context,\n    }\n}\n\nfunction makeProgressElement(\n    wireframe: wireframeProgress,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (wireframe.style?.bar === 'circular') {\n        // value needs to be expressed as a number between 0 and 100\n        const max = wireframe.max || 1\n        let value = wireframe.value || null\n        if (_isPositiveInteger(value) && value <= max) {\n            value = (value / max) * 100\n        } else {\n            value = null\n        }\n\n        const styleOverride = {\n            color: wireframe.style?.color || FOREGROUND,\n            backgroundColor: wireframe.style?.backgroundColor || BACKGROUND,\n        }\n\n        // if not _isPositiveInteger(value) then we render a spinner,\n        // so we need to add a style element with the spin keyframe\n        const stylingChildren: serializedNodeWithId[] = _isPositiveInteger(value)\n            ? []\n            : [\n                  {\n                      type: NodeType.Element,\n                      tagName: 'style',\n                      attributes: {\n                          type: 'text/css',\n                      },\n                      id: context.idSequence.next().value,\n                      childNodes: [\n                          {\n                              type: NodeType.Text,\n                              textContent: `@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`,\n                              id: context.idSequence.next().value,\n                          },\n                      ],\n                  },\n              ]\n\n        const wrappingDivId = context.idSequence.next().value\n        return {\n            result: {\n                type: NodeType.Element,\n                tagName: 'div',\n                attributes: {\n                    style: makeMinimalStyles(wireframe),\n                    'data-rrweb-id': wireframe.id,\n                },\n                id: wireframe.id,\n                childNodes: [\n                    {\n                        type: NodeType.Element,\n                        tagName: 'div',\n                        attributes: {\n                            // with no provided value we render a spinner\n                            style: _isPositiveInteger(value)\n                                ? makeDeterminateProgressStyles(wireframe, styleOverride)\n                                : makeIndeterminateProgressStyles(wireframe, styleOverride),\n                            'data-rrweb-id': wrappingDivId,\n                        },\n                        id: wrappingDivId,\n                        childNodes: stylingChildren,\n                    },\n                    ...children,\n                ],\n            },\n            context,\n        }\n    } else if (wireframe.style?.bar === 'rating') {\n        return makeRatingBar(wireframe, children, context)\n    }\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'progress',\n            attributes: inputAttributes(wireframe),\n            id: wireframe.id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction makeToggleParts(wireframe: wireframeToggle, context: ConversionContext): serializedNodeWithId[] {\n    const togglePosition = wireframe.checked ? 'right' : 'left'\n    const defaultColor = wireframe.checked ? '#1d4aff' : BACKGROUND\n    const sliderPartId = context.idSequence.next().value\n    const handlePartId = context.idSequence.next().value\n    return [\n        {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                'data-toggle-part': 'slider',\n                style: asStyleString([\n                    'position:absolute',\n                    'top:33%',\n                    'left:5%',\n                    'display:inline-block',\n                    'width:75%',\n                    'height:33%',\n                    'opacity: 0.2',\n                    'border-radius:7.5%',\n                    `background-color:${wireframe.style?.color || defaultColor}`,\n                ]),\n                'data-rrweb-id': sliderPartId,\n            },\n            id: sliderPartId,\n            childNodes: [],\n        },\n        {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                'data-toggle-part': 'handle',\n                style: asStyleString([\n                    'position:absolute',\n                    'top:1.5%',\n                    `${togglePosition}:5%`,\n                    'display:flex',\n                    'align-items:center',\n                    'justify-content:center',\n                    'width:40%',\n                    'height:75%',\n                    'cursor:inherit',\n                    'border-radius:50%',\n                    `background-color:${wireframe.style?.color || defaultColor}`,\n                    `border:2px solid ${wireframe.style?.borderColor || wireframe.style?.color || defaultColor}`,\n                ]),\n                'data-rrweb-id': handlePartId,\n            },\n            id: handlePartId,\n            childNodes: [],\n        },\n    ]\n}\n\nfunction makeToggleElement(\n    wireframe: wireframeToggle,\n    context: ConversionContext\n): ConversionResult<\n    elementNode & {\n        id: number\n    }\n> | null {\n    const isLabelled = 'label' in wireframe\n    const wrappingDivId = context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                // if labelled take up available space, otherwise use provided positioning\n                style: isLabelled ? asStyleString(['height:100%', 'flex:1']) : makePositionStyles(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: [\n                {\n                    type: NodeType.Element,\n                    tagName: 'div',\n                    attributes: {\n                        // relative position, fills parent\n                        style: asStyleString(['position:relative', 'width:100%', 'height:100%']),\n                        'data-rrweb-id': wrappingDivId,\n                    },\n                    id: wrappingDivId,\n                    childNodes: makeToggleParts(wireframe, context),\n                },\n            ],\n        },\n        context,\n    }\n}\n\nfunction makeLabelledInput(\n    wireframe: wireframeCheckBox | wireframeRadio | wireframeToggle,\n    theInputElement: serializedNodeWithId,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> {\n    const theLabel: serializedNodeWithId = {\n        type: NodeType.Text,\n        textContent: wireframe.label || '',\n        id: context.idSequence.next().value,\n    }\n\n    const orderedChildren = wireframe.inputType === 'toggle' ? [theLabel, theInputElement] : [theInputElement, theLabel]\n\n    const labelId = context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'label',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': labelId,\n            },\n            id: labelId,\n            childNodes: orderedChildren,\n        },\n        context,\n    }\n}\n\nfunction makeInputElement(\n    wireframe: wireframeInputComponent,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (!wireframe.inputType) {\n        return null\n    }\n\n    if (wireframe.inputType === 'button') {\n        return makeButtonElement(wireframe, children, context)\n    }\n\n    if (wireframe.inputType === 'select') {\n        return makeSelectElement(wireframe, children, context)\n    }\n\n    if (wireframe.inputType === 'progress') {\n        return makeProgressElement(wireframe, children, context)\n    }\n\n    const theInputElement: ConversionResult<serializedNodeWithId> | null =\n        wireframe.inputType === 'toggle'\n            ? makeToggleElement(wireframe, context)\n            : {\n                  result: {\n                      type: NodeType.Element,\n                      tagName: 'input',\n                      attributes: inputAttributes(wireframe),\n                      id: wireframe.id,\n                      childNodes: children,\n                  },\n                  context,\n              }\n\n    if (!theInputElement) {\n        return null\n    }\n\n    if ('label' in wireframe) {\n        return makeLabelledInput(wireframe, theInputElement.result, theInputElement.context)\n    }\n    // when labelled no styles are needed, when un-labelled as here - we add the styling in.\n    ;(theInputElement.result as elementNode).attributes.style = makeStylesString(wireframe)\n    return theInputElement\n}\n\nfunction makeRectangleElement(\n    wireframe: wireframeRectangle,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction chooseConverter<T extends wireframe>(\n    wireframe: T\n): (\n    wireframe: T,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n) => ConversionResult<serializedNodeWithId> | null {\n    // in theory type is always present\n    // but since this is coming over the wire we can't really be sure,\n    // and so we default to div\n    const converterType: MobileNodeType = wireframe.type || 'div'\n    const converterMapping: Record<\n        MobileNodeType,\n        (wireframe: T, children: serializedNodeWithId[]) => ConversionResult<serializedNodeWithId> | null\n    > = {\n        // KLUDGE: TS can't tell that the wireframe type of each function is safe based on the converter type\n        text: makeTextElement as any,\n        image: makeImageElement as any,\n        rectangle: makeRectangleElement as any,\n        div: makeDivElement as any,\n        input: makeInputElement as any,\n        radio_group: makeRadioGroupElement as any,\n        web_view: makeWebViewElement as any,\n        placeholder: makePlaceholderElement as any,\n        status_bar: makeStatusBar as any,\n        navigation_bar: makeNavigationBar as any,\n        screenshot: makeImageElement as any,\n    }\n    return converterMapping[converterType]\n}\n\nfunction convertWireframe(\n    wireframe: wireframe,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const children = convertWireframesFor(wireframe.childWireframes, context)\n    const converted = chooseConverter(wireframe)?.(wireframe, children.result, children.context)\n    return converted || null\n}\n\nfunction convertWireframesFor(\n    wireframes: wireframe[] | undefined,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId[]> {\n    if (!wireframes) {\n        return { result: [], context }\n    }\n\n    const result: serializedNodeWithId[] = []\n    for (const wireframe of wireframes) {\n        const converted = convertWireframe(wireframe, context)\n        if (converted) {\n            result.push(converted.result)\n            context = converted.context\n        }\n    }\n    return { result, context }\n}\n\nfunction isMobileIncrementalSnapshotEvent(x: unknown): x is MobileIncrementalSnapshotEvent {\n    const isIncrementalSnapshot = isObject(x) && 'type' in x && x.type === EventType.IncrementalSnapshot\n    if (!isIncrementalSnapshot) {\n        return false\n    }\n    const hasData = isObject(x) && 'data' in x\n    const data = hasData ? x.data : null\n\n    const hasMutationSource = isObject(data) && 'source' in data && data.source === IncrementalSource.Mutation\n\n    const adds = isObject(data) && 'adds' in data && Array.isArray(data.adds) ? data.adds : null\n    const updates = isObject(data) && 'updates' in data && Array.isArray(data.updates) ? data.updates : null\n\n    const hasUpdatedWireframe = !!updates && updates.length > 0 && isObject(updates[0]) && 'wireframe' in updates[0]\n    const hasAddedWireframe = !!adds && adds.length > 0 && isObject(adds[0]) && 'wireframe' in adds[0]\n\n    return hasMutationSource && (hasAddedWireframe || hasUpdatedWireframe)\n}\n\nfunction chooseParentId(nodeType: MobileNodeType, providedParentId: number): number {\n    return nodeType === 'screenshot' ? BODY_ID : providedParentId\n}\n\nfunction makeIncrementalAdd(add: MobileNodeMutation, context: ConversionContext): addedNodeMutation[] | null {\n    const converted = convertWireframe(add.wireframe, context)\n\n    if (!converted) {\n        return null\n    }\n\n    const addition: addedNodeMutation = {\n        parentId: chooseParentId(add.wireframe.type, add.parentId),\n        nextId: null,\n        node: converted.result,\n    }\n    const adds: addedNodeMutation[] = []\n    if (addition) {\n        const flattened = flattenMutationAdds(addition)\n        flattened.forEach((x) => adds.push(x))\n        return adds\n    }\n    return null\n}\n\n/**\n * When processing an update we remove the entire item, and then add it back in.\n */\nfunction makeIncrementalRemoveForUpdate(update: MobileNodeMutation): removedNodeMutation {\n    return {\n        parentId: chooseParentId(update.wireframe.type, update.parentId),\n        id: update.wireframe.id,\n    }\n}\n\nfunction isNode(x: unknown): x is serializedNodeWithId {\n    // KLUDGE: really we should check that x.type is valid, but we're safe enough already\n    return isObject(x) && 'type' in x && 'id' in x\n}\n\nfunction isNodeWithChildren(x: unknown): x is elementNode | documentNode {\n    return isNode(x) && 'childNodes' in x && Array.isArray(x.childNodes)\n}\n\n/**\n * when creating incremental adds we have to flatten the node tree structure\n * there's no point, then keeping those child nodes in place\n */\nfunction cloneWithoutChildren(converted: addedNodeMutation): addedNodeMutation {\n    const cloned = { ...converted }\n    const clonedNode: serializedNodeWithId = { ...converted.node }\n    if (isNodeWithChildren(clonedNode)) {\n        clonedNode.childNodes = []\n    }\n    cloned.node = clonedNode\n    return cloned\n}\n\nfunction flattenMutationAdds(converted: addedNodeMutation): addedNodeMutation[] {\n    const flattened: addedNodeMutation[] = []\n\n    flattened.push(cloneWithoutChildren(converted))\n\n    const node: unknown = converted.node\n    const newParentId = converted.node.id\n    if (isNodeWithChildren(node)) {\n        node.childNodes.forEach((child) => {\n            flattened.push(\n                cloneWithoutChildren({\n                    parentId: newParentId,\n                    nextId: null,\n                    node: child,\n                })\n            )\n            if (isNodeWithChildren(child)) {\n                flattened.push(...flattenMutationAdds({ parentId: newParentId, nextId: null, node: child }))\n            }\n        })\n    }\n    return flattened\n}\n\n/**\n * each update wireframe carries the entire tree because we don't want to diff on the client\n * that means that we might create multiple mutations for the same node\n * we only want to add it once, so we dedupe the mutations\n * the app guarantees that for a given ID that is present more than once in a single snapshot\n * every instance of that ID is identical\n * it might change in the next snapshot but for a single incremental snapshot there is one\n * and only one version of any given ID\n */\nfunction dedupeMutations<T extends addedNodeMutation | removedNodeMutation>(mutations: T[]): T[] {\n    // KLUDGE: it's slightly yucky to stringify everything but since synthetic nodes\n    // introduce a new id, we can't just compare the id\n    const seen = new Set<string>()\n\n    // in case later mutations are the ones we want to keep, we reverse the array\n    // this does help with the deduping, so, it's likely that the view for a single ID\n    // is not consistent over a snapshot, but it's cheap to reverse so :YOLO:\n    return mutations\n        .reverse()\n        .filter((mutation: addedNodeMutation | removedNodeMutation) => {\n            let toCompare: string\n            if (isRemovedNodeMutation(mutation)) {\n                toCompare = JSON.stringify(mutation)\n            } else {\n                // if this is a synthetic addition, then we need to ignore the id,\n                // since duplicates won't have duplicate ids\n                toCompare = JSON.stringify({\n                    ...mutation.node,\n                    id: 0,\n                })\n            }\n\n            if (seen.has(toCompare)) {\n                return false\n            }\n            seen.add(toCompare)\n            return true\n        })\n        .reverse()\n}\n\n/**\n * We want to ensure that any events don't use id = 0.\n * They must always represent a valid ID from the dom, so we swap in the body id when the id = 0.\n *\n * For \"removes\", we don't need to do anything, the id of the element to be removed remains valid. We won't try and remove other elements that we added during transformation in order to show that element.\n *\n * \"adds\" are converted from wireframes to nodes and converted to `incrementalSnapshotEvent.adds`\n *\n * \"updates\" are converted to a remove and an add.\n *\n */\nexport const makeIncrementalEvent = (\n    mobileEvent: (MobileIncrementalSnapshotEvent | incrementalSnapshotEvent) & {\n        timestamp: number\n        delay?: number\n    }\n): incrementalSnapshotEvent & {\n    timestamp: number\n    delay?: number\n} => {\n    const converted = mobileEvent as unknown as incrementalSnapshotEvent & {\n        timestamp: number\n        delay?: number\n    }\n    if ('id' in converted.data && converted.data.id === 0) {\n        converted.data.id = BODY_ID\n    }\n\n    if (isMobileIncrementalSnapshotEvent(mobileEvent)) {\n        const adds: addedNodeMutation[] = []\n        const removes: removedNodeMutation[] = mobileEvent.data.removes || []\n        if ('adds' in mobileEvent.data && Array.isArray(mobileEvent.data.adds)) {\n            const addsContext = {\n                timestamp: mobileEvent.timestamp,\n                idSequence: globalIdSequence,\n            }\n\n            mobileEvent.data.adds.forEach((add) => {\n                makeIncrementalAdd(add, addsContext)?.forEach((x) => adds.push(x))\n            })\n        }\n        if ('updates' in mobileEvent.data && Array.isArray(mobileEvent.data.updates)) {\n            const updatesContext = {\n                timestamp: mobileEvent.timestamp,\n                idSequence: globalIdSequence,\n            }\n            const updateAdditions: addedNodeMutation[] = []\n            mobileEvent.data.updates.forEach((update) => {\n                const removal = makeIncrementalRemoveForUpdate(update)\n                if (removal) {\n                    removes.push(removal)\n                }\n                makeIncrementalAdd(update, updatesContext)?.forEach((x) => updateAdditions.push(x))\n            })\n            dedupeMutations(updateAdditions).forEach((x) => adds.push(x))\n        }\n\n        converted.data = {\n            source: IncrementalSource.Mutation,\n            attributes: [],\n            texts: [],\n            adds: dedupeMutations(adds),\n            // TODO: this assumes that removes are processed before adds 🤞\n            removes: dedupeMutations(removes),\n        }\n    }\n\n    return converted\n}\n\nfunction makeKeyboardParent(): serializedNodeWithId {\n    return {\n        type: NodeType.Element,\n        tagName: 'div',\n        attributes: {\n            'data-render-reason': 'a fixed placeholder to contain the keyboard in the correct stacking position',\n            'data-rrweb-id': KEYBOARD_PARENT_ID,\n        },\n        id: KEYBOARD_PARENT_ID,\n        childNodes: [],\n    }\n}\n\nfunction makeStatusBarNode(\n    statusBar: wireframeStatusBar | undefined,\n    context: ConversionContext\n): serializedNodeWithId {\n    const childNodes = statusBar ? convertWireframesFor([statusBar], context).result : []\n    return {\n        type: NodeType.Element,\n        tagName: 'div',\n        attributes: {\n            'data-rrweb-id': STATUS_BAR_PARENT_ID,\n        },\n        id: STATUS_BAR_PARENT_ID,\n        childNodes,\n    }\n}\n\nfunction makeNavBarNode(\n    navigationBar: wireframeNavigationBar | undefined,\n    context: ConversionContext\n): serializedNodeWithId {\n    const childNodes = navigationBar ? convertWireframesFor([navigationBar], context).result : []\n    return {\n        type: NodeType.Element,\n        tagName: 'div',\n        attributes: {\n            'data-rrweb-id': NAVIGATION_BAR_PARENT_ID,\n        },\n        id: NAVIGATION_BAR_PARENT_ID,\n        childNodes,\n    }\n}\n\nfunction stripBarsFromWireframe(wireframe: wireframe): {\n    wireframe: wireframe | undefined\n    statusBar: wireframeStatusBar | undefined\n    navBar: wireframeNavigationBar | undefined\n} {\n    if (wireframe.type === 'status_bar') {\n        return { wireframe: undefined, statusBar: wireframe, navBar: undefined }\n    } else if (wireframe.type === 'navigation_bar') {\n        return { wireframe: undefined, statusBar: undefined, navBar: wireframe }\n    }\n    let statusBar: wireframeStatusBar | undefined\n    let navBar: wireframeNavigationBar | undefined\n    const wireframeToReturn: wireframe | undefined = { ...wireframe }\n    wireframeToReturn.childWireframes = []\n    for (const child of wireframe.childWireframes || []) {\n        const {\n            wireframe: childWireframe,\n            statusBar: childStatusBar,\n            navBar: childNavBar,\n        } = stripBarsFromWireframe(child)\n        statusBar = statusBar || childStatusBar\n        navBar = navBar || childNavBar\n        if (childWireframe) {\n            wireframeToReturn.childWireframes.push(childWireframe)\n        }\n    }\n    return { wireframe: wireframeToReturn, statusBar, navBar }\n}\n\n/**\n * We want to be able to place the status bar and navigation bar in the correct stacking order.\n * So, we lift them out of the tree, and return them separately.\n */\nexport function stripBarsFromWireframes(wireframes: wireframe[]): {\n    statusBar: wireframeStatusBar | undefined\n    navigationBar: wireframeNavigationBar | undefined\n    appNodes: wireframe[]\n} {\n    let statusBar: wireframeStatusBar | undefined\n    let navigationBar: wireframeNavigationBar | undefined\n    const copiedNodes: wireframe[] = []\n\n    wireframes.forEach((w) => {\n        const matches = stripBarsFromWireframe(w)\n        if (matches.statusBar) {\n            statusBar = matches.statusBar\n        }\n        if (matches.navBar) {\n            navigationBar = matches.navBar\n        }\n        if (matches.wireframe) {\n            copiedNodes.push(matches.wireframe)\n        }\n    })\n    return { statusBar, navigationBar, appNodes: copiedNodes }\n}\n\nexport const makeFullEvent = (\n    mobileEvent: MobileFullSnapshotEvent & {\n        timestamp: number\n        delay?: number\n    }\n): fullSnapshotEvent & {\n    timestamp: number\n    delay?: number\n} => {\n    // we can restart the id sequence on each full snapshot\n    globalIdSequence = ids()\n\n    if (!(isObject(mobileEvent.data) && 'wireframes' in mobileEvent.data)) {\n        return mobileEvent as unknown as fullSnapshotEvent & {\n            timestamp: number\n            delay?: number\n        }\n    }\n\n    const conversionContext = {\n        timestamp: mobileEvent.timestamp,\n        idSequence: globalIdSequence,\n    }\n\n    const { statusBar, navigationBar, appNodes } = stripBarsFromWireframes(mobileEvent.data.wireframes)\n\n    const nodeGroups = {\n        appNodes: convertWireframesFor(appNodes, conversionContext).result || [],\n        statusBarNode: makeStatusBarNode(statusBar, conversionContext),\n        navBarNode: makeNavBarNode(navigationBar, conversionContext),\n    }\n\n    return {\n        type: EventType.FullSnapshot,\n        timestamp: mobileEvent.timestamp,\n        data: {\n            node: {\n                type: NodeType.Document,\n                childNodes: [\n                    {\n                        type: NodeType.DocumentType,\n                        name: 'html',\n                        publicId: '',\n                        systemId: '',\n                        id: HTML_DOC_TYPE_ID,\n                    },\n                    {\n                        type: NodeType.Element,\n                        tagName: 'html',\n                        attributes: { style: makeHTMLStyles(), 'data-rrweb-id': HTML_ELEMENT_ID },\n                        id: HTML_ELEMENT_ID,\n                        childNodes: [\n                            {\n                                type: NodeType.Element,\n                                tagName: 'head',\n                                attributes: { 'data-rrweb-id': HEAD_ID },\n                                id: HEAD_ID,\n                                childNodes: [makeCSSReset(conversionContext)],\n                            },\n                            {\n                                type: NodeType.Element,\n                                tagName: 'body',\n                                attributes: { style: makeBodyStyles(), 'data-rrweb-id': BODY_ID },\n                                id: BODY_ID,\n                                childNodes: [\n                                    // in the order they should stack if they ever clash\n                                    // lower is higher in the stacking context\n                                    ...nodeGroups.appNodes,\n                                    makeKeyboardParent(),\n                                    nodeGroups.navBarNode,\n                                    nodeGroups.statusBarNode,\n                                ],\n                            },\n                        ],\n                    },\n                ],\n                id: DOCUMENT_ID,\n            },\n            initialOffset: {\n                top: 0,\n                left: 0,\n            },\n        },\n    }\n}\n\nfunction makeCSSReset(context: ConversionContext): serializedNodeWithId {\n    // we need to normalize CSS so browsers don't do unexpected things\n    return {\n        type: NodeType.Element,\n        tagName: 'style',\n        attributes: {\n            type: 'text/css',\n        },\n        id: context.idSequence.next().value,\n        childNodes: [\n            {\n                type: NodeType.Text,\n                textContent: `\n                    body {\n                      margin: unset;\n                    }\n                    input, button, select, textarea {\n                        font: inherit;\n                        margin: 0;\n                        padding: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        padding-block: 0 !important;\n                    }\n                    .input:focus {\n                        outline: none;\n                    }\n                    img {\n                      border-style: none;\n                    }\n                `,\n                id: context.idSequence.next().value,\n            },\n        ],\n    }\n}\n","import { customEvent, EventType, eventWithTime } from '@posthog/rrweb-types'\nimport { actions, beforeUnmount, connect, defaults, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { subscriptions } from 'kea-subscriptions'\nimport api from 'lib/api'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { Dayjs, dayjs } from 'lib/dayjs'\nimport { featureFlagLogic, FeatureFlagsSet } from 'lib/logic/featureFlagLogic'\nimport { chainToElements } from 'lib/utils/elements-chain'\nimport posthog from 'posthog-js'\nimport {\n    InspectorListItemAnnotationComment,\n    RecordingComment,\n} from 'scenes/session-recordings/player/inspector/playerInspectorLogic'\nimport {\n    parseEncodedSnapshots,\n    processAllSnapshots,\n    processAllSnapshotsRaw,\n} from 'scenes/session-recordings/player/snapshot-processing/process-all-snapshots'\nimport { keyForSource } from 'scenes/session-recordings/player/snapshot-processing/source-key'\nimport { teamLogic } from 'scenes/teamLogic'\n\nimport { annotationsModel } from '~/models/annotationsModel'\nimport { hogql, HogQLQueryString } from '~/queries/utils'\nimport {\n    AnnotationScope,\n    RecordingEventsFilters,\n    RecordingEventType,\n    RecordingSegment,\n    RecordingSnapshot,\n    SessionPlayerData,\n    SessionRecordingId,\n    SessionRecordingSnapshotParams,\n    SessionRecordingSnapshotSource,\n    SessionRecordingSnapshotSourceResponse,\n    SessionRecordingType,\n    SessionRecordingUsageType,\n    SnapshotSourceType,\n} from '~/types'\n\nimport { ExportedSessionRecordingFileV2, ExportedSessionType } from '../file-playback/types'\nimport { sessionRecordingEventUsageLogic } from '../sessionRecordingEventUsageLogic'\nimport type { sessionRecordingDataLogicType } from './sessionRecordingDataLogicType'\nimport { getHrefFromSnapshot, ViewportResolution } from './snapshot-processing/patch-meta-event'\nimport { createSegments, mapSnapshotsToWindowId } from './utils/segmenter'\n\nconst IS_TEST_MODE = process.env.NODE_ENV === 'test'\nconst TWENTY_FOUR_HOURS_IN_MS = 24 * 60 * 60 * 1000 // +- before and after start and end of a recording to query for session linked events.\nconst FIVE_MINUTES_IN_MS = 5 * 60 * 1000 // +- before and after start and end of a recording to query for events related by person.\nconst DEFAULT_REALTIME_POLLING_MILLIS = 3000\nconst DEFAULT_V2_POLLING_INTERVAL_MS = 10000\n\nexport interface SessionRecordingDataLogicProps {\n    sessionRecordingId: SessionRecordingId\n    // allows altering v1 polling interval in tests\n    realTimePollingIntervalMilliseconds?: number\n    // allows disabling polling for new sources in tests\n    blobV2PollingDisabled?: boolean\n    playerKey?: string\n}\n\nexport const sessionRecordingDataLogic = kea<sessionRecordingDataLogicType>([\n    path((key) => ['scenes', 'session-recordings', 'sessionRecordingDataLogic', key]),\n    props({} as SessionRecordingDataLogicProps),\n    key(({ sessionRecordingId }) => sessionRecordingId || 'no-session-recording-id'),\n    connect(() => ({\n        actions: [sessionRecordingEventUsageLogic, ['reportRecording']],\n        values: [\n            featureFlagLogic,\n            ['featureFlags'],\n            teamLogic,\n            ['currentTeam'],\n            annotationsModel,\n            ['annotations', 'annotationsLoading'],\n        ],\n    })),\n    defaults({\n        sessionPlayerMetaData: null as SessionRecordingType | null,\n    }),\n    actions({\n        setFilters: (filters: Partial<RecordingEventsFilters>) => ({ filters }),\n        loadRecordingMeta: true,\n        loadRecordingComments: true,\n        maybeLoadRecordingMeta: true,\n        loadSnapshots: true,\n        loadSnapshotSources: (breakpointLength?: number) => ({ breakpointLength }),\n        loadNextSnapshotSource: true,\n        loadSnapshotsForSource: (sources: Pick<SessionRecordingSnapshotSource, 'source' | 'blob_key'>[]) => ({\n            sources,\n        }),\n        loadEvents: true,\n        loadFullEventData: (event: RecordingEventType | RecordingEventType[]) => ({ event }),\n        markViewed: (delay?: number) => ({ delay }),\n        reportUsageIfFullyLoaded: true,\n        persistRecording: true,\n        maybePersistRecording: true,\n        pollRealtimeSnapshots: true,\n        stopRealtimePolling: true,\n        setTrackedWindow: (windowId: string | null) => ({ windowId }),\n        setWasMarkedViewed: (wasMarkedViewed: boolean) => ({ wasMarkedViewed }),\n    }),\n    reducers(() => ({\n        trackedWindow: [\n            null as string | null,\n            {\n                setTrackedWindow: (_, { windowId }) => windowId,\n            },\n        ],\n        filters: [\n            {} as Partial<RecordingEventsFilters>,\n            {\n                setFilters: (state, { filters }) => ({ ...state, ...filters }),\n            },\n        ],\n        isRealtimePolling: [\n            false as boolean,\n            {\n                pollRealtimeSnapshots: () => true,\n                stopRealtimePolling: () => false,\n            },\n        ],\n        isNotFound: [\n            false as boolean,\n            {\n                loadRecordingMeta: () => false,\n                loadRecordingMetaSuccess: () => false,\n                loadRecordingMetaFailure: () => true,\n            },\n        ],\n        snapshotsBySourceSuccessCount: [\n            0,\n            {\n                loadSnapshotsForSourceSuccess: (state) => state + 1,\n            },\n        ],\n        wasMarkedViewed: [\n            false as boolean,\n            {\n                setWasMarkedViewed: (_, { wasMarkedViewed }) => wasMarkedViewed,\n            },\n        ],\n    })),\n    loaders(({ values, props, cache }) => ({\n        sessionComments: {\n            loadRecordingComments: async (_, breakpoint) => {\n                const empty: RecordingComment[] = []\n                if (!props.sessionRecordingId) {\n                    return empty\n                }\n\n                const response = await api.notebooks.recordingComments(props.sessionRecordingId)\n                breakpoint()\n\n                return response.results || empty\n            },\n        },\n        sessionPlayerMetaData: {\n            loadRecordingMeta: async (_, breakpoint) => {\n                if (!props.sessionRecordingId) {\n                    return null\n                }\n\n                const response = await api.recordings.get(props.sessionRecordingId)\n                breakpoint()\n\n                return response\n            },\n\n            persistRecording: async (_, breakpoint) => {\n                if (!values.sessionPlayerMetaData) {\n                    return null\n                }\n                await breakpoint(100)\n                await api.recordings.persist(props.sessionRecordingId)\n\n                return {\n                    ...values.sessionPlayerMetaData,\n                    storage: 'object_storage_lts',\n                }\n            },\n        },\n        snapshotSources: [\n            null as SessionRecordingSnapshotSource[] | null,\n            {\n                loadSnapshotSources: async ({ breakpointLength }, breakpoint) => {\n                    if (breakpointLength) {\n                        await breakpoint(breakpointLength)\n                    }\n                    const blob_v2 = values.featureFlags[FEATURE_FLAGS.RECORDINGS_BLOBBY_V2_REPLAY]\n                    const response = await api.recordings.listSnapshotSources(props.sessionRecordingId, {\n                        blob_v2,\n                    })\n\n                    if (!response.sources) {\n                        return []\n                    }\n                    const anyBlobV2 = response.sources.some((s) => s.source === SnapshotSourceType.blob_v2)\n\n                    if (anyBlobV2) {\n                        return response.sources.filter((s) => s.source === SnapshotSourceType.blob_v2)\n                    }\n                    return response.sources.filter((s) => s.source !== SnapshotSourceType.blob_v2)\n                },\n            },\n        ],\n        snapshotsForSource: [\n            null as SessionRecordingSnapshotSourceResponse | null,\n            {\n                loadSnapshotsForSource: async ({ sources }, breakpoint) => {\n                    let params: SessionRecordingSnapshotParams\n\n                    if (sources.length > 1) {\n                        // they all have to be blob_v2\n                        if (sources.some((s) => s.source !== SnapshotSourceType.blob_v2)) {\n                            throw new Error('Unsupported source for multiple sources')\n                        }\n                        params = {\n                            source: 'blob_v2',\n                            // so the caller has to make sure these are in order!\n                            start_blob_key: sources[0].blob_key,\n                            end_blob_key: sources[sources.length - 1].blob_key,\n                        }\n                    } else {\n                        const source = sources[0]\n\n                        if (source.source === SnapshotSourceType.blob) {\n                            if (!source.blob_key) {\n                                throw new Error('Missing key')\n                            }\n                            params = { blob_key: source.blob_key, source: 'blob' }\n                        } else if (source.source === SnapshotSourceType.realtime) {\n                            params = { source: 'realtime' }\n                        } else if (source.source === SnapshotSourceType.blob_v2) {\n                            params = { source: 'blob_v2', blob_key: source.blob_key }\n                        } else if (source.source === SnapshotSourceType.file) {\n                            // no need to load a file source, it is already loaded\n                            return { source }\n                        } else {\n                            throw new Error(`Unsupported source: ${source.source}`)\n                        }\n                    }\n\n                    await breakpoint(1)\n\n                    const response = await api.recordings.getSnapshots(props.sessionRecordingId, params).catch((e) => {\n                        if (sources[0].source === 'realtime' && e.status === 404) {\n                            // Realtime source is not always available, so a 404 is expected\n                            return []\n                        }\n                        throw e\n                    })\n\n                    // sorting is very cheap for already sorted lists\n                    const parsedSnapshots = (await parseEncodedSnapshots(response, props.sessionRecordingId)).sort(\n                        (a, b) => a.timestamp - b.timestamp\n                    )\n                    // we store the data in the cache because we want to avoid copying this data as much as possible\n                    // and kea's immutability means we were copying all of the data on every snapshot call\n                    cache.snapshotsBySource = cache.snapshotsBySource || {}\n                    // it doesn't matter which source we use as the key, since we combine the snapshots anyway\n                    cache.snapshotsBySource[keyForSource(sources[0])] = { snapshots: parsedSnapshots }\n                    // but we do want to mark the sources as loaded\n                    sources.forEach((s) => {\n                        const k = keyForSource(s)\n                        // we just need something against each key so we don't load it again\n                        cache.snapshotsBySource[k] = cache.snapshotsBySource[k] || {}\n                        cache.snapshotsBySource[k].sourceLoaded = true\n                    })\n\n                    return { sources: sources }\n                },\n            },\n        ],\n        sessionEventsData: [\n            null as null | RecordingEventType[],\n            {\n                loadEvents: async () => {\n                    const { start, end, person } = values.sessionPlayerData\n\n                    if (!person || !start || !end) {\n                        return null\n                    }\n\n                    const sessionEventsQuery = hogql`\nSELECT uuid, event, timestamp, elements_chain, properties.$window_id, properties.$current_url, properties.$event_type, properties.$viewport_width, properties.$viewport_height, properties.$screen_name\nFROM events\nWHERE timestamp > ${start.subtract(TWENTY_FOUR_HOURS_IN_MS, 'ms')}\nAND timestamp < ${end.add(TWENTY_FOUR_HOURS_IN_MS, 'ms')}\nAND $session_id = ${props.sessionRecordingId}\nORDER BY timestamp ASC\nLIMIT 1000000`\n\n                    let relatedEventsQuery = hogql`\nSELECT uuid, event, timestamp, elements_chain, properties.$window_id, properties.$current_url, properties.$event_type\nFROM events\nWHERE timestamp > ${start.subtract(FIVE_MINUTES_IN_MS, 'ms')}\nAND timestamp < ${end.add(FIVE_MINUTES_IN_MS, 'ms')}\nAND (empty ($session_id) OR isNull($session_id))\nAND properties.$lib != 'web'`\n\n                    if (person?.uuid) {\n                        relatedEventsQuery = (relatedEventsQuery +\n                            hogql`\\nAND person_id = ${person.uuid}`) as HogQLQueryString\n                    }\n                    if (!person?.uuid && values.sessionPlayerMetaData?.distinct_id) {\n                        relatedEventsQuery = (relatedEventsQuery +\n                            hogql`\\nAND distinct_id = ${values.sessionPlayerMetaData.distinct_id}`) as HogQLQueryString\n                    }\n\n                    relatedEventsQuery = (relatedEventsQuery +\n                        hogql`\\nORDER BY timestamp ASC\\nLIMIT 1000000`) as HogQLQueryString\n\n                    const [sessionEvents, relatedEvents]: any[] = await Promise.all([\n                        // make one query for all events that are part of the session\n                        api.queryHogQL(sessionEventsQuery),\n                        // make a second for all events from that person,\n                        // not marked as part of the session\n                        // but in the same time range\n                        // these are probably e.g. backend events for the session\n                        // but with no session id\n                        // since posthog-js must always add session id we can also\n                        // take advantage of lib being materialized and further filter\n                        api.queryHogQL(relatedEventsQuery),\n                    ])\n\n                    return [...sessionEvents.results, ...relatedEvents.results].map(\n                        (event: any): RecordingEventType => {\n                            const currentUrl = event[5]\n                            // We use the pathname to simplify the UI - we build it here instead of fetching it to keep data usage small\n                            let pathname: string | undefined\n                            try {\n                                pathname = event[5] ? new URL(event[5]).pathname : undefined\n                            } catch {\n                                pathname = undefined\n                            }\n\n                            const viewportWidth = event.length > 7 ? event[7] : undefined\n                            const viewportHeight = event.length > 8 ? event[8] : undefined\n\n                            return {\n                                id: event[0],\n                                event: event[1],\n                                timestamp: event[2],\n                                elements: chainToElements(event[3]),\n                                properties: {\n                                    $window_id: event[4],\n                                    $current_url: currentUrl,\n                                    $event_type: event[6],\n                                    $pathname: pathname,\n                                    $viewport_width: viewportWidth,\n                                    $viewport_height: viewportHeight,\n                                    $screen_name: event.length > 9 ? event[9] : undefined,\n                                },\n                                playerTime: +dayjs(event[2]) - +start,\n                                fullyLoaded: false,\n                            }\n                        }\n                    )\n                },\n\n                loadFullEventData: async ({ event }) => {\n                    // box so we're always dealing with a list\n                    const events = Array.isArray(event) ? event : [event]\n\n                    let existingEvents = values.sessionEventsData?.filter((x) => events.some((e) => e.id === x.id))\n\n                    const allEventsAreFullyLoaded =\n                        existingEvents?.every((e) => e.fullyLoaded) && existingEvents.length === events.length\n                    if (!existingEvents || allEventsAreFullyLoaded) {\n                        return values.sessionEventsData\n                    }\n\n                    existingEvents = existingEvents.filter((e) => !e.fullyLoaded)\n                    const timestamps = existingEvents.map((ee) => dayjs(ee.timestamp).utc().valueOf())\n                    const eventNames = Array.from(new Set(existingEvents.map((ee) => ee.event)))\n                    const eventIds = existingEvents.map((ee) => ee.id)\n                    const earliestTimestamp = timestamps.reduce((a, b) => Math.min(a, b))\n                    const latestTimestamp = timestamps.reduce((a, b) => Math.max(a, b))\n\n                    try {\n                        const query = hogql`\n                            SELECT properties, uuid\n                            FROM events\n                            -- the timestamp range here is only to avoid querying too much of the events table\n                            -- we don't really care about the absolute value,\n                            -- but we do care about whether timezones have an odd impact\n                            -- so, we extend the range by a day on each side so that timezones don't cause issues\n                            WHERE timestamp > ${dayjs(earliestTimestamp).subtract(1, 'day')}\n                            AND timestamp < ${dayjs(latestTimestamp).add(1, 'day')}\n                            AND event in ${eventNames}\n                            AND uuid in ${eventIds}`\n\n                        const response = await api.queryHogQL(query)\n                        if (response.error) {\n                            throw new Error(response.error)\n                        }\n\n                        for (const event of existingEvents) {\n                            const result = response.results.find((x: any) => {\n                                return x[1] === event.id\n                            })\n\n                            if (result) {\n                                event.properties = JSON.parse(result[0])\n                                event.fullyLoaded = true\n                            }\n                        }\n                    } catch (e) {\n                        // NOTE: This is not ideal but should happen so rarely that it is tolerable.\n                        existingEvents.forEach((e) => (e.fullyLoaded = true))\n                        posthog.captureException(e, { feature: 'session-recording-load-full-event-data' })\n                    }\n\n                    // here we map the events list because we want the result to be a new instance to trigger downstream recalculation\n                    return !values.sessionEventsData\n                        ? values.sessionEventsData\n                        : values.sessionEventsData.map((x) => {\n                              const event = existingEvents?.find((ee) => ee.id === x.id)\n                              return event\n                                  ? ({\n                                        ...x,\n                                        properties: event.properties,\n                                        fullyLoaded: event.fullyLoaded,\n                                    } as RecordingEventType)\n                                  : x\n                          })\n                },\n            },\n        ],\n    })),\n    listeners(({ values, actions, cache, props }) => ({\n        loadSnapshots: () => {\n            // This kicks off the loading chain\n            if (!values.snapshotSourcesLoading) {\n                actions.loadSnapshotSources()\n            }\n        },\n        maybeLoadRecordingMeta: () => {\n            if (!values.sessionPlayerMetaDataLoading) {\n                actions.loadRecordingMeta()\n            }\n            if (!values.sessionCommentsLoading) {\n                actions.loadRecordingComments()\n            }\n        },\n        loadSnapshotSources: () => {\n            // We only load events once we actually start loading the recording\n            if (!values.sessionEventsData) {\n                actions.loadEvents()\n            }\n        },\n        loadRecordingMetaSuccess: () => {\n            actions.reportUsageIfFullyLoaded()\n        },\n\n        loadSnapshotSourcesSuccess: () => {\n            // When we receive the list of sources, we can kick off the loading chain\n            actions.loadNextSnapshotSource()\n        },\n\n        loadSnapshotsForSourceSuccess: ({ snapshotsForSource }) => {\n            const sources = values.snapshotSources\n            const sourceKey = snapshotsForSource.sources\n                ? keyForSource(snapshotsForSource.sources[0])\n                : keyForSource(snapshotsForSource.source)\n            const snapshots = (cache.snapshotsBySource || {})[sourceKey] || []\n\n            // Cache the last response count to detect if we're getting the same data over and over\n            const newSnapshotsCount = snapshots.length\n\n            if ((cache.lastSnapshotsCount ?? newSnapshotsCount) === newSnapshotsCount) {\n                // if we're getting no results from realtime polling, we can increment faster\n                // so that we stop polling sooner\n                const increment = newSnapshotsCount === 0 ? 2 : 1\n                cache.lastSnapshotsUnchangedCount = (cache.lastSnapshotsUnchangedCount ?? 0) + increment\n            } else {\n                cache.lastSnapshotsUnchangedCount = 0\n            }\n            cache.lastSnapshotsCount = newSnapshotsCount\n\n            if (!snapshots.length && sources?.length === 1 && sources[0].source !== SnapshotSourceType.file) {\n                // We got only a single source to load, loaded it successfully, but it had no snapshots.\n                posthog.capture('recording_snapshots_v2_empty_response', {\n                    source: sources[0],\n                })\n            }\n            if (!values.wasMarkedViewed) {\n                actions.markViewed()\n            }\n\n            actions.loadNextSnapshotSource()\n        },\n\n        loadNextSnapshotSource: () => {\n            // yes this is ugly duplication but we're going to deprecate v1 and I want it to be clear which is which\n            if (values.snapshotSources?.some((s) => s.source === SnapshotSourceType.blob_v2)) {\n                const nextSourcesToLoad =\n                    values.snapshotSources?.filter((s) => {\n                        const sourceKey = keyForSource(s)\n                        return (\n                            !cache.snapshotsBySource?.[sourceKey]?.sourceLoaded && s.source !== SnapshotSourceType.file\n                        )\n                    }) || []\n\n                if (nextSourcesToLoad.length > 0) {\n                    return actions.loadSnapshotsForSource(nextSourcesToLoad.slice(0, 30))\n                }\n\n                if (!props.blobV2PollingDisabled) {\n                    actions.loadSnapshotSources(DEFAULT_V2_POLLING_INTERVAL_MS)\n                }\n            } else {\n                const nextSourceToLoad = values.snapshotSources?.find((s) => {\n                    const sourceKey = keyForSource(s)\n                    return !cache.snapshotsBySource?.[sourceKey]?.sourceLoaded && s.source !== SnapshotSourceType.file\n                })\n\n                if (nextSourceToLoad) {\n                    return actions.loadSnapshotsForSource([nextSourceToLoad])\n                }\n\n                // If we have a realtime source, start polling it\n                const realTimeSource = values.snapshotSources?.find((s) => s.source === SnapshotSourceType.realtime)\n                if (realTimeSource) {\n                    actions.pollRealtimeSnapshots()\n                }\n            }\n\n            actions.reportUsageIfFullyLoaded()\n        },\n        pollRealtimeSnapshots: () => {\n            // always make sure we've cleared up the last timeout\n            clearTimeout(cache.realTimePollingTimeoutID)\n            cache.realTimePollingTimeoutID = null\n\n            // ten is an arbitrary limit to try to avoid sending requests to our backend unnecessarily\n            // we could change this or add to it e.g. only poll if browser is visible to user\n            if ((cache.lastSnapshotsUnchangedCount ?? 0) <= 10) {\n                cache.realTimePollingTimeoutID = setTimeout(() => {\n                    actions.loadSnapshotsForSource([{ source: SnapshotSourceType.realtime }])\n                }, props.realTimePollingIntervalMilliseconds || DEFAULT_REALTIME_POLLING_MILLIS)\n            } else {\n                actions.stopRealtimePolling()\n            }\n        },\n        loadEventsSuccess: () => {\n            actions.reportUsageIfFullyLoaded()\n        },\n        reportUsageIfFullyLoaded: (_, breakpoint) => {\n            breakpoint()\n            if (values.fullyLoaded) {\n                actions.reportRecording(\n                    values.sessionPlayerData,\n                    SessionRecordingUsageType.LOADED,\n                    values.sessionPlayerMetaData,\n                    0\n                )\n            }\n        },\n        markViewed: async ({ delay }, breakpoint) => {\n            // Triggered on first paint\n            breakpoint()\n            if (props.playerKey?.startsWith('file-')) {\n                return\n            }\n            if (values.wasMarkedViewed) {\n                return\n            }\n            actions.setWasMarkedViewed(true) // this prevents us from calling the function multiple times\n\n            await breakpoint(IS_TEST_MODE ? 1 : delay ?? 3000)\n            await api.recordings.update(props.sessionRecordingId, {\n                viewed: true,\n                player_metadata: values.sessionPlayerMetaData,\n            })\n            await breakpoint(IS_TEST_MODE ? 1 : 10000)\n            await api.recordings.update(props.sessionRecordingId, {\n                analyzed: true,\n                player_metadata: values.sessionPlayerMetaData,\n            })\n        },\n\n        maybePersistRecording: () => {\n            if (values.sessionPlayerMetaDataLoading) {\n                return\n            }\n\n            if (values.sessionPlayerMetaData?.storage === 'object_storage') {\n                actions.persistRecording()\n            }\n        },\n    })),\n    selectors(({ cache }) => ({\n        sessionAnnotations: [\n            (s) => [s.annotations, s.start, s.end],\n            (annotations, start, end): InspectorListItemAnnotationComment[] => {\n                const allowedScopes = [AnnotationScope.Recording, AnnotationScope.Project, AnnotationScope.Organization]\n                const startValue = start?.valueOf()\n                const endValue = end?.valueOf()\n\n                const result: InspectorListItemAnnotationComment[] = []\n                for (const annotation of annotations) {\n                    if (!allowedScopes.includes(annotation.scope)) {\n                        continue\n                    }\n\n                    if (!annotation.date_marker || !startValue || !endValue || !annotation.content) {\n                        continue\n                    }\n\n                    const annotationTime = dayjs(annotation.date_marker).valueOf()\n                    if (annotationTime < startValue || annotationTime > endValue) {\n                        continue\n                    }\n\n                    result.push({\n                        type: 'comment',\n                        source: 'annotation',\n                        data: annotation,\n                        timestamp: dayjs(annotation.date_marker),\n                        timeInRecording: annotation.date_marker.valueOf() - startValue,\n                        search: annotation.content,\n                        highlightColor: 'primary',\n                    })\n                }\n\n                return result\n            },\n        ],\n        webVitalsEvents: [\n            (s) => [s.sessionEventsData],\n            (sessionEventsData): RecordingEventType[] =>\n                (sessionEventsData || []).filter((e) => e.event === '$web_vitals'),\n        ],\n        AIEvents: [\n            (s) => [s.sessionEventsData],\n            (sessionEventsData): RecordingEventType[] =>\n                // see if event start with $ai_\n                (sessionEventsData || []).filter((e) => e.event.startsWith('$ai_')),\n        ],\n        windowIdForTimestamp: [\n            (s) => [s.segments],\n            (segments) =>\n                (timestamp: number): string | undefined => {\n                    cache.windowIdForTimestamp = cache.windowIdForTimestamp || {}\n                    if (cache.windowIdForTimestamp[timestamp]) {\n                        return cache.windowIdForTimestamp[timestamp]\n                    }\n                    const matchingWindowId = segments.find(\n                        (segment) => segment.startTimestamp <= timestamp && segment.endTimestamp >= timestamp\n                    )?.windowId\n\n                    cache.windowIdForTimestamp[timestamp] = matchingWindowId\n                    return matchingWindowId\n                },\n        ],\n        eventViewports: [\n            (s) => [s.sessionEventsData],\n            (sessionEventsData): (ViewportResolution & { timestamp: string | number })[] =>\n                (sessionEventsData || [])\n                    .filter((e) => e.properties.$viewport_width && e.properties.$viewport_height)\n                    .map((e) => ({\n                        width: e.properties.$viewport_width,\n                        height: e.properties.$viewport_height,\n                        href: e.properties.$current_url,\n                        timestamp: e.timestamp,\n                    })),\n        ],\n        viewportForTimestamp: [\n            (s) => [s.eventViewports],\n            (eventViewports) =>\n                (timestamp: number): ViewportResolution | undefined => {\n                    // we do this as a function because in most recordings we don't need the data, so we don't need to run this every time\n\n                    cache.viewportForTimestamp = cache.viewportForTimestamp || {}\n                    if (cache.viewportForTimestamp[timestamp]) {\n                        return cache.viewportForTimestamp[timestamp]\n                    }\n\n                    let result: ViewportResolution | undefined\n\n                    // First, try to find the first event after the timestamp that has viewport dimensions\n                    const nextEvent = eventViewports\n                        .filter((e) => dayjs(e.timestamp).isSameOrAfter(dayjs(timestamp)))\n                        .sort((a, b) => dayjs(a.timestamp).valueOf() - dayjs(b.timestamp).valueOf())[0]\n\n                    if (nextEvent) {\n                        result = {\n                            width: nextEvent.width,\n                            height: nextEvent.height,\n                            href: nextEvent.href,\n                        }\n                    } else {\n                        // If no event after timestamp, find the closest event before it\n                        const previousEvent = eventViewports\n                            .filter((e) => dayjs(e.timestamp).isBefore(dayjs(timestamp)))\n                            .sort((a, b) => dayjs(b.timestamp).valueOf() - dayjs(a.timestamp).valueOf())[0] // Sort descending to get closest\n\n                        if (previousEvent) {\n                            result = {\n                                width: previousEvent.width,\n                                height: previousEvent.height,\n                                href: previousEvent.href,\n                            }\n                        }\n                    }\n\n                    if (result) {\n                        cache.viewportForTimestamp[timestamp] = result\n                    }\n\n                    return result\n                },\n        ],\n        sessionPlayerData: [\n            (s, p) => [\n                s.sessionPlayerMetaData,\n                s.snapshotsByWindowId,\n                s.segments,\n                s.bufferedToTime,\n                s.start,\n                s.end,\n                s.durationMs,\n                s.fullyLoaded,\n                p.sessionRecordingId,\n            ],\n            (\n                meta,\n                snapshotsByWindowId,\n                segments,\n                bufferedToTime,\n                start,\n                end,\n                durationMs,\n                fullyLoaded,\n                sessionRecordingId\n            ): SessionPlayerData => ({\n                person: meta?.person ?? null,\n                start,\n                end,\n                durationMs,\n                snapshotsByWindowId,\n                segments,\n                bufferedToTime,\n                fullyLoaded,\n                sessionRecordingId,\n            }),\n        ],\n\n        snapshotsLoading: [\n            (s) => [s.snapshotSourcesLoading, s.snapshotsForSourceLoading, s.snapshots, s.featureFlags],\n            (\n                snapshotSourcesLoading: boolean,\n                snapshotsForSourceLoading: boolean,\n                snapshots: RecordingSnapshot[],\n                featureFlags: FeatureFlagsSet\n            ): boolean => {\n                // For v2 recordings, only show loading if we have no snapshots yet\n                if (featureFlags[FEATURE_FLAGS.RECORDINGS_BLOBBY_V2_REPLAY]) {\n                    return snapshots.length === 0\n                }\n\n                // Default behavior for non-v2 recordings\n                // if there's a realTimePollingTimeoutID, don't signal that we're loading\n                // we don't want the UI to flip to \"loading\" every time we poll\n                return !cache.realTimePollingTimeoutID && (snapshotSourcesLoading || snapshotsForSourceLoading)\n            },\n        ],\n\n        snapshotsLoaded: [(s) => [s.snapshotSources], (snapshotSources): boolean => !!snapshotSources],\n\n        fullyLoaded: [\n            (s) => [s.snapshots, s.sessionPlayerMetaDataLoading, s.snapshotsLoading, s.sessionEventsDataLoading],\n            (snapshots, sessionPlayerMetaDataLoading, snapshotsLoading, sessionEventsDataLoading): boolean => {\n                // TODO: Do a proper check for all sources having been loaded\n                return (\n                    !!snapshots?.length &&\n                    !sessionPlayerMetaDataLoading &&\n                    !snapshotsLoading &&\n                    !sessionEventsDataLoading\n                )\n            },\n        ],\n\n        firstSnapshot: [\n            (s) => [s.snapshots],\n            (snapshots): RecordingSnapshot | null => {\n                return snapshots[0] || null\n            },\n        ],\n\n        lastSnapshot: [\n            (s) => [s.snapshots],\n            (snapshots): RecordingSnapshot | null => {\n                return snapshots[snapshots.length - 1] || null\n            },\n        ],\n\n        start: [\n            (s) => [s.firstSnapshot, s.sessionPlayerMetaData],\n            (firstSnapshot, meta): Dayjs | null => {\n                const eventStart = meta?.start_time ? dayjs(meta.start_time) : null\n                const snapshotStart = firstSnapshot ? dayjs(firstSnapshot.timestamp) : null\n\n                // whichever is earliest\n                if (eventStart && snapshotStart) {\n                    return eventStart.isBefore(snapshotStart) ? eventStart : snapshotStart\n                }\n                return eventStart || snapshotStart\n            },\n        ],\n\n        end: [\n            (s) => [s.lastSnapshot, s.sessionPlayerMetaData],\n            (lastSnapshot, meta): Dayjs | null => {\n                const eventEnd = meta?.end_time ? dayjs(meta.end_time) : null\n                const snapshotEnd = lastSnapshot ? dayjs(lastSnapshot.timestamp) : null\n\n                // whichever is latest\n                if (eventEnd && snapshotEnd) {\n                    return eventEnd.isAfter(snapshotEnd) ? eventEnd : snapshotEnd\n                }\n                return eventEnd || snapshotEnd\n            },\n        ],\n\n        durationMs: [\n            (s) => [s.start, s.end],\n            (start, end): number => {\n                return !!start && !!end ? end.diff(start) : 0\n            },\n        ],\n\n        segments: [\n            (s) => [s.snapshots, s.start, s.end, s.trackedWindow],\n            (snapshots, start, end, trackedWindow): RecordingSegment[] => {\n                return createSegments(snapshots || [], start, end, trackedWindow)\n            },\n        ],\n\n        urls: [\n            (s) => [s.snapshots],\n            (snapshots): { url: string; timestamp: number }[] => {\n                return (\n                    snapshots\n                        .filter((snapshot) => getHrefFromSnapshot(snapshot))\n                        .map((snapshot) => {\n                            return {\n                                url: getHrefFromSnapshot(snapshot) as string,\n                                timestamp: snapshot.timestamp,\n                            }\n                        }) ?? []\n                )\n            },\n        ],\n\n        snapshots: [\n            (s, p) => [\n                s.snapshotSources,\n                s.viewportForTimestamp,\n                p.sessionRecordingId,\n                s.snapshotsBySourceSuccessCount,\n            ],\n            (\n                sources,\n                viewportForTimestamp,\n                sessionRecordingId,\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                _snapshotsBySourceSuccessCount\n            ): RecordingSnapshot[] => {\n                if (!sources || !cache.snapshotsBySource) {\n                    return []\n                }\n                const processedSnapshots = processAllSnapshots(\n                    sources,\n                    cache.snapshotsBySource || {},\n                    viewportForTimestamp,\n                    sessionRecordingId\n                )\n                return processedSnapshots['processed'].snapshots || []\n            },\n        ],\n\n        snapshotsRaw: [\n            (s) => [s.snapshotSources, s.viewportForTimestamp],\n            (\n                sources,\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                _snapshotsBySourceSuccessCount\n            ): RecordingSnapshot[] => {\n                if (!sources || !cache.snapshotsBySource) {\n                    return []\n                }\n\n                const processedSnapshots = processAllSnapshotsRaw(sources, cache.snapshotsBySource || {})\n                return processedSnapshots || []\n            },\n        ],\n\n        snapshotsByWindowId: [\n            (s) => [s.snapshots],\n            (snapshots): Record<string, eventWithTime[]> => {\n                return mapSnapshotsToWindowId(snapshots || [])\n            },\n        ],\n\n        snapshotsInvalid: [\n            (s, p) => [s.snapshotsByWindowId, s.fullyLoaded, s.start, p.sessionRecordingId, s.currentTeam],\n            (snapshotsByWindowId, fullyLoaded, start, sessionRecordingId, currentTeam): boolean => {\n                if (!fullyLoaded || !start) {\n                    return false\n                }\n\n                const windowsHaveFullSnapshot = Object.entries(snapshotsByWindowId).reduce(\n                    (acc, [windowId, events]) => {\n                        acc[`window-id-${windowId}-has-full-snapshot`] = events.some(\n                            (event) => event.type === EventType.FullSnapshot\n                        )\n                        return acc\n                    },\n                    {}\n                )\n                const anyWindowMissingFullSnapshot = !Object.values(windowsHaveFullSnapshot).some((x) => x)\n                const everyWindowMissingFullSnapshot = !Object.values(windowsHaveFullSnapshot).every((x) => x)\n\n                if (everyWindowMissingFullSnapshot) {\n                    // video is definitely unplayable\n                    posthog.capture('recording_has_no_full_snapshot', {\n                        watchedSession: sessionRecordingId,\n                        teamId: currentTeam?.id,\n                        teamName: currentTeam?.name,\n                    })\n                } else if (anyWindowMissingFullSnapshot) {\n                    posthog.capture('recording_window_missing_full_snapshot', {\n                        watchedSession: sessionRecordingId,\n                        teamID: currentTeam?.id,\n                        teamName: currentTeam?.name,\n                    })\n                }\n\n                return everyWindowMissingFullSnapshot\n            },\n        ],\n\n        isRecentAndInvalid: [\n            (s) => [s.start, s.snapshotsInvalid],\n            (start, snapshotsInvalid) => {\n                const lessThanFiveMinutesOld = dayjs().diff(start, 'minute') <= 5\n                return snapshotsInvalid && lessThanFiveMinutesOld\n            },\n        ],\n\n        isLikelyPastTTL: [\n            (s) => [s.start, s.snapshotSources],\n            (start, snapshotSources) => {\n                // If the recording is older than 30 days and has only realtime sources being reported, it is likely past its TTL\n                const isOlderThan30Days = dayjs().diff(start, 'hour') > 30\n                const onlyHasRealTime = snapshotSources?.every((s) => s.source === SnapshotSourceType.realtime)\n                const hasNoSources = snapshotSources?.length === 0\n                return isOlderThan30Days && (onlyHasRealTime || hasNoSources)\n            },\n        ],\n\n        bufferedToTime: [\n            (s) => [s.segments],\n            (segments): number | null => {\n                if (!segments.length) {\n                    return null\n                }\n\n                const startTime = segments[0].startTimestamp\n                const lastSegment = segments[segments.length - 1]\n\n                if (lastSegment.kind === 'buffer') {\n                    return lastSegment.startTimestamp - startTime\n                }\n\n                return lastSegment.endTimestamp - startTime\n            },\n        ],\n\n        windowIds: [\n            (s) => [s.snapshotsByWindowId],\n            (snapshotsByWindowId) => {\n                return Object.keys(snapshotsByWindowId)\n            },\n        ],\n\n        createExportJSON: [\n            (s) => [s.sessionPlayerMetaData, s.snapshots],\n            (\n                sessionPlayerMetaData,\n                snapshots\n            ): ((type?: ExportedSessionType) => ExportedSessionRecordingFileV2 | RecordingSnapshot[]) => {\n                return (type?: ExportedSessionType) => {\n                    return type === 'rrweb'\n                        ? snapshots\n                        : {\n                              version: '2023-04-28',\n                              data: {\n                                  id: sessionPlayerMetaData?.id ?? '',\n                                  person: sessionPlayerMetaData?.person,\n                                  snapshots: snapshots,\n                              },\n                          }\n                }\n            },\n        ],\n\n        customRRWebEvents: [\n            (s) => [s.snapshots],\n            (snapshots): customEvent[] => {\n                return snapshots.filter((snapshot) => snapshot.type === EventType.Custom).map((x) => x as customEvent)\n            },\n        ],\n    })),\n    subscriptions(({ actions, values }) => ({\n        webVitalsEvents: (value: RecordingEventType[]) => {\n            // we preload all web vitals data, so it can be used before user interaction\n            if (!values.sessionEventsDataLoading) {\n                actions.loadFullEventData(value)\n            }\n        },\n        AIEvents: (value: RecordingEventType[]) => {\n            // we preload all AI  data, so it can be used before user interaction\n            if (value.length > 0) {\n                actions.loadFullEventData(value)\n            }\n        },\n        isRecentAndInvalid: (prev: boolean, next: boolean) => {\n            if (!prev && next) {\n                posthog.capture('recording cannot playback yet', {\n                    watchedSession: values.sessionPlayerData.sessionRecordingId,\n                })\n            }\n        },\n    })),\n    beforeUnmount(({ cache }) => {\n        // Clear the cache\n\n        if (cache.realTimePollingTimeoutID) {\n            clearTimeout(cache.realTimePollingTimeoutID)\n            cache.realTimePollingTimeoutID = undefined\n        }\n\n        cache.windowIdForTimestamp = undefined\n        cache.viewportForTimestamp = undefined\n        cache.snapshotsBySource = undefined\n    }),\n])\n","import { kea, key, path, props, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { combineUrl } from 'kea-router'\nimport { colonDelimitedDuration, reverseColonDelimitedDuration } from 'lib/utils'\nimport { urls } from 'scenes/urls'\n\nimport type { playerShareLogicType } from './playerShareLogicType'\n\nexport interface FormWithTime {\n    includeTime: boolean\n    time: string | null\n}\n\nfunction makePrivateLinkQueryParams(formWithTime: FormWithTime): Record<string, string | undefined> {\n    return {\n        t: formWithTime.includeTime ? `${reverseColonDelimitedDuration(formWithTime.time) || 0}` : undefined,\n    }\n}\n\nfunction makePrivateLink(id: string, formWithTime: FormWithTime): string {\n    return combineUrl(\n        urls.absolute(urls.currentProject(urls.replaySingle(id))),\n        makePrivateLinkQueryParams(formWithTime)\n    ).url\n}\n\nexport type PlayerShareLogicProps = {\n    seconds: number | null\n    id: string\n    shareType?: 'private' | 'public' | 'linear'\n}\n\nexport const playerShareLogic = kea<playerShareLogicType>([\n    path(() => ['scenes', 'session-recordings', 'player', 'playerShareLogic']),\n    props({} as PlayerShareLogicProps),\n    key((props: PlayerShareLogicProps) => `${props.id}-${props.seconds}`),\n\n    forms(({ props }) => ({\n        privateLinkForm: {\n            defaults: { includeTime: true, time: colonDelimitedDuration(props.seconds, null) } as FormWithTime,\n            errors: ({ time, includeTime }) => ({\n                time:\n                    time && includeTime && reverseColonDelimitedDuration(time || undefined) === null\n                        ? 'Set a valid time like 02:30 (minutes:seconds)'\n                        : undefined,\n            }),\n            options: {\n                // whether we show errors after touch (true) or submit (false)\n                showErrorsOnTouch: true,\n\n                // show errors even without submitting first\n                alwaysShowErrors: true,\n            },\n        },\n        linearLinkForm: {\n            defaults: {\n                includeTime: true,\n                time: colonDelimitedDuration(props.seconds, null),\n                issueTitle: '',\n                issueDescription: '',\n            } as FormWithTime & {\n                issueTitle: string\n                issueDescription: string\n            },\n            errors: ({ time, includeTime }) => ({\n                time:\n                    time && includeTime && reverseColonDelimitedDuration(time || undefined) === null\n                        ? 'Set a valid time like 02:30 (minutes:seconds)'\n                        : undefined,\n            }),\n            options: {\n                // whether we show errors after touch (true) or submit (false)\n                showErrorsOnTouch: true,\n\n                // show errors even without submitting first\n                alwaysShowErrors: true,\n            },\n        },\n    })),\n\n    selectors(({ props }) => ({\n        privateLinkUrlQueryParams: [\n            (s) => [s.privateLinkForm],\n            (privateLinkForm) => {\n                return makePrivateLinkQueryParams(privateLinkForm)\n            },\n        ],\n        privateLinkUrl: [\n            (s) => [s.privateLinkForm],\n            (privateLinkForm) => {\n                return makePrivateLink(props.id, privateLinkForm)\n            },\n        ],\n        linearQueryParams: [\n            (s) => [s.linearLinkForm],\n            (linearLinkForm) => {\n                return {\n                    title: linearLinkForm.issueTitle,\n                    description:\n                        linearLinkForm.issueDescription +\n                        `\\n\\nPostHog recording: ${makePrivateLink(props.id, linearLinkForm)}`,\n                }\n            },\n        ],\n        linearUrl: [\n            (s) => [s.linearQueryParams],\n            (linearQueryParams) => {\n                return combineUrl('https://linear.app/new', linearQueryParams).url\n            },\n        ],\n    })),\n])\n","import { actions, connect, kea, listeners, path, reducers } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { sessionRecordingEventUsageLogic } from 'scenes/session-recordings/sessionRecordingEventUsageLogic'\n\nimport { hogql } from '~/queries/utils'\nimport { CORE_FILTER_DEFINITIONS_BY_GROUP } from '~/taxonomy/taxonomy'\nimport { SessionRecordingPropertiesType, SessionRecordingType } from '~/types'\n\nimport type { sessionRecordingsListPropertiesLogicType } from './sessionRecordingsListPropertiesLogicType'\n// This logic is used to fetch properties for a list of recordings\n// It is used in a global way as the cached values can be re-used\nexport const sessionRecordingsListPropertiesLogic = kea<sessionRecordingsListPropertiesLogicType>([\n    path(() => ['scenes', 'session-recordings', 'playlist', 'sessionRecordingsListPropertiesLogic']),\n    connect(() => ({\n        actions: [sessionRecordingEventUsageLogic, ['reportRecordingsListPropertiesFetched']],\n    })),\n\n    actions({\n        loadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n        maybeLoadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n    }),\n\n    loaders(({ actions }) => ({\n        recordingProperties: [\n            [] as SessionRecordingPropertiesType[],\n            {\n                loadPropertiesForSessions: async ({ sessions }, breakpoint) => {\n                    await breakpoint(100)\n\n                    const startTime = performance.now()\n                    const sessionIds = sessions.map((x) => x.id)\n\n                    const oldestTimestamp = sessions.map((x) => x.start_time).sort()[0]\n                    const newestTimestamp = sessions.map((x) => x.end_time).sort()[sessions.length - 1]\n\n                    const query = hogql`\n                        SELECT \n                            $session_id as session_id, \n                            any(properties.$geoip_country_code) as $geoip_country_code, \n                            any(properties.$browser) as $browser, \n                            any(properties.$device_type) as $device_type, \n                            any(properties.$os) as $os, \n                            any(properties.$os_name) as $os_name,\n                            any(session.$entry_referring_domain) as $entry_referring_domain,\n                            any(properties.$geoip_subdivision_1_name) as $geoip_subdivision_1_name,\n                            any(properties.$geoip_city_name) as $geoip_city_name,\n                            any(session.$entry_current_url) as $entry_current_url\n                        FROM events\n                        WHERE event IN ${Object.keys(CORE_FILTER_DEFINITIONS_BY_GROUP['events'])}\n                        AND session_id IN ${sessionIds}\n                        -- the timestamp range here is only to avoid querying too much of the events table\n                        -- we don't really care about the absolute value, \n                        -- but we do care about whether timezones have an odd impact\n                        -- so, we extend the range by a day on each side so that timezones don't cause issues\n                        AND timestamp >= ${dayjs(oldestTimestamp).subtract(1, 'day')}\n                        AND timestamp <= ${dayjs(newestTimestamp).add(1, 'day')}\n                        GROUP BY session_id`\n\n                    const response = await api.queryHogQL(query)\n                    const loadTimeMs = performance.now() - startTime\n\n                    actions.reportRecordingsListPropertiesFetched(loadTimeMs)\n\n                    breakpoint()\n                    return (response.results || []).map((x: any): SessionRecordingPropertiesType => {\n                        return {\n                            id: x[0],\n                            properties: {\n                                $geoip_country_code: x[1],\n                                $browser: x[2],\n                                $device_type: x[3],\n                                $os: x[4],\n                                $os_name: x[5],\n                                $entry_referring_domain: x[6],\n                                $geoip_subdivision_1_name: x[7],\n                                $geoip_city_name: x[8],\n                                $entry_current_url: x[9],\n                            },\n                        }\n                    })\n                },\n            },\n        ],\n    })),\n\n    listeners(({ actions, values }) => ({\n        maybeLoadPropertiesForSessions: ({ sessions }) => {\n            const newSessions = sessions.filter((session) => !values.recordingPropertiesById[session.id])\n\n            if (newSessions.length > 0) {\n                actions.loadPropertiesForSessions(newSessions)\n            }\n        },\n    })),\n\n    reducers({\n        recordingPropertiesById: [\n            {} as Record<string, SessionRecordingPropertiesType['properties']>,\n            {\n                loadPropertiesForSessionsSuccess: (\n                    state,\n                    { recordingProperties }\n                ): Record<string, SessionRecordingPropertiesType['properties']> => {\n                    const newState = { ...state }\n                    recordingProperties.forEach((properties) => {\n                        if (properties.properties) {\n                            newState[properties.id] = properties.properties\n                        }\n                    })\n\n                    return newState\n                },\n            },\n        ],\n    }),\n])\n","import { IconEllipsis, IconInfo } from '@posthog/icons'\nimport {\n    LemonBanner,\n    LemonButton,\n    LemonDialog,\n    LemonInput,\n    LemonMenu,\n    LemonTable,\n    LemonTableColumns,\n    LemonTabs,\n    Spinner,\n    Tooltip,\n} from '@posthog/lemon-ui'\nimport clsx from 'clsx'\nimport { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { PayGateMini } from 'lib/components/PayGateMini/PayGateMini'\nimport { payGateMiniLogic } from 'lib/components/PayGateMini/payGateMiniLogic'\nimport { RestrictionScope, useRestrictedArea } from 'lib/components/RestrictedArea'\nimport { OrganizationMembershipLevel } from 'lib/constants'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonMarkdown } from 'lib/lemon-ui/LemonMarkdown'\n\nimport { AvailableFeature } from '~/types'\n\nimport { proxyLogic, ProxyRecord } from './proxyLogic'\n\nconst statusText = {\n    valid: 'live',\n    timed_out: 'timed out',\n}\n\nexport function ManagedReverseProxy(): JSX.Element {\n    const { formState, proxyRecords, proxyRecordsLoading } = useValues(proxyLogic)\n    const { showForm, deleteRecord } = useActions(proxyLogic)\n\n    const restrictionReason = useRestrictedArea({\n        minimumAccessLevel: OrganizationMembershipLevel.Admin,\n        scope: RestrictionScope.Organization,\n    })\n\n    const { featureAvailableOnOrg } = useValues(payGateMiniLogic({ feature: AvailableFeature.MANAGED_REVERSE_PROXY }))\n\n    const maxRecordsReached = proxyRecords.length >= (featureAvailableOnOrg?.limit || 0)\n\n    const recordsWithMessages = proxyRecords.filter((record) => !!record.message)\n\n    const columns: LemonTableColumns<ProxyRecord> = [\n        {\n            title: 'Domain',\n            dataIndex: 'domain',\n        },\n        {\n            title: 'Status',\n            dataIndex: 'status',\n            render: function RenderStatus(status) {\n                if (!status) {\n                    return <span>Unknown</span>\n                }\n\n                return (\n                    <div\n                        className={clsx(\n                            'deprecated-space-x-1',\n                            status === 'valid'\n                                ? 'text-success'\n                                : status == 'erroring'\n                                ? 'text-danger'\n                                : 'text-warning-dark'\n                        )}\n                    >\n                        {status === 'issuing' && <Spinner />}\n                        <span className=\"capitalize\">{statusText[status] || status}</span>\n                        {status === 'waiting' && (\n                            <Tooltip title=\"Waiting for DNS records to be created\">\n                                <IconInfo className=\"cursor-pointer\" />\n                            </Tooltip>\n                        )}\n                        {status === 'timed_out' && (\n                            <Tooltip title=\"Timed out waiting for DNS records to be created. Please delete the record and try again\">\n                                <IconInfo className=\"cursor-pointer\" />\n                            </Tooltip>\n                        )}\n                    </div>\n                )\n            },\n        },\n        {\n            title: <span className=\"h-5\" />,\n            width: 20,\n            className: 'flex justify-center',\n            render: function Render(_, { id, status }) {\n                return (\n                    status != 'deleting' &&\n                    !restrictionReason && (\n                        <LemonMenu\n                            items={[\n                                {\n                                    label: 'Delete',\n                                    status: 'danger',\n                                    onClick: () => {\n                                        LemonDialog.open({\n                                            title: 'Delete managed proxy',\n                                            width: '20rem',\n                                            content:\n                                                'Are you sure you want to delete this managed proxy? This cannot be undone and if it is in use then events sent to the domain will not be processed.',\n                                            primaryButton: {\n                                                status: 'danger',\n                                                onClick: () => deleteRecord(id),\n                                                children: 'Delete',\n                                            },\n                                            secondaryButton: {\n                                                children: 'Cancel',\n                                            },\n                                        })\n                                    },\n                                },\n                            ]}\n                        >\n                            <LemonButton size=\"small\" icon={<IconEllipsis className=\"text-secondary\" />} />\n                        </LemonMenu>\n                    )\n                )\n            },\n        },\n    ]\n\n    return (\n        <PayGateMini feature={AvailableFeature.MANAGED_REVERSE_PROXY}>\n            <div className=\"deprecated-space-y-2\">\n                {recordsWithMessages.map((r) => (\n                    <LemonBanner type=\"warning\" key={r.id}>\n                        <LemonMarkdown>{`**${r.domain}**\\n ${r.message}`}</LemonMarkdown>\n                    </LemonBanner>\n                ))}\n                <LemonTable\n                    loading={proxyRecords.length === 0 && proxyRecordsLoading}\n                    columns={columns}\n                    dataSource={proxyRecords}\n                    expandable={{\n                        expandedRowRender: (record) => <ExpandedRow record={record} />,\n                    }}\n                />\n                {formState === 'collapsed' ? (\n                    maxRecordsReached ? (\n                        <LemonBanner type=\"info\">\n                            There is a maximum of {featureAvailableOnOrg?.limit || 0} records allowed per organization.\n                        </LemonBanner>\n                    ) : (\n                        <div className=\"flex\">\n                            <LemonButton onClick={showForm} type=\"primary\" disabledReason={restrictionReason}>\n                                Add managed proxy\n                            </LemonButton>\n                        </div>\n                    )\n                ) : (\n                    <CreateRecordForm />\n                )}\n            </div>\n        </PayGateMini>\n    )\n}\n\nconst ExpandedRow = ({ record }: { record: ProxyRecord }): JSX.Element => {\n    return (\n        <div className=\"pb-4 pr-4\">\n            <LemonTabs\n                size=\"small\"\n                activeKey=\"cname\"\n                tabs={[\n                    {\n                        label: 'CNAME',\n                        key: 'cname',\n                        content: (\n                            <CodeSnippet key={record.id} language={Language.HTTP}>\n                                {record.target_cname}\n                            </CodeSnippet>\n                        ),\n                    },\n                ]}\n            />\n        </div>\n    )\n}\n\nfunction CreateRecordForm(): JSX.Element {\n    const { formState, proxyRecordsLoading, proxyRecords } = useValues(proxyLogic)\n    const { collapseForm } = useActions(proxyLogic)\n\n    const waitingRecords = proxyRecords.filter((r) => r.status === 'waiting')\n\n    return (\n        <div className=\"bg-surface-primary rounded border px-5 py-4 deprecated-space-y-2\">\n            {formState == 'active' ? (\n                <Form\n                    logic={proxyLogic}\n                    formKey=\"createRecord\"\n                    enableFormOnSubmit\n                    className=\"w-full deprecated-space-y-2\"\n                >\n                    <LemonField name=\"domain\">\n                        <LemonInput\n                            autoFocus\n                            placeholder=\"Enter a domain (e.g. ph.mydomain.com)\"\n                            data-attr=\"domain-input\"\n                        />\n                    </LemonField>\n                    <div className=\"flex justify-end gap-2\">\n                        <LemonButton\n                            type=\"secondary\"\n                            onClick={collapseForm}\n                            disabledReason={proxyRecordsLoading ? 'Saving' : undefined}\n                        >\n                            Cancel\n                        </LemonButton>\n                        <LemonButton\n                            htmlType=\"submit\"\n                            type=\"primary\"\n                            data-attr=\"domain-save\"\n                            loading={proxyRecordsLoading}\n                        >\n                            Add\n                        </LemonButton>\n                    </div>\n                </Form>\n            ) : (\n                <>\n                    <div className=\"text-xl font-semibold leading-tight\">Almost there</div>\n                    <div>\n                        You need to set the following <b>CNAME</b> records in your DNS provider:\n                    </div>\n                    {waitingRecords.map((r) => (\n                        <div key={r.id} className=\"deprecated-space-y-1\">\n                            <span className=\"font-semibold\">{r.domain}</span>\n                            <CodeSnippet key={r.id} language={Language.HTTP}>\n                                {r.target_cname}\n                            </CodeSnippet>\n                        </div>\n                    ))}\n                    <div className=\"flex justify-end\">\n                        <LemonButton onClick={collapseForm} type=\"primary\">\n                            Done\n                        </LemonButton>\n                    </div>\n                </>\n            )}\n        </div>\n    )\n}\n","import { Link } from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\nimport { CopyToClipboardInline } from 'lib/components/CopyToClipboard'\nimport { LemonBanner } from 'lib/lemon-ui/LemonBanner'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonInput } from 'lib/lemon-ui/LemonInput/LemonInput'\nimport { LemonModal } from 'lib/lemon-ui/LemonModal'\nimport { LemonTextArea } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\n\nimport { verifiedDomainsLogic } from './verifiedDomainsLogic'\n\nexport function ConfigureSAMLModal(): JSX.Element {\n    const { configureSAMLModalId, isSamlConfigSubmitting, samlConfig } = useValues(verifiedDomainsLogic)\n    const { setConfigureSAMLModalId } = useActions(verifiedDomainsLogic)\n    const { preflight } = useValues(preflightLogic)\n    const siteUrl = preflight?.site_url ?? window.location.origin\n\n    const samlReady = samlConfig.saml_acs_url && samlConfig.saml_entity_id && samlConfig.saml_x509_cert\n\n    const handleClose = (): void => {\n        setConfigureSAMLModalId(null)\n        // clean()\n    }\n\n    return (\n        <LemonModal onClose={handleClose} isOpen={!!configureSAMLModalId} title=\"\" simple>\n            <Form logic={verifiedDomainsLogic} formKey=\"samlConfig\" enableFormOnSubmit className=\"LemonModal__layout \">\n                <LemonModal.Header>\n                    <h3>Configure SAML authentication and provisioning</h3>\n                </LemonModal.Header>\n                <LemonModal.Content className=\"deprecated-space-y-2\">\n                    <p>\n                        <Link to=\"https://posthog.com/docs/data/sso#setting-up-saml\" target=\"_blank\" targetBlankIcon>\n                            Read the docs\n                        </Link>\n                    </p>\n                    <LemonField label=\"ACS Consumer URL\" name=\"_ACSConsumerUrl\">\n                        <CopyToClipboardInline>{`${siteUrl}/complete/saml/`}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField label=\"RelayState\" name=\"_RelayState\">\n                        <CopyToClipboardInline>{configureSAMLModalId || 'unknown'}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField label=\"Audience / Entity ID\" name=\"_Audience\">\n                        <CopyToClipboardInline>{siteUrl}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField name=\"saml_acs_url\" label=\"SAML ACS URL\">\n                        <LemonInput className=\"ph-ignore-input\" placeholder=\"Your IdP's ACS or single sign-on URL.\" />\n                    </LemonField>\n                    <LemonField name=\"saml_entity_id\" label=\"SAML Entity ID\">\n                        <LemonInput className=\"ph-ignore-input\" placeholder=\"Entity ID provided by your IdP.\" />\n                    </LemonField>\n                    <LemonField name=\"saml_x509_cert\" label=\"SAML X.509 Certificate\">\n                        <LemonTextArea\n                            className=\"ph-ignore-input\"\n                            minRows={10}\n                            placeholder={`Enter the public certificate of your IdP. Keep all line breaks.\\n-----BEGIN CERTIFICATE-----\\nMIICVjCCAb+gAwIBAgIBADANBgkqhkiG9w0BAQ0FADBIMQswCQYDVQQGEwJ1czEL\\n-----END CERTIFICATE-----`}\n                        />\n                    </LemonField>\n                    {!samlReady && (\n                        <LemonBanner type=\"info\">\n                            SAML will not be enabled unless you enter all attributes above. However you can still\n                            settings as draft.\n                        </LemonBanner>\n                    )}\n                </LemonModal.Content>\n                <LemonModal.Footer>\n                    <LemonButton loading={isSamlConfigSubmitting} type=\"primary\" htmlType=\"submit\">\n                        Save settings\n                    </LemonButton>\n                </LemonModal.Footer>\n            </Form>\n        </LemonModal>\n    )\n}\n","import { LemonButton, LemonDivider, LemonModal } from '@posthog/lemon-ui'\nimport { useValues } from 'kea'\nimport { router } from 'kea-router'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { IconOpenInNew } from 'lib/lemon-ui/icons'\nimport { SurveyQuestionType } from 'posthog-js'\nimport { surveyLogic } from 'scenes/surveys/surveyLogic'\nimport { urls } from 'scenes/urls'\n\nimport { Survey, SurveyEventName, SurveyEventProperties, SurveyQuestion } from '~/types'\n\nimport { buildPartialResponsesFilter, createAnswerFilterHogQLExpression } from './utils'\n\ninterface SurveySQLHelperProps {\n    isOpen: boolean\n    onClose: () => void\n}\n\nexport function SurveySQLHelper({ isOpen, onClose }: SurveySQLHelperProps): JSX.Element {\n    const { survey, answerFilters } = useValues(surveyLogic)\n\n    const filterConditions = createAnswerFilterHogQLExpression(answerFilters, survey as Survey)\n\n    const generateSingleQuestionQuery = (question: SurveyQuestion, index: number): string => {\n        return `SELECT\n    distinct_id,\n    getSurveyResponse(${index}, '${question.id}'${\n            question.type === SurveyQuestionType.MultipleChoice ? ', true' : ''\n        }) AS \"${question.question}\",\n    timestamp\nFROM\n    events\nWHERE\n    event = '${SurveyEventName.SENT}'\n    AND properties.${SurveyEventProperties.SURVEY_ID} = '${survey.id}'\n    ${buildPartialResponsesFilter(survey as Survey)}\n    ${filterConditions ? filterConditions : ''}\nORDER BY\n    timestamp DESC\nLIMIT\n    100`\n    }\n\n    const generateFullSurveyQuery = (): string => {\n        const questionSelects = survey.questions\n            .map((question: SurveyQuestion, index: number) => {\n                return `    getSurveyResponse(${index}, '${question.id}'${\n                    question.type === SurveyQuestionType.MultipleChoice ? ', true' : ''\n                }) AS \"${question.question}\"`\n            })\n            .join(',\\n')\n\n        return `SELECT\n    distinct_id,\n${questionSelects},\n    timestamp\nFROM\n    events\nWHERE\n    event = '${SurveyEventName.SENT}'\n    AND properties.${SurveyEventProperties.SURVEY_ID} = '${survey.id}'\n    ${buildPartialResponsesFilter(survey as Survey)}\n    ${filterConditions ? filterConditions : ''}\nORDER BY\n    timestamp DESC\nLIMIT\n    100`\n    }\n\n    // Function to open query in a new insight\n    const openInInsight = (query: string): void => {\n        router.actions.push(urls.sqlEditor(query))\n    }\n\n    return (\n        <LemonModal\n            isOpen={isOpen}\n            onClose={onClose}\n            title=\"SQL Query Helper\"\n            description={\n                <div className=\"flex flex-col gap-1 text-sm text-muted\">\n                    <p>\n                        <b>Important:</b> Since March 7, 2025, survey responses are stored using question IDs\n                        ([UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)) instead of indexes. The\n                        queries below handle both formats using the <code>coalesce</code> function.\n                    </p>\n                    <p>\n                        <b>Note:</b> These queries only include response filters set on the table. Additional property\n                        filters like cohorts, user properties, etc. are not included.\n                    </p>\n                </div>\n            }\n            width={800}\n        >\n            <div className=\"flex flex-col gap-2\">\n                <div className=\"flex flex-col gap-1\">\n                    <h4>Full Survey Query</h4>\n                    <p className=\"text-sm text-muted\">Returns all questions for this survey.</p>\n                    <CodeSnippet\n                        language={Language.SQL}\n                        compact\n                        actions={\n                            <LemonButton\n                                icon={<IconOpenInNew />}\n                                size=\"small\"\n                                onClick={() => openInInsight(generateFullSurveyQuery())}\n                                tooltip=\"Open as new insight\"\n                                noPadding\n                            />\n                        }\n                    >\n                        {generateFullSurveyQuery()}\n                    </CodeSnippet>\n                </div>\n\n                <LemonDivider />\n\n                <div className=\"flex flex-col gap-2\">\n                    <h4>Individual Question Queries</h4>\n                    <p className=\"text-sm text-muted\">Returns responses for individual questions.</p>\n\n                    <div className=\"flex flex-col gap-1\">\n                        {survey.questions.map((question: SurveyQuestion, index: number) => (\n                            <div key={question.id || index} className=\"flex flex-col gap-2\">\n                                <h5>{question.question}</h5>\n                                <CodeSnippet\n                                    language={Language.SQL}\n                                    compact\n                                    actions={\n                                        <LemonButton\n                                            icon={<IconOpenInNew />}\n                                            size=\"small\"\n                                            onClick={() => openInInsight(generateSingleQuestionQuery(question, index))}\n                                            tooltip=\"Open as new insight\"\n                                            noPadding\n                                        />\n                                    }\n                                >\n                                    {generateSingleQuestionQuery(question, index)}\n                                </CodeSnippet>\n                            </div>\n                        ))}\n                    </div>\n                </div>\n            </div>\n        </LemonModal>\n    )\n}\n","import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, afterMount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl, router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { dayjs } from 'lib/dayjs'\nimport { featureFlagLogic as enabledFlagLogic, FeatureFlagsSet } from 'lib/logic/featureFlagLogic'\nimport { allOperatorsMapping, dateStringToDayJs, debounce, hasFormErrors, isObject } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { Scene } from 'scenes/sceneTypes'\nimport {\n    branchingConfigToDropdownValue,\n    canQuestionHaveResponseBasedBranching,\n    createBranchingConfig,\n    getDefaultBranchingType,\n} from 'scenes/surveys/components/question-branching/utils'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { activationLogic, ActivationTask } from '~/layout/navigation-3000/sidepanel/panels/activation/activationLogic'\nimport { refreshTreeItem } from '~/layout/panel-layout/ProjectTree/projectTreeLogic'\nimport { MAX_SELECT_RETURNED_ROWS } from '~/queries/nodes/DataTable/DataTableExport'\nimport { CompareFilter, DataTableNode, InsightVizNode, NodeKind } from '~/queries/schema/schema-general'\nimport { HogQLQueryString } from '~/queries/utils'\nimport {\n    AnyPropertyFilter,\n    BaseMathType,\n    Breadcrumb,\n    EventPropertyFilter,\n    FeatureFlagFilters,\n    IntervalType,\n    MultipleSurveyQuestion,\n    ProjectTreeRef,\n    PropertyFilterType,\n    PropertyOperator,\n    RatingSurveyQuestion,\n    Survey,\n    SurveyEventName,\n    SurveyEventProperties,\n    SurveyEventStats,\n    SurveyMatchType,\n    SurveyQuestion,\n    SurveyQuestionBase,\n    SurveyQuestionBranchingType,\n    SurveyQuestionType,\n    SurveyRates,\n    SurveySchedule,\n    SurveyStats,\n} from '~/types'\n\nimport {\n    defaultSurveyAppearance,\n    defaultSurveyFieldValues,\n    NEW_SURVEY,\n    NewSurvey,\n    SURVEY_RATING_SCALE,\n} from './constants'\nimport type { surveyLogicType } from './surveyLogicType'\nimport { surveysLogic } from './surveysLogic'\nimport {\n    buildPartialResponsesFilter,\n    createAnswerFilterHogQLExpression,\n    DATE_FORMAT,\n    getResponseFieldWithId,\n    getSurveyEndDateForQuery,\n    getSurveyResponse,\n    getSurveyStartDateForQuery,\n    isSurveyRunning,\n    sanitizeSurvey,\n    sanitizeSurveyAppearance,\n    validateSurveyAppearance,\n} from './utils'\n\nexport type SurveyBaseStatTuple = [string, number, number, string | null, string | null] // [event_name, total_count, unique_persons, first_seen, last_seen]\nexport type SurveyBaseStatsResult = SurveyBaseStatTuple[] | null\nexport type DismissedAndSentCountResult = number | null\n\nconst DEFAULT_OPERATORS: Record<SurveyQuestionType, { label: string; value: PropertyOperator }> = {\n    [SurveyQuestionType.Open]: {\n        label: allOperatorsMapping[PropertyOperator.IContains],\n        value: PropertyOperator.IContains,\n    },\n    [SurveyQuestionType.Rating]: {\n        label: allOperatorsMapping[PropertyOperator.Exact],\n        value: PropertyOperator.Exact,\n    },\n    [SurveyQuestionType.SingleChoice]: {\n        label: allOperatorsMapping[PropertyOperator.Exact],\n        value: PropertyOperator.Exact,\n    },\n    [SurveyQuestionType.MultipleChoice]: {\n        label: allOperatorsMapping[PropertyOperator.IContains],\n        value: PropertyOperator.IContains,\n    },\n    [SurveyQuestionType.Link]: {\n        label: allOperatorsMapping[PropertyOperator.Exact],\n        value: PropertyOperator.Exact,\n    },\n}\n\nexport enum SurveyEditSection {\n    Steps = 'steps',\n    Widget = 'widget',\n    Presentation = 'presentation',\n    Appearance = 'appearance',\n    Customization = 'customization',\n    DisplayConditions = 'DisplayConditions',\n    Scheduling = 'scheduling',\n    CompletionConditions = 'CompletionConditions',\n}\nexport interface SurveyLogicProps {\n    /** Either a UUID or 'new'. */\n    id: string\n}\n\nexport interface SurveyMetricsQueries {\n    surveysShown: DataTableNode\n    surveysDismissed: DataTableNode\n}\n\nexport interface SurveyRatingResults {\n    [key: number]: {\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveyRecurringNPSResults {\n    [key: number]: {\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveySingleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveyMultipleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n    }\n}\n\nexport interface SurveyOpenTextResults {\n    [key: number]: {\n        events: { distinct_id: string; properties: Record<string, any>; personProperties: Record<string, any> }[]\n    }\n}\n\nexport interface QuestionResultsReady {\n    [key: string]: boolean\n}\n\nexport type DataCollectionType = 'until_stopped' | 'until_limit' | 'until_adaptive_limit'\n\nexport interface SurveyDateRange {\n    date_from: string | null\n    date_to: string | null\n}\n\nfunction duplicateExistingSurvey(survey: Survey | NewSurvey): Partial<Survey> {\n    return {\n        ...survey,\n        questions: survey.questions.map((question) => ({\n            ...question,\n            id: undefined,\n        })),\n        id: NEW_SURVEY.id,\n        name: `${survey.name} (copy)`,\n        archived: false,\n        start_date: null,\n        end_date: null,\n        targeting_flag_filters: survey.targeting_flag?.filters ?? NEW_SURVEY.targeting_flag_filters,\n        linked_flag_id: survey.linked_flag?.id ?? NEW_SURVEY.linked_flag_id,\n    }\n}\n\nexport interface ChoiceQuestionResponseData {\n    label: string\n    value: number\n    isPredefined: boolean\n}\n\nexport interface OpenQuestionResponseData {\n    distinctId: string\n    response: string\n    personProperties?: Record<string, any>\n}\n\nexport interface ChoiceQuestionProcessedResponses {\n    type: SurveyQuestionType.SingleChoice | SurveyQuestionType.Rating | SurveyQuestionType.MultipleChoice\n    data: ChoiceQuestionResponseData[]\n    totalResponses: number\n}\n\nexport interface OpenQuestionProcessedResponses {\n    type: SurveyQuestionType.Open\n    data: OpenQuestionResponseData[]\n    totalResponses: number\n}\n\nexport type QuestionProcessedResponses = ChoiceQuestionProcessedResponses | OpenQuestionProcessedResponses\n\ninterface ResponsesByQuestion {\n    [questionId: string]: QuestionProcessedResponses\n}\n\nexport interface ConsolidatedSurveyResults {\n    responsesByQuestion: {\n        [questionId: string]: QuestionProcessedResponses\n    }\n}\n\n/**\n * Raw survey response data from the SQL query.\n * Each SurveyResponseRow represents one user's complete response to all questions.\n *\n * Structure:\n * - response[questionIndex] contains the answer to that specific question\n * - For rating/single choice/open questions: response[questionIndex] is a string\n * - For multiple choice questions: response[questionIndex] is a string[]\n * - The last elements may contain metadata like person properties and distinct_id\n *\n * Example:\n * [\n *   [\"9\", [\"Customer case studies\"], \"Great product!\", \"user123\"],\n *   [\"7\", [\"Tutorials\", \"Other\"], \"Good but could improve\", \"user456\"]\n * ]\n */\nexport type SurveyResponseRow = Array<string | string[]>\nexport type SurveyRawResults = SurveyResponseRow[]\n\nfunction isEmptyOrUndefined(value: any): boolean {\n    return value === null || value === undefined || value === ''\n}\n\nfunction isQuestionOpenChoice(question: SurveyQuestion, choiceIndex: number): boolean {\n    if (question.type !== SurveyQuestionType.SingleChoice && question.type !== SurveyQuestionType.MultipleChoice) {\n        return false\n    }\n    return !!(choiceIndex === question.choices.length - 1 && question?.hasOpenChoice)\n}\n\n// Extract question processors into separate functions for better maintainability\nfunction processSingleChoiceQuestion(\n    question: MultipleSurveyQuestion,\n    questionIndex: number,\n    results: SurveyRawResults\n): ChoiceQuestionProcessedResponses {\n    const counts: { [key: string]: number } = {}\n    let total = 0\n\n    // Zero-fill predefined choices (excluding open choice)\n    question.choices?.forEach((choice: string, choiceIndex: number) => {\n        if (!isQuestionOpenChoice(question, choiceIndex)) {\n            counts[choice] = 0\n        }\n    })\n\n    // Count responses\n    results?.forEach((row: SurveyResponseRow) => {\n        const value = row[questionIndex] as string\n        if (!isEmptyOrUndefined(value)) {\n            counts[value] = (counts[value] || 0) + 1\n            total += 1\n        }\n    })\n\n    const data = Object.entries(counts)\n        .map(([label, value]) => ({\n            label,\n            value,\n            isPredefined: question.choices?.includes(label) ?? false,\n        }))\n        .sort((a, b) => b.value - a.value)\n\n    return {\n        type: SurveyQuestionType.SingleChoice,\n        data,\n        totalResponses: total,\n    }\n}\n\nfunction processRatingQuestion(\n    question: RatingSurveyQuestion,\n    questionIndex: number,\n    results: SurveyRawResults\n): ChoiceQuestionProcessedResponses {\n    const scaleSize = question.scale === SURVEY_RATING_SCALE.NPS_10_POINT ? 11 : question.scale\n    const counts = new Array(scaleSize).fill(0)\n    let total = 0\n\n    results?.forEach((row: SurveyResponseRow) => {\n        const value = row[questionIndex] as string\n        if (!isEmptyOrUndefined(value)) {\n            const parsedValue = parseInt(value, 10)\n            if (!isNaN(parsedValue)) {\n                let arrayIndex: number\n                let isValid = false\n\n                if (question.scale === SURVEY_RATING_SCALE.NPS_10_POINT) {\n                    // NPS scale: 0-10 (11 values)\n                    isValid = parsedValue >= 0 && parsedValue <= 10\n                    arrayIndex = parsedValue\n                } else {\n                    // Regular rating scales: 1-N (N values, but we use 0-based indexing)\n                    // For a 5-point scale, accept ratings 1-5 and map them to indices 0-4\n                    isValid = parsedValue >= 1 && parsedValue <= question.scale\n                    arrayIndex = parsedValue - 1 // Convert 1-based to 0-based\n                }\n\n                if (isValid) {\n                    counts[arrayIndex] += 1\n                    total += 1\n                }\n            }\n        }\n    })\n\n    const data = counts.map((count, index) => {\n        // For display labels:\n        // - NPS (scale 10): show 0-10\n        // - Regular scales: show 1-N (convert from 0-based index)\n        const label = question.scale === SURVEY_RATING_SCALE.NPS_10_POINT ? index.toString() : (index + 1).toString()\n\n        return {\n            label,\n            value: count,\n            isPredefined: true,\n        }\n    })\n\n    return {\n        type: SurveyQuestionType.Rating,\n        data,\n        totalResponses: total,\n    }\n}\n\nfunction processMultipleChoiceQuestion(\n    question: MultipleSurveyQuestion,\n    questionIndex: number,\n    results: SurveyRawResults\n): ChoiceQuestionProcessedResponses {\n    const counts: { [key: string]: number } = {}\n    let total = 0\n\n    // Zero-fill predefined choices (excluding open choice)\n    question.choices?.forEach((choice: string, choiceIndex: number) => {\n        if (!isQuestionOpenChoice(question, choiceIndex)) {\n            counts[choice] = 0\n        }\n    })\n\n    results?.forEach((row: SurveyResponseRow) => {\n        const value = row[questionIndex] as string[]\n        if (value !== null && value !== undefined) {\n            total += 1\n            value.forEach((choice) => {\n                const cleaned = choice.replace(/^['\"]+|['\"]+$/g, '')\n                if (!isEmptyOrUndefined(cleaned)) {\n                    counts[cleaned] = (counts[cleaned] || 0) + 1\n                }\n            })\n        }\n    })\n\n    const data = Object.entries(counts)\n        .map(([label, value]) => ({\n            label,\n            value,\n            isPredefined: question.choices?.includes(label) ?? false,\n        }))\n        .sort((a, b) => b.value - a.value)\n\n    return {\n        type: SurveyQuestionType.MultipleChoice,\n        data,\n        totalResponses: total,\n    }\n}\n\nfunction processOpenQuestion(questionIndex: number, results: SurveyRawResults): OpenQuestionProcessedResponses {\n    const data: { distinctId: string; response: string; personProperties?: Record<string, any> }[] = []\n    let totalResponses = 0\n\n    results?.forEach((row: SurveyResponseRow) => {\n        const value = row[questionIndex] as string\n        if (isEmptyOrUndefined(value)) {\n            return\n        }\n\n        const response = {\n            distinctId: row.at(-1) as string,\n            response: value,\n            personProperties: undefined as Record<string, any> | undefined,\n        }\n\n        const unparsedPersonProperties = row.at(-2)\n        if (unparsedPersonProperties && unparsedPersonProperties !== null) {\n            try {\n                response.personProperties = JSON.parse(unparsedPersonProperties as string)\n            } catch {\n                // Ignore parsing errors for person properties as there's no real action here\n                // It just means we won't show the person properties in the question visualization\n            }\n        }\n\n        totalResponses += 1\n        data.push(response)\n    })\n\n    return {\n        type: SurveyQuestionType.Open,\n        data,\n        totalResponses,\n    }\n}\n\nexport function processResultsForSurveyQuestions(\n    questions: SurveyQuestion[],\n    results: SurveyRawResults\n): ResponsesByQuestion {\n    const responsesByQuestion: ResponsesByQuestion = {}\n\n    questions.forEach((question, index) => {\n        // Skip questions without IDs or Link questions\n        if (!question.id || question.type === SurveyQuestionType.Link) {\n            return\n        }\n\n        let processedData: QuestionProcessedResponses\n\n        switch (question.type) {\n            case SurveyQuestionType.SingleChoice:\n                processedData = processSingleChoiceQuestion(question, index, results)\n                break\n            case SurveyQuestionType.Rating:\n                processedData = processRatingQuestion(question, index, results)\n                break\n            case SurveyQuestionType.MultipleChoice:\n                processedData = processMultipleChoiceQuestion(question, index, results)\n                break\n            case SurveyQuestionType.Open:\n                processedData = processOpenQuestion(index, results)\n                break\n            default:\n                // Skip unknown question types\n                return\n        }\n\n        responsesByQuestion[question.id] = processedData\n    })\n\n    return responsesByQuestion\n}\n\nexport const surveyLogic = kea<surveyLogicType>([\n    props({} as SurveyLogicProps),\n    key(({ id }) => id),\n    path((key) => ['scenes', 'surveys', 'surveyLogic', key]),\n    connect(() => ({\n        actions: [\n            surveysLogic,\n            ['loadSurveys'],\n            eventUsageLogic,\n            [\n                'reportSurveyCreated',\n                'reportSurveyEdited',\n                'reportSurveyArchived',\n                'reportSurveyViewed',\n                'reportSurveyCycleDetected',\n            ],\n        ],\n        values: [enabledFlagLogic, ['featureFlags as enabledFlags'], surveysLogic, ['data']],\n    })),\n    actions({\n        setSurveyMissing: true,\n        editingSurvey: (editing: boolean) => ({ editing }),\n        setDefaultForQuestionType: (\n            idx: number,\n            type: SurveyQuestionType,\n            isEditingQuestion: boolean,\n            isEditingDescription: boolean,\n            isEditingThankYouMessage: boolean\n        ) => ({\n            idx,\n            type,\n            isEditingQuestion,\n            isEditingDescription,\n            isEditingThankYouMessage,\n        }),\n        setQuestionBranchingType: (questionIndex, type, specificQuestionIndex) => ({\n            questionIndex,\n            type,\n            specificQuestionIndex,\n        }),\n        setResponseBasedBranchingForQuestion: (questionIndex, responseValue, nextStep, specificQuestionIndex) => ({\n            questionIndex,\n            responseValue,\n            nextStep,\n            specificQuestionIndex,\n        }),\n        setDataCollectionType: (dataCollectionType: DataCollectionType) => ({\n            dataCollectionType,\n        }),\n        resetBranchingForQuestion: (questionIndex) => ({ questionIndex }),\n        deleteBranchingLogic: true,\n        archiveSurvey: true,\n        setWritingHTMLDescription: (writingHTML: boolean) => ({ writingHTML }),\n        setSurveyTemplateValues: (template: Partial<NewSurvey>) => ({ template }),\n        setSelectedPageIndex: (idx: number | null) => ({ idx }),\n        setSelectedSection: (section: SurveyEditSection | null) => ({ section }),\n        resetTargeting: true,\n        resetSurveyAdaptiveSampling: true,\n        resetSurveyResponseLimits: true,\n        setFlagPropertyErrors: (errors: any) => ({ errors }),\n        setPropertyFilters: (propertyFilters: AnyPropertyFilter[]) => ({ propertyFilters }),\n        setAnswerFilters: (filters: EventPropertyFilter[], reloadResults: boolean = true) => ({\n            filters,\n            reloadResults,\n        }),\n        setDateRange: (dateRange: SurveyDateRange, reloadResults: boolean = true) => ({ dateRange, reloadResults }),\n        setInterval: (interval: IntervalType) => ({ interval }),\n        setCompareFilter: (compareFilter: CompareFilter) => ({ compareFilter }),\n        setFilterSurveyStatsByDistinctId: (filterByDistinctId: boolean) => ({ filterByDistinctId }),\n        setBaseStatsResults: (results: SurveyBaseStatsResult) => ({ results }),\n        setDismissedAndSentCount: (count: DismissedAndSentCountResult) => ({ count }),\n    }),\n    loaders(({ props, actions, values }) => ({\n        responseSummary: {\n            summarize: async ({ questionIndex, questionId }: { questionIndex?: number; questionId?: string }) => {\n                return api.surveys.summarize_responses(props.id, questionIndex, questionId)\n            },\n        },\n        survey: {\n            loadSurvey: async () => {\n                if (props.id && props.id !== 'new') {\n                    try {\n                        const survey = await api.surveys.get(props.id)\n                        const currentFilters = values.answerFilters\n                        actions.reportSurveyViewed(survey)\n                        // Initialize answer filters for all questions - first for index-based, then for id-based\n                        actions.setAnswerFilters(\n                            survey.questions.map((question) => {\n                                const { indexBasedKey, idBasedKey } = getResponseFieldWithId(0, question.id)\n                                const currentFilterForQuestion = currentFilters.find(\n                                    (filter) => filter.key === idBasedKey\n                                )\n                                return {\n                                    key: idBasedKey || indexBasedKey,\n                                    operator:\n                                        currentFilterForQuestion?.operator ?? DEFAULT_OPERATORS[question.type].value,\n                                    type: PropertyFilterType.Event as const,\n                                    value: currentFilterForQuestion?.value ?? [],\n                                }\n                            }),\n                            false\n                        )\n                        actions.setDateRange(\n                            {\n                                date_from: getSurveyStartDateForQuery(survey),\n                                date_to: getSurveyEndDateForQuery(survey),\n                            },\n                            false\n                        )\n                        return survey\n                    } catch (error: any) {\n                        if (error.status === 404) {\n                            actions.setSurveyMissing()\n                            return { ...NEW_SURVEY }\n                        }\n                        throw error\n                    }\n                }\n                if (props.id === 'new' && router.values.hashParams.fromTemplate) {\n                    const templatedSurvey = values.survey\n                    templatedSurvey.appearance = {\n                        ...defaultSurveyAppearance,\n                        ...teamLogic.values.currentTeam?.survey_config?.appearance,\n                        ...templatedSurvey.appearance,\n                    }\n                    return templatedSurvey\n                }\n\n                const newSurvey = NEW_SURVEY\n                newSurvey.appearance = {\n                    ...defaultSurveyAppearance,\n                    ...teamLogic.values.currentTeam?.survey_config?.appearance,\n                    ...newSurvey.appearance,\n                }\n\n                return newSurvey\n            },\n            createSurvey: async (surveyPayload: Partial<Survey>) => {\n                return await api.surveys.create(surveyPayload)\n            },\n            updateSurvey: async (surveyPayload: Partial<Survey>) => {\n                const response = await api.surveys.update(props.id, surveyPayload)\n                refreshTreeItem('survey', props.id)\n                return response\n            },\n            launchSurvey: async () => {\n                const startDate = dayjs()\n                return await api.surveys.update(props.id, { start_date: startDate.toISOString() })\n            },\n            stopSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: dayjs().toISOString() })\n            },\n            resumeSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: null })\n            },\n        },\n        duplicatedSurvey: {\n            duplicateSurvey: async () => {\n                const { survey } = values\n                const payload = duplicateExistingSurvey(survey)\n                const createdSurvey = await api.surveys.create(sanitizeSurvey(payload))\n\n                lemonToast.success('Survey duplicated.', {\n                    toastId: `survey-duplicated-${createdSurvey.id}`,\n                    button: {\n                        label: 'View Survey',\n                        action: () => {\n                            router.actions.push(urls.survey(createdSurvey.id))\n                        },\n                    },\n                })\n\n                actions.reportSurveyCreated(createdSurvey, true)\n                return survey\n            },\n        },\n        surveyBaseStats: {\n            loadSurveyBaseStats: async (): Promise<SurveyBaseStatsResult> => {\n                if (props.id === NEW_SURVEY.id || !values.survey?.start_date) {\n                    return null\n                }\n                // if we have answer filters, we need to apply them to the query for the 'survey sent' event only\n                const answerFilterCondition = values.answerFilterHogQLExpression\n                    ? values.answerFilterHogQLExpression.slice(4)\n                    : '1=1' // Use '1=1' for SQL TRUE\n\n                const query = `\n                    -- QUERYING BASE STATS\n                    SELECT\n                        event as event_name,\n                        count() as total_count,\n                        count(DISTINCT person_id) as unique_persons,\n                        if(count() > 0, min(timestamp), null) as first_seen,\n                        if(count() > 0, max(timestamp), null) as last_seen\n                    FROM events\n                    WHERE team_id = ${teamLogic.values.currentTeamId}\n                        AND event IN ('${SurveyEventName.SHOWN}', '${SurveyEventName.DISMISSED}', '${SurveyEventName.SENT}')\n                        AND properties.${SurveyEventProperties.SURVEY_ID} = '${props.id}'\n                        ${values.timestampFilter}\n                        AND {filters} -- Apply property filters here to the main query\n                        -- Main condition for handling partial responses and answer filters:\n                        AND (\n                            event != '${SurveyEventName.DISMISSED}'\n                            OR\n                            COALESCE(JSONExtractBool(properties, '${SurveyEventProperties.SURVEY_PARTIALLY_COMPLETED}'), False) = False\n                        )\n                        AND (\n                            -- Include non-'sent' events directly\n                            event != '${SurveyEventName.SENT}'\n                            OR\n                            -- Include 'sent' events only if they meet the outer query's answer filter AND are in the unique list (old or latest partial/complete)\n                            (\n                                (${answerFilterCondition}) -- Apply answer filters ONLY to 'sent' events in the outer query\n                                -- Check if the event's UUID is in the list generated by the subquery\n                                ${values.partialResponsesFilter}\n                            )\n                        )\n                    GROUP BY event` as HogQLQueryString\n\n                const response = await api.queryHogQL(query, {\n                    queryParams: {\n                        filters: {\n                            properties: values.propertyFilters,\n                        },\n                    },\n                })\n                actions.setBaseStatsResults(response.results as SurveyBaseStatsResult)\n                const numberOfSurveySentEvents = response.results?.find(\n                    (result) => result[0] === SurveyEventName.SENT\n                )?.[1]\n                actions.loadConsolidatedSurveyResults(numberOfSurveySentEvents)\n                return response.results as SurveyBaseStatsResult\n            },\n        },\n        surveyDismissedAndSentCount: {\n            loadSurveyDismissedAndSentCount: async (): Promise<DismissedAndSentCountResult> => {\n                if (props.id === NEW_SURVEY.id || !values.survey?.start_date) {\n                    return null\n                }\n                // if we have answer filters, we need to apply them to the query for the 'survey sent' event only\n                const answerFilterCondition =\n                    values.answerFilterHogQLExpression === ''\n                        ? '1=1' // Use '1=1' for SQL TRUE\n                        : values.answerFilterHogQLExpression.substring(4)\n\n                const query = `\n                    -- QUERYING DISMISSED AND SENT COUNT\n                    SELECT count()\n                    FROM (\n                        SELECT person_id\n                        FROM events\n                        WHERE team_id = ${teamLogic.values.currentTeamId}\n                            AND event IN ('${SurveyEventName.DISMISSED}', '${SurveyEventName.SENT}')\n                            AND properties.${SurveyEventProperties.SURVEY_ID} = '${props.id}'\n                            ${values.timestampFilter}\n                            AND (\n                            event != '${SurveyEventName.DISMISSED}'\n                            OR\n                            COALESCE(JSONExtractBool(properties, '${SurveyEventProperties.SURVEY_PARTIALLY_COMPLETED}'), False) = False\n                            )\n                            AND {filters} -- Apply property filters here to reduce initial events\n                        GROUP BY person_id\n                        HAVING sum(if(event = '${SurveyEventName.DISMISSED}', 1, 0)) > 0 -- Has at least one dismissed event (matching property filters)\n                            AND sum(if(event = '${SurveyEventName.SENT}' AND (${answerFilterCondition}), 1, 0)) > 0 -- Has at least one sent event matching BOTH property and answer filters\n                    ) AS PersonsWithBothEvents` as HogQLQueryString\n\n                const response = await api.queryHogQL(query, {\n                    queryParams: {\n                        filters: {\n                            properties: values.propertyFilters, // Property filters applied in WHERE\n                        },\n                    },\n                })\n                const count = response.results?.[0]?.[0] ?? 0\n                actions.setDismissedAndSentCount(count)\n                return count as DismissedAndSentCountResult\n            },\n        },\n        consolidatedSurveyResults: {\n            loadConsolidatedSurveyResults: async (\n                limit = MAX_SELECT_RETURNED_ROWS\n            ): Promise<ConsolidatedSurveyResults> => {\n                if (props.id === NEW_SURVEY.id || !values.survey?.start_date) {\n                    return { responsesByQuestion: {} }\n                }\n\n                // Build an array of all questions with their types\n                const questionFields = values.survey.questions.map((question, index) => {\n                    return `${getSurveyResponse(question, index)} AS q${index}_response`\n                })\n\n                // Also get distinct_id and person properties for open text questions\n                const query = `\n                    -- QUERYING ALL SURVEY RESPONSES IN ONE GO\n                    SELECT\n                        ${questionFields.join(',\\n')},\n                        person.properties,\n                        events.distinct_id\n                    FROM events\n                    WHERE event = '${SurveyEventName.SENT}'\n                        AND properties.${SurveyEventProperties.SURVEY_ID} = '${props.id}'\n                        ${values.timestampFilter}\n                        ${values.answerFilterHogQLExpression}\n                        ${values.partialResponsesFilter}\n                        AND {filters}\n                    ORDER BY events.timestamp DESC\n                    LIMIT ${limit}` as HogQLQueryString\n\n                const responseJSON = await api.queryHogQL(query, {\n                    queryParams: {\n                        filters: {\n                            properties: values.propertyFilters,\n                        },\n                    },\n                })\n                const { results } = responseJSON\n\n                // Process the results into a format that can be used by each question type\n                const responsesByQuestion = processResultsForSurveyQuestions(values.survey.questions, results)\n\n                return { responsesByQuestion }\n            },\n        },\n    })),\n    listeners(({ actions, values }) => {\n        const reloadAllSurveyResults = debounce((): void => {\n            // Load survey stats data\n            actions.loadSurveyBaseStats()\n            actions.loadSurveyDismissedAndSentCount()\n        }, 1000)\n\n        return {\n            createSurveySuccess: ({ survey }) => {\n                lemonToast.success(<>Survey {survey.name} created</>)\n                actions.loadSurveys()\n                router.actions.replace(urls.survey(survey.id))\n                actions.reportSurveyCreated(survey)\n            },\n            updateSurveySuccess: ({ survey }) => {\n                lemonToast.success(<>Survey {survey.name} updated</>)\n                actions.editingSurvey(false)\n                actions.reportSurveyEdited(survey)\n                actions.loadSurveys()\n            },\n            duplicateSurveySuccess: () => {\n                actions.loadSurveys()\n            },\n            launchSurveySuccess: ({ survey }) => {\n                lemonToast.success(<>Survey {survey.name} launched</>)\n                actions.loadSurveys()\n            },\n            stopSurveySuccess: () => {\n                actions.loadSurveys()\n            },\n            resumeSurveySuccess: () => {\n                actions.loadSurveys()\n            },\n            archiveSurvey: () => {\n                actions.updateSurvey({ archived: true })\n            },\n            loadSurveySuccess: () => {\n                // Trigger stats loading after survey loads\n                if (values.survey.id !== NEW_SURVEY.id && values.survey.start_date) {\n                    actions.loadSurveyBaseStats()\n                    actions.loadSurveyDismissedAndSentCount()\n                }\n\n                if (values.survey.start_date) {\n                    activationLogic.findMounted()?.actions.markTaskAsCompleted(ActivationTask.LaunchSurvey)\n                }\n            },\n            resetSurveyResponseLimits: () => {\n                actions.setSurveyValue('responses_limit', null)\n            },\n            resetSurveyAdaptiveSampling: () => {\n                actions.setSurveyValues({\n                    response_sampling_interval: null,\n                    response_sampling_interval_type: null,\n                    response_sampling_limit: null,\n                    response_sampling_start_date: null,\n                    response_sampling_daily_limits: null,\n                })\n            },\n            resetTargeting: () => {\n                actions.setSurveyValue('linked_flag_id', NEW_SURVEY.linked_flag_id)\n                actions.setSurveyValue('targeting_flag_filters', NEW_SURVEY.targeting_flag_filters)\n                actions.setSurveyValue('linked_flag', NEW_SURVEY.linked_flag)\n                actions.setSurveyValue('targeting_flag', NEW_SURVEY.targeting_flag)\n                actions.setSurveyValue('conditions', NEW_SURVEY.conditions)\n                actions.setSurveyValue('remove_targeting_flag', true)\n                actions.setSurveyValue('responses_limit', NEW_SURVEY.responses_limit)\n                actions.setSurveyValues({\n                    iteration_count: NEW_SURVEY.iteration_count,\n                    iteration_frequency_days: NEW_SURVEY.iteration_frequency_days,\n                })\n                actions.setFlagPropertyErrors(null)\n            },\n            submitSurveyFailure: async () => {\n                // When errors occur, scroll to the error, but wait for errors to be set in the DOM first\n                if (hasFormErrors(values.flagPropertyErrors) || values.urlMatchTypeValidationError) {\n                    actions.setSelectedSection(SurveyEditSection.DisplayConditions)\n                } else if (hasFormErrors(values.survey.appearance)) {\n                    actions.setSelectedSection(SurveyEditSection.Customization)\n                } else {\n                    actions.setSelectedSection(SurveyEditSection.Steps)\n                }\n                setTimeout(\n                    () =>\n                        document\n                            .querySelector(`.Field--error`)\n                            ?.scrollIntoView({ block: 'center', behavior: 'smooth' }),\n                    5\n                )\n            },\n            setPropertyFilters: () => {\n                reloadAllSurveyResults()\n            },\n            setAnswerFilters: ({ reloadResults }) => {\n                if (reloadResults) {\n                    reloadAllSurveyResults()\n                }\n            },\n            setDateRange: ({ reloadResults }) => {\n                if (reloadResults) {\n                    reloadAllSurveyResults()\n                }\n            },\n        }\n    }),\n    reducers({\n        filterSurveyStatsByDistinctId: [\n            true,\n            { persist: true },\n            {\n                setFilterSurveyStatsByDistinctId: (_, { filterByDistinctId }) => filterByDistinctId,\n            },\n        ],\n        isEditingSurvey: [\n            false,\n            {\n                editingSurvey: (_, { editing }) => editing,\n            },\n        ],\n        surveyMissing: [\n            false,\n            {\n                setSurveyMissing: () => true,\n            },\n        ],\n        dataCollectionType: [\n            'until_stopped' as DataCollectionType,\n            {\n                setDataCollectionType: (_, { dataCollectionType }) => dataCollectionType,\n            },\n        ],\n        propertyFilters: [\n            [] as AnyPropertyFilter[],\n            { persist: true },\n            {\n                setPropertyFilters: (_, { propertyFilters }) => propertyFilters,\n            },\n        ],\n        survey: [\n            { ...NEW_SURVEY } as NewSurvey | Survey,\n            {\n                setDefaultForQuestionType: (\n                    state,\n                    { idx, type, isEditingQuestion, isEditingDescription, isEditingThankYouMessage }\n                ) => {\n                    const question = isEditingQuestion\n                        ? state.questions[idx].question\n                        : defaultSurveyFieldValues[type].questions[0].question\n                    const description = isEditingDescription\n                        ? state.questions[idx].description\n                        : defaultSurveyFieldValues[type].questions[0].description\n                    const thankYouMessageHeader = isEditingThankYouMessage\n                        ? state.appearance?.thankYouMessageHeader\n                        : defaultSurveyFieldValues[type].appearance.thankYouMessageHeader\n                    const newQuestions = [...state.questions]\n                    newQuestions[idx] = {\n                        ...state.questions[idx],\n                        ...(defaultSurveyFieldValues[type].questions[0] as SurveyQuestionBase),\n                        question,\n                        description,\n                    }\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                        appearance: {\n                            ...state.appearance,\n                            ...defaultSurveyFieldValues[type].appearance,\n                            thankYouMessageHeader,\n                        },\n                    }\n                },\n                setSurveyTemplateValues: (_, { template }) => {\n                    const newTemplateSurvey = { ...NEW_SURVEY, ...template }\n                    return newTemplateSurvey\n                },\n                setQuestionBranchingType: (state, { questionIndex, type, specificQuestionIndex }) => {\n                    const newQuestions = [...state.questions]\n                    const question = newQuestions[questionIndex]\n\n                    // Validate response-based branching is only used with compatible question types\n                    if (\n                        type === SurveyQuestionBranchingType.ResponseBased &&\n                        !canQuestionHaveResponseBasedBranching(question)\n                    ) {\n                        question.branching = undefined\n                        lemonToast.error(\n                            <>\n                                Response-based branching is not supported for {question.type} questions. Removing\n                                branching logic from this question.\n                            </>\n                        )\n                    } else {\n                        // Use centralized branching config creation\n                        question.branching = createBranchingConfig(type, specificQuestionIndex)\n                    }\n\n                    newQuestions[questionIndex] = question\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n                setResponseBasedBranchingForQuestion: (\n                    state,\n                    { questionIndex, responseValue, nextStep, specificQuestionIndex }\n                ) => {\n                    const newQuestions = [...state.questions]\n                    const question = newQuestions[questionIndex]\n\n                    // Use centralized validation for response-based branching compatibility\n                    if (!canQuestionHaveResponseBasedBranching(question)) {\n                        throw new Error(\n                            `Survey question type must be ${SurveyQuestionType.Rating} or ${SurveyQuestionType.SingleChoice} for response-based branching`\n                        )\n                    }\n\n                    if (question.branching?.type !== SurveyQuestionBranchingType.ResponseBased) {\n                        throw new Error(\n                            `Survey question branching type must be ${SurveyQuestionBranchingType.ResponseBased}`\n                        )\n                    }\n\n                    if ('responseValues' in question.branching) {\n                        if (nextStep === SurveyQuestionBranchingType.NextQuestion) {\n                            // Remove the response mapping to default to next question\n                            delete question.branching.responseValues[responseValue]\n                        } else if (nextStep === SurveyQuestionBranchingType.End) {\n                            // Map response to end survey\n                            question.branching.responseValues[responseValue] = SurveyQuestionBranchingType.End\n                        } else if (nextStep === SurveyQuestionBranchingType.SpecificQuestion) {\n                            // Map response to specific question index\n                            question.branching.responseValues[responseValue] = specificQuestionIndex\n                        }\n                    }\n\n                    newQuestions[questionIndex] = question\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n                resetBranchingForQuestion: (state, { questionIndex }) => {\n                    const newQuestions = [...state.questions]\n                    const question = newQuestions[questionIndex]\n                    delete question.branching\n\n                    newQuestions[questionIndex] = question\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n                deleteBranchingLogic: (state) => {\n                    const newQuestions = [...state.questions]\n                    newQuestions.forEach((question) => {\n                        delete question.branching\n                    })\n\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n            },\n        ],\n        selectedPageIndex: [\n            0 as number | null,\n            {\n                setSelectedPageIndex: (_, { idx }) => idx,\n            },\n        ],\n        selectedSection: [\n            SurveyEditSection.Steps as SurveyEditSection | null,\n            {\n                setSelectedSection: (_, { section }) => section,\n            },\n        ],\n        writingHTMLDescription: [\n            false,\n            {\n                setWritingHTMLDescription: (_, { writingHTML }) => writingHTML,\n            },\n        ],\n        flagPropertyErrors: [\n            null as any,\n            {\n                setFlagPropertyErrors: (_, { errors }) => errors,\n            },\n        ],\n        answerFilters: [\n            [] as EventPropertyFilter[],\n            { persist: true },\n            {\n                setAnswerFilters: (_, { filters }) => filters,\n            },\n        ],\n        dateRange: [\n            null as SurveyDateRange | null,\n            {\n                setDateRange: (_, { dateRange }) => dateRange,\n            },\n        ],\n        interval: [\n            null as IntervalType | null,\n            {\n                setInterval: (_, { interval }) => interval,\n            },\n        ],\n        compareFilter: [\n            { compare: true } as CompareFilter,\n            {\n                setCompareFilter: (_, { compareFilter }) => compareFilter,\n            },\n        ],\n        surveyBaseStatsInternal: [\n            null as SurveyBaseStatsResult,\n            {\n                setBaseStatsResults: (_, { results }) => results,\n                loadSurveySuccess: () => null,\n                resetSurvey: () => null,\n            },\n        ],\n        surveyDismissedAndSentCountInternal: [\n            null as DismissedAndSentCountResult,\n            {\n                setDismissedAndSentCount: (_, { count }) => count,\n                loadSurveySuccess: () => null,\n                resetSurvey: () => null,\n            },\n        ],\n    }),\n    selectors({\n        timestampFilter: [\n            (s) => [s.survey, s.dateRange],\n            (survey: Survey, dateRange: SurveyDateRange): string => {\n                // If no date range provided, use the survey's default date range\n                if (!dateRange) {\n                    return `AND timestamp >= '${getSurveyStartDateForQuery(survey)}'\n                AND timestamp <= '${getSurveyEndDateForQuery(survey)}'`\n                }\n\n                // ----- Handle FROM date -----\n                // Parse the date string to a dayjs object\n                let fromDateDayjs = dateStringToDayJs(dateRange.date_from)\n\n                // Use survey creation date as lower bound if needed\n                const surveyStartDayjs = dayjs(getSurveyStartDateForQuery(survey))\n                if (surveyStartDayjs && fromDateDayjs && fromDateDayjs.isBefore(surveyStartDayjs)) {\n                    fromDateDayjs = surveyStartDayjs\n                }\n\n                // Fall back to survey start date if no valid from date\n                const fromDate = fromDateDayjs\n                    ? fromDateDayjs.utc().format(DATE_FORMAT)\n                    : getSurveyStartDateForQuery(survey)\n\n                // ----- Handle TO date -----\n                // Parse the date string or use current time\n                const toDateDayjs = dateStringToDayJs(dateRange.date_to) || dayjs()\n\n                // Use survey end date as upper bound if it exists\n                const toDate = survey.end_date\n                    ? getSurveyEndDateForQuery(survey)\n                    : toDateDayjs.utc().format(DATE_FORMAT)\n\n                return `AND timestamp >= '${fromDate}'\n                AND timestamp <= '${toDate}'`\n            },\n        ],\n        partialResponsesFilter: [\n            (s) => [s.survey],\n            (survey: Survey): string => {\n                if (survey.enable_partial_responses) {\n                    return buildPartialResponsesFilter(survey)\n                }\n                /**\n                 * Return only complete responses. For pre-partial responses, we didn't have the survey_completed property.\n                 * So we return all responses that don't have it.\n                 * For posthog-js > 1.240, we use the $survey_completed property.\n                 */\n                return `AND (\n                            NOT JSONHas(properties, '${SurveyEventProperties.SURVEY_COMPLETED}')\n                            OR JSONExtractBool(properties, '${SurveyEventProperties.SURVEY_COMPLETED}') = true\n                        )`\n            },\n        ],\n        isAdaptiveLimitFFEnabled: [\n            (s) => [s.enabledFlags],\n            (enabledFlags: FeatureFlagsSet): boolean => {\n                return !!enabledFlags[FEATURE_FLAGS.SURVEYS_ADAPTIVE_LIMITS]\n            },\n        ],\n        isAnyResultsLoading: [\n            (s) => [s.surveyBaseStatsLoading, s.surveyDismissedAndSentCountLoading, s.consolidatedSurveyResultsLoading],\n            (\n                surveyBaseStatsLoading: boolean,\n                surveyDismissedAndSentCountLoading: boolean,\n                consolidatedSurveyResultsLoading: boolean\n            ) => {\n                return consolidatedSurveyResultsLoading || surveyBaseStatsLoading || surveyDismissedAndSentCountLoading\n            },\n        ],\n        defaultAnswerFilters: [\n            (s) => [s.survey],\n            (survey: Survey): EventPropertyFilter[] => {\n                return survey.questions.map((question) => {\n                    const { indexBasedKey, idBasedKey } = getResponseFieldWithId(0, question.id)\n                    return {\n                        key: idBasedKey || indexBasedKey,\n                        operator: DEFAULT_OPERATORS[question.type].value,\n                        type: PropertyFilterType.Event as const,\n                        value: [],\n                    }\n                })\n            },\n        ],\n        isSurveyRunning: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return isSurveyRunning(survey)\n            },\n        ],\n        surveyUsesLimit: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(survey.responses_limit && survey.responses_limit > 0)\n            },\n        ],\n        surveyUsesAdaptiveLimit: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(\n                    survey.response_sampling_interval &&\n                    survey.response_sampling_interval > 0 &&\n                    survey.response_sampling_interval_type !== '' &&\n                    survey.response_sampling_limit &&\n                    survey.response_sampling_limit > 0\n                )\n            },\n        ],\n        surveyShufflingQuestionsAvailable: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return survey.questions.length > 1\n            },\n        ],\n        showSurveyRepeatSchedule: [(s) => [s.survey], (survey: Survey) => survey.schedule === SurveySchedule.Recurring],\n        descriptionContentType: [\n            (s) => [s.survey],\n            (survey: Survey) => (questionIndex: number) => {\n                return survey.questions[questionIndex].descriptionContentType\n            },\n        ],\n        surveyRepeatedActivationAvailable: [\n            (s) => [s.survey],\n            (survey: Survey): boolean =>\n                survey.conditions?.events?.values != undefined && survey.conditions?.events?.values?.length > 0,\n        ],\n        hasTargetingSet: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                const hasLinkedFlag =\n                    !!survey.linked_flag_id || (survey.linked_flag && Object.keys(survey.linked_flag).length > 0)\n                const hasTargetingFlag =\n                    (survey.targeting_flag && Object.keys(survey.targeting_flag).length > 0) ||\n                    (survey.targeting_flag_filters && Object.keys(survey.targeting_flag_filters).length > 0)\n                const hasOtherConditions = survey.conditions && Object.keys(survey.conditions).length > 0\n                return !!hasLinkedFlag || !!hasTargetingFlag || !!hasOtherConditions\n            },\n        ],\n        breadcrumbs: [\n            (s) => [s.survey],\n            (survey: Survey): Breadcrumb[] => [\n                {\n                    key: Scene.Surveys,\n                    name: 'Surveys',\n                    path: urls.surveys(),\n                },\n                { key: [Scene.Survey, survey?.id || 'new'], name: survey.name },\n            ],\n        ],\n        projectTreeRef: [\n            () => [(_, props: SurveyLogicProps) => props.id],\n            (id): ProjectTreeRef => {\n                return { type: 'survey', ref: id === 'new' ? null : String(id) }\n            },\n        ],\n        answerFilterHogQLExpression: [\n            (s) => [s.survey, s.answerFilters],\n            (survey: Survey, answerFilters: EventPropertyFilter[]): string => {\n                return createAnswerFilterHogQLExpression(answerFilters, survey)\n            },\n        ],\n        dataTableQuery: [\n            (s) => [s.survey, s.propertyFilters, s.answerFilterHogQLExpression, s.partialResponsesFilter, s.dateRange],\n            (\n                survey: Survey,\n                propertyFilters: AnyPropertyFilter[],\n                answerFilterHogQLExpression: string,\n                partialResponsesFilter: string,\n                dateRange: SurveyDateRange\n            ): DataTableNode | null => {\n                if (survey.id === 'new') {\n                    return null\n                }\n                const startDate = getSurveyStartDateForQuery(survey)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                const where = [`event == '${SurveyEventName.SENT}'`, partialResponsesFilter.replace(/^AND\\s+/, '')]\n\n                if (answerFilterHogQLExpression !== '') {\n                    // skip the 'AND ' prefix\n                    where.push(answerFilterHogQLExpression.substring(4))\n                }\n\n                return {\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.EventsQuery,\n                        select: [\n                            '*',\n                            ...survey.questions.map((q, i) => {\n                                if (q.type === SurveyQuestionType.MultipleChoice) {\n                                    return `arrayStringConcat(${getSurveyResponse(q, i)}, ', ') -- ${q.question}`\n                                }\n                                // Use the new condition that checks both formats\n                                return `${getSurveyResponse(q, i)} -- ${q.question}`\n                            }),\n                            'timestamp',\n                            'person',\n                            `coalesce(JSONExtractString(properties, '$lib_version')) -- Library Version`,\n                            `coalesce(JSONExtractString(properties, '$lib')) -- Library`,\n                            `coalesce(JSONExtractString(properties, '$current_url')) -- URL`,\n                        ],\n                        orderBy: ['timestamp DESC'],\n                        where,\n                        after: dateRange?.date_from || startDate,\n                        before: dateRange?.date_to || endDate,\n                        properties: [\n                            {\n                                type: PropertyFilterType.Event,\n                                key: SurveyEventProperties.SURVEY_ID,\n                                operator: PropertyOperator.Exact,\n                                value: survey.id,\n                            },\n                            ...propertyFilters,\n                        ],\n                    },\n                    propertiesViaUrl: true,\n                    showExport: true,\n                    showReload: true,\n                    showEventFilter: false,\n                    showPropertyFilter: false,\n                    showTimings: false,\n                }\n            },\n        ],\n        targetingFlagFilters: [\n            (s) => [s.survey],\n            (survey): FeatureFlagFilters | undefined => {\n                if (survey.targeting_flag_filters) {\n                    return {\n                        ...survey.targeting_flag_filters,\n                        groups: survey.targeting_flag_filters.groups,\n                        multivariate: null,\n                        payloads: {},\n                        super_groups: undefined,\n                    }\n                }\n                return survey.targeting_flag?.filters || undefined\n            },\n        ],\n        urlMatchTypeValidationError: [\n            (s) => [s.survey],\n            (survey): string | null => {\n                if (\n                    survey.conditions?.url &&\n                    [SurveyMatchType.Regex, SurveyMatchType.NotRegex].includes(\n                        survey.conditions?.urlMatchType || SurveyMatchType.Exact\n                    )\n                ) {\n                    try {\n                        new RegExp(survey.conditions.url)\n                    } catch (e: any) {\n                        return e.message\n                    }\n                }\n                return null\n            },\n        ],\n        deviceTypesMatchTypeValidationError: [\n            (s) => [s.survey],\n            (survey: Survey): string | null => {\n                if (\n                    survey.conditions?.deviceTypes &&\n                    [SurveyMatchType.Regex, SurveyMatchType.NotRegex].includes(\n                        survey.conditions?.deviceTypesMatchType || SurveyMatchType.Exact\n                    )\n                ) {\n                    try {\n                        new RegExp(survey.conditions.deviceTypes?.at(0) || '')\n                    } catch (e: any) {\n                        return e.message\n                    }\n                }\n                return null\n            },\n        ],\n        getBranchingDropdownValue: [\n            (s) => [s.survey],\n            (survey) => (questionIndex: number, question: SurveyQuestion) => {\n                if (question.branching?.type) {\n                    const { type } = question.branching\n\n                    if (type === SurveyQuestionBranchingType.SpecificQuestion) {\n                        const nextQuestionIndex = question.branching.index\n                        return branchingConfigToDropdownValue(type, nextQuestionIndex)\n                    }\n\n                    return type\n                }\n\n                // No branching specified, default to Next question / Confirmation message\n                return getDefaultBranchingType(questionIndex, survey.questions.length)\n            },\n        ],\n        getResponseBasedBranchingDropdownValue: [\n            (s) => [s.survey],\n            (survey) => (questionIndex: number, question: RatingSurveyQuestion | MultipleSurveyQuestion, response) => {\n                if (!question.branching || !('responseValues' in question.branching)) {\n                    return SurveyQuestionBranchingType.NextQuestion\n                }\n\n                // If a value is mapped onto an integer, we're redirecting to a specific question\n                if (Number.isInteger(question.branching.responseValues[response])) {\n                    const nextQuestionIndex = question.branching.responseValues[response]\n                    return `${SurveyQuestionBranchingType.SpecificQuestion}:${nextQuestionIndex}`\n                }\n\n                // If any other value is present (practically only Confirmation message), return that value\n                if (question.branching?.responseValues?.[response]) {\n                    return question.branching.responseValues[response]\n                }\n\n                // No branching specified, default to Next question / Confirmation message\n                if (questionIndex < survey.questions.length - 1) {\n                    return SurveyQuestionBranchingType.NextQuestion\n                }\n\n                return SurveyQuestionBranchingType.End\n            },\n        ],\n        hasCycle: [\n            (s) => [s.survey],\n            (survey) => {\n                const graph = new Map()\n                survey.questions.forEach((question, fromIndex: number) => {\n                    if (!graph.has(fromIndex)) {\n                        graph.set(fromIndex, new Set())\n                    }\n\n                    if (question.branching?.type === SurveyQuestionBranchingType.End) {\n                        return\n                    } else if (\n                        question.branching?.type === SurveyQuestionBranchingType.SpecificQuestion &&\n                        Number.isInteger(question.branching.index)\n                    ) {\n                        const toIndex = question.branching.index\n                        graph.get(fromIndex).add(toIndex)\n                        return\n                    } else if (\n                        question.branching?.type === SurveyQuestionBranchingType.ResponseBased &&\n                        isObject(question.branching?.responseValues)\n                    ) {\n                        for (const [_, toIndex] of Object.entries(question.branching?.responseValues)) {\n                            if (Number.isInteger(toIndex)) {\n                                graph.get(fromIndex).add(toIndex)\n                            }\n                        }\n                    }\n\n                    // No branching - still need to connect the next question\n                    if (fromIndex < survey.questions.length - 1) {\n                        const toIndex = fromIndex + 1\n                        graph.get(fromIndex).add(toIndex)\n                    }\n                })\n\n                let cycleDetected = false\n                function dfs(node: number, seen: number[]): void {\n                    if (cycleDetected) {\n                        return\n                    }\n\n                    for (const neighbor of graph.get(node) || []) {\n                        if (seen.includes(neighbor)) {\n                            cycleDetected = true\n                            return\n                        }\n                        dfs(neighbor, seen.concat(neighbor))\n                    }\n                }\n                dfs(0, [0])\n\n                return cycleDetected\n            },\n        ],\n        hasBranchingLogic: [\n            (s) => [s.survey],\n            (survey) =>\n                survey.questions.some((question) => question.branching && Object.keys(question.branching).length > 0),\n        ],\n        surveyAsInsightURL: [\n            (s) => [s.survey],\n            (survey) => {\n                const query: InsightVizNode = {\n                    kind: NodeKind.InsightVizNode,\n                    source: {\n                        kind: NodeKind.TrendsQuery,\n                        properties: [\n                            {\n                                key: SurveyEventProperties.SURVEY_ID,\n                                value: survey.id,\n                                operator: PropertyOperator.Exact,\n                                type: PropertyFilterType.Event,\n                            },\n                        ],\n                        series: [\n                            {\n                                kind: NodeKind.EventsNode,\n                                event: SurveyEventName.SENT,\n                                name: SurveyEventName.SENT,\n                                math: BaseMathType.TotalCount,\n                            },\n                            {\n                                kind: NodeKind.EventsNode,\n                                event: SurveyEventName.SHOWN,\n                                name: SurveyEventName.SHOWN,\n                                math: BaseMathType.TotalCount,\n                            },\n                            {\n                                kind: NodeKind.EventsNode,\n                                event: SurveyEventName.DISMISSED,\n                                name: SurveyEventName.DISMISSED,\n                                math: BaseMathType.TotalCount,\n                            },\n                        ],\n                    },\n                }\n\n                return urls.insightNew({ query })\n            },\n        ],\n        defaultInterval: [\n            (s) => [s.survey],\n            (survey: Survey): IntervalType => {\n                const start = getSurveyStartDateForQuery(survey)\n                const end = getSurveyEndDateForQuery(survey)\n                const diffInDays = dayjs(end).diff(dayjs(start), 'days')\n                const diffInWeeks = dayjs(end).diff(dayjs(start), 'weeks')\n\n                if (diffInDays < 2) {\n                    return 'hour'\n                }\n                if (diffInWeeks <= 4) {\n                    return 'day'\n                }\n                if (diffInWeeks <= 12) {\n                    return 'week'\n                }\n                return 'month'\n            },\n        ],\n        processedSurveyStats: [\n            (s) => [s.surveyBaseStatsInternal, s.surveyDismissedAndSentCountInternal],\n            (\n                baseStatsResults: SurveyBaseStatsResult,\n                dismissedAndSentCount: DismissedAndSentCountResult\n            ): SurveyStats | null => {\n                if (!baseStatsResults) {\n                    return null\n                }\n\n                const defaultEventStats: Omit<SurveyEventStats, 'first_seen' | 'last_seen'> = {\n                    total_count: 0,\n                    unique_persons: 0,\n                    unique_persons_only_seen: 0,\n                    total_count_only_seen: 0,\n                }\n\n                const stats: SurveyStats = {\n                    [SurveyEventName.SHOWN]: { ...defaultEventStats, first_seen: null, last_seen: null },\n                    [SurveyEventName.DISMISSED]: { ...defaultEventStats, first_seen: null, last_seen: null },\n                    [SurveyEventName.SENT]: { ...defaultEventStats, first_seen: null, last_seen: null },\n                }\n\n                // Process base results\n                baseStatsResults.forEach(([eventName, totalCount, uniquePersons, firstSeen, lastSeen]) => {\n                    const eventStats: SurveyEventStats = {\n                        total_count: totalCount,\n                        unique_persons: uniquePersons,\n                        first_seen: firstSeen ? dayjs(firstSeen).toISOString() : null,\n                        last_seen: lastSeen ? dayjs(lastSeen).toISOString() : null,\n                        unique_persons_only_seen: 0,\n                        total_count_only_seen: 0,\n                    }\n                    if (eventName === SurveyEventName.SHOWN) {\n                        stats[SurveyEventName.SHOWN] = eventStats\n                    } else if (eventName === SurveyEventName.DISMISSED) {\n                        stats[SurveyEventName.DISMISSED] = eventStats\n                    } else if (eventName === SurveyEventName.SENT) {\n                        stats[SurveyEventName.SENT] = eventStats\n                    }\n                })\n\n                // Adjust dismissed unique count\n                const adjustedDismissedUnique = Math.max(\n                    0,\n                    stats[SurveyEventName.DISMISSED].unique_persons - (dismissedAndSentCount ?? 0)\n                )\n                stats[SurveyEventName.DISMISSED].unique_persons = adjustedDismissedUnique\n\n                // Calculate derived 'only_seen' counts\n                const uniqueShown = stats[SurveyEventName.SHOWN].unique_persons\n                const uniqueDismissed = stats[SurveyEventName.DISMISSED].unique_persons\n                const uniqueSent = stats[SurveyEventName.SENT].unique_persons\n\n                const totalShown = stats[SurveyEventName.SHOWN].total_count\n                const totalDismissed = stats[SurveyEventName.DISMISSED].total_count\n                const totalSent = stats[SurveyEventName.SENT].total_count\n\n                stats[SurveyEventName.SHOWN].unique_persons_only_seen = Math.max(\n                    0,\n                    uniqueShown - uniqueDismissed - uniqueSent\n                )\n                stats[SurveyEventName.SHOWN].total_count_only_seen = Math.max(\n                    0,\n                    totalShown - totalDismissed - totalSent\n                )\n\n                return stats\n            },\n        ],\n        surveyRates: [\n            (s) => [s.processedSurveyStats],\n            (stats: SurveyStats | null): SurveyRates => {\n                const defaultRates: SurveyRates = {\n                    response_rate: 0.0,\n                    dismissal_rate: 0.0,\n                    unique_users_response_rate: 0.0,\n                    unique_users_dismissal_rate: 0.0,\n                }\n\n                if (!stats) {\n                    return defaultRates\n                }\n\n                const shownCount = stats[SurveyEventName.SHOWN].total_count\n                if (shownCount > 0) {\n                    const sentCount = stats[SurveyEventName.SENT].total_count\n                    const dismissedCount = stats[SurveyEventName.DISMISSED].total_count\n                    const uniqueUsersShownCount = stats[SurveyEventName.SHOWN].unique_persons\n                    const uniqueUsersSentCount = stats[SurveyEventName.SENT].unique_persons\n                    const uniqueUsersDismissedCount = stats[SurveyEventName.DISMISSED].unique_persons\n\n                    return {\n                        response_rate: parseFloat(((sentCount / shownCount) * 100).toFixed(2)),\n                        dismissal_rate: parseFloat(((dismissedCount / shownCount) * 100).toFixed(2)),\n                        unique_users_response_rate: parseFloat(\n                            ((uniqueUsersSentCount / uniqueUsersShownCount) * 100).toFixed(2)\n                        ),\n                        unique_users_dismissal_rate: parseFloat(\n                            ((uniqueUsersDismissedCount / uniqueUsersShownCount) * 100).toFixed(2)\n                        ),\n                    }\n                }\n                return defaultRates\n            },\n        ],\n    }),\n    forms(({ actions, props, values }) => ({\n        survey: {\n            defaults: { ...NEW_SURVEY } as NewSurvey | Survey,\n            errors: ({ name, questions, appearance, type }) => {\n                const sanitizedAppearance = sanitizeSurveyAppearance(appearance)\n                return {\n                    name: !name && 'Please enter a name.',\n                    questions: questions.map((question) => {\n                        const questionErrors = {\n                            question: !question.question && 'Please enter a question label.',\n                        }\n\n                        if (question.type === SurveyQuestionType.Link) {\n                            if (question.link) {\n                                if (question.link.startsWith('mailto:')) {\n                                    const emailRegex = /^mailto:[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\n                                    if (!emailRegex.test(question.link)) {\n                                        return {\n                                            ...questionErrors,\n                                            link: 'Please enter a valid mailto link (e.g., mailto:example@domain.com).',\n                                        }\n                                    }\n                                } else {\n                                    try {\n                                        const url = new URL(question.link)\n                                        if (url.protocol !== 'https:') {\n                                            return {\n                                                ...questionErrors,\n                                                link: 'Only HTTPS links are supported for security reasons.',\n                                            }\n                                        }\n                                    } catch {\n                                        return {\n                                            ...questionErrors,\n                                            link: 'Please enter a valid HTTPS URL.',\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        if (question.type === SurveyQuestionType.Rating) {\n                            return {\n                                ...questionErrors,\n                                display: !question.display && 'Please choose a display type.',\n                                scale: !question.scale && 'Please choose a scale.',\n                                lowerBoundLabel: !question.lowerBoundLabel && 'Please enter a lower bound label.',\n                                upperBoundLabel: !question.upperBoundLabel && 'Please enter an upper bound label.',\n                            }\n                        } else if (\n                            question.type === SurveyQuestionType.SingleChoice ||\n                            question.type === SurveyQuestionType.MultipleChoice\n                        ) {\n                            return {\n                                ...questionErrors,\n                                choices: question.choices.some((choice) => !choice.trim())\n                                    ? 'Please ensure all choices are non-empty.'\n                                    : undefined,\n                            }\n                        }\n\n                        return questionErrors\n                    }),\n                    // release conditions controlled using a PureField in the form\n                    targeting_flag_filters: values.flagPropertyErrors,\n                    // controlled using a PureField in the form\n                    urlMatchType: values.urlMatchTypeValidationError,\n                    appearance:\n                        sanitizedAppearance &&\n                        validateSurveyAppearance(\n                            sanitizedAppearance,\n                            questions.some((q) => q.type === SurveyQuestionType.Rating),\n                            type\n                        ),\n                }\n            },\n            submit: (surveyPayload) => {\n                if (values.hasCycle) {\n                    actions.reportSurveyCycleDetected(values.survey)\n\n                    return lemonToast.error(\n                        'Your survey contains an endless cycle. Please revisit your branching rules.'\n                    )\n                }\n\n                const payload = sanitizeSurvey(surveyPayload)\n\n                // when the survey is being submitted, we should turn off editing mode\n                actions.editingSurvey(false)\n                if (props.id && props.id !== 'new') {\n                    actions.updateSurvey(payload)\n                } else {\n                    actions.createSurvey({ ...payload, _create_in_folder: 'Unfiled/Surveys' })\n                }\n            },\n        },\n    })),\n    urlToAction(({ actions, props }) => ({\n        [urls.survey(props.id ?? 'new')]: (_, { edit }, __, { method }) => {\n            // We always set the editingSurvey to true when we create a new survey\n            if (props.id === 'new') {\n                actions.editingSurvey(true)\n            }\n            // If the URL was pushed (user clicked on a link), reset the scene's data.\n            // This avoids resetting form fields if you click back/forward.\n            if (method === 'PUSH') {\n                if (props.id) {\n                    actions.loadSurvey()\n                } else {\n                    actions.resetSurvey()\n                }\n            }\n\n            if (edit) {\n                actions.editingSurvey(true)\n            }\n        },\n    })),\n    actionToUrl(({ values }) => ({\n        setSurveyTemplateValues: () => {\n            const hashParams = router.values.hashParams\n            hashParams['fromTemplate'] = true\n\n            return [urls.survey(values.survey.id), router.values.searchParams, hashParams]\n        },\n        editingSurvey: ({ editing }) => {\n            const searchParams = router.values.searchParams\n            if (editing) {\n                searchParams['edit'] = true\n            } else {\n                delete searchParams['edit']\n            }\n\n            return [router.values.location.pathname, router.values.searchParams, router.values.hashParams]\n        },\n    })),\n    afterMount(({ props, actions }) => {\n        if (props.id !== 'new') {\n            actions.loadSurvey()\n        }\n        if (props.id === 'new') {\n            actions.resetSurvey()\n        }\n    }),\n])\n","import DOMPurify from 'dompurify'\nimport { DeepPartialMap, ValidationErrorType } from 'kea-forms'\nimport { dayjs } from 'lib/dayjs'\nimport { QuestionProcessedResponses, SurveyRatingResults } from 'scenes/surveys/surveyLogic'\n\nimport {\n    EventPropertyFilter,\n    Survey,\n    SurveyAppearance,\n    SurveyDisplayConditions,\n    SurveyEventName,\n    SurveyEventProperties,\n    SurveyQuestion,\n    SurveyQuestionType,\n    SurveyType,\n} from '~/types'\n\nconst sanitizeConfig = { ADD_ATTR: ['target'] }\n\nexport function sanitizeHTML(html: string): string {\n    return DOMPurify.sanitize(html, sanitizeConfig)\n}\n\nexport function sanitizeColor(color: string | undefined): string | undefined {\n    if (!color) {\n        return undefined\n    }\n\n    // test if the color is valid by adding a # to the beginning of the string\n    if (CSS.supports('color', `#${color}`)) {\n        return `#${color}`\n    }\n\n    return color\n}\n\nexport function validateCSSProperty(property: string, value: string | undefined): string | undefined {\n    if (!value) {\n        return undefined\n    }\n    const isValidCSSProperty = CSS.supports(property, value)\n    return !isValidCSSProperty ? `${value} is not a valid property for ${property}.` : undefined\n}\n\nexport function validateSurveyAppearance(\n    appearance: SurveyAppearance,\n    hasRatingQuestions: boolean,\n    surveyType: SurveyType\n): DeepPartialMap<SurveyAppearance, ValidationErrorType> {\n    return {\n        backgroundColor: validateCSSProperty('background-color', appearance.backgroundColor),\n        borderColor: validateCSSProperty('border-color', appearance.borderColor),\n        // Only validate rating button colors if there's a rating question\n        ...(hasRatingQuestions && {\n            ratingButtonActiveColor: validateCSSProperty('background-color', appearance.ratingButtonActiveColor),\n            ratingButtonColor: validateCSSProperty('background-color', appearance.ratingButtonColor),\n        }),\n        submitButtonColor: validateCSSProperty('background-color', appearance.submitButtonColor),\n        submitButtonTextColor: validateCSSProperty('color', appearance.submitButtonTextColor),\n        maxWidth: validateCSSProperty('width', appearance.maxWidth),\n        boxPadding: validateCSSProperty('padding', appearance.boxPadding),\n        boxShadow: validateCSSProperty('box-shadow', appearance.boxShadow),\n        borderRadius: validateCSSProperty('border-radius', appearance.borderRadius),\n        zIndex: validateCSSProperty('z-index', appearance.zIndex),\n        widgetSelector:\n            surveyType === SurveyType.Widget && appearance?.widgetType === 'selector' && !appearance.widgetSelector\n                ? 'Please enter a CSS selector.'\n                : undefined,\n    }\n}\n\nexport function getSurveyResponseKey(questionIndex: number): string {\n    return questionIndex === 0\n        ? SurveyEventProperties.SURVEY_RESPONSE\n        : `${SurveyEventProperties.SURVEY_RESPONSE}_${questionIndex}`\n}\n\nexport function getSurveyIdBasedResponseKey(questionId: string): string {\n    return `${SurveyEventProperties.SURVEY_RESPONSE}_${questionId}`\n}\n\n// Helper function to generate the response field keys with proper typing\nexport const getResponseFieldWithId = (\n    questionIndex: number,\n    questionId?: string\n): { indexBasedKey: string; idBasedKey: string | undefined } => {\n    return {\n        indexBasedKey: getSurveyResponseKey(questionIndex),\n        idBasedKey: questionId ? getSurveyIdBasedResponseKey(questionId) : undefined,\n    }\n}\n\nexport function sanitizeSurveyDisplayConditions(\n    displayConditions?: SurveyDisplayConditions | null\n): SurveyDisplayConditions | null {\n    if (!displayConditions) {\n        return null\n    }\n\n    return {\n        ...displayConditions,\n        url: displayConditions.url.trim(),\n        selector: displayConditions.selector?.trim(),\n    }\n}\n\nexport function sanitizeSurveyAppearance(\n    appearance?: SurveyAppearance | null,\n    isPartialResponsesEnabled = false\n): SurveyAppearance | null {\n    if (!appearance) {\n        return null\n    }\n\n    return {\n        ...appearance,\n        shuffleQuestions: isPartialResponsesEnabled ? false : appearance.shuffleQuestions,\n        backgroundColor: sanitizeColor(appearance.backgroundColor),\n        borderColor: sanitizeColor(appearance.borderColor),\n        ratingButtonActiveColor: sanitizeColor(appearance.ratingButtonActiveColor),\n        ratingButtonColor: sanitizeColor(appearance.ratingButtonColor),\n        submitButtonColor: sanitizeColor(appearance.submitButtonColor),\n        submitButtonTextColor: sanitizeColor(appearance.submitButtonTextColor),\n        thankYouMessageHeader: sanitizeHTML(appearance.thankYouMessageHeader ?? ''),\n        thankYouMessageDescription: sanitizeHTML(appearance.thankYouMessageDescription ?? ''),\n    }\n}\n\nexport type NPSBreakdown = {\n    total: number\n    promoters: number\n    passives: number\n    detractors: number\n    score: string\n}\n\n// NPS calculation constants\nconst NPS_SCALE_SIZE = 11 // 0-10 scale\nconst NPS_PROMOTER_MIN = 9 // 9-10 are promoters\nconst NPS_PASSIVE_MIN = 7 // 7-8 are passives. 0-6 are detractors but we don't need a variable for that.\n\ninterface NPSRawData {\n    values: number[]\n    total: number\n}\n\n/**\n * Extracts raw NPS data from processed survey data\n */\nfunction extractNPSRawData(processedData: QuestionProcessedResponses): NPSRawData | null {\n    if (\n        !processedData?.data ||\n        processedData.type !== SurveyQuestionType.Rating ||\n        !Array.isArray(processedData.data) ||\n        processedData.data.length !== NPS_SCALE_SIZE\n    ) {\n        return null\n    }\n\n    return {\n        values: processedData.data.map((item) => item.value),\n        total: processedData.totalResponses,\n    }\n}\n\n/**\n * Extracts raw NPS data from legacy survey rating results\n */\nfunction extractNPSRawDataFromLegacy(surveyRatingResults: SurveyRatingResults[number]): NPSRawData | null {\n    if (!surveyRatingResults?.data || surveyRatingResults.data.length !== NPS_SCALE_SIZE) {\n        return null\n    }\n\n    return {\n        values: surveyRatingResults.data,\n        total: surveyRatingResults.total,\n    }\n}\n\n/**\n * Core NPS calculation logic - works with raw data arrays\n */\nfunction calculateNPSFromRawData(rawData: NPSRawData): NPSBreakdown {\n    if (rawData.total === 0) {\n        return { total: 0, promoters: 0, passives: 0, detractors: 0, score: '0.0' }\n    }\n\n    const promoters = rawData.values.slice(NPS_PROMOTER_MIN, NPS_SCALE_SIZE).reduce((acc, curr) => acc + curr, 0)\n    const passives = rawData.values.slice(NPS_PASSIVE_MIN, NPS_PROMOTER_MIN).reduce((acc, curr) => acc + curr, 0)\n    const detractors = rawData.values.slice(0, NPS_PASSIVE_MIN).reduce((acc, curr) => acc + curr, 0)\n\n    const score = ((promoters - detractors) / rawData.total) * 100\n\n    return {\n        total: rawData.total,\n        promoters,\n        passives,\n        detractors,\n        score: score.toFixed(1),\n    }\n}\n\nexport function calculateNpsBreakdownFromProcessedData(processedData: QuestionProcessedResponses): NPSBreakdown | null {\n    const rawData = extractNPSRawData(processedData)\n    return rawData ? calculateNPSFromRawData(rawData) : null\n}\n\nexport function calculateNpsBreakdown(surveyRatingResults: SurveyRatingResults[number]): NPSBreakdown | null {\n    const rawData = extractNPSRawDataFromLegacy(surveyRatingResults)\n    return rawData ? calculateNPSFromRawData(rawData) : null\n}\n\n// Helper to escape special characters in SQL strings\nfunction escapeSqlString(value: string): string {\n    return value.replace(/['\\\\]/g, '\\\\$&')\n}\n\nexport function getSurveyResponse(question: SurveyQuestion, index: number): string {\n    const { indexBasedKey, idBasedKey } = getResponseFieldWithId(index, question.id)\n\n    if (question.type === SurveyQuestionType.MultipleChoice) {\n        return `if(\n        JSONHas(events.properties, '${idBasedKey}') AND length(JSONExtractArrayRaw(events.properties, '${idBasedKey}')) > 0,\n        JSONExtractArrayRaw(events.properties, '${idBasedKey}'),\n        JSONExtractArrayRaw(events.properties, '${indexBasedKey}')\n    )`\n    }\n\n    return `COALESCE(\n        NULLIF(JSONExtractString(events.properties, '${idBasedKey}'), ''),\n        NULLIF(JSONExtractString(events.properties, '${indexBasedKey}'), '')\n    )`\n}\n\n/**\n * Creates a HogQL expression for survey answer filters that handles both index-based and ID-based property keys\n * using OR logic between the alternative formats for each question.\n *\n * @param filters - The answer filters to convert to HogQL expressions\n * @param survey - The survey object (needed to access question IDs)\n * @returns A HogQL expression string that can be used in queries. If there are no filters, it returns an empty string.\n *\n * TODO: Consider leveraging the backend query builder instead of duplicating this logic in the frontend.\n * ClickHouse has powerful functions like match(), multiIf(), etc. that could be used more effectively.\n */\nexport function createAnswerFilterHogQLExpression(filters: EventPropertyFilter[], survey: Survey): string {\n    if (!filters || !filters.length) {\n        return ''\n    }\n\n    // Build the filter expression as a string\n    let filterExpression = ''\n    let hasValidFilter = false\n\n    // Process each filter\n    for (const filter of filters) {\n        // Skip filters with empty or undefined values\n        if (filter.value === undefined || filter.value === null || filter.value === '') {\n            continue\n        }\n\n        // Skip empty arrays\n        if (Array.isArray(filter.value) && filter.value.length === 0) {\n            continue\n        }\n\n        // Skip ILIKE filters with empty search patterns\n        if (\n            filter.operator === 'icontains' &&\n            (filter.value === '%' ||\n                filter.value === '%%' ||\n                (typeof filter.value === 'string' && filter.value.trim() === ''))\n        ) {\n            continue\n        }\n\n        // split the string '$survey_response_' and take the last part, as that's the question id\n        const questionId = filter.key.split(`${SurveyEventProperties.SURVEY_RESPONSE}_`).at(-1)\n        const question = survey.questions.find((question) => question.id === questionId)\n        if (!questionId || !question) {\n            continue\n        }\n\n        const questionIndex = survey.questions.findIndex((question) => question.id === questionId)\n\n        // Create the condition for this filter\n        let condition = ''\n        let escapedValue: string\n        let valueList: string\n\n        // Handle different operators\n        switch (filter.operator) {\n            case 'exact':\n            case 'is_not':\n                if (Array.isArray(filter.value)) {\n                    valueList = filter.value.map((v) => `'${escapeSqlString(String(v))}'`).join(', ')\n                    condition = `(${getSurveyResponse(question, questionIndex)} ${\n                        filter.operator === 'is_not' ? 'NOT IN' : 'IN'\n                    } (${valueList}))`\n                } else {\n                    escapedValue = escapeSqlString(String(filter.value))\n                    condition = `(${getSurveyResponse(question, questionIndex)} ${\n                        filter.operator === 'is_not' ? '!=' : '='\n                    } '${escapedValue}')`\n                }\n                break\n            case 'icontains':\n                escapedValue = escapeSqlString(String(filter.value))\n                condition = `(${getSurveyResponse(question, questionIndex)} ILIKE '%${escapedValue}%')`\n                break\n            case 'not_icontains':\n                escapedValue = escapeSqlString(String(filter.value))\n                condition = `(NOT ${getSurveyResponse(question, questionIndex)} ILIKE '%${escapedValue}%')`\n                break\n            case 'regex':\n                escapedValue = escapeSqlString(String(filter.value))\n                condition = `(match(${getSurveyResponse(question, questionIndex)}, '${escapedValue}'))`\n                break\n            case 'not_regex':\n                escapedValue = escapeSqlString(String(filter.value))\n                condition = `(NOT match(${getSurveyResponse(question, questionIndex)}, '${escapedValue}'))`\n                break\n            // Add more operators as needed\n            default:\n                continue // Skip unsupported operators\n        }\n\n        // Add this condition to the overall expression\n        if (condition) {\n            if (hasValidFilter) {\n                filterExpression += ' AND '\n            }\n            filterExpression += condition\n            hasValidFilter = true\n        }\n    }\n\n    return hasValidFilter ? `AND ${filterExpression}` : ''\n}\n\nexport function isSurveyRunning(survey: Survey): boolean {\n    return !!(survey.start_date && !survey.end_date)\n}\n\nexport const DATE_FORMAT = 'YYYY-MM-DDTHH:mm:ss'\n\nexport function getSurveyStartDateForQuery(survey: Survey): string {\n    return dayjs(survey.created_at).utc().startOf('day').format(DATE_FORMAT)\n}\n\nexport function getSurveyEndDateForQuery(survey: Survey): string {\n    return survey.end_date\n        ? dayjs(survey.end_date).utc().endOf('day').format(DATE_FORMAT)\n        : dayjs().utc().endOf('day').format(DATE_FORMAT)\n}\n\nexport function buildPartialResponsesFilter(survey: Survey): string {\n    if (!survey.enable_partial_responses) {\n        return `AND (\n        NOT JSONHas(properties, '${SurveyEventProperties.SURVEY_COMPLETED}')\n        OR JSONExtractBool(properties, '${SurveyEventProperties.SURVEY_COMPLETED}') = true\n    )`\n    }\n\n    return `AND uuid in (\n        SELECT\n            argMax(uuid, timestamp)\n        FROM events\n        WHERE and(\n            equals(event, '${SurveyEventName.SENT}'),\n            equals(JSONExtractString(properties, '${SurveyEventProperties.SURVEY_ID}'), '${survey.id}'),\n            greaterOrEquals(timestamp, '${getSurveyStartDateForQuery(survey)}'),\n            lessOrEquals(timestamp, '${getSurveyEndDateForQuery(survey)}')\n        )\n        GROUP BY\n            if(\n                JSONHas(properties, '${SurveyEventProperties.SURVEY_SUBMISSION_ID}'),\n                JSONExtractString(properties, '${SurveyEventProperties.SURVEY_SUBMISSION_ID}'),\n                toString(uuid)\n            )\n    ) --- Filter to ensure we only get one response per ${SurveyEventProperties.SURVEY_SUBMISSION_ID}`\n}\n\nexport function sanitizeSurvey(survey: Partial<Survey>): Partial<Survey> {\n    const sanitizedQuestions =\n        survey.questions?.map((question) => ({\n            ...question,\n            question: sanitizeHTML(question.question ?? ''),\n            description: sanitizeHTML(question.description ?? ''),\n        })) || []\n\n    const sanitizedAppearance = sanitizeSurveyAppearance(survey.appearance, survey.enable_partial_responses ?? false)\n\n    // Remove widget-specific fields if survey type is not Widget\n    if (survey.type !== SurveyType.Widget && sanitizedAppearance) {\n        delete sanitizedAppearance.widgetType\n        delete sanitizedAppearance.widgetLabel\n        delete sanitizedAppearance.widgetColor\n    }\n\n    return {\n        ...survey,\n        conditions: sanitizeSurveyDisplayConditions(survey.conditions),\n        questions: sanitizedQuestions,\n        appearance: sanitizedAppearance,\n    }\n}\n","import { LemonCollapse, LemonModal, Link } from '@posthog/lemon-ui'\nimport { useValues } from 'kea'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport EarlyAccessFeatureImage from 'public/early-access-feature-demo.png'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { urls } from 'scenes/urls'\n\nimport { FeatureFlagType, PipelineStage, Region } from '~/types'\n\ninterface InstructionsModalProps {\n    flag: FeatureFlagType['key']\n    visible: boolean\n    onClose: () => void\n}\n\nexport function InstructionsModal({ onClose, visible, flag }: InstructionsModalProps): JSX.Element {\n    const { preflight } = useValues(preflightLogic)\n\n    const getCloudPanels = (): JSX.Element => (\n        <LemonCollapse\n            className=\"mt-2 bg-surface-primary\"\n            defaultActiveKey=\"1\"\n            panels={[\n                {\n                    key: '1',\n                    header: 'Option 1: Widget Site App',\n                    content: (\n                        <div>\n                            Give your users a{' '}\n                            <Link\n                                to={urls.pipelineNodeNew(PipelineStage.SiteApp, {\n                                    id: preflight?.region === Region.EU ? 332 : 574,\n                                })}\n                            >\n                                prebuilt widget\n                            </Link>{' '}\n                            to opt-in to features\n                            <img className=\"max-h-full max-w-full mt-2.5\" src={EarlyAccessFeatureImage} />\n                        </div>\n                    ),\n                },\n                {\n                    key: '2',\n                    header: 'Option 2: Custom implementation',\n                    content: (\n                        <div>\n                            <b>Opt user in</b>\n                            <div>\n                                <FeatureEnrollInstructions flag={flag} />\n                            </div>\n\n                            <b>Opt user out</b>\n                            <div>\n                                <FeatureUnenrollInstructions flag={flag} />\n                            </div>\n\n                            <b>Retrieve Previews</b>\n                            <div>\n                                <RetrievePreviewsInstructions />\n                            </div>\n                        </div>\n                    ),\n                },\n            ]}\n        />\n    )\n\n    const getSelfHostedPanels = (): JSX.Element => (\n        <div>\n            <b>Opt user in</b>\n            <div>\n                <FeatureEnrollInstructions flag={flag} />\n            </div>\n\n            <b>Opt user out</b>\n            <div>\n                <FeatureUnenrollInstructions flag={flag} />\n            </div>\n\n            <b>Retrieve Previews</b>\n            <div>\n                <RetrievePreviewsInstructions />\n            </div>\n        </div>\n    )\n\n    const panels: JSX.Element = preflight?.cloud ? getCloudPanels() : getSelfHostedPanels()\n\n    return (\n        <LemonModal title=\"How to implement opt-in feature flags\" isOpen={visible} onClose={onClose} width={640}>\n            <div>\n                <div className=\"mb-2\">\n                    Implement manual release condition toggles to give your users the ability choose which features they\n                    want to try\n                </div>\n                {panels}\n            </div>\n        </LemonModal>\n    )\n}\n\nfunction FeatureEnrollInstructions({ flag }: { flag: string }): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.updateEarlyAccessFeatureEnrollment(\"${flag}\", true)\n`}\n        </CodeSnippet>\n    )\n}\n\nfunction FeatureUnenrollInstructions({ flag }: { flag: string }): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.updateEarlyAccessFeatureEnrollment(\"${flag}\", false)\n`}\n        </CodeSnippet>\n    )\n}\n\nfunction RetrievePreviewsInstructions(): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.getEarlyAccessFeatures((previewItemData) => {\n    // do something with early access feature\n})\n`}\n        </CodeSnippet>\n    )\n}\n","import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, afterMount, kea, listeners, path, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { router } from 'kea-router'\nimport api from 'lib/api'\nimport { uuid } from 'lib/utils'\nimport { isObject } from 'lib/utils'\nimport { urls } from 'scenes/urls'\n\nimport type { llmObservabilityPlaygroundLogicType } from './llmObservabilityPlaygroundLogicType'\n\nexport interface ModelOption {\n    id: string\n    name: string\n    provider: string\n    description: string\n}\n\nexport interface PlaygroundResponse {\n    text: string\n    model: string\n    usage: {\n        prompt_tokens: number | null\n        completion_tokens: number | null\n        total_tokens: number | null\n    }\n}\n\nexport type MessageRole = 'user' | 'assistant' | 'system'\n\nexport interface Message {\n    role: MessageRole\n    content: string\n}\n\nexport interface ComparisonItem {\n    id: string\n    model: string\n    systemPrompt: string\n    requestMessages: Message[]\n    response: string\n    usage?: {\n        prompt_tokens?: number | null\n        completion_tokens?: number | null\n        total_tokens?: number | null\n    }\n    ttftMs?: number | null\n    latencyMs?: number | null\n}\n\nexport const llmObservabilityPlaygroundLogic = kea<llmObservabilityPlaygroundLogicType>([\n    path(['products', 'llm_observability', 'frontend', 'llmObservabilityPlaygroundLogic']),\n\n    actions({\n        setModel: (model: string) => ({ model }),\n        setSystemPrompt: (systemPrompt: string) => ({ systemPrompt }),\n        setTemperature: (temperature: number) => ({ temperature }),\n        setMaxTokens: (maxTokens: number) => ({ maxTokens }),\n        setThinking: (thinking: boolean) => ({ thinking }),\n        clearConversation: true,\n        submitPrompt: true,\n        setMessages: (messages: Message[]) => ({ messages }),\n        deleteMessage: (index: number) => ({ index }),\n        addAssistantMessageChunk: (text: string) => ({ text }),\n        finalizeAssistantMessage: true,\n        addMessage: (message?: Partial<Message>) => ({ message }),\n        updateMessage: (index: number, payload: Partial<Message>) => ({ index, payload }),\n        addResponseToHistory: (content: string) => ({ content }),\n        addCurrentRunToComparison: true,\n        setLastRunDetails: (details: ComparisonItem | null) => ({ details }),\n        addToComparison: (item: ComparisonItem) => ({ item }),\n        removeFromComparison: (id: string) => ({ id }),\n        clearComparison: true,\n        setupPlaygroundFromEvent: (payload: { model?: string; input?: any }) => ({ payload }),\n        setResponseError: (hasError: boolean) => ({ hasError }),\n        clearResponseError: true,\n    }),\n\n    reducers({\n        model: ['', { setModel: (_, { model }) => model }],\n        systemPrompt: ['You are a helpful AI assistant.', { setSystemPrompt: (_, { systemPrompt }) => systemPrompt }],\n        temperature: [0.7, { setTemperature: (_, { temperature }) => temperature }],\n        maxTokens: [1024, { setMaxTokens: (_, { maxTokens }) => maxTokens }],\n        thinking: [false, { setThinking: (_, { thinking }) => thinking }],\n        messages: [\n            [] as Message[],\n            {\n                clearConversation: () => [],\n                setMessages: (_, { messages }) => messages,\n                deleteMessage: (state, { index }) => state.filter((_, i) => i !== index),\n                addMessage: (state, { message }) => {\n                    const defaultMessage: Message = { role: 'user', content: '' }\n                    return [...state, { ...defaultMessage, ...message }]\n                },\n                updateMessage: (state, { index, payload }) => {\n                    if (index < 0 || index >= state.length) {\n                        return state\n                    }\n                    const newState = [...state]\n                    newState[index] = { ...newState[index], ...payload }\n                    return newState\n                },\n                addResponseToHistory: (state, { content }) => {\n                    if (content) {\n                        return [...state, { role: 'assistant', content }]\n                    }\n                    return state\n                },\n            },\n        ],\n        submitting: [\n            false as boolean,\n            {\n                submitPrompt: () => true,\n                addAssistantMessageChunk: () => true,\n                finalizeAssistantMessage: () => false,\n            },\n        ],\n        currentResponse: [\n            null as string | null,\n            {\n                submitPrompt: () => '',\n                addAssistantMessageChunk: (state, { text }) => (state ?? '') + text,\n                addResponseToHistory: () => null,\n                clearConversation: () => null,\n                setMessages: () => null,\n            },\n        ],\n        lastRunDetails: [\n            null as ComparisonItem | null,\n            {\n                submitPrompt: () => null,\n                setLastRunDetails: (_, { details }) => details,\n                addToComparison: () => null,\n                clearConversation: () => null,\n                setMessages: () => null,\n            },\n        ],\n        comparisonItems: [\n            [] as ComparisonItem[],\n            {\n                addToComparison: (state, { item }) => [...state, item],\n                removeFromComparison: (state, { id }) => state.filter((item) => item.id !== id),\n                clearComparison: () => [],\n            },\n        ],\n        responseHasError: [\n            false as boolean,\n            {\n                submitPrompt: () => false,\n                setResponseError: (_, { hasError }) => hasError,\n                clearResponseError: () => false,\n                clearConversation: () => false,\n                setMessages: () => false,\n                addResponseToHistory: () => false,\n            },\n        ],\n    }),\n    loaders(({ values }) => ({\n        modelOptions: {\n            __default: [] as ModelOption[],\n            loadModelOptions: async () => {\n                try {\n                    const response = await api.get('/api/llm_proxy/models/')\n                    if (!values.model && (response as ModelOption[])?.length > 0) {\n                        llmObservabilityPlaygroundLogic.actions.setModel((response as ModelOption[])[0].id)\n                    }\n                    return response as ModelOption[]\n                } catch (error) {\n                    console.error('Error loading model options:', error)\n                    return values.modelOptions\n                }\n            },\n        },\n    })),\n    listeners(({ actions, values }) => ({\n        submitPrompt: async (_, breakpoint) => {\n            const requestModel = values.model\n            const requestSystemPrompt = values.systemPrompt\n            const messagesToSend = values.messages.filter(\n                (m) => (m.role === 'user' || m.role === 'assistant' || m.role === 'system') && m.content.trim()\n            )\n\n            const requestMessages = messagesToSend\n\n            if (messagesToSend.length === 0) {\n                lemonToast.error('Please add some messages before running the prompt')\n                actions.finalizeAssistantMessage()\n                return\n            }\n\n            let responseUsage: ComparisonItem['usage'] = {}\n            let ttftMs: number | null = null\n            let latencyMs: number | null = null\n            let firstTokenTime: number | null = null\n\n            // Declare startTime outside try block\n            let startTime: number | null = null\n\n            try {\n                // Start timer for latency? Might be inaccurate due to network etc.\n                startTime = performance.now()\n\n                await api.stream('/api/llm_proxy/completion', {\n                    method: 'POST',\n                    data: {\n                        system: requestSystemPrompt,\n                        messages: messagesToSend.filter((m) => m.role === 'user' || m.role === 'assistant'),\n                        model: requestModel,\n                        thinking: values.thinking,\n                        temperature: values.temperature,\n                        max_tokens: values.maxTokens,\n                    },\n                    headers: { 'Content-Type': 'application/json' },\n                    onMessage: (event) => {\n                        breakpoint()\n                        if (!event.data) {\n                            return\n                        }\n                        try {\n                            const data = JSON.parse(event.data)\n                            if (data.type === 'text') {\n                                if (firstTokenTime === null && startTime !== null) {\n                                    firstTokenTime = performance.now()\n                                    ttftMs = firstTokenTime - startTime\n                                }\n                                actions.addAssistantMessageChunk(data.text)\n                            } else if (data.type === 'usage') {\n                                responseUsage = {\n                                    prompt_tokens: data.prompt_tokens ?? null,\n                                    completion_tokens: data.completion_tokens ?? null,\n                                    total_tokens: data.total_tokens ?? null,\n                                }\n                            } else if (data.error) {\n                                console.error('LLM Error:', data.error)\n                                actions.addAssistantMessageChunk(`\\n\\n**LLM Error:** ${data.error}`)\n                                actions.setResponseError(true)\n                            }\n                        } catch (e) {\n                            console.error('Error parsing stream message:', e, 'Data:', event.data)\n                            actions.addAssistantMessageChunk(`\\n\\n**Stream Error:** Could not parse response chunk.`)\n                            actions.setResponseError(true)\n                        }\n                    },\n                    onError: (err) => {\n                        console.error('Stream error:', err)\n                        actions.addAssistantMessageChunk(\n                            `\\n\\n**Stream Connection Error:** ${err.message || 'Unknown error'}`\n                        )\n                        actions.setResponseError(true)\n                        actions.finalizeAssistantMessage()\n                    },\n                })\n                actions.finalizeAssistantMessage()\n            } catch (error) {\n                console.error('Submit prompt error:', error)\n                actions.addAssistantMessageChunk(`\\n\\n**Error:** Failed to initiate prompt submission.`)\n                actions.setResponseError(true)\n                lemonToast.error('Failed to connect to LLM service. Please try again.')\n                actions.finalizeAssistantMessage()\n            } finally {\n                if (startTime) {\n                    const endTime = performance.now()\n                    latencyMs = endTime - startTime\n                }\n            }\n\n            if (values.currentResponse !== null) {\n                const runDetails: ComparisonItem = {\n                    id: uuid(),\n                    model: requestModel,\n                    systemPrompt: requestSystemPrompt,\n                    requestMessages: requestMessages,\n                    response: values.currentResponse,\n                    usage: responseUsage,\n                    ttftMs: ttftMs,\n                    latencyMs: latencyMs,\n                }\n                actions.setLastRunDetails(runDetails)\n            }\n        },\n        addCurrentRunToComparison: () => {\n            if (values.lastRunDetails) {\n                actions.addToComparison(values.lastRunDetails)\n            }\n        },\n        setupPlaygroundFromEvent: ({ payload }) => {\n            const { model, input } = payload\n\n            // Set model if available\n            if (model) {\n                actions.setModel(model)\n            }\n\n            let systemPromptContent: string | undefined = undefined\n            let conversationMessages: Message[] = []\n            let initialUserPrompt: string | undefined = undefined\n\n            if (input) {\n                try {\n                    // Case 1: Input is a standard messages array\n                    if (Array.isArray(input) && input.every((msg) => msg.role && msg.content)) {\n                        // Find and set system message\n                        const systemMessage = input.find((msg) => msg.role === 'system')\n                        if (systemMessage?.content && typeof systemMessage.content === 'string') {\n                            systemPromptContent = systemMessage.content\n                        }\n\n                        // Extract user and assistant messages for history\n                        conversationMessages = input\n                            .filter((msg) => msg.role === 'user' || msg.role === 'assistant')\n                            .map((msg) => ({\n                                role: msg.role as 'user' | 'assistant',\n                                content: typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content),\n                            }))\n                    }\n                    // Case 2: Input is just a single string prompt\n                    else if (typeof input === 'string') {\n                        initialUserPrompt = input\n                    }\n                    // Case 3: Input is some other object (try to extract content)\n                    else if (isObject(input)) {\n                        if (typeof input.content === 'string') {\n                            initialUserPrompt = input.content\n                        } else if (input.content && typeof input.content !== 'string') {\n                            initialUserPrompt = JSON.stringify(input.content, null, 2)\n                        } else {\n                            initialUserPrompt = JSON.stringify(input, null, 2)\n                        }\n                    }\n                } catch (e) {\n                    console.error('Error processing input for playground:', e)\n                    initialUserPrompt = String(input)\n                    conversationMessages = []\n                }\n            }\n\n            // Set state in playground logic\n            if (systemPromptContent) {\n                actions.setSystemPrompt(systemPromptContent)\n            } else {\n                // Reset to default if no system prompt found in the input\n                actions.setSystemPrompt('You are a helpful AI assistant.')\n            }\n\n            // If the input was just a string, add it as the first user message\n            if (initialUserPrompt) {\n                // Prepend it so it appears first in the playground\n                conversationMessages.unshift({ role: 'user', content: initialUserPrompt })\n            }\n\n            actions.setMessages(conversationMessages) // Set the extracted history (potentially including the initial prompt)\n\n            // Navigate to the playground\n            router.actions.push(urls.llmObservabilityPlayground())\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadModelOptions()\n    }),\n    selectors({}),\n])\n"],"names":[],"sourceRoot":""}