{"version":3,"file":"21172.537e8c0e.iframe.bundle.js","mappings":";AA4jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@posthog/storybook/../../products/llm_observability/frontend/llmObservabilityLogic.tsx"],"sourcesContent":["import { actions, afterMount, connect, kea, listeners, path, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl, router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { TaxonomicFilterGroupType } from 'lib/components/TaxonomicFilter/types'\nimport { dayjs } from 'lib/dayjs'\nimport { objectsEqual } from 'lib/utils'\nimport { isDefinitionStale } from 'lib/utils/definitions'\nimport { insightDataLogic } from 'scenes/insights/insightDataLogic'\nimport { sceneLogic } from 'scenes/sceneLogic'\nimport { urls } from 'scenes/urls'\n\nimport { groupsModel } from '~/models/groupsModel'\nimport { DataTableNode, NodeKind, TrendsQuery } from '~/queries/schema/schema-general'\nimport { isAnyPropertyFilters } from '~/queries/schema-guards'\nimport { QueryContext } from '~/queries/types'\nimport {\n    AnyPropertyFilter,\n    BaseMathType,\n    ChartDisplayType,\n    EventDefinitionType,\n    HogQLMathType,\n    InsightShortId,\n    PropertyFilterType,\n    PropertyMathType,\n    PropertyOperator,\n} from '~/types'\n\nimport type { llmObservabilityLogicType } from './llmObservabilityLogicType'\n\nexport const LLM_OBSERVABILITY_DATA_COLLECTION_NODE_ID = 'llm-observability-data'\n\nconst INITIAL_DASHBOARD_DATE_FROM = '-7d' as string | null\nconst INITIAL_EVENTS_DATE_FROM = '-1d' as string | null\nconst INITIAL_DATE_TO = null as string | null\n\nexport interface QueryTile {\n    title: string\n    description?: string\n    query: TrendsQuery\n    context?: QueryContext\n    layout?: {\n        className?: string\n    }\n}\n\nexport const llmObservabilityLogic = kea<llmObservabilityLogicType>([\n    path(['products', 'llm_observability', 'frontend', 'llmObservabilityLogic']),\n\n    connect({ values: [sceneLogic, ['sceneKey'], groupsModel, ['groupsEnabled']] }),\n\n    actions({\n        setDates: (dateFrom: string | null, dateTo: string | null) => ({ dateFrom, dateTo }),\n        setDashboardDateFilter: (dateFrom: string | null, dateTo: string | null) => ({ dateFrom, dateTo }),\n        setShouldFilterTestAccounts: (shouldFilterTestAccounts: boolean) => ({ shouldFilterTestAccounts }),\n        setPropertyFilters: (propertyFilters: AnyPropertyFilter[]) => ({ propertyFilters }),\n        setGenerationsQuery: (query: DataTableNode) => ({ query }),\n        setTracesQuery: (query: DataTableNode) => ({ query }),\n        refreshAllDashboardItems: true,\n        setRefreshStatus: (tileId: string, loading?: boolean) => ({ tileId, loading }),\n    }),\n\n    reducers({\n        dateFilter: [\n            {\n                dateFrom: INITIAL_EVENTS_DATE_FROM,\n                dateTo: INITIAL_DATE_TO,\n            },\n            {\n                setDates: (_, { dateFrom, dateTo }) => ({ dateFrom, dateTo }),\n            },\n        ],\n\n        dashboardDateFilter: [\n            {\n                dateFrom: INITIAL_DASHBOARD_DATE_FROM,\n                dateTo: INITIAL_DATE_TO,\n            },\n            {\n                setDates: (_, { dateFrom, dateTo }) => ({ dateFrom, dateTo }),\n            },\n        ],\n\n        shouldFilterTestAccounts: [\n            false,\n            {\n                setShouldFilterTestAccounts: (_, { shouldFilterTestAccounts }) => shouldFilterTestAccounts,\n            },\n        ],\n\n        propertyFilters: [\n            [] as AnyPropertyFilter[],\n            {\n                setPropertyFilters: (_, { propertyFilters }) => propertyFilters,\n            },\n        ],\n\n        generationsQueryOverride: [\n            null as DataTableNode | null,\n            {\n                setGenerationsQuery: (_, { query }) => query,\n            },\n        ],\n\n        tracesQueryOverride: [\n            null as DataTableNode | null,\n            {\n                setTracesQuery: (_, { query }) => query,\n            },\n        ],\n\n        refreshStatus: [\n            {} as Record<string, { loading?: boolean; timer?: Date }>,\n            {\n                setRefreshStatus: (state, { tileId, loading }) => ({\n                    ...state,\n                    [tileId]: loading ? { loading: true, timer: new Date() } : state[tileId],\n                }),\n                refreshAllDashboardItems: () => ({}),\n            },\n        ],\n        newestRefreshed: [\n            null as Date | null,\n            {\n                setRefreshStatus: (state, { loading }) => (!loading ? new Date() : state),\n            },\n        ],\n    }),\n\n    loaders({\n        hasSentAiGenerationEvent: {\n            __default: undefined as boolean | undefined,\n            loadAIEventDefinition: async (): Promise<boolean> => {\n                const aiGenerationDefinition = await api.eventDefinitions.list({\n                    event_type: EventDefinitionType.Event,\n                    search: '$ai_generation',\n                })\n\n                // no need to worry about pagination here, event names beginning with $ are reserved, and we're not\n                // going to add enough reserved event names that match this search term to cause problems\n                const definition = aiGenerationDefinition.results.find((r) => r.name === '$ai_generation')\n                if (definition && !isDefinitionStale(definition)) {\n                    return true\n                }\n                return false\n            },\n        },\n    }),\n\n    selectors({\n        activeTab: [\n            (s) => [s.sceneKey],\n            (sceneKey) => {\n                if (sceneKey === 'llmObservabilityGenerations') {\n                    return 'generations'\n                } else if (sceneKey === 'llmObservabilityTraces') {\n                    return 'traces'\n                } else if (sceneKey === 'llmObservabilityUsers') {\n                    return 'users'\n                }\n                return 'dashboard'\n            },\n        ],\n\n        tiles: [\n            (s) => [s.dashboardDateFilter, s.shouldFilterTestAccounts, s.propertyFilters],\n            (dashboardDateFilter, shouldFilterTestAccounts, propertyFilters): QueryTile[] => [\n                {\n                    title: 'Traces',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                                math: HogQLMathType.HogQL,\n                                math_hogql: 'COUNT(DISTINCT properties.$ai_trace_id)',\n                            },\n                        ],\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        insightProps: {\n                            dashboardItemId: `new-traces-query`,\n                        },\n                        onDataPointClick: (series) => {\n                            if (typeof series.day === 'string') {\n                                // NOTE: This assumes the chart is day-by-day\n                                const dayStart = dayjs(series.day).startOf('day')\n                                router.actions.push(urls.llmObservabilityTraces(), {\n                                    ...router.values.searchParams,\n                                    date_from: dayStart.format('YYYY-MM-DD[T]HH:mm:ss'),\n                                    date_to: dayStart\n                                        .add(1, 'day')\n                                        .subtract(1, 'second')\n                                        .format('YYYY-MM-DD[T]HH:mm:ss'),\n                                })\n                            }\n                        },\n                    },\n                },\n                {\n                    title: 'Generative AI users',\n                    description: 'To count users, set `distinct_id` in LLM tracking.',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                                math: BaseMathType.UniqueUsers,\n                            },\n                        ],\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters.concat({\n                            type: PropertyFilterType.HogQL,\n                            key: 'distinct_id != properties.$ai_trace_id',\n                        }),\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        insightProps: {\n                            dashboardItemId: `new-generations-query`,\n                        },\n                    },\n                },\n                {\n                    title: 'Total cost (USD)',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                math: PropertyMathType.Sum,\n                                kind: NodeKind.EventsNode,\n                                math_property: '$ai_total_cost_usd',\n                            },\n                        ],\n                        trendsFilter: {\n                            aggregationAxisPrefix: '$',\n                            decimalPlaces: 4,\n                            display: ChartDisplayType.BoldNumber,\n                        },\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        groupTypeLabel: 'traces',\n                        onDataPointClick: () => {\n                            router.actions.push(urls.llmObservabilityTraces(), router.values.searchParams)\n                        },\n                    },\n                },\n                {\n                    title: 'Cost per user (USD)',\n                    description: \"Average cost for each generative AI user active in the data point's period.\",\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                math: PropertyMathType.Sum,\n                                kind: NodeKind.EventsNode,\n                                math_property: '$ai_total_cost_usd',\n                            },\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                                math: BaseMathType.UniqueUsers,\n                            },\n                        ],\n                        trendsFilter: {\n                            formula: 'A / B',\n                            aggregationAxisPrefix: '$',\n                            decimalPlaces: 2,\n                        },\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters.concat({\n                            type: PropertyFilterType.HogQL,\n                            key: 'distinct_id != properties.$ai_trace_id',\n                        }),\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        insightProps: {\n                            dashboardItemId: `new-cost-per-user-query`,\n                        },\n                    },\n                },\n                {\n                    title: 'Cost by model (USD)',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                math: PropertyMathType.Sum,\n                                kind: NodeKind.EventsNode,\n                                math_property: '$ai_total_cost_usd',\n                            },\n                        ],\n                        breakdownFilter: {\n                            breakdown_type: 'event',\n                            breakdown: '$ai_model',\n                        },\n                        trendsFilter: {\n                            aggregationAxisPrefix: '$',\n                            decimalPlaces: 2,\n                            display: ChartDisplayType.ActionsBarValue,\n                            showValuesOnSeries: true,\n                        },\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        groupTypeLabel: 'traces',\n                        onDataPointClick: ({ breakdown }) => {\n                            router.actions.push(urls.llmObservabilityTraces(), {\n                                ...router.values.searchParams,\n                                filters: [\n                                    ...(router.values.searchParams.filters || []),\n                                    {\n                                        type: PropertyFilterType.Event,\n                                        key: '$ai_model',\n                                        operator: PropertyOperator.Exact,\n                                        value: breakdown as string,\n                                    },\n                                ],\n                            })\n                        },\n                    },\n                },\n                {\n                    title: 'Generation calls',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                            },\n                        ],\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        groupTypeLabel: 'generations',\n                        insightProps: {\n                            dashboardItemId: `new-generation-calls-query`,\n                        },\n                        onDataPointClick: (series) => {\n                            if (typeof series.day === 'string') {\n                                const dayStart = dayjs(series.day).startOf('day')\n                                router.actions.push(urls.llmObservabilityGenerations(), {\n                                    ...router.values.searchParams,\n                                    date_from: dayStart.format('YYYY-MM-DD[T]HH:mm:ss'),\n                                    date_to: dayStart\n                                        .add(1, 'day')\n                                        .subtract(1, 'second')\n                                        .format('YYYY-MM-DD[T]HH:mm:ss'),\n                                })\n                            }\n                        },\n                    },\n                },\n                {\n                    title: 'Generation latency by model (median)',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                math: PropertyMathType.Median,\n                                kind: NodeKind.EventsNode,\n                                math_property: '$ai_latency',\n                            },\n                        ],\n                        breakdownFilter: {\n                            breakdown: '$ai_model',\n                        },\n                        trendsFilter: {\n                            aggregationAxisPostfix: ' s',\n                            decimalPlaces: 2,\n                        },\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        groupTypeLabel: 'generations',\n                        insightProps: {\n                            dashboardItemId: `new-generation-latency-by-model-query`,\n                        },\n                        onDataPointClick: (series) => {\n                            if (typeof series.day === 'string') {\n                                const dayStart = dayjs(series.day).startOf('day')\n                                router.actions.push(urls.llmObservabilityGenerations(), {\n                                    ...router.values.searchParams,\n                                    date_from: dayStart.format('YYYY-MM-DD[T]HH:mm:ss'),\n                                    date_to: dayStart\n                                        .add(1, 'day')\n                                        .subtract(1, 'second')\n                                        .format('YYYY-MM-DD[T]HH:mm:ss'),\n                                    filters: [\n                                        ...(router.values.searchParams.filters || []),\n                                        {\n                                            type: PropertyFilterType.Event,\n                                            key: '$ai_model',\n                                            operator: PropertyOperator.Exact,\n                                            value: series.breakdown as string,\n                                        },\n                                    ] as AnyPropertyFilter[],\n                                })\n                            }\n                        },\n                    },\n                },\n                {\n                    title: 'Generations by HTTP status',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                            },\n                        ],\n                        breakdownFilter: {\n                            breakdown: '$ai_http_status',\n                        },\n                        trendsFilter: {\n                            display: ChartDisplayType.ActionsBarValue,\n                        },\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        groupTypeLabel: 'generations',\n                        onDataPointClick: (series) => {\n                            router.actions.push(urls.llmObservabilityGenerations(), {\n                                ...router.values.searchParams,\n                                filters: [\n                                    ...(router.values.searchParams.filters || []),\n                                    {\n                                        type: PropertyFilterType.Event,\n                                        key: '$ai_http_status',\n                                        operator: PropertyOperator.Exact,\n                                        value: series.breakdown as string,\n                                    },\n                                ] as AnyPropertyFilter[],\n                            })\n                        },\n                    },\n                },\n            ],\n        ],\n\n        tracesQuery: [\n            (s) => [s.tracesQueryOverride, s.defaultTracesQuery],\n            (override, defQuery) => override || defQuery,\n        ],\n        defaultTracesQuery: [\n            (s) => [\n                s.dateFilter,\n                s.shouldFilterTestAccounts,\n                s.propertyFilters,\n                groupsModel.selectors.groupsTaxonomicTypes,\n            ],\n            (dateFilter, shouldFilterTestAccounts, propertyFilters, groupsTaxonomicTypes): DataTableNode => ({\n                kind: NodeKind.DataTableNode,\n                source: {\n                    kind: NodeKind.TracesQuery,\n                    dateRange: {\n                        date_from: dateFilter.dateFrom || undefined,\n                        date_to: dateFilter.dateTo || undefined,\n                    },\n                    filterTestAccounts: shouldFilterTestAccounts ?? false,\n                    properties: propertyFilters,\n                },\n                columns: ['id', 'traceName', 'person', 'totalLatency', 'usage', 'totalCost', 'timestamp'],\n                showDateRange: true,\n                showReload: true,\n                showSearch: true,\n                showTestAccountFilters: true,\n                showExport: true,\n                showOpenEditorButton: false,\n                showColumnConfigurator: false,\n                showPropertyFilter: [\n                    TaxonomicFilterGroupType.EventProperties,\n                    TaxonomicFilterGroupType.PersonProperties,\n                    ...groupsTaxonomicTypes,\n                    TaxonomicFilterGroupType.Cohorts,\n                    TaxonomicFilterGroupType.HogQLExpression,\n                ],\n            }),\n        ],\n        generationsQuery: [\n            (s) => [s.generationsQueryOverride, s.defaultGenerationsQuery],\n            (override, defQuery) => override || defQuery,\n        ],\n        defaultGenerationsQuery: [\n            (s) => [\n                s.dateFilter,\n                s.shouldFilterTestAccounts,\n                s.propertyFilters,\n                groupsModel.selectors.groupsTaxonomicTypes,\n            ],\n            (dateFilter, shouldFilterTestAccounts, propertyFilters, groupsTaxonomicTypes): DataTableNode => ({\n                kind: NodeKind.DataTableNode,\n                source: {\n                    kind: NodeKind.EventsQuery,\n                    select: [\n                        '*',\n                        'uuid',\n                        'properties.$ai_trace_id',\n                        'person',\n                        \"f'{properties.$ai_model}' -- Model\",\n                        \"f'{round(toFloat(properties.$ai_latency), 2)} s' -- Latency\",\n                        \"f'{properties.$ai_input_tokens} → {properties.$ai_output_tokens} (∑ {toInt(properties.$ai_input_tokens) + toInt(properties.$ai_output_tokens)})' -- Token usage\",\n                        \"f'${round(toFloat(properties.$ai_total_cost_usd), 6)}' -- Total cost\",\n                        'timestamp',\n                    ],\n                    orderBy: ['timestamp DESC'],\n                    after: dateFilter.dateFrom || undefined,\n                    before: dateFilter.dateTo || undefined,\n                    filterTestAccounts: shouldFilterTestAccounts,\n                    event: '$ai_generation',\n                    properties: propertyFilters,\n                },\n                showDateRange: true,\n                showReload: true,\n                showSearch: true,\n                showTestAccountFilters: true,\n                showColumnConfigurator: true,\n                showPropertyFilter: [\n                    TaxonomicFilterGroupType.EventProperties,\n                    TaxonomicFilterGroupType.PersonProperties,\n                    ...groupsTaxonomicTypes,\n                    TaxonomicFilterGroupType.Cohorts,\n                    TaxonomicFilterGroupType.HogQLExpression,\n                ],\n                showExport: true,\n                showActions: false,\n            }),\n        ],\n        usersQuery: [\n            (s) => [\n                s.dateFilter,\n                s.shouldFilterTestAccounts,\n                s.propertyFilters,\n                groupsModel.selectors.groupsTaxonomicTypes,\n            ],\n            (dateFilter, shouldFilterTestAccounts, propertyFilters, groupsTaxonomicTypes): DataTableNode => ({\n                kind: NodeKind.DataTableNode,\n                source: {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                SELECT\n                    argMax(user_tuple, timestamp) as user,\n                    countDistinctIf(ai_trace_id, notEmpty(ai_trace_id)) as traces,\n                    count() as generations,\n                    round(sum(toFloat(ai_total_cost_usd)), 4) as total_cost,\n                    min(timestamp) as first_seen,\n                    max(timestamp) as last_seen\n                FROM (\n                    SELECT \n                        distinct_id,\n                        timestamp,\n                        JSONExtractRaw(properties, '$ai_trace_id') as ai_trace_id,\n                        JSONExtractRaw(properties, '$ai_total_cost_usd') as ai_total_cost_usd,\n                        tuple(\n                            distinct_id,\n                            person.created_at,\n                            person.properties\n                        ) as user_tuple\n                    FROM events\n                    WHERE event = '$ai_generation' AND {filters}\n                )\n                GROUP BY distinct_id\n                ORDER BY total_cost DESC\n                LIMIT 50\n                    `,\n                    filters: {\n                        dateRange: {\n                            date_from: dateFilter.dateFrom || null,\n                            date_to: dateFilter.dateTo || null,\n                        },\n                        filterTestAccounts: shouldFilterTestAccounts,\n                        properties: propertyFilters,\n                    },\n                },\n                columns: ['user', 'traces', 'generations', 'total_cost', 'first_seen', 'last_seen'],\n                showDateRange: true,\n                showReload: true,\n                showSearch: true,\n                showPropertyFilter: [\n                    TaxonomicFilterGroupType.EventProperties,\n                    TaxonomicFilterGroupType.PersonProperties,\n                    ...groupsTaxonomicTypes,\n                    TaxonomicFilterGroupType.Cohorts,\n                    TaxonomicFilterGroupType.HogQLExpression,\n                ],\n                showTestAccountFilters: true,\n                showExport: true,\n                showColumnConfigurator: true,\n            }),\n        ],\n        isRefreshing: [\n            (s) => [s.refreshStatus],\n            (refreshStatus) => Object.values(refreshStatus).some((status) => status.loading),\n        ],\n    }),\n\n    urlToAction(({ actions, values }) => {\n        function applySearchParams({ filters, date_from, date_to, filter_test_accounts }: Record<string, any>): void {\n            // Reusing logic and naming from webAnalyticsLogic\n            const parsedFilters = isAnyPropertyFilters(filters) ? filters : []\n            if (!objectsEqual(parsedFilters, values.propertyFilters)) {\n                actions.setPropertyFilters(parsedFilters)\n            }\n            if (\n                (date_from || INITIAL_EVENTS_DATE_FROM) !== values.dateFilter.dateFrom ||\n                (date_to || INITIAL_DATE_TO) !== values.dateFilter.dateTo\n            ) {\n                actions.setDates(date_from || INITIAL_EVENTS_DATE_FROM, date_to || INITIAL_DATE_TO)\n            }\n            const filterTestAccountsValue = [true, 'true', 1, '1'].includes(filter_test_accounts)\n            if (filterTestAccountsValue !== values.shouldFilterTestAccounts) {\n                actions.setShouldFilterTestAccounts(filterTestAccountsValue)\n            }\n        }\n\n        return {\n            [urls.llmObservabilityDashboard()]: (_, searchParams) => applySearchParams(searchParams),\n            [urls.llmObservabilityGenerations()]: (_, searchParams) => applySearchParams(searchParams),\n            [urls.llmObservabilityTraces()]: (_, searchParams) => applySearchParams(searchParams),\n            [urls.llmObservabilityUsers()]: (_, searchParams) => applySearchParams(searchParams),\n        }\n    }),\n\n    actionToUrl(() => ({\n        setPropertyFilters: ({ propertyFilters }) => [\n            router.values.location.pathname,\n            {\n                ...router.values.searchParams,\n                filters: propertyFilters.length > 0 ? propertyFilters : undefined,\n            },\n        ],\n        setDates: ({ dateFrom, dateTo }) => [\n            router.values.location.pathname,\n            {\n                ...router.values.searchParams,\n                date_from: dateFrom === INITIAL_EVENTS_DATE_FROM ? undefined : dateFrom || undefined,\n                date_to: dateTo || undefined,\n            },\n        ],\n        setShouldFilterTestAccounts: ({ shouldFilterTestAccounts }) => [\n            router.values.location.pathname,\n            {\n                ...router.values.searchParams,\n                filter_test_accounts: shouldFilterTestAccounts ? 'true' : undefined,\n            },\n        ],\n    })),\n\n    afterMount(({ actions }) => {\n        actions.loadAIEventDefinition()\n    }),\n\n    listeners(({ actions, values }) => ({\n        refreshAllDashboardItems: async () => {\n            // Set loading state for all tiles\n            values.tiles.forEach((_, index) => {\n                actions.setRefreshStatus(`tile-${index}`, true)\n            })\n\n            try {\n                // Refresh all tiles in parallel\n                values.tiles.map((tile, index) => {\n                    const insightProps = {\n                        dashboardItemId: tile.context?.insightProps?.dashboardItemId as InsightShortId,\n                    }\n                    const mountedInsightDataLogic = insightDataLogic.findMounted(insightProps)\n                    if (mountedInsightDataLogic) {\n                        mountedInsightDataLogic.actions.loadData('force_blocking')\n                    }\n                    actions.setRefreshStatus(`tile-${index}`, false)\n                })\n            } catch (error) {\n                console.error('Error refreshing dashboard items:', error)\n                // Clear loading states on error\n                values.tiles.forEach((_, index) => {\n                    actions.setRefreshStatus(`tile-${index}`, false)\n                })\n            }\n        },\n    })),\n])\n"],"names":[],"sourceRoot":""}