(self.webpackChunk_posthog_storybook=self.webpackChunk_posthog_storybook||[]).push([[39796],{"../../node_modules/.pnpm/@xyflow+react@12.6.0_@types+react@17.0.52_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@xyflow/react/dist/esm/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Aq:()=>Background,T7:()=>BackgroundVariant,ZX:()=>Controls,HH:()=>Handle,a9:()=>MiniMap,x$:()=>index,tV:()=>ReactFlowProvider,yn:()=>applyEdgeChanges,Fb:()=>applyNodeChanges,_K:()=>useReactFlow,Bn:()=>useUpdateNodeInternals});var BackgroundVariant,jsx_runtime=__webpack_require__("../../node_modules/.pnpm/react@18.2.0/node_modules/react/jsx-runtime.js"),react=__webpack_require__("../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js");function classcat_cc(names){if("string"==typeof names||"number"==typeof names)return""+names;let out="";if(Array.isArray(names))for(let i=0,tmp;i<names.length;i++)""!==(tmp=classcat_cc(names[i]))&&(out+=(out&&" ")+tmp);else for(let k in names)names[k]&&(out+=(out&&" ")+k);return out}var esm=__webpack_require__("../../node_modules/.pnpm/@xyflow+system@0.0.57/node_modules/@xyflow/system/dist/esm/index.js"),with_selector=__webpack_require__("../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js");let createStoreImpl=createState=>{let state;let listeners=new Set,setState=(partial,replace)=>{let nextState="function"==typeof partial?partial(state):partial;if(!Object.is(nextState,state)){let previousState=state;state=(null!=replace?replace:"object"!=typeof nextState||null===nextState)?nextState:Object.assign({},state,nextState),listeners.forEach(listener=>listener(state,previousState))}},getState=()=>state,api={setState,getState,getInitialState:()=>initialState,subscribe:listener=>(listeners.add(listener),()=>listeners.delete(listener)),destroy:()=>{console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),listeners.clear()}},initialState=state=createState(setState,getState,api);return api},createStore=createState=>createState?createStoreImpl(createState):createStoreImpl,{useDebugValue}=react,{useSyncExternalStoreWithSelector}=with_selector,identity=arg=>arg;function useStoreWithEqualityFn(api,selector=identity,equalityFn){let slice=useSyncExternalStoreWithSelector(api.subscribe,api.getState,api.getServerState||api.getInitialState,selector,equalityFn);return useDebugValue(slice),slice}let createWithEqualityFnImpl=(createState,defaultEqualityFn)=>{let api=createStore(createState),useBoundStoreWithEqualityFn=(selector,equalityFn=defaultEqualityFn)=>useStoreWithEqualityFn(api,selector,equalityFn);return Object.assign(useBoundStoreWithEqualityFn,api),useBoundStoreWithEqualityFn},createWithEqualityFn=(createState,defaultEqualityFn)=>createState?createWithEqualityFnImpl(createState,defaultEqualityFn):createWithEqualityFnImpl;function shallow$1(objA,objB){if(Object.is(objA,objB))return!0;if("object"!=typeof objA||null===objA||"object"!=typeof objB||null===objB)return!1;if(objA instanceof Map&&objB instanceof Map){if(objA.size!==objB.size)return!1;for(let[key,value]of objA)if(!Object.is(value,objB.get(key)))return!1;return!0}if(objA instanceof Set&&objB instanceof Set){if(objA.size!==objB.size)return!1;for(let value of objA)if(!objB.has(value))return!1;return!0}let keysA=Object.keys(objA);if(keysA.length!==Object.keys(objB).length)return!1;for(let keyA of keysA)if(!Object.prototype.hasOwnProperty.call(objB,keyA)||!Object.is(objA[keyA],objB[keyA]))return!1;return!0}__webpack_require__("../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/index.js");let StoreContext=(0,react.createContext)(null),Provider$1=StoreContext.Provider,zustandErrorMessage=esm.Qj.error001();function useStore(selector,equalityFn){let store=(0,react.useContext)(StoreContext);if(null===store)throw Error(zustandErrorMessage);return useStoreWithEqualityFn(store,selector,equalityFn)}function useStoreApi(){let store=(0,react.useContext)(StoreContext);if(null===store)throw Error(zustandErrorMessage);return(0,react.useMemo)(()=>({getState:store.getState,setState:store.setState,subscribe:store.subscribe}),[store])}let style={display:"none"},ariaLiveStyle={position:"absolute",width:1,height:1,margin:-1,border:0,padding:0,overflow:"hidden",clip:"rect(0px, 0px, 0px, 0px)",clipPath:"inset(100%)"},ARIA_NODE_DESC_KEY="react-flow__node-desc",ARIA_EDGE_DESC_KEY="react-flow__edge-desc",selector$o=s=>s.ariaLiveMessage;function AriaLiveMessage({rfId}){let ariaLiveMessage=useStore(selector$o);return(0,jsx_runtime.jsx)("div",{id:`react-flow__aria-live-${rfId}`,"aria-live":"assertive","aria-atomic":"true",style:ariaLiveStyle,children:ariaLiveMessage})}function A11yDescriptions({rfId,disableKeyboardA11y}){return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsxs)("div",{id:`${ARIA_NODE_DESC_KEY}-${rfId}`,style:style,children:["Press enter or space to select a node.",!disableKeyboardA11y&&"You can then use the arrow keys to move the node around."," Press delete to remove it and escape to cancel."," "]}),(0,jsx_runtime.jsx)("div",{id:`${ARIA_EDGE_DESC_KEY}-${rfId}`,style:style,children:"Press enter or space to select an edge. You can then press delete to remove it or escape to cancel."}),!disableKeyboardA11y&&(0,jsx_runtime.jsx)(AriaLiveMessage,{rfId:rfId})]})}let selector$n=s=>s.userSelectionActive?"none":"all",Panel=(0,react.forwardRef)(({position="top-left",children,className,style,...rest},ref)=>{let pointerEvents=useStore(selector$n),positionClasses=`${position}`.split("-");return(0,jsx_runtime.jsx)("div",{className:classcat_cc(["react-flow__panel",className,...positionClasses]),style:{...style,pointerEvents},ref:ref,...rest,children:children})});function Attribution({proOptions,position="bottom-right"}){return proOptions?.hideAttribution?null:(0,jsx_runtime.jsx)(Panel,{position:position,className:"react-flow__attribution","data-message":"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev",children:(0,jsx_runtime.jsx)("a",{href:"https://reactflow.dev",target:"_blank",rel:"noopener noreferrer","aria-label":"React Flow attribution",children:"React Flow"})})}Panel.displayName="Panel";let selector$m=s=>{let selectedNodes=[],selectedEdges=[];for(let[,node]of s.nodeLookup)node.selected&&selectedNodes.push(node.internals.userNode);for(let[,edge]of s.edgeLookup)edge.selected&&selectedEdges.push(edge);return{selectedNodes,selectedEdges}},selectId=obj=>obj.id;function areEqual(a,b){return shallow$1(a.selectedNodes.map(selectId),b.selectedNodes.map(selectId))&&shallow$1(a.selectedEdges.map(selectId),b.selectedEdges.map(selectId))}function SelectionListenerInner({onSelectionChange}){let store=useStoreApi(),{selectedNodes,selectedEdges}=useStore(selector$m,areEqual);return(0,react.useEffect)(()=>{let params={nodes:selectedNodes,edges:selectedEdges};onSelectionChange?.(params),store.getState().onSelectionChangeHandlers.forEach(fn=>fn(params))},[selectedNodes,selectedEdges,onSelectionChange]),null}let changeSelector=s=>!!s.onSelectionChangeHandlers;function SelectionListener({onSelectionChange}){let storeHasSelectionChangeHandlers=useStore(changeSelector);return onSelectionChange||storeHasSelectionChangeHandlers?(0,jsx_runtime.jsx)(SelectionListenerInner,{onSelectionChange:onSelectionChange}):null}let defaultNodeOrigin=[0,0],defaultViewport={x:0,y:0,zoom:1},fieldsToTrack=["nodes","edges","defaultNodes","defaultEdges","onConnect","onConnectStart","onConnectEnd","onClickConnectStart","onClickConnectEnd","nodesDraggable","nodesConnectable","nodesFocusable","edgesFocusable","edgesReconnectable","elevateNodesOnSelect","elevateEdgesOnSelect","minZoom","maxZoom","nodeExtent","onNodesChange","onEdgesChange","elementsSelectable","connectionMode","snapGrid","snapToGrid","translateExtent","connectOnClick","defaultEdgeOptions","fitView","fitViewOptions","onNodesDelete","onEdgesDelete","onDelete","onNodeDrag","onNodeDragStart","onNodeDragStop","onSelectionDrag","onSelectionDragStart","onSelectionDragStop","onMoveStart","onMove","onMoveEnd","noPanClassName","nodeOrigin","autoPanOnConnect","autoPanOnNodeDrag","onError","connectionRadius","isValidConnection","selectNodesOnDrag","nodeDragThreshold","onBeforeDelete","debug","autoPanSpeed","paneClickDistance","rfId"],selector$l=s=>({setNodes:s.setNodes,setEdges:s.setEdges,setMinZoom:s.setMinZoom,setMaxZoom:s.setMaxZoom,setTranslateExtent:s.setTranslateExtent,setNodeExtent:s.setNodeExtent,reset:s.reset,setDefaultNodesAndEdges:s.setDefaultNodesAndEdges,setPaneClickDistance:s.setPaneClickDistance}),initPrevValues={translateExtent:esm.k5,nodeOrigin:defaultNodeOrigin,minZoom:.5,maxZoom:2,elementsSelectable:!0,noPanClassName:"nopan",rfId:"1",paneClickDistance:0};function StoreUpdater(props){let{setNodes,setEdges,setMinZoom,setMaxZoom,setTranslateExtent,setNodeExtent,reset,setDefaultNodesAndEdges,setPaneClickDistance}=useStore(selector$l,shallow$1),store=useStoreApi();(0,react.useEffect)(()=>(setDefaultNodesAndEdges(props.defaultNodes,props.defaultEdges),()=>{previousFields.current=initPrevValues,reset()}),[]);let previousFields=(0,react.useRef)(initPrevValues);return(0,react.useEffect)(()=>{for(let fieldName of fieldsToTrack){let fieldValue=props[fieldName];fieldValue!==previousFields.current[fieldName]&&void 0!==props[fieldName]&&("nodes"===fieldName?setNodes(fieldValue):"edges"===fieldName?setEdges(fieldValue):"minZoom"===fieldName?setMinZoom(fieldValue):"maxZoom"===fieldName?setMaxZoom(fieldValue):"translateExtent"===fieldName?setTranslateExtent(fieldValue):"nodeExtent"===fieldName?setNodeExtent(fieldValue):"paneClickDistance"===fieldName?setPaneClickDistance(fieldValue):"fitView"===fieldName?store.setState({fitViewQueued:fieldValue}):"fitViewOptions"===fieldName?store.setState({fitViewOptions:fieldValue}):store.setState({[fieldName]:fieldValue}))}previousFields.current=props},fieldsToTrack.map(fieldName=>props[fieldName])),null}function getMediaQuery(){return"undefined"!=typeof window&&window.matchMedia?window.matchMedia("(prefers-color-scheme: dark)"):null}function useColorModeClass(colorMode){let[colorModeClass,setColorModeClass]=(0,react.useState)("system"===colorMode?null:colorMode);return(0,react.useEffect)(()=>{if("system"!==colorMode){setColorModeClass(colorMode);return}let mediaQuery=getMediaQuery(),updateColorModeClass=()=>setColorModeClass(mediaQuery?.matches?"dark":"light");return updateColorModeClass(),mediaQuery?.addEventListener("change",updateColorModeClass),()=>{mediaQuery?.removeEventListener("change",updateColorModeClass)}},[colorMode]),null!==colorModeClass?colorModeClass:getMediaQuery()?.matches?"dark":"light"}let defaultDoc="undefined"!=typeof document?document:null;function useKeyPress(keyCode=null,options={target:defaultDoc,actInsideInputWithModifier:!0}){let[keyPressed,setKeyPressed]=(0,react.useState)(!1),modifierPressed=(0,react.useRef)(!1),pressedKeys=(0,react.useRef)(new Set([])),[keyCodes,keysToWatch]=(0,react.useMemo)(()=>{if(null!==keyCode){let keys=(Array.isArray(keyCode)?keyCode:[keyCode]).filter(kc=>"string"==typeof kc).map(kc=>kc.replace("+","\n").replace("\n\n","\n+").split("\n")),keysFlat=keys.reduce((res,item)=>res.concat(...item),[]);return[keys,keysFlat]}return[[],[]]},[keyCode]);return(0,react.useEffect)(()=>{let target=options?.target||defaultDoc;if(null!==keyCode){let downHandler=event=>{if(modifierPressed.current=event.ctrlKey||event.metaKey||event.shiftKey||event.altKey,(!modifierPressed.current||modifierPressed.current&&!options.actInsideInputWithModifier)&&(0,esm.s$)(event))return!1;let keyOrCode=useKeyOrCode(event.code,keysToWatch);if(pressedKeys.current.add(event[keyOrCode]),isMatchingKey(keyCodes,pressedKeys.current,!1)){let target=event.composedPath?.()?.[0]||event.target,isInteractiveElement=target?.nodeName==="BUTTON"||target?.nodeName==="A";!1!==options.preventDefault&&(modifierPressed.current||!isInteractiveElement)&&event.preventDefault(),setKeyPressed(!0)}},upHandler=event=>{let keyOrCode=useKeyOrCode(event.code,keysToWatch);isMatchingKey(keyCodes,pressedKeys.current,!0)?(setKeyPressed(!1),pressedKeys.current.clear()):pressedKeys.current.delete(event[keyOrCode]),"Meta"===event.key&&pressedKeys.current.clear(),modifierPressed.current=!1},resetHandler=()=>{pressedKeys.current.clear(),setKeyPressed(!1)};return target?.addEventListener("keydown",downHandler),target?.addEventListener("keyup",upHandler),window.addEventListener("blur",resetHandler),window.addEventListener("contextmenu",resetHandler),()=>{target?.removeEventListener("keydown",downHandler),target?.removeEventListener("keyup",upHandler),window.removeEventListener("blur",resetHandler),window.removeEventListener("contextmenu",resetHandler)}}},[keyCode,setKeyPressed]),keyPressed}function isMatchingKey(keyCodes,pressedKeys,isUp){return keyCodes.filter(keys=>isUp||keys.length===pressedKeys.size).some(keys=>keys.every(k=>pressedKeys.has(k)))}function useKeyOrCode(eventCode,keysToWatch){return keysToWatch.includes(eventCode)?"code":"key"}let useViewportHelper=()=>{let store=useStoreApi();return(0,react.useMemo)(()=>({zoomIn:options=>{let{panZoom}=store.getState();return panZoom?panZoom.scaleBy(1.2,{duration:options?.duration}):Promise.resolve(!1)},zoomOut:options=>{let{panZoom}=store.getState();return panZoom?panZoom.scaleBy(1/1.2,{duration:options?.duration}):Promise.resolve(!1)},zoomTo:(zoomLevel,options)=>{let{panZoom}=store.getState();return panZoom?panZoom.scaleTo(zoomLevel,{duration:options?.duration}):Promise.resolve(!1)},getZoom:()=>store.getState().transform[2],setViewport:async(viewport,options)=>{let{transform:[tX,tY,tZoom],panZoom}=store.getState();return panZoom?(await panZoom.setViewport({x:viewport.x??tX,y:viewport.y??tY,zoom:viewport.zoom??tZoom},{duration:options?.duration}),Promise.resolve(!0)):Promise.resolve(!1)},getViewport:()=>{let[x,y,zoom]=store.getState().transform;return{x,y,zoom}},setCenter:async(x,y,options)=>{let{width,height,maxZoom,panZoom}=store.getState(),nextZoom=void 0!==options?.zoom?options.zoom:maxZoom;return panZoom?(await panZoom.setViewport({x:width/2-x*nextZoom,y:height/2-y*nextZoom,zoom:nextZoom},{duration:options?.duration}),Promise.resolve(!0)):Promise.resolve(!1)},fitBounds:async(bounds,options)=>{let{width,height,minZoom,maxZoom,panZoom}=store.getState(),viewport=(0,esm.$i)(bounds,width,height,minZoom,maxZoom,options?.padding??.1);return panZoom?(await panZoom.setViewport(viewport,{duration:options?.duration}),Promise.resolve(!0)):Promise.resolve(!1)},screenToFlowPosition:(clientPosition,options={})=>{let{transform,snapGrid,snapToGrid,domNode}=store.getState();if(!domNode)return clientPosition;let{x:domX,y:domY}=domNode.getBoundingClientRect(),correctedPosition={x:clientPosition.x-domX,y:clientPosition.y-domY},_snapGrid=options.snapGrid??snapGrid,_snapToGrid=options.snapToGrid??snapToGrid;return(0,esm.m)(correctedPosition,transform,_snapToGrid,_snapGrid)},flowToScreenPosition:flowPosition=>{let{transform,domNode}=store.getState();if(!domNode)return flowPosition;let{x:domX,y:domY}=domNode.getBoundingClientRect(),rendererPosition=(0,esm.oj)(flowPosition,transform);return{x:rendererPosition.x+domX,y:rendererPosition.y+domY}}}),[])};function applyChanges(changes,elements){let updatedElements=[],changesMap=new Map,addItemChanges=[];for(let change of changes){if("add"===change.type){addItemChanges.push(change);continue}if("remove"===change.type||"replace"===change.type)changesMap.set(change.id,[change]);else{let elementChanges=changesMap.get(change.id);elementChanges?elementChanges.push(change):changesMap.set(change.id,[change])}}for(let element of elements){let changes=changesMap.get(element.id);if(!changes){updatedElements.push(element);continue}if("remove"===changes[0].type)continue;if("replace"===changes[0].type){updatedElements.push({...changes[0].item});continue}let updatedElement={...element};for(let change of changes)applyChange(change,updatedElement);updatedElements.push(updatedElement)}return addItemChanges.length&&addItemChanges.forEach(change=>{void 0!==change.index?updatedElements.splice(change.index,0,{...change.item}):updatedElements.push({...change.item})}),updatedElements}function applyChange(change,element){switch(change.type){case"select":element.selected=change.selected;break;case"position":void 0!==change.position&&(element.position=change.position),void 0!==change.dragging&&(element.dragging=change.dragging);break;case"dimensions":void 0!==change.dimensions&&(element.measured??={},element.measured.width=change.dimensions.width,element.measured.height=change.dimensions.height,change.setAttributes&&((!0===change.setAttributes||"width"===change.setAttributes)&&(element.width=change.dimensions.width),(!0===change.setAttributes||"height"===change.setAttributes)&&(element.height=change.dimensions.height))),"boolean"==typeof change.resizing&&(element.resizing=change.resizing)}}function applyNodeChanges(changes,nodes){return applyChanges(changes,nodes)}function applyEdgeChanges(changes,edges){return applyChanges(changes,edges)}function createSelectionChange(id,selected){return{id,type:"select",selected}}function getSelectionChanges(items,selectedIds=new Set,mutateItem=!1){let changes=[];for(let[id,item]of items){let willBeSelected=selectedIds.has(id);void 0===item.selected&&!willBeSelected||item.selected===willBeSelected||(mutateItem&&(item.selected=willBeSelected),changes.push(createSelectionChange(item.id,willBeSelected)))}return changes}function getElementsDiffChanges({items=[],lookup}){let changes=[],itemsLookup=new Map(items.map(item=>[item.id,item]));for(let[index,item]of items.entries()){let lookupItem=lookup.get(item.id),storeItem=lookupItem?.internals?.userNode??lookupItem;void 0!==storeItem&&storeItem!==item&&changes.push({id:item.id,item:item,type:"replace"}),void 0===storeItem&&changes.push({item:item,type:"add",index})}for(let[id]of lookup)void 0===itemsLookup.get(id)&&changes.push({id,type:"remove"});return changes}function elementToRemoveChange(item){return{id:item.id,type:"remove"}}let isNode=element=>(0,esm.Vt)(element),isEdge=element=>(0,esm.J3)(element);function fixedForwardRef(render){return(0,react.forwardRef)(render)}let useIsomorphicLayoutEffect="undefined"!=typeof window?react.useLayoutEffect:react.useEffect;function useQueue(runQueue){let[serial,setSerial]=(0,react.useState)(BigInt(0)),[queue]=(0,react.useState)(()=>createQueue(()=>setSerial(n=>n+BigInt(1))));return useIsomorphicLayoutEffect(()=>{let queueItems=queue.get();queueItems.length&&(runQueue(queueItems),queue.reset())},[serial]),queue}function createQueue(cb){let queue=[];return{get:()=>queue,reset:()=>{queue=[]},push:item=>{queue.push(item),cb()}}}let BatchContext=(0,react.createContext)(null);function BatchProvider({children}){let store=useStoreApi(),nodeQueue=useQueue((0,react.useCallback)(queueItems=>{let{nodes=[],setNodes,hasDefaultNodes,onNodesChange,nodeLookup,fitViewQueued}=store.getState(),next=nodes;for(let payload of queueItems)next="function"==typeof payload?payload(next):payload;if(hasDefaultNodes)setNodes(next);else{let changes=getElementsDiffChanges({items:next,lookup:nodeLookup});changes.length>0?onNodesChange?.(changes):fitViewQueued&&window.requestAnimationFrame(()=>{let{fitViewQueued,nodes,setNodes}=store.getState();fitViewQueued&&setNodes(nodes)})}},[])),edgeQueue=useQueue((0,react.useCallback)(queueItems=>{let{edges=[],setEdges,hasDefaultEdges,onEdgesChange,edgeLookup}=store.getState(),next=edges;for(let payload of queueItems)next="function"==typeof payload?payload(next):payload;hasDefaultEdges?setEdges(next):onEdgesChange&&onEdgesChange(getElementsDiffChanges({items:next,lookup:edgeLookup}))},[])),value=(0,react.useMemo)(()=>({nodeQueue,edgeQueue}),[]);return(0,jsx_runtime.jsx)(BatchContext.Provider,{value:value,children:children})}function useBatchContext(){let batchContext=(0,react.useContext)(BatchContext);if(!batchContext)throw Error("useBatchContext must be used within a BatchProvider");return batchContext}let selector$k=s=>!!s.panZoom;function useReactFlow(){let viewportHelper=useViewportHelper(),store=useStoreApi(),batchContext=useBatchContext(),viewportInitialized=useStore(selector$k),generalHelper=(0,react.useMemo)(()=>{let getInternalNode=id=>store.getState().nodeLookup.get(id),setNodes=payload=>{batchContext.nodeQueue.push(payload)},setEdges=payload=>{batchContext.edgeQueue.push(payload)},getNodeRect=node=>{let{nodeLookup,nodeOrigin}=store.getState(),nodeToUse=isNode(node)?node:nodeLookup.get(node.id),position=nodeToUse.parentId?(0,esm.ZB)(nodeToUse.position,nodeToUse.measured,nodeToUse.parentId,nodeLookup,nodeOrigin):nodeToUse.position,nodeWithPosition={...nodeToUse,position,width:nodeToUse.measured?.width??nodeToUse.width,height:nodeToUse.measured?.height??nodeToUse.height};return(0,esm.PS)(nodeWithPosition)},updateNode=(id,nodeUpdate,options={replace:!1})=>{setNodes(prevNodes=>prevNodes.map(node=>{if(node.id===id){let nextNode="function"==typeof nodeUpdate?nodeUpdate(node):nodeUpdate;return options.replace&&isNode(nextNode)?nextNode:{...node,...nextNode}}return node}))},updateEdge=(id,edgeUpdate,options={replace:!1})=>{setEdges(prevEdges=>prevEdges.map(edge=>{if(edge.id===id){let nextEdge="function"==typeof edgeUpdate?edgeUpdate(edge):edgeUpdate;return options.replace&&isEdge(nextEdge)?nextEdge:{...edge,...nextEdge}}return edge}))};return{getNodes:()=>store.getState().nodes.map(n=>({...n})),getNode:id=>getInternalNode(id)?.internals.userNode,getInternalNode,getEdges:()=>{let{edges=[]}=store.getState();return edges.map(e=>({...e}))},getEdge:id=>store.getState().edgeLookup.get(id),setNodes,setEdges,addNodes:payload=>{let newNodes=Array.isArray(payload)?payload:[payload];batchContext.nodeQueue.push(nodes=>[...nodes,...newNodes])},addEdges:payload=>{let newEdges=Array.isArray(payload)?payload:[payload];batchContext.edgeQueue.push(edges=>[...edges,...newEdges])},toObject:()=>{let{nodes=[],edges=[],transform}=store.getState(),[x,y,zoom]=transform;return{nodes:nodes.map(n=>({...n})),edges:edges.map(e=>({...e})),viewport:{x,y,zoom}}},deleteElements:async({nodes:nodesToRemove=[],edges:edgesToRemove=[]})=>{let{nodes,edges,onNodesDelete,onEdgesDelete,triggerNodeChanges,triggerEdgeChanges,onDelete,onBeforeDelete}=store.getState(),{nodes:matchingNodes,edges:matchingEdges}=await (0,esm.WD)({nodesToRemove,edgesToRemove,nodes,edges,onBeforeDelete}),hasMatchingEdges=matchingEdges.length>0,hasMatchingNodes=matchingNodes.length>0;if(hasMatchingEdges){let edgeChanges=matchingEdges.map(elementToRemoveChange);onEdgesDelete?.(matchingEdges),triggerEdgeChanges(edgeChanges)}if(hasMatchingNodes){let nodeChanges=matchingNodes.map(elementToRemoveChange);onNodesDelete?.(matchingNodes),triggerNodeChanges(nodeChanges)}return(hasMatchingNodes||hasMatchingEdges)&&onDelete?.({nodes:matchingNodes,edges:matchingEdges}),{deletedNodes:matchingNodes,deletedEdges:matchingEdges}},getIntersectingNodes:(nodeOrRect,partially=!0,nodes)=>{let isRect=(0,esm.J$)(nodeOrRect),nodeRect=isRect?nodeOrRect:getNodeRect(nodeOrRect),hasNodesOption=void 0!==nodes;return nodeRect?(nodes||store.getState().nodes).filter(n=>{let internalNode=store.getState().nodeLookup.get(n.id);if(internalNode&&!isRect&&(n.id===nodeOrRect.id||!internalNode.internals.positionAbsolute))return!1;let currNodeRect=(0,esm.PS)(hasNodesOption?n:internalNode),overlappingArea=(0,esm.lp)(currNodeRect,nodeRect);return partially&&overlappingArea>0||overlappingArea>=nodeRect.width*nodeRect.height}):[]},isNodeIntersecting:(nodeOrRect,area,partially=!0)=>{let nodeRect=(0,esm.J$)(nodeOrRect)?nodeOrRect:getNodeRect(nodeOrRect);if(!nodeRect)return!1;let overlappingArea=(0,esm.lp)(nodeRect,area);return partially&&overlappingArea>0||overlappingArea>=nodeRect.width*nodeRect.height},updateNode,updateNodeData:(id,dataUpdate,options={replace:!1})=>{updateNode(id,node=>{let nextData="function"==typeof dataUpdate?dataUpdate(node):dataUpdate;return options.replace?{...node,data:nextData}:{...node,data:{...node.data,...nextData}}},options)},updateEdge,updateEdgeData:(id,dataUpdate,options={replace:!1})=>{updateEdge(id,edge=>{let nextData="function"==typeof dataUpdate?dataUpdate(edge):dataUpdate;return options.replace?{...edge,data:nextData}:{...edge,data:{...edge.data,...nextData}}},options)},getNodesBounds:nodes=>{let{nodeLookup,nodeOrigin}=store.getState();return(0,esm.RX)(nodes,{nodeLookup,nodeOrigin})},getHandleConnections:({type,id,nodeId})=>Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id?`-${id}`:""}`)?.values()??[]),getNodeConnections:({type,handleId,nodeId})=>Array.from(store.getState().connectionLookup.get(`${nodeId}${type?handleId?`-${type}-${handleId}`:`-${type}`:""}`)?.values()??[]),fitView:async options=>{let fitViewResolver=store.getState().fitViewResolver??(0,esm.nu)();return store.setState({fitViewQueued:!0,fitViewOptions:options,fitViewResolver}),batchContext.nodeQueue.push(nodes=>[...nodes]),fitViewResolver.promise}}},[]);return(0,react.useMemo)(()=>({...generalHelper,...viewportHelper,viewportInitialized}),[viewportInitialized])}let selected=item=>item.selected,deleteKeyOptions={actInsideInputWithModifier:!1},win$1="undefined"!=typeof window?window:void 0;function useGlobalKeyHandler({deleteKeyCode,multiSelectionKeyCode}){let store=useStoreApi(),{deleteElements}=useReactFlow(),deleteKeyPressed=useKeyPress(deleteKeyCode,deleteKeyOptions),multiSelectionKeyPressed=useKeyPress(multiSelectionKeyCode,{target:win$1});(0,react.useEffect)(()=>{if(deleteKeyPressed){let{edges,nodes}=store.getState();deleteElements({nodes:nodes.filter(selected),edges:edges.filter(selected)}),store.setState({nodesSelectionActive:!1})}},[deleteKeyPressed]),(0,react.useEffect)(()=>{store.setState({multiSelectionActive:multiSelectionKeyPressed})},[multiSelectionKeyPressed])}function useResizeHandler(domNode){let store=useStoreApi();(0,react.useEffect)(()=>{let updateDimensions=()=>{if(!domNode.current)return!1;let size=(0,esm.t_)(domNode.current);(0===size.height||0===size.width)&&store.getState().onError?.("004",esm.Qj.error004()),store.setState({width:size.width||500,height:size.height||500})};if(domNode.current){updateDimensions(),window.addEventListener("resize",updateDimensions);let resizeObserver=new ResizeObserver(()=>updateDimensions());return resizeObserver.observe(domNode.current),()=>{window.removeEventListener("resize",updateDimensions),resizeObserver&&domNode.current&&resizeObserver.unobserve(domNode.current)}}},[])}let containerStyle={position:"absolute",width:"100%",height:"100%",top:0,left:0},selector$j=s=>({userSelectionActive:s.userSelectionActive,lib:s.lib});function ZoomPane({onPaneContextMenu,zoomOnScroll=!0,zoomOnPinch=!0,panOnScroll=!1,panOnScrollSpeed=.5,panOnScrollMode=esm.IY.Free,zoomOnDoubleClick=!0,panOnDrag=!0,defaultViewport,translateExtent,minZoom,maxZoom,zoomActivationKeyCode,preventScrolling=!0,children,noWheelClassName,noPanClassName,onViewportChange,isControlledViewport,paneClickDistance}){let store=useStoreApi(),zoomPane=(0,react.useRef)(null),{userSelectionActive,lib}=useStore(selector$j,shallow$1),zoomActivationKeyPressed=useKeyPress(zoomActivationKeyCode),panZoom=(0,react.useRef)();useResizeHandler(zoomPane);let onTransformChange=(0,react.useCallback)(transform=>{onViewportChange?.({x:transform[0],y:transform[1],zoom:transform[2]}),isControlledViewport||store.setState({transform})},[onViewportChange,isControlledViewport]);return(0,react.useEffect)(()=>{if(zoomPane.current){panZoom.current=(0,esm.X6)({domNode:zoomPane.current,minZoom,maxZoom,translateExtent,viewport:defaultViewport,paneClickDistance,onDraggingChange:paneDragging=>store.setState({paneDragging}),onPanZoomStart:(event,vp)=>{let{onViewportChangeStart,onMoveStart}=store.getState();onMoveStart?.(event,vp),onViewportChangeStart?.(vp)},onPanZoom:(event,vp)=>{let{onViewportChange,onMove}=store.getState();onMove?.(event,vp),onViewportChange?.(vp)},onPanZoomEnd:(event,vp)=>{let{onViewportChangeEnd,onMoveEnd}=store.getState();onMoveEnd?.(event,vp),onViewportChangeEnd?.(vp)}});let{x,y,zoom}=panZoom.current.getViewport();return store.setState({panZoom:panZoom.current,transform:[x,y,zoom],domNode:zoomPane.current.closest(".react-flow")}),()=>{panZoom.current?.destroy()}}},[]),(0,react.useEffect)(()=>{panZoom.current?.update({onPaneContextMenu,zoomOnScroll,zoomOnPinch,panOnScroll,panOnScrollSpeed,panOnScrollMode,zoomOnDoubleClick,panOnDrag,zoomActivationKeyPressed,preventScrolling,noPanClassName,userSelectionActive,noWheelClassName,lib,onTransformChange})},[onPaneContextMenu,zoomOnScroll,zoomOnPinch,panOnScroll,panOnScrollSpeed,panOnScrollMode,zoomOnDoubleClick,panOnDrag,zoomActivationKeyPressed,preventScrolling,noPanClassName,userSelectionActive,noWheelClassName,lib,onTransformChange]),(0,jsx_runtime.jsx)("div",{className:"react-flow__renderer",ref:zoomPane,style:containerStyle,children:children})}let selector$i=s=>({userSelectionActive:s.userSelectionActive,userSelectionRect:s.userSelectionRect});function UserSelection(){let{userSelectionActive,userSelectionRect}=useStore(selector$i,shallow$1);return userSelectionActive&&userSelectionRect?(0,jsx_runtime.jsx)("div",{className:"react-flow__selection react-flow__container",style:{width:userSelectionRect.width,height:userSelectionRect.height,transform:`translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`}}):null}let wrapHandler=(handler,containerRef)=>event=>{event.target===containerRef.current&&handler?.(event)},selector$h=s=>({userSelectionActive:s.userSelectionActive,elementsSelectable:s.elementsSelectable,connectionInProgress:s.connection.inProgress,dragging:s.paneDragging});function Pane({isSelecting,selectionKeyPressed,selectionMode=esm.oW.Full,panOnDrag,selectionOnDrag,onSelectionStart,onSelectionEnd,onPaneClick,onPaneContextMenu,onPaneScroll,onPaneMouseEnter,onPaneMouseMove,onPaneMouseLeave,children}){let store=useStoreApi(),{userSelectionActive,elementsSelectable,dragging,connectionInProgress}=useStore(selector$h,shallow$1),hasActiveSelection=elementsSelectable&&(isSelecting||userSelectionActive),container=(0,react.useRef)(null),containerBounds=(0,react.useRef)(),selectedNodeIds=(0,react.useRef)(new Set),selectedEdgeIds=(0,react.useRef)(new Set),selectionInProgress=(0,react.useRef)(!1),selectionStarted=(0,react.useRef)(!1),onClick=event=>{if(selectionInProgress.current||connectionInProgress){selectionInProgress.current=!1;return}onPaneClick?.(event),store.getState().resetSelectedElements(),store.setState({nodesSelectionActive:!1})},draggable=!0===panOnDrag||Array.isArray(panOnDrag)&&panOnDrag.includes(0);return(0,jsx_runtime.jsxs)("div",{className:classcat_cc(["react-flow__pane",{draggable,dragging,selection:isSelecting}]),onClick:hasActiveSelection?void 0:wrapHandler(onClick,container),onContextMenu:wrapHandler(event=>{if(Array.isArray(panOnDrag)&&panOnDrag?.includes(2)){event.preventDefault();return}onPaneContextMenu?.(event)},container),onWheel:wrapHandler(onPaneScroll?event=>onPaneScroll(event):void 0,container),onPointerEnter:hasActiveSelection?void 0:onPaneMouseEnter,onPointerDown:hasActiveSelection?event=>{let{resetSelectedElements,domNode}=store.getState();if(containerBounds.current=domNode?.getBoundingClientRect(),!elementsSelectable||!isSelecting||0!==event.button||event.target!==container.current||!containerBounds.current)return;event.target?.setPointerCapture?.(event.pointerId),selectionStarted.current=!0,selectionInProgress.current=!1;let{x,y}=(0,esm.wv)(event.nativeEvent,containerBounds.current);resetSelectedElements(),store.setState({userSelectionRect:{width:0,height:0,startX:x,startY:y,x,y}}),onSelectionStart?.(event)}:onPaneMouseMove,onPointerMove:hasActiveSelection?event=>{let{userSelectionRect,transform,nodeLookup,edgeLookup,connectionLookup,triggerNodeChanges,triggerEdgeChanges,defaultEdgeOptions}=store.getState();if(!containerBounds.current||!userSelectionRect)return;selectionInProgress.current=!0;let{x:mouseX,y:mouseY}=(0,esm.wv)(event.nativeEvent,containerBounds.current),{startX,startY}=userSelectionRect,nextUserSelectRect={startX,startY,x:mouseX<startX?mouseX:startX,y:mouseY<startY?mouseY:startY,width:Math.abs(mouseX-startX),height:Math.abs(mouseY-startY)},prevSelectedNodeIds=selectedNodeIds.current,prevSelectedEdgeIds=selectedEdgeIds.current;selectedNodeIds.current=new Set((0,esm.f5)(nodeLookup,nextUserSelectRect,transform,selectionMode===esm.oW.Partial,!0).map(node=>node.id)),selectedEdgeIds.current=new Set;let edgesSelectable=defaultEdgeOptions?.selectable??!0;for(let nodeId of selectedNodeIds.current){let connections=connectionLookup.get(nodeId);if(connections)for(let{edgeId}of connections.values()){let edge=edgeLookup.get(edgeId);edge&&(edge.selectable??edgesSelectable)&&selectedEdgeIds.current.add(edgeId)}}(0,esm.OL)(prevSelectedNodeIds,selectedNodeIds.current)||triggerNodeChanges(getSelectionChanges(nodeLookup,selectedNodeIds.current,!0)),(0,esm.OL)(prevSelectedEdgeIds,selectedEdgeIds.current)||triggerEdgeChanges(getSelectionChanges(edgeLookup,selectedEdgeIds.current)),store.setState({userSelectionRect:nextUserSelectRect,userSelectionActive:!0,nodesSelectionActive:!1})}:onPaneMouseMove,onPointerUp:hasActiveSelection?event=>{if(0!==event.button||!selectionStarted.current)return;event.target?.releasePointerCapture?.(event.pointerId);let{userSelectionRect}=store.getState();!userSelectionActive&&userSelectionRect&&event.target===container.current&&onClick?.(event),store.setState({userSelectionActive:!1,userSelectionRect:null,nodesSelectionActive:selectedNodeIds.current.size>0}),onSelectionEnd?.(event),(selectionKeyPressed||selectionOnDrag)&&(selectionInProgress.current=!1),selectionStarted.current=!1}:void 0,onPointerLeave:onPaneMouseLeave,ref:container,style:containerStyle,children:[children,(0,jsx_runtime.jsx)(UserSelection,{})]})}function handleNodeClick({id,store,unselect=!1,nodeRef}){let{addSelectedNodes,unselectNodesAndEdges,multiSelectionActive,nodeLookup,onError}=store.getState(),node=nodeLookup.get(id);if(!node){onError?.("012",esm.Qj.error012(id));return}store.setState({nodesSelectionActive:!1}),node.selected?(unselect||node.selected&&multiSelectionActive)&&(unselectNodesAndEdges({nodes:[node],edges:[]}),requestAnimationFrame(()=>nodeRef?.current?.blur())):addSelectedNodes([id])}function useDrag({nodeRef,disabled=!1,noDragClassName,handleSelector,nodeId,isSelectable,nodeClickDistance}){let store=useStoreApi(),[dragging,setDragging]=(0,react.useState)(!1),xyDrag=(0,react.useRef)();return(0,react.useEffect)(()=>{xyDrag.current=(0,esm.oC)({getStoreItems:()=>store.getState(),onNodeMouseDown:id=>{handleNodeClick({id,store,nodeRef})},onDragStart:()=>{setDragging(!0)},onDragStop:()=>{setDragging(!1)}})},[]),(0,react.useEffect)(()=>{if(disabled)xyDrag.current?.destroy();else if(nodeRef.current)return xyDrag.current?.update({noDragClassName,handleSelector,domNode:nodeRef.current,isSelectable,nodeId,nodeClickDistance}),()=>{xyDrag.current?.destroy()}},[noDragClassName,handleSelector,disabled,isSelectable,nodeRef,nodeId]),dragging}let selectedAndDraggable=nodesDraggable=>n=>n.selected&&(n.draggable||nodesDraggable&&void 0===n.draggable);function useMoveSelectedNodes(){let store=useStoreApi();return(0,react.useCallback)(params=>{let{nodeExtent,snapToGrid,snapGrid,nodesDraggable,onError,updateNodePositions,nodeLookup,nodeOrigin}=store.getState(),nodeUpdates=new Map,isSelected=selectedAndDraggable(nodesDraggable),xVelo=snapToGrid?snapGrid[0]:5,yVelo=snapToGrid?snapGrid[1]:5,xDiff=params.direction.x*xVelo*params.factor,yDiff=params.direction.y*yVelo*params.factor;for(let[,node]of nodeLookup){if(!isSelected(node))continue;let nextPosition={x:node.internals.positionAbsolute.x+xDiff,y:node.internals.positionAbsolute.y+yDiff};snapToGrid&&(nextPosition=(0,esm._2)(nextPosition,snapGrid));let{position,positionAbsolute}=(0,esm.q7)({nodeId:node.id,nextPosition,nodeLookup,nodeExtent,nodeOrigin,onError});node.position=position,node.internals.positionAbsolute=positionAbsolute,nodeUpdates.set(node.id,node)}updateNodePositions(nodeUpdates)},[])}let NodeIdContext=(0,react.createContext)(null),Provider=NodeIdContext.Provider;NodeIdContext.Consumer;let useNodeId=()=>(0,react.useContext)(NodeIdContext),selector$g=s=>({connectOnClick:s.connectOnClick,noPanClassName:s.noPanClassName,rfId:s.rfId}),connectingSelector=(nodeId,handleId,type)=>state=>{let{connectionClickStartHandle:clickHandle,connectionMode,connection}=state,{fromHandle,toHandle,isValid}=connection,connectingTo=toHandle?.nodeId===nodeId&&toHandle?.id===handleId&&toHandle?.type===type;return{connectingFrom:fromHandle?.nodeId===nodeId&&fromHandle?.id===handleId&&fromHandle?.type===type,connectingTo,clickConnecting:clickHandle?.nodeId===nodeId&&clickHandle?.id===handleId&&clickHandle?.type===type,isPossibleEndHandle:connectionMode===esm.jD.Strict?fromHandle?.type!==type:nodeId!==fromHandle?.nodeId||handleId!==fromHandle?.id,connectionInProcess:!!fromHandle,clickConnectionInProcess:!!clickHandle,valid:connectingTo&&isValid}};function HandleComponent({type="source",position=esm.Ly.Top,isValidConnection,isConnectable=!0,isConnectableStart=!0,isConnectableEnd=!0,id,onConnect,children,className,onMouseDown,onTouchStart,...rest},ref){let handleId=id||null,isTarget="target"===type,store=useStoreApi(),nodeId=useNodeId(),{connectOnClick,noPanClassName,rfId}=useStore(selector$g,shallow$1),{connectingFrom,connectingTo,clickConnecting,isPossibleEndHandle,connectionInProcess,clickConnectionInProcess,valid}=useStore(connectingSelector(nodeId,handleId,type),shallow$1);nodeId||store.getState().onError?.("010",esm.Qj.error010());let onConnectExtended=params=>{let{defaultEdgeOptions,onConnect:onConnectAction,hasDefaultEdges}=store.getState(),edgeParams={...defaultEdgeOptions,...params};if(hasDefaultEdges){let{edges,setEdges}=store.getState();setEdges((0,esm.Z_)(edgeParams,edges))}onConnectAction?.(edgeParams),onConnect?.(edgeParams)},onPointerDown=event=>{if(!nodeId)return;let isMouseTriggered=(0,esm.N5)(event.nativeEvent);if(isConnectableStart&&(isMouseTriggered&&0===event.button||!isMouseTriggered)){let currentStore=store.getState();esm.Ql.onPointerDown(event.nativeEvent,{autoPanOnConnect:currentStore.autoPanOnConnect,connectionMode:currentStore.connectionMode,connectionRadius:currentStore.connectionRadius,domNode:currentStore.domNode,nodeLookup:currentStore.nodeLookup,lib:currentStore.lib,isTarget,handleId,nodeId,flowId:currentStore.rfId,panBy:currentStore.panBy,cancelConnection:currentStore.cancelConnection,onConnectStart:currentStore.onConnectStart,onConnectEnd:currentStore.onConnectEnd,updateConnection:currentStore.updateConnection,onConnect:onConnectExtended,isValidConnection:isValidConnection||currentStore.isValidConnection,getTransform:()=>store.getState().transform,getFromHandle:()=>store.getState().connection.fromHandle,autoPanSpeed:currentStore.autoPanSpeed})}isMouseTriggered?onMouseDown?.(event):onTouchStart?.(event)};return(0,jsx_runtime.jsx)("div",{"data-handleid":handleId,"data-nodeid":nodeId,"data-handlepos":position,"data-id":`${rfId}-${nodeId}-${handleId}-${type}`,className:classcat_cc(["react-flow__handle",`react-flow__handle-${position}`,"nodrag",noPanClassName,className,{source:!isTarget,target:isTarget,connectable:isConnectable,connectablestart:isConnectableStart,connectableend:isConnectableEnd,clickconnecting:clickConnecting,connectingfrom:connectingFrom,connectingto:connectingTo,valid,connectionindicator:isConnectable&&(!connectionInProcess||isPossibleEndHandle)&&(connectionInProcess||clickConnectionInProcess?isConnectableEnd:isConnectableStart)}]),onMouseDown:onPointerDown,onTouchStart:onPointerDown,onClick:connectOnClick?event=>{let{onClickConnectStart,onClickConnectEnd,connectionClickStartHandle,connectionMode,isValidConnection:isValidConnectionStore,lib,rfId:flowId,nodeLookup,connection:connectionState}=store.getState();if(!nodeId||!connectionClickStartHandle&&!isConnectableStart)return;if(!connectionClickStartHandle){onClickConnectStart?.(event.nativeEvent,{nodeId,handleId,handleType:type}),store.setState({connectionClickStartHandle:{nodeId,type,id:handleId}});return}let doc=(0,esm.S2)(event.target),isValidConnectionHandler=isValidConnection||isValidConnectionStore,{connection,isValid}=esm.Ql.isValid(event.nativeEvent,{handle:{nodeId,id:handleId,type},connectionMode,fromNodeId:connectionClickStartHandle.nodeId,fromHandleId:connectionClickStartHandle.id||null,fromType:connectionClickStartHandle.type,isValidConnection:isValidConnectionHandler,flowId,doc,lib,nodeLookup});isValid&&connection&&onConnectExtended(connection);let connectionClone=structuredClone(connectionState);delete connectionClone.inProgress,connectionClone.toPosition=connectionClone.toHandle?connectionClone.toHandle.position:null,onClickConnectEnd?.(event,connectionClone),store.setState({connectionClickStartHandle:null})}:void 0,ref:ref,...rest,children:children})}let Handle=(0,react.memo)(fixedForwardRef(HandleComponent)),arrowKeyDiffs={ArrowUp:{x:0,y:-1},ArrowDown:{x:0,y:1},ArrowLeft:{x:-1,y:0},ArrowRight:{x:1,y:0}},builtinNodeTypes={input:function InputNode({data,isConnectable,sourcePosition=esm.Ly.Bottom}){return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[data?.label,(0,jsx_runtime.jsx)(Handle,{type:"source",position:sourcePosition,isConnectable:isConnectable})]})},default:function DefaultNode({data,isConnectable,targetPosition=esm.Ly.Top,sourcePosition=esm.Ly.Bottom}){return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)(Handle,{type:"target",position:targetPosition,isConnectable:isConnectable}),data?.label,(0,jsx_runtime.jsx)(Handle,{type:"source",position:sourcePosition,isConnectable:isConnectable})]})},output:function OutputNode({data,isConnectable,targetPosition=esm.Ly.Top}){return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)(Handle,{type:"target",position:targetPosition,isConnectable:isConnectable}),data?.label]})},group:function GroupNode(){return null}};function getNodeInlineStyleDimensions(node){return void 0===node.internals.handleBounds?{width:node.width??node.initialWidth??node.style?.width,height:node.height??node.initialHeight??node.style?.height}:{width:node.width??node.style?.width,height:node.height??node.style?.height}}let selector$f=s=>{let{width,height,x,y}=(0,esm.W0)(s.nodeLookup,{filter:node=>!!node.selected});return{width:(0,esm.kE)(width)?width:null,height:(0,esm.kE)(height)?height:null,userSelectionActive:s.userSelectionActive,transformString:`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]}) translate(${x}px,${y}px)`}};function NodesSelection({onSelectionContextMenu,noPanClassName,disableKeyboardA11y}){let store=useStoreApi(),{width,height,transformString,userSelectionActive}=useStore(selector$f,shallow$1),moveSelectedNodes=useMoveSelectedNodes(),nodeRef=(0,react.useRef)(null);if((0,react.useEffect)(()=>{disableKeyboardA11y||nodeRef.current?.focus({preventScroll:!0})},[disableKeyboardA11y]),useDrag({nodeRef}),userSelectionActive||!width||!height)return null;let onContextMenu=onSelectionContextMenu?event=>{onSelectionContextMenu(event,store.getState().nodes.filter(n=>n.selected))}:void 0;return(0,jsx_runtime.jsx)("div",{className:classcat_cc(["react-flow__nodesselection","react-flow__container",noPanClassName]),style:{transform:transformString},children:(0,jsx_runtime.jsx)("div",{ref:nodeRef,className:"react-flow__nodesselection-rect",onContextMenu:onContextMenu,tabIndex:disableKeyboardA11y?void 0:-1,onKeyDown:disableKeyboardA11y?void 0:event=>{Object.prototype.hasOwnProperty.call(arrowKeyDiffs,event.key)&&(event.preventDefault(),moveSelectedNodes({direction:arrowKeyDiffs[event.key],factor:event.shiftKey?4:1}))},style:{width,height}})})}let win="undefined"!=typeof window?window:void 0,selector$e=s=>({nodesSelectionActive:s.nodesSelectionActive,userSelectionActive:s.userSelectionActive});function FlowRendererComponent({children,onPaneClick,onPaneMouseEnter,onPaneMouseMove,onPaneMouseLeave,onPaneContextMenu,onPaneScroll,paneClickDistance,deleteKeyCode,selectionKeyCode,selectionOnDrag,selectionMode,onSelectionStart,onSelectionEnd,multiSelectionKeyCode,panActivationKeyCode,zoomActivationKeyCode,elementsSelectable,zoomOnScroll,zoomOnPinch,panOnScroll:_panOnScroll,panOnScrollSpeed,panOnScrollMode,zoomOnDoubleClick,panOnDrag:_panOnDrag,defaultViewport,translateExtent,minZoom,maxZoom,preventScrolling,onSelectionContextMenu,noWheelClassName,noPanClassName,disableKeyboardA11y,onViewportChange,isControlledViewport}){let{nodesSelectionActive,userSelectionActive}=useStore(selector$e),selectionKeyPressed=useKeyPress(selectionKeyCode,{target:win}),panActivationKeyPressed=useKeyPress(panActivationKeyCode,{target:win}),panOnDrag=panActivationKeyPressed||_panOnDrag,panOnScroll=panActivationKeyPressed||_panOnScroll,_selectionOnDrag=selectionOnDrag&&!0!==panOnDrag,isSelecting=selectionKeyPressed||userSelectionActive||_selectionOnDrag;return useGlobalKeyHandler({deleteKeyCode,multiSelectionKeyCode}),(0,jsx_runtime.jsx)(ZoomPane,{onPaneContextMenu:onPaneContextMenu,elementsSelectable:elementsSelectable,zoomOnScroll:zoomOnScroll,zoomOnPinch:zoomOnPinch,panOnScroll:panOnScroll,panOnScrollSpeed:panOnScrollSpeed,panOnScrollMode:panOnScrollMode,zoomOnDoubleClick:zoomOnDoubleClick,panOnDrag:!selectionKeyPressed&&panOnDrag,defaultViewport:defaultViewport,translateExtent:translateExtent,minZoom:minZoom,maxZoom:maxZoom,zoomActivationKeyCode:zoomActivationKeyCode,preventScrolling:preventScrolling,noWheelClassName:noWheelClassName,noPanClassName:noPanClassName,onViewportChange:onViewportChange,isControlledViewport:isControlledViewport,paneClickDistance:paneClickDistance,children:(0,jsx_runtime.jsxs)(Pane,{onSelectionStart:onSelectionStart,onSelectionEnd:onSelectionEnd,onPaneClick:onPaneClick,onPaneMouseEnter:onPaneMouseEnter,onPaneMouseMove:onPaneMouseMove,onPaneMouseLeave:onPaneMouseLeave,onPaneContextMenu:onPaneContextMenu,onPaneScroll:onPaneScroll,panOnDrag:panOnDrag,isSelecting:!!isSelecting,selectionMode:selectionMode,selectionKeyPressed:selectionKeyPressed,selectionOnDrag:_selectionOnDrag,children:[children,nodesSelectionActive&&(0,jsx_runtime.jsx)(NodesSelection,{onSelectionContextMenu:onSelectionContextMenu,noPanClassName:noPanClassName,disableKeyboardA11y:disableKeyboardA11y})]})})}FlowRendererComponent.displayName="FlowRenderer";let FlowRenderer=(0,react.memo)(FlowRendererComponent),selector$d=onlyRenderVisible=>s=>onlyRenderVisible?(0,esm.f5)(s.nodeLookup,{x:0,y:0,width:s.width,height:s.height},s.transform,!0).map(node=>node.id):Array.from(s.nodeLookup.keys());function useVisibleNodeIds(onlyRenderVisible){return useStore((0,react.useCallback)(selector$d(onlyRenderVisible),[onlyRenderVisible]),shallow$1)}let selector$c=s=>s.updateNodeInternals;function useResizeObserver(){let updateNodeInternals=useStore(selector$c),[resizeObserver]=(0,react.useState)(()=>"undefined"==typeof ResizeObserver?null:new ResizeObserver(entries=>{let updates=new Map;entries.forEach(entry=>{let id=entry.target.getAttribute("data-id");updates.set(id,{id,nodeElement:entry.target,force:!0})}),updateNodeInternals(updates)}));return(0,react.useEffect)(()=>()=>{resizeObserver?.disconnect()},[resizeObserver]),resizeObserver}function useNodeObserver({node,nodeType,hasDimensions,resizeObserver}){let store=useStoreApi(),nodeRef=(0,react.useRef)(null),observedNode=(0,react.useRef)(null),prevSourcePosition=(0,react.useRef)(node.sourcePosition),prevTargetPosition=(0,react.useRef)(node.targetPosition),prevType=(0,react.useRef)(nodeType),isInitialized=hasDimensions&&!!node.internals.handleBounds;return(0,react.useEffect)(()=>{!nodeRef.current||node.hidden||isInitialized&&observedNode.current===nodeRef.current||(observedNode.current&&resizeObserver?.unobserve(observedNode.current),resizeObserver?.observe(nodeRef.current),observedNode.current=nodeRef.current)},[isInitialized,node.hidden]),(0,react.useEffect)(()=>()=>{observedNode.current&&(resizeObserver?.unobserve(observedNode.current),observedNode.current=null)},[]),(0,react.useEffect)(()=>{if(nodeRef.current){let typeChanged=prevType.current!==nodeType,sourcePosChanged=prevSourcePosition.current!==node.sourcePosition,targetPosChanged=prevTargetPosition.current!==node.targetPosition;(typeChanged||sourcePosChanged||targetPosChanged)&&(prevType.current=nodeType,prevSourcePosition.current=node.sourcePosition,prevTargetPosition.current=node.targetPosition,store.getState().updateNodeInternals(new Map([[node.id,{id:node.id,nodeElement:nodeRef.current,force:!0}]])))}},[node.id,nodeType,node.sourcePosition,node.targetPosition]),nodeRef}function NodeWrapper({id,onClick,onMouseEnter,onMouseMove,onMouseLeave,onContextMenu,onDoubleClick,nodesDraggable,elementsSelectable,nodesConnectable,nodesFocusable,resizeObserver,noDragClassName,noPanClassName,disableKeyboardA11y,rfId,nodeTypes,nodeClickDistance,onError}){let{node,internals,isParent}=useStore(s=>{let node=s.nodeLookup.get(id),isParent=s.parentLookup.has(id);return{node,internals:node.internals,isParent}},shallow$1),nodeType=node.type||"default",NodeComponent=nodeTypes?.[nodeType]||builtinNodeTypes[nodeType];void 0===NodeComponent&&(onError?.("003",esm.Qj.error003(nodeType)),nodeType="default",NodeComponent=builtinNodeTypes.default);let isDraggable=!!(node.draggable||nodesDraggable&&void 0===node.draggable),isSelectable=!!(node.selectable||elementsSelectable&&void 0===node.selectable),isConnectable=!!(node.connectable||nodesConnectable&&void 0===node.connectable),isFocusable=!!(node.focusable||nodesFocusable&&void 0===node.focusable),store=useStoreApi(),hasDimensions=(0,esm.nb)(node),nodeRef=useNodeObserver({node,nodeType,hasDimensions,resizeObserver}),dragging=useDrag({nodeRef,disabled:node.hidden||!isDraggable,noDragClassName,handleSelector:node.dragHandle,nodeId:id,isSelectable,nodeClickDistance}),moveSelectedNodes=useMoveSelectedNodes();if(node.hidden)return null;let nodeDimensions=(0,esm.Rf)(node),inlineDimensions=getNodeInlineStyleDimensions(node),hasPointerEvents=isSelectable||isDraggable||onClick||onMouseEnter||onMouseMove||onMouseLeave,onMouseEnterHandler=onMouseEnter?event=>onMouseEnter(event,{...internals.userNode}):void 0,onMouseMoveHandler=onMouseMove?event=>onMouseMove(event,{...internals.userNode}):void 0,onMouseLeaveHandler=onMouseLeave?event=>onMouseLeave(event,{...internals.userNode}):void 0,onContextMenuHandler=onContextMenu?event=>onContextMenu(event,{...internals.userNode}):void 0,onDoubleClickHandler=onDoubleClick?event=>onDoubleClick(event,{...internals.userNode}):void 0;return(0,jsx_runtime.jsx)("div",{className:classcat_cc(["react-flow__node",`react-flow__node-${nodeType}`,{[noPanClassName]:isDraggable},node.className,{selected:node.selected,selectable:isSelectable,parent:isParent,draggable:isDraggable,dragging}]),ref:nodeRef,style:{zIndex:internals.z,transform:`translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,pointerEvents:hasPointerEvents?"all":"none",visibility:hasDimensions?"visible":"hidden",...node.style,...inlineDimensions},"data-id":id,"data-testid":`rf__node-${id}`,onMouseEnter:onMouseEnterHandler,onMouseMove:onMouseMoveHandler,onMouseLeave:onMouseLeaveHandler,onContextMenu:onContextMenuHandler,onClick:event=>{let{selectNodesOnDrag,nodeDragThreshold}=store.getState();isSelectable&&(!selectNodesOnDrag||!isDraggable||nodeDragThreshold>0)&&handleNodeClick({id,store,nodeRef}),onClick&&onClick(event,{...internals.userNode})},onDoubleClick:onDoubleClickHandler,onKeyDown:isFocusable?event=>{!(0,esm.s$)(event.nativeEvent)&&!disableKeyboardA11y&&(esm.wQ.includes(event.key)&&isSelectable?handleNodeClick({id,store,unselect:"Escape"===event.key,nodeRef}):isDraggable&&node.selected&&Object.prototype.hasOwnProperty.call(arrowKeyDiffs,event.key)&&(event.preventDefault(),store.setState({ariaLiveMessage:`Moved selected node ${event.key.replace("Arrow","").toLowerCase()}. New position, x: ${~~internals.positionAbsolute.x}, y: ${~~internals.positionAbsolute.y}`}),moveSelectedNodes({direction:arrowKeyDiffs[event.key],factor:event.shiftKey?4:1})))}:void 0,tabIndex:isFocusable?0:void 0,role:isFocusable?"button":void 0,"aria-describedby":disableKeyboardA11y?void 0:`${ARIA_NODE_DESC_KEY}-${rfId}`,"aria-label":node.ariaLabel,children:(0,jsx_runtime.jsx)(Provider,{value:id,children:(0,jsx_runtime.jsx)(NodeComponent,{id:id,data:node.data,type:nodeType,positionAbsoluteX:internals.positionAbsolute.x,positionAbsoluteY:internals.positionAbsolute.y,selected:node.selected??!1,selectable:isSelectable,draggable:isDraggable,deletable:node.deletable??!0,isConnectable:isConnectable,sourcePosition:node.sourcePosition,targetPosition:node.targetPosition,dragging:dragging,dragHandle:node.dragHandle,zIndex:internals.z,parentId:node.parentId,...nodeDimensions})})})}let selector$b=s=>({nodesDraggable:s.nodesDraggable,nodesConnectable:s.nodesConnectable,nodesFocusable:s.nodesFocusable,elementsSelectable:s.elementsSelectable,onError:s.onError});function NodeRendererComponent(props){let{nodesDraggable,nodesConnectable,nodesFocusable,elementsSelectable,onError}=useStore(selector$b,shallow$1),nodeIds=useVisibleNodeIds(props.onlyRenderVisibleElements),resizeObserver=useResizeObserver();return(0,jsx_runtime.jsx)("div",{className:"react-flow__nodes",style:containerStyle,children:nodeIds.map(nodeId=>(0,jsx_runtime.jsx)(NodeWrapper,{id:nodeId,nodeTypes:props.nodeTypes,nodeExtent:props.nodeExtent,onClick:props.onNodeClick,onMouseEnter:props.onNodeMouseEnter,onMouseMove:props.onNodeMouseMove,onMouseLeave:props.onNodeMouseLeave,onContextMenu:props.onNodeContextMenu,onDoubleClick:props.onNodeDoubleClick,noDragClassName:props.noDragClassName,noPanClassName:props.noPanClassName,rfId:props.rfId,disableKeyboardA11y:props.disableKeyboardA11y,resizeObserver:resizeObserver,nodesDraggable:nodesDraggable,nodesConnectable:nodesConnectable,nodesFocusable:nodesFocusable,elementsSelectable:elementsSelectable,nodeClickDistance:props.nodeClickDistance,onError:onError},nodeId))})}NodeRendererComponent.displayName="NodeRenderer";let NodeRenderer=(0,react.memo)(NodeRendererComponent);function useVisibleEdgeIds(onlyRenderVisible){return useStore((0,react.useCallback)(s=>{if(!onlyRenderVisible)return s.edges.map(edge=>edge.id);let visibleEdgeIds=[];if(s.width&&s.height)for(let edge of s.edges){let sourceNode=s.nodeLookup.get(edge.source),targetNode=s.nodeLookup.get(edge.target);sourceNode&&targetNode&&(0,esm.RY)({sourceNode,targetNode,width:s.width,height:s.height,transform:s.transform})&&visibleEdgeIds.push(edge.id)}return visibleEdgeIds},[onlyRenderVisible]),shallow$1)}let MarkerSymbols={[esm.QZ.Arrow]:({color="none",strokeWidth=1})=>(0,jsx_runtime.jsx)("polyline",{style:{stroke:color,strokeWidth},strokeLinecap:"round",strokeLinejoin:"round",fill:"none",points:"-5,-4 0,0 -5,4"}),[esm.QZ.ArrowClosed]:({color="none",strokeWidth=1})=>(0,jsx_runtime.jsx)("polyline",{style:{stroke:color,fill:color,strokeWidth},strokeLinecap:"round",strokeLinejoin:"round",points:"-5,-4 0,0 -5,4 -5,-4"})};function useMarkerSymbol(type){let store=useStoreApi();return(0,react.useMemo)(()=>Object.prototype.hasOwnProperty.call(MarkerSymbols,type)?MarkerSymbols[type]:(store.getState().onError?.("009",esm.Qj.error009(type)),null),[type])}let Marker=({id,type,color,width=12.5,height=12.5,markerUnits="strokeWidth",strokeWidth,orient="auto-start-reverse"})=>{let Symbol=useMarkerSymbol(type);return Symbol?(0,jsx_runtime.jsx)("marker",{className:"react-flow__arrowhead",id:id,markerWidth:`${width}`,markerHeight:`${height}`,viewBox:"-10 -10 20 20",markerUnits:markerUnits,orient:orient,refX:"0",refY:"0",children:(0,jsx_runtime.jsx)(Symbol,{color:color,strokeWidth:strokeWidth})}):null},MarkerDefinitions=({defaultColor,rfId})=>{let edges=useStore(s=>s.edges),defaultEdgeOptions=useStore(s=>s.defaultEdgeOptions),markers=(0,react.useMemo)(()=>(0,esm.n3)(edges,{id:rfId,defaultColor,defaultMarkerStart:defaultEdgeOptions?.markerStart,defaultMarkerEnd:defaultEdgeOptions?.markerEnd}),[edges,defaultEdgeOptions,rfId,defaultColor]);return markers.length?(0,jsx_runtime.jsx)("svg",{className:"react-flow__marker","aria-hidden":"true",children:(0,jsx_runtime.jsx)("defs",{children:markers.map(marker=>(0,jsx_runtime.jsx)(Marker,{id:marker.id,type:marker.type,color:marker.color,width:marker.width,height:marker.height,markerUnits:marker.markerUnits,strokeWidth:marker.strokeWidth,orient:marker.orient},marker.id))})}):null};MarkerDefinitions.displayName="MarkerDefinitions";var MarkerDefinitions$1=(0,react.memo)(MarkerDefinitions);function EdgeTextComponent({x,y,label,labelStyle,labelShowBg=!0,labelBgStyle,labelBgPadding=[2,4],labelBgBorderRadius=2,children,className,...rest}){let[edgeTextBbox,setEdgeTextBbox]=(0,react.useState)({x:1,y:0,width:0,height:0}),edgeTextClasses=classcat_cc(["react-flow__edge-textwrapper",className]),edgeTextRef=(0,react.useRef)(null);return((0,react.useEffect)(()=>{if(edgeTextRef.current){let textBbox=edgeTextRef.current.getBBox();setEdgeTextBbox({x:textBbox.x,y:textBbox.y,width:textBbox.width,height:textBbox.height})}},[label]),label)?(0,jsx_runtime.jsxs)("g",{transform:`translate(${x-edgeTextBbox.width/2} ${y-edgeTextBbox.height/2})`,className:edgeTextClasses,visibility:edgeTextBbox.width?"visible":"hidden",...rest,children:[labelShowBg&&(0,jsx_runtime.jsx)("rect",{width:edgeTextBbox.width+2*labelBgPadding[0],x:-labelBgPadding[0],y:-labelBgPadding[1],height:edgeTextBbox.height+2*labelBgPadding[1],className:"react-flow__edge-textbg",style:labelBgStyle,rx:labelBgBorderRadius,ry:labelBgBorderRadius}),(0,jsx_runtime.jsx)("text",{className:"react-flow__edge-text",y:edgeTextBbox.height/2,dy:"0.3em",ref:edgeTextRef,style:labelStyle,children:label}),children]}):null}EdgeTextComponent.displayName="EdgeText";let EdgeText=(0,react.memo)(EdgeTextComponent);function BaseEdge({path,labelX,labelY,label,labelStyle,labelShowBg,labelBgStyle,labelBgPadding,labelBgBorderRadius,interactionWidth=20,...props}){return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)("path",{...props,d:path,fill:"none",className:classcat_cc(["react-flow__edge-path",props.className])}),interactionWidth&&(0,jsx_runtime.jsx)("path",{d:path,fill:"none",strokeOpacity:0,strokeWidth:interactionWidth,className:"react-flow__edge-interaction"}),label&&(0,esm.kE)(labelX)&&(0,esm.kE)(labelY)?(0,jsx_runtime.jsx)(EdgeText,{x:labelX,y:labelY,label:label,labelStyle:labelStyle,labelShowBg:labelShowBg,labelBgStyle:labelBgStyle,labelBgPadding:labelBgPadding,labelBgBorderRadius:labelBgBorderRadius}):null]})}function getControl({pos,x1,y1,x2,y2}){return pos===esm.Ly.Left||pos===esm.Ly.Right?[.5*(x1+x2),y1]:[x1,.5*(y1+y2)]}function getSimpleBezierPath({sourceX,sourceY,sourcePosition=esm.Ly.Bottom,targetX,targetY,targetPosition=esm.Ly.Top}){let[sourceControlX,sourceControlY]=getControl({pos:sourcePosition,x1:sourceX,y1:sourceY,x2:targetX,y2:targetY}),[targetControlX,targetControlY]=getControl({pos:targetPosition,x1:targetX,y1:targetY,x2:sourceX,y2:sourceY}),[labelX,labelY,offsetX,offsetY]=(0,esm.lM)({sourceX,sourceY,targetX,targetY,sourceControlX,sourceControlY,targetControlX,targetControlY});return[`M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,labelX,labelY,offsetX,offsetY]}function createSimpleBezierEdge(params){return(0,react.memo)(({id,sourceX,sourceY,targetX,targetY,sourcePosition,targetPosition,label,labelStyle,labelShowBg,labelBgStyle,labelBgPadding,labelBgBorderRadius,style,markerEnd,markerStart,interactionWidth})=>{let[path,labelX,labelY]=getSimpleBezierPath({sourceX,sourceY,sourcePosition,targetX,targetY,targetPosition}),_id=params.isInternal?void 0:id;return(0,jsx_runtime.jsx)(BaseEdge,{id:_id,path:path,labelX:labelX,labelY:labelY,label:label,labelStyle:labelStyle,labelShowBg:labelShowBg,labelBgStyle:labelBgStyle,labelBgPadding:labelBgPadding,labelBgBorderRadius:labelBgBorderRadius,style:style,markerEnd:markerEnd,markerStart:markerStart,interactionWidth:interactionWidth})})}let SimpleBezierEdge=createSimpleBezierEdge({isInternal:!1}),SimpleBezierEdgeInternal=createSimpleBezierEdge({isInternal:!0});function createSmoothStepEdge(params){return(0,react.memo)(({id,sourceX,sourceY,targetX,targetY,label,labelStyle,labelShowBg,labelBgStyle,labelBgPadding,labelBgBorderRadius,style,sourcePosition=esm.Ly.Bottom,targetPosition=esm.Ly.Top,markerEnd,markerStart,pathOptions,interactionWidth})=>{let[path,labelX,labelY]=(0,esm.OW)({sourceX,sourceY,sourcePosition,targetX,targetY,targetPosition,borderRadius:pathOptions?.borderRadius,offset:pathOptions?.offset}),_id=params.isInternal?void 0:id;return(0,jsx_runtime.jsx)(BaseEdge,{id:_id,path:path,labelX:labelX,labelY:labelY,label:label,labelStyle:labelStyle,labelShowBg:labelShowBg,labelBgStyle:labelBgStyle,labelBgPadding:labelBgPadding,labelBgBorderRadius:labelBgBorderRadius,style:style,markerEnd:markerEnd,markerStart:markerStart,interactionWidth:interactionWidth})})}SimpleBezierEdge.displayName="SimpleBezierEdge",SimpleBezierEdgeInternal.displayName="SimpleBezierEdgeInternal";let SmoothStepEdge=createSmoothStepEdge({isInternal:!1}),SmoothStepEdgeInternal=createSmoothStepEdge({isInternal:!0});function createStepEdge(params){return(0,react.memo)(({id,...props})=>{let _id=params.isInternal?void 0:id;return(0,jsx_runtime.jsx)(SmoothStepEdge,{...props,id:_id,pathOptions:(0,react.useMemo)(()=>({borderRadius:0,offset:props.pathOptions?.offset}),[props.pathOptions?.offset])})})}SmoothStepEdge.displayName="SmoothStepEdge",SmoothStepEdgeInternal.displayName="SmoothStepEdgeInternal";let StepEdge=createStepEdge({isInternal:!1}),StepEdgeInternal=createStepEdge({isInternal:!0});function createStraightEdge(params){return(0,react.memo)(({id,sourceX,sourceY,targetX,targetY,label,labelStyle,labelShowBg,labelBgStyle,labelBgPadding,labelBgBorderRadius,style,markerEnd,markerStart,interactionWidth})=>{let[path,labelX,labelY]=(0,esm.Hm)({sourceX,sourceY,targetX,targetY}),_id=params.isInternal?void 0:id;return(0,jsx_runtime.jsx)(BaseEdge,{id:_id,path:path,labelX:labelX,labelY:labelY,label:label,labelStyle:labelStyle,labelShowBg:labelShowBg,labelBgStyle:labelBgStyle,labelBgPadding:labelBgPadding,labelBgBorderRadius:labelBgBorderRadius,style:style,markerEnd:markerEnd,markerStart:markerStart,interactionWidth:interactionWidth})})}StepEdge.displayName="StepEdge",StepEdgeInternal.displayName="StepEdgeInternal";let StraightEdge=createStraightEdge({isInternal:!1}),StraightEdgeInternal=createStraightEdge({isInternal:!0});function createBezierEdge(params){return(0,react.memo)(({id,sourceX,sourceY,targetX,targetY,sourcePosition=esm.Ly.Bottom,targetPosition=esm.Ly.Top,label,labelStyle,labelShowBg,labelBgStyle,labelBgPadding,labelBgBorderRadius,style,markerEnd,markerStart,pathOptions,interactionWidth})=>{let[path,labelX,labelY]=(0,esm.OQ)({sourceX,sourceY,sourcePosition,targetX,targetY,targetPosition,curvature:pathOptions?.curvature}),_id=params.isInternal?void 0:id;return(0,jsx_runtime.jsx)(BaseEdge,{id:_id,path:path,labelX:labelX,labelY:labelY,label:label,labelStyle:labelStyle,labelShowBg:labelShowBg,labelBgStyle:labelBgStyle,labelBgPadding:labelBgPadding,labelBgBorderRadius:labelBgBorderRadius,style:style,markerEnd:markerEnd,markerStart:markerStart,interactionWidth:interactionWidth})})}StraightEdge.displayName="StraightEdge",StraightEdgeInternal.displayName="StraightEdgeInternal";let BezierEdge=createBezierEdge({isInternal:!1}),BezierEdgeInternal=createBezierEdge({isInternal:!0});BezierEdge.displayName="BezierEdge",BezierEdgeInternal.displayName="BezierEdgeInternal";let builtinEdgeTypes={default:BezierEdgeInternal,straight:StraightEdgeInternal,step:StepEdgeInternal,smoothstep:SmoothStepEdgeInternal,simplebezier:SimpleBezierEdgeInternal},nullPosition={sourceX:null,sourceY:null,targetX:null,targetY:null,sourcePosition:null,targetPosition:null},shiftX=(x,shift,position)=>position===esm.Ly.Left?x-shift:position===esm.Ly.Right?x+shift:x,shiftY=(y,shift,position)=>position===esm.Ly.Top?y-shift:position===esm.Ly.Bottom?y+shift:y,EdgeUpdaterClassName="react-flow__edgeupdater";function EdgeAnchor({position,centerX,centerY,radius=10,onMouseDown,onMouseEnter,onMouseOut,type}){return(0,jsx_runtime.jsx)("circle",{onMouseDown:onMouseDown,onMouseEnter:onMouseEnter,onMouseOut:onMouseOut,className:classcat_cc([EdgeUpdaterClassName,`${EdgeUpdaterClassName}-${type}`]),cx:shiftX(centerX,radius,position),cy:shiftY(centerY,radius,position),r:radius,stroke:"transparent",fill:"transparent"})}function EdgeUpdateAnchors({isReconnectable,reconnectRadius,edge,sourceX,sourceY,targetX,targetY,sourcePosition,targetPosition,onReconnect,onReconnectStart,onReconnectEnd,setReconnecting,setUpdateHover}){let store=useStoreApi(),handleEdgeUpdater=(event,oppositeHandle)=>{if(0!==event.button)return;let{autoPanOnConnect,domNode,isValidConnection,connectionMode,connectionRadius,lib,onConnectStart,onConnectEnd,cancelConnection,nodeLookup,rfId:flowId,panBy,updateConnection}=store.getState(),isTarget="target"===oppositeHandle.type;setReconnecting(!0),onReconnectStart?.(event,edge,oppositeHandle.type),esm.Ql.onPointerDown(event.nativeEvent,{autoPanOnConnect,connectionMode,connectionRadius,domNode,handleId:oppositeHandle.id,nodeId:oppositeHandle.nodeId,nodeLookup,isTarget,edgeUpdaterType:oppositeHandle.type,lib,flowId,cancelConnection,panBy,isValidConnection,onConnect:connection=>onReconnect?.(edge,connection),onConnectStart,onConnectEnd,onReconnectEnd:(evt,connectionState)=>{setReconnecting(!1),onReconnectEnd?.(evt,edge,oppositeHandle.type,connectionState)},updateConnection,getTransform:()=>store.getState().transform,getFromHandle:()=>store.getState().connection.fromHandle})},onReconnectMouseEnter=()=>setUpdateHover(!0),onReconnectMouseOut=()=>setUpdateHover(!1);return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(!0===isReconnectable||"source"===isReconnectable)&&(0,jsx_runtime.jsx)(EdgeAnchor,{position:sourcePosition,centerX:sourceX,centerY:sourceY,radius:reconnectRadius,onMouseDown:event=>handleEdgeUpdater(event,{nodeId:edge.target,id:edge.targetHandle??null,type:"target"}),onMouseEnter:onReconnectMouseEnter,onMouseOut:onReconnectMouseOut,type:"source"}),(!0===isReconnectable||"target"===isReconnectable)&&(0,jsx_runtime.jsx)(EdgeAnchor,{position:targetPosition,centerX:targetX,centerY:targetY,radius:reconnectRadius,onMouseDown:event=>handleEdgeUpdater(event,{nodeId:edge.source,id:edge.sourceHandle??null,type:"source"}),onMouseEnter:onReconnectMouseEnter,onMouseOut:onReconnectMouseOut,type:"target"})]})}function EdgeWrapper({id,edgesFocusable,edgesReconnectable,elementsSelectable,onClick,onDoubleClick,onContextMenu,onMouseEnter,onMouseMove,onMouseLeave,reconnectRadius,onReconnect,onReconnectStart,onReconnectEnd,rfId,edgeTypes,noPanClassName,onError,disableKeyboardA11y}){let edge=useStore(s=>s.edgeLookup.get(id)),defaultEdgeOptions=useStore(s=>s.defaultEdgeOptions),edgeType=(edge=defaultEdgeOptions?{...defaultEdgeOptions,...edge}:edge).type||"default",EdgeComponent=edgeTypes?.[edgeType]||builtinEdgeTypes[edgeType];void 0===EdgeComponent&&(onError?.("011",esm.Qj.error011(edgeType)),edgeType="default",EdgeComponent=builtinEdgeTypes.default);let isFocusable=!!(edge.focusable||edgesFocusable&&void 0===edge.focusable),isReconnectable=void 0!==onReconnect&&(edge.reconnectable||edgesReconnectable&&void 0===edge.reconnectable),isSelectable=!!(edge.selectable||elementsSelectable&&void 0===edge.selectable),edgeRef=(0,react.useRef)(null),[updateHover,setUpdateHover]=(0,react.useState)(!1),[reconnecting,setReconnecting]=(0,react.useState)(!1),store=useStoreApi(),{zIndex,sourceX,sourceY,targetX,targetY,sourcePosition,targetPosition}=useStore((0,react.useCallback)(store=>{let sourceNode=store.nodeLookup.get(edge.source),targetNode=store.nodeLookup.get(edge.target);if(!sourceNode||!targetNode)return{zIndex:edge.zIndex,...nullPosition};let edgePosition=(0,esm.JU)({id,sourceNode,targetNode,sourceHandle:edge.sourceHandle||null,targetHandle:edge.targetHandle||null,connectionMode:store.connectionMode,onError});return{zIndex:(0,esm.xx)({selected:edge.selected,zIndex:edge.zIndex,sourceNode,targetNode,elevateOnSelect:store.elevateEdgesOnSelect}),...edgePosition||nullPosition}},[edge.source,edge.target,edge.sourceHandle,edge.targetHandle,edge.selected,edge.zIndex]),shallow$1),markerStartUrl=(0,react.useMemo)(()=>edge.markerStart?`url('#${(0,esm.dW)(edge.markerStart,rfId)}')`:void 0,[edge.markerStart,rfId]),markerEndUrl=(0,react.useMemo)(()=>edge.markerEnd?`url('#${(0,esm.dW)(edge.markerEnd,rfId)}')`:void 0,[edge.markerEnd,rfId]);if(edge.hidden||null===sourceX||null===sourceY||null===targetX||null===targetY)return null;let onEdgeDoubleClick=onDoubleClick?event=>{onDoubleClick(event,{...edge})}:void 0,onEdgeContextMenu=onContextMenu?event=>{onContextMenu(event,{...edge})}:void 0,onEdgeMouseEnter=onMouseEnter?event=>{onMouseEnter(event,{...edge})}:void 0,onEdgeMouseMove=onMouseMove?event=>{onMouseMove(event,{...edge})}:void 0,onEdgeMouseLeave=onMouseLeave?event=>{onMouseLeave(event,{...edge})}:void 0;return(0,jsx_runtime.jsx)("svg",{style:{zIndex},children:(0,jsx_runtime.jsxs)("g",{className:classcat_cc(["react-flow__edge",`react-flow__edge-${edgeType}`,edge.className,noPanClassName,{selected:edge.selected,animated:edge.animated,inactive:!isSelectable&&!onClick,updating:updateHover,selectable:isSelectable}]),onClick:event=>{let{addSelectedEdges,unselectNodesAndEdges,multiSelectionActive}=store.getState();isSelectable&&(store.setState({nodesSelectionActive:!1}),edge.selected&&multiSelectionActive?(unselectNodesAndEdges({nodes:[],edges:[edge]}),edgeRef.current?.blur()):addSelectedEdges([id])),onClick&&onClick(event,edge)},onDoubleClick:onEdgeDoubleClick,onContextMenu:onEdgeContextMenu,onMouseEnter:onEdgeMouseEnter,onMouseMove:onEdgeMouseMove,onMouseLeave:onEdgeMouseLeave,onKeyDown:isFocusable?event=>{if(!disableKeyboardA11y&&esm.wQ.includes(event.key)&&isSelectable){let{unselectNodesAndEdges,addSelectedEdges}=store.getState();"Escape"===event.key?(edgeRef.current?.blur(),unselectNodesAndEdges({edges:[edge]})):addSelectedEdges([id])}}:void 0,tabIndex:isFocusable?0:void 0,role:isFocusable?"button":"img","data-id":id,"data-testid":`rf__edge-${id}`,"aria-label":null===edge.ariaLabel?void 0:edge.ariaLabel||`Edge from ${edge.source} to ${edge.target}`,"aria-describedby":isFocusable?`${ARIA_EDGE_DESC_KEY}-${rfId}`:void 0,ref:edgeRef,children:[!reconnecting&&(0,jsx_runtime.jsx)(EdgeComponent,{id:id,source:edge.source,target:edge.target,type:edge.type,selected:edge.selected,animated:edge.animated,selectable:isSelectable,deletable:edge.deletable??!0,label:edge.label,labelStyle:edge.labelStyle,labelShowBg:edge.labelShowBg,labelBgStyle:edge.labelBgStyle,labelBgPadding:edge.labelBgPadding,labelBgBorderRadius:edge.labelBgBorderRadius,sourceX:sourceX,sourceY:sourceY,targetX:targetX,targetY:targetY,sourcePosition:sourcePosition,targetPosition:targetPosition,data:edge.data,style:edge.style,sourceHandleId:edge.sourceHandle,targetHandleId:edge.targetHandle,markerStart:markerStartUrl,markerEnd:markerEndUrl,pathOptions:"pathOptions"in edge?edge.pathOptions:void 0,interactionWidth:edge.interactionWidth}),isReconnectable&&(0,jsx_runtime.jsx)(EdgeUpdateAnchors,{edge:edge,isReconnectable:isReconnectable,reconnectRadius:reconnectRadius,onReconnect:onReconnect,onReconnectStart:onReconnectStart,onReconnectEnd:onReconnectEnd,sourceX:sourceX,sourceY:sourceY,targetX:targetX,targetY:targetY,sourcePosition:sourcePosition,targetPosition:targetPosition,setUpdateHover:setUpdateHover,setReconnecting:setReconnecting})]})})}let selector$a=s=>({edgesFocusable:s.edgesFocusable,edgesReconnectable:s.edgesReconnectable,elementsSelectable:s.elementsSelectable,connectionMode:s.connectionMode,onError:s.onError});function EdgeRendererComponent({defaultMarkerColor,onlyRenderVisibleElements,rfId,edgeTypes,noPanClassName,onReconnect,onEdgeContextMenu,onEdgeMouseEnter,onEdgeMouseMove,onEdgeMouseLeave,onEdgeClick,reconnectRadius,onEdgeDoubleClick,onReconnectStart,onReconnectEnd,disableKeyboardA11y}){let{edgesFocusable,edgesReconnectable,elementsSelectable,onError}=useStore(selector$a,shallow$1),edgeIds=useVisibleEdgeIds(onlyRenderVisibleElements);return(0,jsx_runtime.jsxs)("div",{className:"react-flow__edges",children:[(0,jsx_runtime.jsx)(MarkerDefinitions$1,{defaultColor:defaultMarkerColor,rfId:rfId}),edgeIds.map(id=>(0,jsx_runtime.jsx)(EdgeWrapper,{id:id,edgesFocusable:edgesFocusable,edgesReconnectable:edgesReconnectable,elementsSelectable:elementsSelectable,noPanClassName:noPanClassName,onReconnect:onReconnect,onContextMenu:onEdgeContextMenu,onMouseEnter:onEdgeMouseEnter,onMouseMove:onEdgeMouseMove,onMouseLeave:onEdgeMouseLeave,onClick:onEdgeClick,reconnectRadius:reconnectRadius,onDoubleClick:onEdgeDoubleClick,onReconnectStart:onReconnectStart,onReconnectEnd:onReconnectEnd,rfId:rfId,onError:onError,edgeTypes:edgeTypes,disableKeyboardA11y:disableKeyboardA11y},id))]})}EdgeRendererComponent.displayName="EdgeRenderer";let EdgeRenderer=(0,react.memo)(EdgeRendererComponent),selector$9=s=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;function Viewport({children}){let transform=useStore(selector$9);return(0,jsx_runtime.jsx)("div",{className:"react-flow__viewport xyflow__viewport react-flow__container",style:{transform},children:children})}function useOnInitHandler(onInit){let rfInstance=useReactFlow(),isInitialized=(0,react.useRef)(!1);(0,react.useEffect)(()=>{!isInitialized.current&&rfInstance.viewportInitialized&&onInit&&(setTimeout(()=>onInit(rfInstance),1),isInitialized.current=!0)},[onInit,rfInstance.viewportInitialized])}let selector$8=state=>state.panZoom?.syncViewport;function useViewportSync(viewport){let syncViewport=useStore(selector$8),store=useStoreApi();return(0,react.useEffect)(()=>{viewport&&(syncViewport?.(viewport),store.setState({transform:[viewport.x,viewport.y,viewport.zoom]}))},[viewport,syncViewport]),null}function storeSelector$1(s){return s.connection.inProgress?{...s.connection,to:(0,esm.m)(s.connection.to,s.transform)}:{...s.connection}}function getSelector(connectionSelector){return connectionSelector?s=>connectionSelector(storeSelector$1(s)):storeSelector$1}function useConnection(connectionSelector){return useStore(getSelector(connectionSelector),shallow$1)}let selector$7=s=>({nodesConnectable:s.nodesConnectable,isValid:s.connection.isValid,inProgress:s.connection.inProgress,width:s.width,height:s.height});function ConnectionLineWrapper({containerStyle,style,type,component}){let{nodesConnectable,width,height,isValid,inProgress}=useStore(selector$7,shallow$1);return width&&nodesConnectable&&inProgress?(0,jsx_runtime.jsx)("svg",{style:containerStyle,width:width,height:height,className:"react-flow__connectionline react-flow__container",children:(0,jsx_runtime.jsx)("g",{className:classcat_cc(["react-flow__connection",(0,esm.Zp)(isValid)]),children:(0,jsx_runtime.jsx)(ConnectionLine,{style:style,type:type,CustomComponent:component,isValid:isValid})})}):null}let ConnectionLine=({style,type=esm.t8.Bezier,CustomComponent,isValid})=>{let{inProgress,from,fromNode,fromHandle,fromPosition,to,toNode,toHandle,toPosition}=useConnection();if(!inProgress)return;if(CustomComponent)return(0,jsx_runtime.jsx)(CustomComponent,{connectionLineType:type,connectionLineStyle:style,fromNode:fromNode,fromHandle:fromHandle,fromX:from.x,fromY:from.y,toX:to.x,toY:to.y,fromPosition:fromPosition,toPosition:toPosition,connectionStatus:(0,esm.Zp)(isValid),toNode:toNode,toHandle:toHandle});let path="",pathParams={sourceX:from.x,sourceY:from.y,sourcePosition:fromPosition,targetX:to.x,targetY:to.y,targetPosition:toPosition};switch(type){case esm.t8.Bezier:[path]=(0,esm.OQ)(pathParams);break;case esm.t8.SimpleBezier:[path]=getSimpleBezierPath(pathParams);break;case esm.t8.Step:[path]=(0,esm.OW)({...pathParams,borderRadius:0});break;case esm.t8.SmoothStep:[path]=(0,esm.OW)(pathParams);break;default:[path]=(0,esm.Hm)(pathParams)}return(0,jsx_runtime.jsx)("path",{d:path,fill:"none",className:"react-flow__connection-path",style:style})};ConnectionLine.displayName="ConnectionLine";let emptyTypes={};function useNodeOrEdgeTypesWarning(nodeOrEdgeTypes=emptyTypes){(0,react.useRef)(nodeOrEdgeTypes),useStoreApi(),(0,react.useEffect)(()=>{},[nodeOrEdgeTypes])}function useStylesLoadedWarning(){useStoreApi(),(0,react.useRef)(!1),(0,react.useEffect)(()=>{},[])}function GraphViewComponent({nodeTypes,edgeTypes,onInit,onNodeClick,onEdgeClick,onNodeDoubleClick,onEdgeDoubleClick,onNodeMouseEnter,onNodeMouseMove,onNodeMouseLeave,onNodeContextMenu,onSelectionContextMenu,onSelectionStart,onSelectionEnd,connectionLineType,connectionLineStyle,connectionLineComponent,connectionLineContainerStyle,selectionKeyCode,selectionOnDrag,selectionMode,multiSelectionKeyCode,panActivationKeyCode,zoomActivationKeyCode,deleteKeyCode,onlyRenderVisibleElements,elementsSelectable,defaultViewport,translateExtent,minZoom,maxZoom,preventScrolling,defaultMarkerColor,zoomOnScroll,zoomOnPinch,panOnScroll,panOnScrollSpeed,panOnScrollMode,zoomOnDoubleClick,panOnDrag,onPaneClick,onPaneMouseEnter,onPaneMouseMove,onPaneMouseLeave,onPaneScroll,onPaneContextMenu,paneClickDistance,nodeClickDistance,onEdgeContextMenu,onEdgeMouseEnter,onEdgeMouseMove,onEdgeMouseLeave,reconnectRadius,onReconnect,onReconnectStart,onReconnectEnd,noDragClassName,noWheelClassName,noPanClassName,disableKeyboardA11y,nodeExtent,rfId,viewport,onViewportChange}){return useNodeOrEdgeTypesWarning(nodeTypes),useNodeOrEdgeTypesWarning(edgeTypes),useStylesLoadedWarning(),useOnInitHandler(onInit),useViewportSync(viewport),(0,jsx_runtime.jsx)(FlowRenderer,{onPaneClick:onPaneClick,onPaneMouseEnter:onPaneMouseEnter,onPaneMouseMove:onPaneMouseMove,onPaneMouseLeave:onPaneMouseLeave,onPaneContextMenu:onPaneContextMenu,onPaneScroll:onPaneScroll,paneClickDistance:paneClickDistance,deleteKeyCode:deleteKeyCode,selectionKeyCode:selectionKeyCode,selectionOnDrag:selectionOnDrag,selectionMode:selectionMode,onSelectionStart:onSelectionStart,onSelectionEnd:onSelectionEnd,multiSelectionKeyCode:multiSelectionKeyCode,panActivationKeyCode:panActivationKeyCode,zoomActivationKeyCode:zoomActivationKeyCode,elementsSelectable:elementsSelectable,zoomOnScroll:zoomOnScroll,zoomOnPinch:zoomOnPinch,zoomOnDoubleClick:zoomOnDoubleClick,panOnScroll:panOnScroll,panOnScrollSpeed:panOnScrollSpeed,panOnScrollMode:panOnScrollMode,panOnDrag:panOnDrag,defaultViewport:defaultViewport,translateExtent:translateExtent,minZoom:minZoom,maxZoom:maxZoom,onSelectionContextMenu:onSelectionContextMenu,preventScrolling:preventScrolling,noDragClassName:noDragClassName,noWheelClassName:noWheelClassName,noPanClassName:noPanClassName,disableKeyboardA11y:disableKeyboardA11y,onViewportChange:onViewportChange,isControlledViewport:!!viewport,children:(0,jsx_runtime.jsxs)(Viewport,{children:[(0,jsx_runtime.jsx)(EdgeRenderer,{edgeTypes:edgeTypes,onEdgeClick:onEdgeClick,onEdgeDoubleClick:onEdgeDoubleClick,onReconnect:onReconnect,onReconnectStart:onReconnectStart,onReconnectEnd:onReconnectEnd,onlyRenderVisibleElements:onlyRenderVisibleElements,onEdgeContextMenu:onEdgeContextMenu,onEdgeMouseEnter:onEdgeMouseEnter,onEdgeMouseMove:onEdgeMouseMove,onEdgeMouseLeave:onEdgeMouseLeave,reconnectRadius:reconnectRadius,defaultMarkerColor:defaultMarkerColor,noPanClassName:noPanClassName,disableKeyboardA11y:disableKeyboardA11y,rfId:rfId}),(0,jsx_runtime.jsx)(ConnectionLineWrapper,{style:connectionLineStyle,type:connectionLineType,component:connectionLineComponent,containerStyle:connectionLineContainerStyle}),(0,jsx_runtime.jsx)("div",{className:"react-flow__edgelabel-renderer"}),(0,jsx_runtime.jsx)(NodeRenderer,{nodeTypes:nodeTypes,onNodeClick:onNodeClick,onNodeDoubleClick:onNodeDoubleClick,onNodeMouseEnter:onNodeMouseEnter,onNodeMouseMove:onNodeMouseMove,onNodeMouseLeave:onNodeMouseLeave,onNodeContextMenu:onNodeContextMenu,nodeClickDistance:nodeClickDistance,onlyRenderVisibleElements:onlyRenderVisibleElements,noPanClassName:noPanClassName,noDragClassName:noDragClassName,disableKeyboardA11y:disableKeyboardA11y,nodeExtent:nodeExtent,rfId:rfId}),(0,jsx_runtime.jsx)("div",{className:"react-flow__viewport-portal"})]})})}GraphViewComponent.displayName="GraphView";let GraphView=(0,react.memo)(GraphViewComponent),getInitialState=({nodes,edges,defaultNodes,defaultEdges,width,height,fitView,fitViewOptions,minZoom=.5,maxZoom=2,nodeOrigin,nodeExtent}={})=>{let nodeLookup=new Map,parentLookup=new Map,connectionLookup=new Map,edgeLookup=new Map,storeEdges=defaultEdges??edges??[],storeNodes=defaultNodes??nodes??[],storeNodeOrigin=nodeOrigin??[0,0],storeNodeExtent=nodeExtent??esm.k5;(0,esm.be)(connectionLookup,edgeLookup,storeEdges);let nodesInitialized=(0,esm.yF)(storeNodes,nodeLookup,parentLookup,{nodeOrigin:storeNodeOrigin,nodeExtent:storeNodeExtent,elevateNodesOnSelect:!1}),transform=[0,0,1];if(fitView&&width&&height){let bounds=(0,esm.W0)(nodeLookup,{filter:node=>!!((node.width||node.initialWidth)&&(node.height||node.initialHeight))}),{x,y,zoom}=(0,esm.$i)(bounds,width,height,minZoom,maxZoom,fitViewOptions?.padding??.1);transform=[x,y,zoom]}return{rfId:"1",width:0,height:0,transform,nodes:storeNodes,nodesInitialized,nodeLookup,parentLookup,edges:storeEdges,edgeLookup,connectionLookup,onNodesChange:null,onEdgesChange:null,hasDefaultNodes:void 0!==defaultNodes,hasDefaultEdges:void 0!==defaultEdges,panZoom:null,minZoom,maxZoom,translateExtent:esm.k5,nodeExtent:storeNodeExtent,nodesSelectionActive:!1,userSelectionActive:!1,userSelectionRect:null,connectionMode:esm.jD.Strict,domNode:null,paneDragging:!1,noPanClassName:"nopan",nodeOrigin:storeNodeOrigin,nodeDragThreshold:1,snapGrid:[15,15],snapToGrid:!1,nodesDraggable:!0,nodesConnectable:!0,nodesFocusable:!0,edgesFocusable:!0,edgesReconnectable:!0,elementsSelectable:!0,elevateNodesOnSelect:!0,elevateEdgesOnSelect:!1,selectNodesOnDrag:!0,multiSelectionActive:!1,fitViewQueued:fitView??!1,fitViewOptions,fitViewResolver:null,connection:{...esm.Ky},connectionClickStartHandle:null,connectOnClick:!0,ariaLiveMessage:"",autoPanOnConnect:!0,autoPanOnNodeDrag:!0,autoPanSpeed:15,connectionRadius:20,onError:esm.Ki,isValidConnection:void 0,onSelectionChangeHandlers:[],lib:"react",debug:!1}},esm_createStore=({nodes,edges,defaultNodes,defaultEdges,width,height,fitView,fitViewOptions,minZoom,maxZoom,nodeOrigin,nodeExtent})=>createWithEqualityFn((set,get)=>{async function resolveFitView(){let{nodeLookup,panZoom,fitViewOptions,fitViewResolver,width,height,minZoom,maxZoom}=get();panZoom&&(await (0,esm.Eg)({nodes:nodeLookup,width,height,panZoom,minZoom,maxZoom},fitViewOptions),fitViewResolver?.resolve(!0),set({fitViewResolver:null}))}return{...getInitialState({nodes,edges,width,height,fitView,fitViewOptions,minZoom,maxZoom,nodeOrigin,nodeExtent,defaultNodes,defaultEdges}),setNodes:nodes=>{let{nodeLookup,parentLookup,nodeOrigin,elevateNodesOnSelect,fitViewQueued}=get(),nodesInitialized=(0,esm.yF)(nodes,nodeLookup,parentLookup,{nodeOrigin,nodeExtent,elevateNodesOnSelect,checkEquality:!0});fitViewQueued&&nodesInitialized?(resolveFitView(),set({nodes,nodesInitialized,fitViewQueued:!1,fitViewOptions:void 0})):set({nodes,nodesInitialized})},setEdges:edges=>{let{connectionLookup,edgeLookup}=get();(0,esm.be)(connectionLookup,edgeLookup,edges),set({edges})},setDefaultNodesAndEdges:(nodes,edges)=>{if(nodes){let{setNodes}=get();setNodes(nodes),set({hasDefaultNodes:!0})}if(edges){let{setEdges}=get();setEdges(edges),set({hasDefaultEdges:!0})}},updateNodeInternals:updates=>{let{triggerNodeChanges,nodeLookup,parentLookup,domNode,nodeOrigin,nodeExtent,debug,fitViewQueued}=get(),{changes,updatedInternals}=(0,esm.B1)(updates,nodeLookup,parentLookup,domNode,nodeOrigin,nodeExtent);updatedInternals&&((0,esm.VV)(nodeLookup,parentLookup,{nodeOrigin,nodeExtent}),fitViewQueued?(resolveFitView(),set({fitViewQueued:!1,fitViewOptions:void 0})):set({}),changes?.length>0&&(debug&&console.log("React Flow: trigger node changes",changes),triggerNodeChanges?.(changes)))},updateNodePositions:(nodeDragItems,dragging=!1)=>{let parentExpandChildren=[],changes=[],{nodeLookup,triggerNodeChanges}=get();for(let[id,dragItem]of nodeDragItems){let node=nodeLookup.get(id),expandParent=!!(node?.expandParent&&node?.parentId&&dragItem?.position),change={id,type:"position",position:expandParent?{x:Math.max(0,dragItem.position.x),y:Math.max(0,dragItem.position.y)}:dragItem.position,dragging};expandParent&&node.parentId&&parentExpandChildren.push({id,parentId:node.parentId,rect:{...dragItem.internals.positionAbsolute,width:dragItem.measured.width??0,height:dragItem.measured.height??0}}),changes.push(change)}if(parentExpandChildren.length>0){let{parentLookup,nodeOrigin}=get(),parentExpandChanges=(0,esm.so)(parentExpandChildren,nodeLookup,parentLookup,nodeOrigin);changes.push(...parentExpandChanges)}triggerNodeChanges(changes)},triggerNodeChanges:changes=>{let{onNodesChange,setNodes,nodes,hasDefaultNodes,debug}=get();changes?.length&&(hasDefaultNodes&&setNodes(applyChanges(changes,nodes)),debug&&console.log("React Flow: trigger node changes",changes),onNodesChange?.(changes))},triggerEdgeChanges:changes=>{let{onEdgesChange,setEdges,edges,hasDefaultEdges,debug}=get();changes?.length&&(hasDefaultEdges&&setEdges(applyChanges(changes,edges)),debug&&console.log("React Flow: trigger edge changes",changes),onEdgesChange?.(changes))},addSelectedNodes:selectedNodeIds=>{let{multiSelectionActive,edgeLookup,nodeLookup,triggerNodeChanges,triggerEdgeChanges}=get();if(multiSelectionActive){triggerNodeChanges(selectedNodeIds.map(nodeId=>createSelectionChange(nodeId,!0)));return}triggerNodeChanges(getSelectionChanges(nodeLookup,new Set([...selectedNodeIds]),!0)),triggerEdgeChanges(getSelectionChanges(edgeLookup))},addSelectedEdges:selectedEdgeIds=>{let{multiSelectionActive,edgeLookup,nodeLookup,triggerNodeChanges,triggerEdgeChanges}=get();if(multiSelectionActive){triggerEdgeChanges(selectedEdgeIds.map(edgeId=>createSelectionChange(edgeId,!0)));return}triggerEdgeChanges(getSelectionChanges(edgeLookup,new Set([...selectedEdgeIds]))),triggerNodeChanges(getSelectionChanges(nodeLookup,new Set,!0))},unselectNodesAndEdges:({nodes,edges}={})=>{let{edges:storeEdges,nodes:storeNodes,nodeLookup,triggerNodeChanges,triggerEdgeChanges}=get(),nodeChanges=(nodes||storeNodes).map(n=>{let internalNode=nodeLookup.get(n.id);return internalNode&&(internalNode.selected=!1),createSelectionChange(n.id,!1)}),edgeChanges=(edges||storeEdges).map(edge=>createSelectionChange(edge.id,!1));triggerNodeChanges(nodeChanges),triggerEdgeChanges(edgeChanges)},setMinZoom:minZoom=>{let{panZoom,maxZoom}=get();panZoom?.setScaleExtent([minZoom,maxZoom]),set({minZoom})},setMaxZoom:maxZoom=>{let{panZoom,minZoom}=get();panZoom?.setScaleExtent([minZoom,maxZoom]),set({maxZoom})},setTranslateExtent:translateExtent=>{get().panZoom?.setTranslateExtent(translateExtent),set({translateExtent})},setPaneClickDistance:clickDistance=>{get().panZoom?.setClickDistance(clickDistance)},resetSelectedElements:()=>{let{edges,nodes,triggerNodeChanges,triggerEdgeChanges,elementsSelectable}=get();if(!elementsSelectable)return;let nodeChanges=nodes.reduce((res,node)=>node.selected?[...res,createSelectionChange(node.id,!1)]:res,[]),edgeChanges=edges.reduce((res,edge)=>edge.selected?[...res,createSelectionChange(edge.id,!1)]:res,[]);triggerNodeChanges(nodeChanges),triggerEdgeChanges(edgeChanges)},setNodeExtent:nextNodeExtent=>{let{nodes,nodeLookup,parentLookup,nodeOrigin,elevateNodesOnSelect,nodeExtent}=get();(nextNodeExtent[0][0]!==nodeExtent[0][0]||nextNodeExtent[0][1]!==nodeExtent[0][1]||nextNodeExtent[1][0]!==nodeExtent[1][0]||nextNodeExtent[1][1]!==nodeExtent[1][1])&&((0,esm.yF)(nodes,nodeLookup,parentLookup,{nodeOrigin,nodeExtent:nextNodeExtent,elevateNodesOnSelect,checkEquality:!1}),set({nodeExtent:nextNodeExtent}))},panBy:delta=>{let{transform,width,height,panZoom,translateExtent}=get();return(0,esm.hO)({delta,panZoom,transform,translateExtent,width,height})},cancelConnection:()=>{set({connection:{...esm.Ky}})},updateConnection:connection=>{set({connection})},reset:()=>set({...getInitialState()})}},Object.is);function ReactFlowProvider({initialNodes:nodes,initialEdges:edges,defaultNodes,defaultEdges,initialWidth:width,initialHeight:height,initialMinZoom:minZoom,initialMaxZoom:maxZoom,initialFitViewOptions:fitViewOptions,fitView,nodeOrigin,nodeExtent,children}){let[store]=(0,react.useState)(()=>esm_createStore({nodes,edges,defaultNodes,defaultEdges,width,height,fitView,minZoom,maxZoom,fitViewOptions,nodeOrigin,nodeExtent}));return(0,jsx_runtime.jsx)(Provider$1,{value:store,children:(0,jsx_runtime.jsx)(BatchProvider,{children:children})})}function Wrapper({children,nodes,edges,defaultNodes,defaultEdges,width,height,fitView,fitViewOptions,minZoom,maxZoom,nodeOrigin,nodeExtent}){return(0,react.useContext)(StoreContext)?(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:children}):(0,jsx_runtime.jsx)(ReactFlowProvider,{initialNodes:nodes,initialEdges:edges,defaultNodes:defaultNodes,defaultEdges:defaultEdges,initialWidth:width,initialHeight:height,fitView:fitView,initialFitViewOptions:fitViewOptions,initialMinZoom:minZoom,initialMaxZoom:maxZoom,nodeOrigin:nodeOrigin,nodeExtent:nodeExtent,children:children})}let wrapperStyle={width:"100%",height:"100%",overflow:"hidden",position:"relative",zIndex:0};var index=fixedForwardRef(function ReactFlow({nodes,edges,defaultNodes,defaultEdges,className,nodeTypes,edgeTypes,onNodeClick,onEdgeClick,onInit,onMove,onMoveStart,onMoveEnd,onConnect,onConnectStart,onConnectEnd,onClickConnectStart,onClickConnectEnd,onNodeMouseEnter,onNodeMouseMove,onNodeMouseLeave,onNodeContextMenu,onNodeDoubleClick,onNodeDragStart,onNodeDrag,onNodeDragStop,onNodesDelete,onEdgesDelete,onDelete,onSelectionChange,onSelectionDragStart,onSelectionDrag,onSelectionDragStop,onSelectionContextMenu,onSelectionStart,onSelectionEnd,onBeforeDelete,connectionMode,connectionLineType=esm.t8.Bezier,connectionLineStyle,connectionLineComponent,connectionLineContainerStyle,deleteKeyCode="Backspace",selectionKeyCode="Shift",selectionOnDrag=!1,selectionMode=esm.oW.Full,panActivationKeyCode="Space",multiSelectionKeyCode=(0,esm.Q5)()?"Meta":"Control",zoomActivationKeyCode=(0,esm.Q5)()?"Meta":"Control",snapToGrid,snapGrid,onlyRenderVisibleElements=!1,selectNodesOnDrag,nodesDraggable,nodesConnectable,nodesFocusable,nodeOrigin=defaultNodeOrigin,edgesFocusable,edgesReconnectable,elementsSelectable=!0,defaultViewport:defaultViewport$1=defaultViewport,minZoom=.5,maxZoom=2,translateExtent=esm.k5,preventScrolling=!0,nodeExtent,defaultMarkerColor="#b1b1b7",zoomOnScroll=!0,zoomOnPinch=!0,panOnScroll=!1,panOnScrollSpeed=.5,panOnScrollMode=esm.IY.Free,zoomOnDoubleClick=!0,panOnDrag=!0,onPaneClick,onPaneMouseEnter,onPaneMouseMove,onPaneMouseLeave,onPaneScroll,onPaneContextMenu,paneClickDistance=0,nodeClickDistance=0,children,onReconnect,onReconnectStart,onReconnectEnd,onEdgeContextMenu,onEdgeDoubleClick,onEdgeMouseEnter,onEdgeMouseMove,onEdgeMouseLeave,reconnectRadius=10,onNodesChange,onEdgesChange,noDragClassName="nodrag",noWheelClassName="nowheel",noPanClassName="nopan",fitView,fitViewOptions,connectOnClick,attributionPosition,proOptions,defaultEdgeOptions,elevateNodesOnSelect,elevateEdgesOnSelect,disableKeyboardA11y=!1,autoPanOnConnect,autoPanOnNodeDrag,autoPanSpeed,connectionRadius,isValidConnection,onError,style,id,nodeDragThreshold,viewport,onViewportChange,width,height,colorMode="light",debug,onScroll,...rest},ref){let rfId=id||"1",colorModeClassName=useColorModeClass(colorMode),wrapperOnScroll=(0,react.useCallback)(e=>{e.currentTarget.scrollTo({top:0,left:0,behavior:"instant"}),onScroll?.(e)},[onScroll]);return(0,jsx_runtime.jsx)("div",{"data-testid":"rf__wrapper",...rest,onScroll:wrapperOnScroll,style:{...style,...wrapperStyle},ref:ref,className:classcat_cc(["react-flow",className,colorModeClassName]),id:id,children:(0,jsx_runtime.jsxs)(Wrapper,{nodes:nodes,edges:edges,width:width,height:height,fitView:fitView,fitViewOptions:fitViewOptions,minZoom:minZoom,maxZoom:maxZoom,nodeOrigin:nodeOrigin,nodeExtent:nodeExtent,children:[(0,jsx_runtime.jsx)(GraphView,{onInit:onInit,onNodeClick:onNodeClick,onEdgeClick:onEdgeClick,onNodeMouseEnter:onNodeMouseEnter,onNodeMouseMove:onNodeMouseMove,onNodeMouseLeave:onNodeMouseLeave,onNodeContextMenu:onNodeContextMenu,onNodeDoubleClick:onNodeDoubleClick,nodeTypes:nodeTypes,edgeTypes:edgeTypes,connectionLineType:connectionLineType,connectionLineStyle:connectionLineStyle,connectionLineComponent:connectionLineComponent,connectionLineContainerStyle:connectionLineContainerStyle,selectionKeyCode:selectionKeyCode,selectionOnDrag:selectionOnDrag,selectionMode:selectionMode,deleteKeyCode:deleteKeyCode,multiSelectionKeyCode:multiSelectionKeyCode,panActivationKeyCode:panActivationKeyCode,zoomActivationKeyCode:zoomActivationKeyCode,onlyRenderVisibleElements:onlyRenderVisibleElements,defaultViewport:defaultViewport$1,translateExtent:translateExtent,minZoom:minZoom,maxZoom:maxZoom,preventScrolling:preventScrolling,zoomOnScroll:zoomOnScroll,zoomOnPinch:zoomOnPinch,zoomOnDoubleClick:zoomOnDoubleClick,panOnScroll:panOnScroll,panOnScrollSpeed:panOnScrollSpeed,panOnScrollMode:panOnScrollMode,panOnDrag:panOnDrag,onPaneClick:onPaneClick,onPaneMouseEnter:onPaneMouseEnter,onPaneMouseMove:onPaneMouseMove,onPaneMouseLeave:onPaneMouseLeave,onPaneScroll:onPaneScroll,onPaneContextMenu:onPaneContextMenu,paneClickDistance:paneClickDistance,nodeClickDistance:nodeClickDistance,onSelectionContextMenu:onSelectionContextMenu,onSelectionStart:onSelectionStart,onSelectionEnd:onSelectionEnd,onReconnect:onReconnect,onReconnectStart:onReconnectStart,onReconnectEnd:onReconnectEnd,onEdgeContextMenu:onEdgeContextMenu,onEdgeDoubleClick:onEdgeDoubleClick,onEdgeMouseEnter:onEdgeMouseEnter,onEdgeMouseMove:onEdgeMouseMove,onEdgeMouseLeave:onEdgeMouseLeave,reconnectRadius:reconnectRadius,defaultMarkerColor:defaultMarkerColor,noDragClassName:noDragClassName,noWheelClassName:noWheelClassName,noPanClassName:noPanClassName,rfId:rfId,disableKeyboardA11y:disableKeyboardA11y,nodeExtent:nodeExtent,viewport:viewport,onViewportChange:onViewportChange}),(0,jsx_runtime.jsx)(StoreUpdater,{nodes:nodes,edges:edges,defaultNodes:defaultNodes,defaultEdges:defaultEdges,onConnect:onConnect,onConnectStart:onConnectStart,onConnectEnd:onConnectEnd,onClickConnectStart:onClickConnectStart,onClickConnectEnd:onClickConnectEnd,nodesDraggable:nodesDraggable,nodesConnectable:nodesConnectable,nodesFocusable:nodesFocusable,edgesFocusable:edgesFocusable,edgesReconnectable:edgesReconnectable,elementsSelectable:elementsSelectable,elevateNodesOnSelect:elevateNodesOnSelect,elevateEdgesOnSelect:elevateEdgesOnSelect,minZoom:minZoom,maxZoom:maxZoom,nodeExtent:nodeExtent,onNodesChange:onNodesChange,onEdgesChange:onEdgesChange,snapToGrid:snapToGrid,snapGrid:snapGrid,connectionMode:connectionMode,translateExtent:translateExtent,connectOnClick:connectOnClick,defaultEdgeOptions:defaultEdgeOptions,fitView:fitView,fitViewOptions:fitViewOptions,onNodesDelete:onNodesDelete,onEdgesDelete:onEdgesDelete,onDelete:onDelete,onNodeDragStart:onNodeDragStart,onNodeDrag:onNodeDrag,onNodeDragStop:onNodeDragStop,onSelectionDrag:onSelectionDrag,onSelectionDragStart:onSelectionDragStart,onSelectionDragStop:onSelectionDragStop,onMove:onMove,onMoveStart:onMoveStart,onMoveEnd:onMoveEnd,noPanClassName:noPanClassName,nodeOrigin:nodeOrigin,rfId:rfId,autoPanOnConnect:autoPanOnConnect,autoPanOnNodeDrag:autoPanOnNodeDrag,autoPanSpeed:autoPanSpeed,onError:onError,connectionRadius:connectionRadius,isValidConnection:isValidConnection,selectNodesOnDrag:selectNodesOnDrag,nodeDragThreshold:nodeDragThreshold,onBeforeDelete:onBeforeDelete,paneClickDistance:paneClickDistance,debug:debug}),(0,jsx_runtime.jsx)(SelectionListener,{onSelectionChange:onSelectionChange}),children,(0,jsx_runtime.jsx)(Attribution,{proOptions:proOptions,position:attributionPosition}),(0,jsx_runtime.jsx)(A11yDescriptions,{rfId:rfId,disableKeyboardA11y:disableKeyboardA11y})]})})});function useUpdateNodeInternals(){let store=useStoreApi();return(0,react.useCallback)(id=>{let{domNode,updateNodeInternals}=store.getState(),updateIds=Array.isArray(id)?id:[id],updates=new Map;updateIds.forEach(updateId=>{let nodeElement=domNode?.querySelector(`.react-flow__node[data-id="${updateId}"]`);nodeElement&&updates.set(updateId,{id:updateId,nodeElement,force:!0})}),requestAnimationFrame(()=>updateNodeInternals(updates,{triggerFitView:!1}))},[])}function LinePattern({dimensions,lineWidth,variant,className}){return(0,jsx_runtime.jsx)("path",{strokeWidth:lineWidth,d:`M${dimensions[0]/2} 0 V${dimensions[1]} M0 ${dimensions[1]/2} H${dimensions[0]}`,className:classcat_cc(["react-flow__background-pattern",variant,className])})}function DotPattern({radius,className}){return(0,jsx_runtime.jsx)("circle",{cx:radius,cy:radius,r:radius,className:classcat_cc(["react-flow__background-pattern","dots",className])})}esm.Qj.error014(),!function(BackgroundVariant){BackgroundVariant.Lines="lines",BackgroundVariant.Dots="dots",BackgroundVariant.Cross="cross"}(BackgroundVariant||(BackgroundVariant={}));let defaultSize={[BackgroundVariant.Dots]:1,[BackgroundVariant.Lines]:1,[BackgroundVariant.Cross]:6},selector$3=s=>({transform:s.transform,patternId:`pattern-${s.rfId}`});function BackgroundComponent({id,variant=BackgroundVariant.Dots,gap=20,size,lineWidth=1,offset=0,color,bgColor,style,className,patternClassName}){let ref=(0,react.useRef)(null),{transform,patternId}=useStore(selector$3,shallow$1),patternSize=size||defaultSize[variant],isDots=variant===BackgroundVariant.Dots,isCross=variant===BackgroundVariant.Cross,gapXY=Array.isArray(gap)?gap:[gap,gap],scaledGap=[gapXY[0]*transform[2]||1,gapXY[1]*transform[2]||1],scaledSize=patternSize*transform[2],offsetXY=Array.isArray(offset)?offset:[offset,offset],patternDimensions=isCross?[scaledSize,scaledSize]:scaledGap,scaledOffset=[offsetXY[0]*transform[2]||1+patternDimensions[0]/2,offsetXY[1]*transform[2]||1+patternDimensions[1]/2],_patternId=`${patternId}${id||""}`;return(0,jsx_runtime.jsxs)("svg",{className:classcat_cc(["react-flow__background",className]),style:{...style,...containerStyle,"--xy-background-color-props":bgColor,"--xy-background-pattern-color-props":color},ref:ref,"data-testid":"rf__background",children:[(0,jsx_runtime.jsx)("pattern",{id:_patternId,x:transform[0]%scaledGap[0],y:transform[1]%scaledGap[1],width:scaledGap[0],height:scaledGap[1],patternUnits:"userSpaceOnUse",patternTransform:`translate(-${scaledOffset[0]},-${scaledOffset[1]})`,children:isDots?(0,jsx_runtime.jsx)(DotPattern,{radius:scaledSize/2,className:patternClassName}):(0,jsx_runtime.jsx)(LinePattern,{dimensions:patternDimensions,lineWidth:lineWidth,variant:variant,className:patternClassName})}),(0,jsx_runtime.jsx)("rect",{x:"0",y:"0",width:"100%",height:"100%",fill:`url(#${_patternId})`})]})}BackgroundComponent.displayName="Background";let Background=(0,react.memo)(BackgroundComponent);function PlusIcon(){return(0,jsx_runtime.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",children:(0,jsx_runtime.jsx)("path",{d:"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z"})})}function MinusIcon(){return(0,jsx_runtime.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 5",children:(0,jsx_runtime.jsx)("path",{d:"M0 0h32v4.2H0z"})})}function FitViewIcon(){return(0,jsx_runtime.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 30",children:(0,jsx_runtime.jsx)("path",{d:"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z"})})}function LockIcon(){return(0,jsx_runtime.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 25 32",children:(0,jsx_runtime.jsx)("path",{d:"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z"})})}function UnlockIcon(){return(0,jsx_runtime.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 25 32",children:(0,jsx_runtime.jsx)("path",{d:"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z"})})}function ControlButton({children,className,...rest}){return(0,jsx_runtime.jsx)("button",{type:"button",className:classcat_cc(["react-flow__controls-button",className]),...rest,children:children})}let selector$2=s=>({isInteractive:s.nodesDraggable||s.nodesConnectable||s.elementsSelectable,minZoomReached:s.transform[2]<=s.minZoom,maxZoomReached:s.transform[2]>=s.maxZoom});function ControlsComponent({style,showZoom=!0,showFitView=!0,showInteractive=!0,fitViewOptions,onZoomIn,onZoomOut,onFitView,onInteractiveChange,className,children,position="bottom-left",orientation="vertical","aria-label":ariaLabel="React Flow controls"}){let store=useStoreApi(),{isInteractive,minZoomReached,maxZoomReached}=useStore(selector$2,shallow$1),{zoomIn,zoomOut,fitView}=useReactFlow();return(0,jsx_runtime.jsxs)(Panel,{className:classcat_cc(["react-flow__controls","horizontal"===orientation?"horizontal":"vertical",className]),position:position,style:style,"data-testid":"rf__controls","aria-label":ariaLabel,children:[showZoom&&(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)(ControlButton,{onClick:()=>{zoomIn(),onZoomIn?.()},className:"react-flow__controls-zoomin",title:"zoom in","aria-label":"zoom in",disabled:maxZoomReached,children:(0,jsx_runtime.jsx)(PlusIcon,{})}),(0,jsx_runtime.jsx)(ControlButton,{onClick:()=>{zoomOut(),onZoomOut?.()},className:"react-flow__controls-zoomout",title:"zoom out","aria-label":"zoom out",disabled:minZoomReached,children:(0,jsx_runtime.jsx)(MinusIcon,{})})]}),showFitView&&(0,jsx_runtime.jsx)(ControlButton,{className:"react-flow__controls-fitview",onClick:()=>{fitView(fitViewOptions),onFitView?.()},title:"fit view","aria-label":"fit view",children:(0,jsx_runtime.jsx)(FitViewIcon,{})}),showInteractive&&(0,jsx_runtime.jsx)(ControlButton,{className:"react-flow__controls-interactive",onClick:()=>{store.setState({nodesDraggable:!isInteractive,nodesConnectable:!isInteractive,elementsSelectable:!isInteractive}),onInteractiveChange?.(!isInteractive)},title:"toggle interactivity","aria-label":"toggle interactivity",children:isInteractive?(0,jsx_runtime.jsx)(UnlockIcon,{}):(0,jsx_runtime.jsx)(LockIcon,{})}),children]})}ControlsComponent.displayName="Controls";let Controls=(0,react.memo)(ControlsComponent);function MiniMapNodeComponent({id,x,y,width,height,style,color,strokeColor,strokeWidth,className,borderRadius,shapeRendering,selected,onClick}){let{background,backgroundColor}=style||{};return(0,jsx_runtime.jsx)("rect",{className:classcat_cc(["react-flow__minimap-node",{selected},className]),x:x,y:y,rx:borderRadius,ry:borderRadius,width:width,height:height,style:{fill:color||background||backgroundColor,stroke:strokeColor,strokeWidth},shapeRendering:shapeRendering,onClick:onClick?event=>onClick(event,id):void 0})}let MiniMapNode=(0,react.memo)(MiniMapNodeComponent),selectorNodeIds=s=>s.nodes.map(node=>node.id),getAttrFunction=func=>func instanceof Function?func:()=>func;function MiniMapNodes({nodeStrokeColor,nodeColor,nodeClassName="",nodeBorderRadius=5,nodeStrokeWidth,nodeComponent:NodeComponent=MiniMapNode,onClick}){let nodeIds=useStore(selectorNodeIds,shallow$1),nodeColorFunc=getAttrFunction(nodeColor),nodeStrokeColorFunc=getAttrFunction(nodeStrokeColor),nodeClassNameFunc=getAttrFunction(nodeClassName),shapeRendering="undefined"==typeof window||window.chrome?"crispEdges":"geometricPrecision";return(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:nodeIds.map(nodeId=>(0,jsx_runtime.jsx)(NodeComponentWrapper,{id:nodeId,nodeColorFunc:nodeColorFunc,nodeStrokeColorFunc:nodeStrokeColorFunc,nodeClassNameFunc:nodeClassNameFunc,nodeBorderRadius:nodeBorderRadius,nodeStrokeWidth:nodeStrokeWidth,NodeComponent:NodeComponent,onClick:onClick,shapeRendering:shapeRendering},nodeId))})}function NodeComponentWrapperInner({id,nodeColorFunc,nodeStrokeColorFunc,nodeClassNameFunc,nodeBorderRadius,nodeStrokeWidth,shapeRendering,NodeComponent,onClick}){let{node,x,y,width,height}=useStore(s=>{let{internals}=s.nodeLookup.get(id),node=internals.userNode,{x,y}=internals.positionAbsolute,{width,height}=(0,esm.Rf)(node);return{node,x,y,width,height}},shallow$1);return node&&!node.hidden&&(0,esm.nb)(node)?(0,jsx_runtime.jsx)(NodeComponent,{x:x,y:y,width:width,height:height,style:node.style,selected:!!node.selected,className:nodeClassNameFunc(node),color:nodeColorFunc(node),borderRadius:nodeBorderRadius,strokeColor:nodeStrokeColorFunc(node),strokeWidth:nodeStrokeWidth,shapeRendering:shapeRendering,onClick:onClick,id:node.id}):null}let NodeComponentWrapper=(0,react.memo)(NodeComponentWrapperInner);var MiniMapNodes$1=(0,react.memo)(MiniMapNodes);let filterHidden=node=>!node.hidden,selector$1=s=>{let viewBB={x:-s.transform[0]/s.transform[2],y:-s.transform[1]/s.transform[2],width:s.width/s.transform[2],height:s.height/s.transform[2]};return{viewBB,boundingRect:s.nodeLookup.size>0?(0,esm.oI)((0,esm.W0)(s.nodeLookup,{filter:filterHidden}),viewBB):viewBB,rfId:s.rfId,panZoom:s.panZoom,translateExtent:s.translateExtent,flowWidth:s.width,flowHeight:s.height}};function MiniMapComponent({style,className,nodeStrokeColor,nodeColor,nodeClassName="",nodeBorderRadius=5,nodeStrokeWidth,nodeComponent,bgColor,maskColor,maskStrokeColor,maskStrokeWidth,position="bottom-right",onClick,onNodeClick,pannable=!1,zoomable=!1,ariaLabel="React Flow mini map",inversePan,zoomStep=10,offsetScale=5}){let store=useStoreApi(),svg=(0,react.useRef)(null),{boundingRect,viewBB,rfId,panZoom,translateExtent,flowWidth,flowHeight}=useStore(selector$1,shallow$1),elementWidth=style?.width??200,elementHeight=style?.height??150,viewScale=Math.max(boundingRect.width/elementWidth,boundingRect.height/elementHeight),viewWidth=viewScale*elementWidth,viewHeight=viewScale*elementHeight,offset=offsetScale*viewScale,x=boundingRect.x-(viewWidth-boundingRect.width)/2-offset,y=boundingRect.y-(viewHeight-boundingRect.height)/2-offset,width=viewWidth+2*offset,height=viewHeight+2*offset,labelledBy=`react-flow__minimap-desc-${rfId}`,viewScaleRef=(0,react.useRef)(0),minimapInstance=(0,react.useRef)();viewScaleRef.current=viewScale,(0,react.useEffect)(()=>{if(svg.current&&panZoom)return minimapInstance.current=(0,esm.FD)({domNode:svg.current,panZoom,getTransform:()=>store.getState().transform,getViewScale:()=>viewScaleRef.current}),()=>{minimapInstance.current?.destroy()}},[panZoom]),(0,react.useEffect)(()=>{minimapInstance.current?.update({translateExtent,width:flowWidth,height:flowHeight,inversePan,pannable,zoomStep,zoomable})},[pannable,zoomable,inversePan,zoomStep,translateExtent,flowWidth,flowHeight]);let onSvgClick=onClick?event=>{let[x,y]=minimapInstance.current?.pointer(event)||[0,0];onClick(event,{x,y})}:void 0,onSvgNodeClick=onNodeClick?(0,react.useCallback)((event,nodeId)=>{onNodeClick(event,store.getState().nodeLookup.get(nodeId).internals.userNode)},[]):void 0;return(0,jsx_runtime.jsx)(Panel,{position:position,style:{...style,"--xy-minimap-background-color-props":"string"==typeof bgColor?bgColor:void 0,"--xy-minimap-mask-background-color-props":"string"==typeof maskColor?maskColor:void 0,"--xy-minimap-mask-stroke-color-props":"string"==typeof maskStrokeColor?maskStrokeColor:void 0,"--xy-minimap-mask-stroke-width-props":"number"==typeof maskStrokeWidth?maskStrokeWidth*viewScale:void 0,"--xy-minimap-node-background-color-props":"string"==typeof nodeColor?nodeColor:void 0,"--xy-minimap-node-stroke-color-props":"string"==typeof nodeStrokeColor?nodeStrokeColor:void 0,"--xy-minimap-node-stroke-width-props":"number"==typeof nodeStrokeWidth?nodeStrokeWidth:void 0},className:classcat_cc(["react-flow__minimap",className]),"data-testid":"rf__minimap",children:(0,jsx_runtime.jsxs)("svg",{width:elementWidth,height:elementHeight,viewBox:`${x} ${y} ${width} ${height}`,className:"react-flow__minimap-svg",role:"img","aria-labelledby":labelledBy,ref:svg,onClick:onSvgClick,children:[ariaLabel&&(0,jsx_runtime.jsx)("title",{id:labelledBy,children:ariaLabel}),(0,jsx_runtime.jsx)(MiniMapNodes$1,{onClick:onSvgNodeClick,nodeColor:nodeColor,nodeStrokeColor:nodeStrokeColor,nodeBorderRadius:nodeBorderRadius,nodeClassName:nodeClassName,nodeStrokeWidth:nodeStrokeWidth,nodeComponent:nodeComponent}),(0,jsx_runtime.jsx)("path",{className:"react-flow__minimap-mask",d:`M${x-offset},${y-offset}h${width+2*offset}v${height+2*offset}h${-width-2*offset}z
        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,fillRule:"evenodd",pointerEvents:"none"})]})})}MiniMapComponent.displayName="MiniMap";let MiniMap=(0,react.memo)(MiniMapComponent);function ResizeControl({nodeId,position,variant=esm.pB.Handle,className,style={},children,color,minWidth=10,minHeight=10,maxWidth=Number.MAX_VALUE,maxHeight=Number.MAX_VALUE,keepAspectRatio=!1,resizeDirection,shouldResize,onResizeStart,onResize,onResizeEnd}){let contextNodeId=useNodeId(),id="string"==typeof nodeId?nodeId:contextNodeId,store=useStoreApi(),resizeControlRef=(0,react.useRef)(null),defaultPosition=variant===esm.pB.Line?"right":"bottom-right",controlPosition=position??defaultPosition,resizer=(0,react.useRef)(null);(0,react.useEffect)(()=>{if(resizeControlRef.current&&id)return resizer.current||(resizer.current=(0,esm.Cz)({domNode:resizeControlRef.current,nodeId:id,getStoreItems:()=>{let{nodeLookup,transform,snapGrid,snapToGrid,nodeOrigin,domNode}=store.getState();return{nodeLookup,transform,snapGrid,snapToGrid,nodeOrigin,paneDomNode:domNode}},onChange:(change,childChanges)=>{let{triggerNodeChanges,nodeLookup,parentLookup,nodeOrigin}=store.getState(),changes=[],nextPosition={x:change.x,y:change.y},node=nodeLookup.get(id);if(node&&node.expandParent&&node.parentId){let origin=node.origin??nodeOrigin,width=change.width??node.measured.width??0,height=change.height??node.measured.height??0,child={id:node.id,parentId:node.parentId,rect:{width,height,...(0,esm.ZB)({x:change.x??node.position.x,y:change.y??node.position.y},{width,height},node.parentId,nodeLookup,origin)}},parentExpandChanges=(0,esm.so)([child],nodeLookup,parentLookup,nodeOrigin);changes.push(...parentExpandChanges),nextPosition.x=change.x?Math.max(origin[0]*width,change.x):void 0,nextPosition.y=change.y?Math.max(origin[1]*height,change.y):void 0}if(void 0!==nextPosition.x&&void 0!==nextPosition.y){let positionChange={id,type:"position",position:{...nextPosition}};changes.push(positionChange)}if(void 0!==change.width&&void 0!==change.height){let dimensionChange={id,type:"dimensions",resizing:!0,setAttributes:!resizeDirection||("horizontal"===resizeDirection?"width":"height"),dimensions:{width:change.width,height:change.height}};changes.push(dimensionChange)}for(let childChange of childChanges){let positionChange={...childChange,type:"position"};changes.push(positionChange)}triggerNodeChanges(changes)},onEnd:({width,height})=>{store.getState().triggerNodeChanges([{id:id,type:"dimensions",resizing:!1,dimensions:{width,height}}])}})),resizer.current.update({controlPosition,boundaries:{minWidth,minHeight,maxWidth,maxHeight},keepAspectRatio,resizeDirection,onResizeStart,onResize,onResizeEnd,shouldResize}),()=>{resizer.current?.destroy()}},[controlPosition,minWidth,minHeight,maxWidth,maxHeight,keepAspectRatio,onResizeStart,onResize,onResizeEnd,shouldResize]);let positionClassNames=controlPosition.split("-"),colorStyleProp=variant===esm.pB.Line?"borderColor":"backgroundColor",controlStyle=color?{...style,[colorStyleProp]:color}:style;return(0,jsx_runtime.jsx)("div",{className:classcat_cc(["react-flow__resize-control","nodrag",...positionClassNames,variant,className]),ref:resizeControlRef,style:controlStyle,children:children})}(0,react.memo)(ResizeControl);let selector=state=>state.domNode?.querySelector(".react-flow__renderer"),nodeEqualityFn=(a,b)=>a?.internals.positionAbsolute.x!==b?.internals.positionAbsolute.x||a?.internals.positionAbsolute.y!==b?.internals.positionAbsolute.y||a?.measured.width!==b?.measured.width||a?.measured.height!==b?.measured.height||a?.selected!==b?.selected||a?.internals.z!==b?.internals.z},"../../node_modules/.pnpm/@xyflow+system@0.0.57/node_modules/@xyflow/system/dist/esm/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{t8:()=>ConnectionLineType,jD:()=>ConnectionMode,QZ:()=>MarkerType,IY:()=>PanOnScrollMode,Ly:()=>Position,pB:()=>ResizeControlVariant,oW:()=>SelectionMode,oC:()=>XYDrag,Ql:()=>XYHandle,FD:()=>XYMinimap,X6:()=>XYPanZoom,Cz:()=>XYResizer,Z_:()=>addEdge,yF:()=>adoptUserNodes,OL:()=>areSetsEqual,q7:()=>calculateNodePosition,n3:()=>createMarkerIds,Ki:()=>devWarn,wQ:()=>elementSelectionKeys,Qj:()=>errorMessages,ZB:()=>evaluateAbsolutePosition,Eg:()=>fitViewport,lM:()=>getBezierEdgeCenter,OQ:()=>getBezierPath,oI:()=>getBoundsOfRects,Zp:()=>getConnectionStatus,t_:()=>getDimensions,JU:()=>getEdgePosition,WD:()=>getElementsToRemove,xx:()=>getElevatedEdgeZIndex,wv:()=>getEventPosition,S2:()=>getHostForElement,W0:()=>getInternalNodesBounds,dW:()=>getMarkerId,Rf:()=>getNodeDimensions,RX:()=>getNodesBounds,f5:()=>getNodesInside,xA:()=>getOutgoers,lp:()=>getOverlappingArea,OW:()=>getSmoothStepPath,Hm:()=>getStraightPath,$i:()=>getViewportForBounds,so:()=>handleExpandParent,k5:()=>infiniteExtent,Ky:()=>initialConnection,J3:()=>isEdgeBase,RY:()=>isEdgeVisible,s$:()=>isInputDOMNode,Q5:()=>isMacOs,N5:()=>isMouseEvent,Vt:()=>isNodeBase,kE:()=>isNumeric,J$:()=>isRectObject,nb:()=>nodeHasDimensions,PS:()=>nodeToRect,hO:()=>panBy,m:()=>pointToRendererPoint,oj:()=>rendererPointToPoint,_2:()=>snapPosition,VV:()=>updateAbsolutePositions,be:()=>updateConnectionLookup,B1:()=>updateNodeInternals,nu:()=>withResolvers});var ConnectionMode,PanOnScrollMode,SelectionMode,ConnectionLineType,MarkerType,Position,ResizeControlVariant,dispatch=__webpack_require__("../../node_modules/.pnpm/d3-dispatch@3.0.1/node_modules/d3-dispatch/src/dispatch.js"),src_select=__webpack_require__("../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/select.js"),pointer=__webpack_require__("../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/pointer.js"),nodrag=__webpack_require__("../../node_modules/.pnpm/d3-drag@3.0.0/node_modules/d3-drag/src/nodrag.js"),noevent=__webpack_require__("../../node_modules/.pnpm/d3-drag@3.0.0/node_modules/d3-drag/src/noevent.js");let constant=x=>()=>x;function DragEvent(type,{sourceEvent,subject,target,identifier,active,x,y,dx,dy,dispatch}){Object.defineProperties(this,{type:{value:type,enumerable:!0,configurable:!0},sourceEvent:{value:sourceEvent,enumerable:!0,configurable:!0},subject:{value:subject,enumerable:!0,configurable:!0},target:{value:target,enumerable:!0,configurable:!0},identifier:{value:identifier,enumerable:!0,configurable:!0},active:{value:active,enumerable:!0,configurable:!0},x:{value:x,enumerable:!0,configurable:!0},y:{value:y,enumerable:!0,configurable:!0},dx:{value:dx,enumerable:!0,configurable:!0},dy:{value:dy,enumerable:!0,configurable:!0},_:{value:dispatch}})}function defaultFilter(event){return!event.ctrlKey&&!event.button}function defaultContainer(){return this.parentNode}function defaultSubject(event,d){return null==d?{x:event.x,y:event.y}:d}function defaultTouchable(){return navigator.maxTouchPoints||"ontouchstart"in this}function drag(){var mousedownx,mousedowny,mousemoving,touchending,filter=defaultFilter,container=defaultContainer,subject=defaultSubject,touchable=defaultTouchable,gestures={},listeners=(0,dispatch.Z)("start","drag","end"),active=0,clickDistance2=0;function drag(selection){selection.on("mousedown.drag",mousedowned).filter(touchable).on("touchstart.drag",touchstarted).on("touchmove.drag",touchmoved,noevent.Q7).on("touchend.drag touchcancel.drag",touchended).style("touch-action","none").style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function mousedowned(event,d){if(!touchending&&filter.call(this,event,d)){var gesture=beforestart(this,container.call(this,event,d),event,d,"mouse");gesture&&((0,src_select.Z)(event.view).on("mousemove.drag",mousemoved,noevent.Dd).on("mouseup.drag",mouseupped,noevent.Dd),(0,nodrag.Z)(event.view),(0,noevent.rG)(event),mousemoving=!1,mousedownx=event.clientX,mousedowny=event.clientY,gesture("start",event))}}function mousemoved(event){if((0,noevent.ZP)(event),!mousemoving){var dx=event.clientX-mousedownx,dy=event.clientY-mousedowny;mousemoving=dx*dx+dy*dy>clickDistance2}gestures.mouse("drag",event)}function mouseupped(event){(0,src_select.Z)(event.view).on("mousemove.drag mouseup.drag",null),(0,nodrag.D)(event.view,mousemoving),(0,noevent.ZP)(event),gestures.mouse("end",event)}function touchstarted(event,d){if(filter.call(this,event,d)){var i,gesture,touches=event.changedTouches,c=container.call(this,event,d),n=touches.length;for(i=0;i<n;++i)(gesture=beforestart(this,c,event,d,touches[i].identifier,touches[i]))&&((0,noevent.rG)(event),gesture("start",event,touches[i]))}}function touchmoved(event){var i,gesture,touches=event.changedTouches,n=touches.length;for(i=0;i<n;++i)(gesture=gestures[touches[i].identifier])&&((0,noevent.ZP)(event),gesture("drag",event,touches[i]))}function touchended(event){var i,gesture,touches=event.changedTouches,n=touches.length;for(touchending&&clearTimeout(touchending),touchending=setTimeout(function(){touchending=null},500),i=0;i<n;++i)(gesture=gestures[touches[i].identifier])&&((0,noevent.rG)(event),gesture("end",event,touches[i]))}function beforestart(that,container,event,d,identifier,touch){var dx,dy,s,dispatch=listeners.copy(),p=(0,pointer.Z)(touch||event,container);if(null!=(s=subject.call(that,new DragEvent("beforestart",{sourceEvent:event,target:drag,identifier,active,x:p[0],y:p[1],dx:0,dy:0,dispatch}),d)))return dx=s.x-p[0]||0,dy=s.y-p[1]||0,function gesture(type,event,touch){var n,p0=p;switch(type){case"start":gestures[identifier]=gesture,n=active++;break;case"end":delete gestures[identifier],--active;case"drag":p=(0,pointer.Z)(touch||event,container),n=active}dispatch.call(type,that,new DragEvent(type,{sourceEvent:event,subject:s,target:drag,identifier,active:n,x:p[0]+dx,y:p[1]+dy,dx:p[0]-p0[0],dy:p[1]-p0[1],dispatch}),d)}}return drag.filter=function(_){return arguments.length?(filter="function"==typeof _?_:constant(!!_),drag):filter},drag.container=function(_){return arguments.length?(container="function"==typeof _?_:constant(_),drag):container},drag.subject=function(_){return arguments.length?(subject="function"==typeof _?_:constant(_),drag):subject},drag.touchable=function(_){return arguments.length?(touchable="function"==typeof _?_:constant(!!_),drag):touchable},drag.on=function(){var value=listeners.on.apply(listeners,arguments);return value===listeners?drag:value},drag.clickDistance=function(_){return arguments.length?(clickDistance2=(_*=1)*_,drag):Math.sqrt(clickDistance2)},drag}DragEvent.prototype.on=function(){var value=this._.on.apply(this._,arguments);return value===this._?this:value};var src=__webpack_require__("../../node_modules/.pnpm/d3-zoom@3.0.0/node_modules/d3-zoom/src/index.js");let errorMessages={error001:()=>"[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",error002:()=>"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",error003:nodeType=>`Node type "${nodeType}" not found. Using fallback type "default".`,error004:()=>"The React Flow parent container needs a width and a height to render the graph.",error005:()=>"Only child nodes can use a parent extent.",error006:()=>"Can't create edge. An edge needs a source and a target.",error007:id=>`The old edge with id=${id} does not exist.`,error009:type=>`Marker type "${type}" doesn't exist.`,error008:(handleType,{id,sourceHandle,targetHandle})=>`Couldn't create edge for ${handleType} handle id: "${"source"===handleType?sourceHandle:targetHandle}", edge id: ${id}.`,error010:()=>"Handle: No node id found. Make sure to only use a Handle inside a custom Node.",error011:edgeType=>`Edge type "${edgeType}" not found. Using fallback type "default".`,error012:id=>`Node with id "${id}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,error013:(lib="react")=>`It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,error014:()=>"useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",error015:()=>"It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."},infiniteExtent=[[Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY],[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY]],elementSelectionKeys=["Enter"," ","Escape"];!function(ConnectionMode){ConnectionMode.Strict="strict",ConnectionMode.Loose="loose"}(ConnectionMode||(ConnectionMode={})),function(PanOnScrollMode){PanOnScrollMode.Free="free",PanOnScrollMode.Vertical="vertical",PanOnScrollMode.Horizontal="horizontal"}(PanOnScrollMode||(PanOnScrollMode={})),function(SelectionMode){SelectionMode.Partial="partial",SelectionMode.Full="full"}(SelectionMode||(SelectionMode={}));let initialConnection={inProgress:!1,isValid:null,from:null,fromHandle:null,fromPosition:null,fromNode:null,to:null,toHandle:null,toPosition:null,toNode:null};!function(ConnectionLineType){ConnectionLineType.Bezier="default",ConnectionLineType.Straight="straight",ConnectionLineType.Step="step",ConnectionLineType.SmoothStep="smoothstep",ConnectionLineType.SimpleBezier="simplebezier"}(ConnectionLineType||(ConnectionLineType={})),function(MarkerType){MarkerType.Arrow="arrow",MarkerType.ArrowClosed="arrowclosed"}(MarkerType||(MarkerType={})),function(Position){Position.Left="left",Position.Top="top",Position.Right="right",Position.Bottom="bottom"}(Position||(Position={}));let oppositePosition={[Position.Left]:Position.Right,[Position.Right]:Position.Left,[Position.Top]:Position.Bottom,[Position.Bottom]:Position.Top};function getConnectionStatus(isValid){return null===isValid?null:isValid?"valid":"invalid"}let isEdgeBase=element=>"id"in element&&"source"in element&&"target"in element,isNodeBase=element=>"id"in element&&"position"in element&&!("source"in element)&&!("target"in element),isInternalNodeBase=element=>"id"in element&&"internals"in element&&!("source"in element)&&!("target"in element),getOutgoers=(node,nodes,edges)=>{if(!node.id)return[];let outgoerIds=new Set;return edges.forEach(edge=>{edge.source===node.id&&outgoerIds.add(edge.target)}),nodes.filter(n=>outgoerIds.has(n.id))},getNodePositionWithOrigin=(node,nodeOrigin=[0,0])=>{let{width,height}=getNodeDimensions(node),origin=node.origin??nodeOrigin,offsetX=width*origin[0],offsetY=height*origin[1];return{x:node.position.x-offsetX,y:node.position.y-offsetY}},getNodesBounds=(nodes,params={nodeOrigin:[0,0]})=>0===nodes.length?{x:0,y:0,width:0,height:0}:boxToRect(nodes.reduce((currBox,nodeOrId)=>{let isId="string"==typeof nodeOrId,currentNode=params.nodeLookup||isId?void 0:nodeOrId;return params.nodeLookup&&(currentNode=isId?params.nodeLookup.get(nodeOrId):isInternalNodeBase(nodeOrId)?nodeOrId:params.nodeLookup.get(nodeOrId.id)),getBoundsOfBoxes(currBox,currentNode?nodeToBox(currentNode,params.nodeOrigin):{x:0,y:0,x2:0,y2:0})},{x:1/0,y:1/0,x2:-1/0,y2:-1/0})),getInternalNodesBounds=(nodeLookup,params={})=>{if(0===nodeLookup.size)return{x:0,y:0,width:0,height:0};let box={x:1/0,y:1/0,x2:-1/0,y2:-1/0};return nodeLookup.forEach(node=>{if(void 0===params.filter||params.filter(node)){let nodeBox=nodeToBox(node);box=getBoundsOfBoxes(box,nodeBox)}}),boxToRect(box)},getNodesInside=(nodes,rect,[tx,ty,tScale]=[0,0,1],partially=!1,excludeNonSelectableNodes=!1)=>{let paneRect={...pointToRendererPoint(rect,[tx,ty,tScale]),width:rect.width/tScale,height:rect.height/tScale},visibleNodes=[];for(let node of nodes.values()){let{measured,selectable=!0,hidden=!1}=node;if(excludeNonSelectableNodes&&!selectable||hidden)continue;let width=measured.width??node.width??node.initialWidth??null,height=measured.height??node.height??node.initialHeight??null,overlappingArea=getOverlappingArea(paneRect,nodeToRect(node)),area=(width??0)*(height??0),partiallyVisible=partially&&overlappingArea>0;(!node.internals.handleBounds||partiallyVisible||overlappingArea>=area||node.dragging)&&visibleNodes.push(node)}return visibleNodes},getConnectedEdges=(nodes,edges)=>{let nodeIds=new Set;return nodes.forEach(node=>{nodeIds.add(node.id)}),edges.filter(edge=>nodeIds.has(edge.source)||nodeIds.has(edge.target))};function getFitViewNodes(nodeLookup,options){let fitViewNodes=new Map,optionNodeIds=options?.nodes?new Set(options.nodes.map(node=>node.id)):null;return nodeLookup.forEach(n=>{n.measured.width&&n.measured.height&&(options?.includeHiddenNodes||!n.hidden)&&(!optionNodeIds||optionNodeIds.has(n.id))&&fitViewNodes.set(n.id,n)}),fitViewNodes}async function fitViewport({nodes,width,height,panZoom,minZoom,maxZoom},options){if(0===nodes.size)return Promise.resolve(!0);let viewport=getViewportForBounds(getInternalNodesBounds(getFitViewNodes(nodes,options)),width,height,options?.minZoom??minZoom,options?.maxZoom??maxZoom,options?.padding??.1);return await panZoom.setViewport(viewport,{duration:options?.duration}),Promise.resolve(!0)}function calculateNodePosition({nodeId,nextPosition,nodeLookup,nodeOrigin=[0,0],nodeExtent,onError}){let node=nodeLookup.get(nodeId),parentNode=node.parentId?nodeLookup.get(node.parentId):void 0,{x:parentX,y:parentY}=parentNode?parentNode.internals.positionAbsolute:{x:0,y:0},origin=node.origin??nodeOrigin,extent=nodeExtent;if("parent"!==node.extent||node.expandParent)parentNode&&isCoordinateExtent(node.extent)&&(extent=[[node.extent[0][0]+parentX,node.extent[0][1]+parentY],[node.extent[1][0]+parentX,node.extent[1][1]+parentY]]);else if(parentNode){let parentWidth=parentNode.measured.width,parentHeight=parentNode.measured.height;parentWidth&&parentHeight&&(extent=[[parentX,parentY],[parentX+parentWidth,parentY+parentHeight]])}else onError?.("005",errorMessages.error005());let positionAbsolute=isCoordinateExtent(extent)?clampPosition(nextPosition,extent,node.measured):nextPosition;return(void 0===node.measured.width||void 0===node.measured.height)&&onError?.("015",errorMessages.error015()),{position:{x:positionAbsolute.x-parentX+(node.measured.width??0)*origin[0],y:positionAbsolute.y-parentY+(node.measured.height??0)*origin[1]},positionAbsolute}}async function getElementsToRemove({nodesToRemove=[],edgesToRemove=[],nodes,edges,onBeforeDelete}){let nodeIds=new Set(nodesToRemove.map(node=>node.id)),matchingNodes=[];for(let node of nodes){if(!1===node.deletable)continue;let isIncluded=nodeIds.has(node.id),parentHit=!isIncluded&&node.parentId&&matchingNodes.find(n=>n.id===node.parentId);(isIncluded||parentHit)&&matchingNodes.push(node)}let edgeIds=new Set(edgesToRemove.map(edge=>edge.id)),deletableEdges=edges.filter(edge=>!1!==edge.deletable),connectedEdges=getConnectedEdges(matchingNodes,deletableEdges);for(let edge of deletableEdges)edgeIds.has(edge.id)&&!connectedEdges.find(e=>e.id===edge.id)&&connectedEdges.push(edge);if(!onBeforeDelete)return{edges:connectedEdges,nodes:matchingNodes};let onBeforeDeleteResult=await onBeforeDelete({nodes:matchingNodes,edges:connectedEdges});return"boolean"==typeof onBeforeDeleteResult?onBeforeDeleteResult?{edges:connectedEdges,nodes:matchingNodes}:{edges:[],nodes:[]}:onBeforeDeleteResult}let clamp=(val,min=0,max=1)=>Math.min(Math.max(val,min),max),clampPosition=(position={x:0,y:0},extent,dimensions)=>({x:clamp(position.x,extent[0][0],extent[1][0]-(dimensions?.width??0)),y:clamp(position.y,extent[0][1],extent[1][1]-(dimensions?.height??0))});function clampPositionToParent(childPosition,childDimensions,parent){let{width:parentWidth,height:parentHeight}=getNodeDimensions(parent),{x:parentX,y:parentY}=parent.internals.positionAbsolute;return clampPosition(childPosition,[[parentX,parentY],[parentX+parentWidth,parentY+parentHeight]],childDimensions)}let calcAutoPanVelocity=(value,min,max)=>value<min?clamp(Math.abs(value-min),1,min)/min:value>max?-clamp(Math.abs(value-max),1,min)/min:0,calcAutoPan=(pos,bounds,speed=15,distance=40)=>[calcAutoPanVelocity(pos.x,distance,bounds.width-distance)*speed,calcAutoPanVelocity(pos.y,distance,bounds.height-distance)*speed],getBoundsOfBoxes=(box1,box2)=>({x:Math.min(box1.x,box2.x),y:Math.min(box1.y,box2.y),x2:Math.max(box1.x2,box2.x2),y2:Math.max(box1.y2,box2.y2)}),rectToBox=({x,y,width,height})=>({x,y,x2:x+width,y2:y+height}),boxToRect=({x,y,x2,y2})=>({x,y,width:x2-x,height:y2-y}),nodeToRect=(node,nodeOrigin=[0,0])=>{let{x,y}=isInternalNodeBase(node)?node.internals.positionAbsolute:getNodePositionWithOrigin(node,nodeOrigin);return{x,y,width:node.measured?.width??node.width??node.initialWidth??0,height:node.measured?.height??node.height??node.initialHeight??0}},nodeToBox=(node,nodeOrigin=[0,0])=>{let{x,y}=isInternalNodeBase(node)?node.internals.positionAbsolute:getNodePositionWithOrigin(node,nodeOrigin);return{x,y,x2:x+(node.measured?.width??node.width??node.initialWidth??0),y2:y+(node.measured?.height??node.height??node.initialHeight??0)}},getBoundsOfRects=(rect1,rect2)=>boxToRect(getBoundsOfBoxes(rectToBox(rect1),rectToBox(rect2))),getOverlappingArea=(rectA,rectB)=>Math.ceil(Math.max(0,Math.min(rectA.x+rectA.width,rectB.x+rectB.width)-Math.max(rectA.x,rectB.x))*Math.max(0,Math.min(rectA.y+rectA.height,rectB.y+rectB.height)-Math.max(rectA.y,rectB.y))),isRectObject=obj=>isNumeric(obj.width)&&isNumeric(obj.height)&&isNumeric(obj.x)&&isNumeric(obj.y),isNumeric=n=>!isNaN(n)&&isFinite(n),devWarn=(id,message)=>{},snapPosition=(position,snapGrid=[1,1])=>({x:snapGrid[0]*Math.round(position.x/snapGrid[0]),y:snapGrid[1]*Math.round(position.y/snapGrid[1])}),pointToRendererPoint=({x,y},[tx,ty,tScale],snapToGrid=!1,snapGrid=[1,1])=>{let position={x:(x-tx)/tScale,y:(y-ty)/tScale};return snapToGrid?snapPosition(position,snapGrid):position},rendererPointToPoint=({x,y},[tx,ty,tScale])=>({x:x*tScale+tx,y:y*tScale+ty});function parsePadding(padding,viewport){if("number"==typeof padding)return Math.floor((viewport-viewport/(1+padding))*.5);if("string"==typeof padding&&padding.endsWith("px")){let paddingValue=parseFloat(padding);if(!Number.isNaN(paddingValue))return Math.floor(paddingValue)}if("string"==typeof padding&&padding.endsWith("%")){let paddingValue=parseFloat(padding);if(!Number.isNaN(paddingValue))return Math.floor(viewport*paddingValue*.01)}return console.error(`[React Flow] The padding value "${padding}" is invalid. Please provide a number or a string with a valid unit (px or %).`),0}function parsePaddings(padding,width,height){if("string"==typeof padding||"number"==typeof padding){let paddingY=parsePadding(padding,height),paddingX=parsePadding(padding,width);return{top:paddingY,right:paddingX,bottom:paddingY,left:paddingX,x:2*paddingX,y:2*paddingY}}if("object"==typeof padding){let top=parsePadding(padding.top??padding.y??0,height),bottom=parsePadding(padding.bottom??padding.y??0,height),left=parsePadding(padding.left??padding.x??0,width),right=parsePadding(padding.right??padding.x??0,width);return{top,right,bottom,left,x:left+right,y:top+bottom}}return{top:0,right:0,bottom:0,left:0,x:0,y:0}}function calculateAppliedPaddings(bounds,x,y,zoom,width,height){let{x:left,y:top}=rendererPointToPoint(bounds,[x,y,zoom]),{x:boundRight,y:boundBottom}=rendererPointToPoint({x:bounds.x+bounds.width,y:bounds.y+bounds.height},[x,y,zoom]);return{left:Math.floor(left),top:Math.floor(top),right:Math.floor(width-boundRight),bottom:Math.floor(height-boundBottom)}}let getViewportForBounds=(bounds,width,height,minZoom,maxZoom,padding)=>{let p=parsePaddings(padding,width,height),clampedZoom=clamp(Math.min((width-p.x)/bounds.width,(height-p.y)/bounds.height),minZoom,maxZoom),boundsCenterX=bounds.x+bounds.width/2,boundsCenterY=bounds.y+bounds.height/2,x=width/2-boundsCenterX*clampedZoom,y=height/2-boundsCenterY*clampedZoom,newPadding=calculateAppliedPaddings(bounds,x,y,clampedZoom,width,height),offset={left:Math.min(newPadding.left-p.left,0),top:Math.min(newPadding.top-p.top,0),right:Math.min(newPadding.right-p.right,0),bottom:Math.min(newPadding.bottom-p.bottom,0)};return{x:x-offset.left+offset.right,y:y-offset.top+offset.bottom,zoom:clampedZoom}},isMacOs=()=>"undefined"!=typeof navigator&&navigator?.userAgent?.indexOf("Mac")>=0;function isCoordinateExtent(extent){return void 0!==extent&&"parent"!==extent}function getNodeDimensions(node){return{width:node.measured?.width??node.width??node.initialWidth??0,height:node.measured?.height??node.height??node.initialHeight??0}}function nodeHasDimensions(node){return(node.measured?.width??node.width??node.initialWidth)!==void 0&&(node.measured?.height??node.height??node.initialHeight)!==void 0}function evaluateAbsolutePosition(position,dimensions={width:0,height:0},parentId,nodeLookup,nodeOrigin){let positionAbsolute={...position},parent=nodeLookup.get(parentId);if(parent){let origin=parent.origin||nodeOrigin;positionAbsolute.x+=parent.internals.positionAbsolute.x-(dimensions.width??0)*origin[0],positionAbsolute.y+=parent.internals.positionAbsolute.y-(dimensions.height??0)*origin[1]}return positionAbsolute}function areSetsEqual(a,b){if(a.size!==b.size)return!1;for(let item of a)if(!b.has(item))return!1;return!0}function withResolvers(){let resolve,reject;return{promise:new Promise((res,rej)=>{resolve=res,reject=rej}),resolve,reject}}function getPointerPosition(event,{snapGrid=[0,0],snapToGrid=!1,transform,containerBounds}){let{x,y}=getEventPosition(event),pointerPos=pointToRendererPoint({x:x-(containerBounds?.left??0),y:y-(containerBounds?.top??0)},transform),{x:xSnapped,y:ySnapped}=snapToGrid?snapPosition(pointerPos,snapGrid):pointerPos;return{xSnapped,ySnapped,...pointerPos}}let getDimensions=node=>({width:node.offsetWidth,height:node.offsetHeight}),getHostForElement=element=>element?.getRootNode?.()||window?.document,inputTags=["INPUT","SELECT","TEXTAREA"];function isInputDOMNode(event){let target=event.composedPath?.()?.[0]||event.target;return target?.nodeType===1&&(inputTags.includes(target.nodeName)||target.hasAttribute("contenteditable")||!!target.closest(".nokey"))}let isMouseEvent=event=>"clientX"in event,getEventPosition=(event,bounds)=>{let isMouse=isMouseEvent(event),evtX=isMouse?event.clientX:event.touches?.[0].clientX,evtY=isMouse?event.clientY:event.touches?.[0].clientY;return{x:evtX-(bounds?.left??0),y:evtY-(bounds?.top??0)}},getHandleBounds=(type,nodeElement,nodeBounds,zoom,nodeId)=>{let handles=nodeElement.querySelectorAll(`.${type}`);return handles&&handles.length?Array.from(handles).map(handle=>{let handleBounds=handle.getBoundingClientRect();return{id:handle.getAttribute("data-handleid"),type,nodeId,position:handle.getAttribute("data-handlepos"),x:(handleBounds.left-nodeBounds.left)/zoom,y:(handleBounds.top-nodeBounds.top)/zoom,...getDimensions(handle)}}):null};function getBezierEdgeCenter({sourceX,sourceY,targetX,targetY,sourceControlX,sourceControlY,targetControlX,targetControlY}){let centerX=.125*sourceX+.375*sourceControlX+.375*targetControlX+.125*targetX,centerY=.125*sourceY+.375*sourceControlY+.375*targetControlY+.125*targetY,offsetX=Math.abs(centerX-sourceX),offsetY=Math.abs(centerY-sourceY);return[centerX,centerY,offsetX,offsetY]}function calculateControlOffset(distance,curvature){return distance>=0?.5*distance:25*curvature*Math.sqrt(-distance)}function getControlWithCurvature({pos,x1,y1,x2,y2,c}){switch(pos){case Position.Left:return[x1-calculateControlOffset(x1-x2,c),y1];case Position.Right:return[x1+calculateControlOffset(x2-x1,c),y1];case Position.Top:return[x1,y1-calculateControlOffset(y1-y2,c)];case Position.Bottom:return[x1,y1+calculateControlOffset(y2-y1,c)]}}function getBezierPath({sourceX,sourceY,sourcePosition=Position.Bottom,targetX,targetY,targetPosition=Position.Top,curvature=.25}){let[sourceControlX,sourceControlY]=getControlWithCurvature({pos:sourcePosition,x1:sourceX,y1:sourceY,x2:targetX,y2:targetY,c:curvature}),[targetControlX,targetControlY]=getControlWithCurvature({pos:targetPosition,x1:targetX,y1:targetY,x2:sourceX,y2:sourceY,c:curvature}),[labelX,labelY,offsetX,offsetY]=getBezierEdgeCenter({sourceX,sourceY,targetX,targetY,sourceControlX,sourceControlY,targetControlX,targetControlY});return[`M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,labelX,labelY,offsetX,offsetY]}function getEdgeCenter({sourceX,sourceY,targetX,targetY}){let xOffset=Math.abs(targetX-sourceX)/2,yOffset=Math.abs(targetY-sourceY)/2;return[targetX<sourceX?targetX+xOffset:targetX-xOffset,targetY<sourceY?targetY+yOffset:targetY-yOffset,xOffset,yOffset]}function getElevatedEdgeZIndex({sourceNode,targetNode,selected=!1,zIndex=0,elevateOnSelect=!1}){if(!elevateOnSelect)return zIndex;let edgeOrConnectedNodeSelected=selected||targetNode.selected||sourceNode.selected,selectedZIndex=Math.max(sourceNode.internals.z||0,targetNode.internals.z||0,1e3);return zIndex+(edgeOrConnectedNodeSelected?selectedZIndex:0)}function isEdgeVisible({sourceNode,targetNode,width,height,transform}){let edgeBox=getBoundsOfBoxes(nodeToBox(sourceNode),nodeToBox(targetNode));return edgeBox.x===edgeBox.x2&&(edgeBox.x2+=1),edgeBox.y===edgeBox.y2&&(edgeBox.y2+=1),getOverlappingArea({x:-transform[0]/transform[2],y:-transform[1]/transform[2],width:width/transform[2],height:height/transform[2]},boxToRect(edgeBox))>0}let getEdgeId=({source,sourceHandle,target,targetHandle})=>`xy-edge__${source}${sourceHandle||""}-${target}${targetHandle||""}`,connectionExists=(edge,edges)=>edges.some(el=>el.source===edge.source&&el.target===edge.target&&(el.sourceHandle===edge.sourceHandle||!el.sourceHandle&&!edge.sourceHandle)&&(el.targetHandle===edge.targetHandle||!el.targetHandle&&!edge.targetHandle)),addEdge=(edgeParams,edges)=>{let edge;return edgeParams.source&&edgeParams.target?connectionExists(edge=isEdgeBase(edgeParams)?{...edgeParams}:{...edgeParams,id:getEdgeId(edgeParams)},edges)?edges:(null===edge.sourceHandle&&delete edge.sourceHandle,null===edge.targetHandle&&delete edge.targetHandle,edges.concat(edge)):(devWarn("006",errorMessages.error006()),edges)};function getStraightPath({sourceX,sourceY,targetX,targetY}){let[labelX,labelY,offsetX,offsetY]=getEdgeCenter({sourceX,sourceY,targetX,targetY});return[`M ${sourceX},${sourceY}L ${targetX},${targetY}`,labelX,labelY,offsetX,offsetY]}let handleDirections={[Position.Left]:{x:-1,y:0},[Position.Right]:{x:1,y:0},[Position.Top]:{x:0,y:-1},[Position.Bottom]:{x:0,y:1}},getDirection=({source,sourcePosition=Position.Bottom,target})=>sourcePosition===Position.Left||sourcePosition===Position.Right?source.x<target.x?{x:1,y:0}:{x:-1,y:0}:source.y<target.y?{x:0,y:1}:{x:0,y:-1},distance=(a,b)=>Math.sqrt(Math.pow(b.x-a.x,2)+Math.pow(b.y-a.y,2));function getPoints({source,sourcePosition=Position.Bottom,target,targetPosition=Position.Top,center,offset}){let centerX,centerY;let sourceDir=handleDirections[sourcePosition],targetDir=handleDirections[targetPosition],sourceGapped={x:source.x+sourceDir.x*offset,y:source.y+sourceDir.y*offset},targetGapped={x:target.x+targetDir.x*offset,y:target.y+targetDir.y*offset},dir=getDirection({source:sourceGapped,sourcePosition,target:targetGapped}),dirAccessor=0!==dir.x?"x":"y",currDir=dir[dirAccessor],points=[],sourceGapOffset={x:0,y:0},targetGapOffset={x:0,y:0},[defaultCenterX,defaultCenterY,defaultOffsetX,defaultOffsetY]=getEdgeCenter({sourceX:source.x,sourceY:source.y,targetX:target.x,targetY:target.y});if(sourceDir[dirAccessor]*targetDir[dirAccessor]==-1){centerX=center.x??defaultCenterX,centerY=center.y??defaultCenterY;let verticalSplit=[{x:centerX,y:sourceGapped.y},{x:centerX,y:targetGapped.y}],horizontalSplit=[{x:sourceGapped.x,y:centerY},{x:targetGapped.x,y:centerY}];points=sourceDir[dirAccessor]===currDir?"x"===dirAccessor?verticalSplit:horizontalSplit:"x"===dirAccessor?horizontalSplit:verticalSplit}else{let sourceTarget=[{x:sourceGapped.x,y:targetGapped.y}],targetSource=[{x:targetGapped.x,y:sourceGapped.y}];if(points="x"===dirAccessor?sourceDir.x===currDir?targetSource:sourceTarget:sourceDir.y===currDir?sourceTarget:targetSource,sourcePosition===targetPosition){let diff=Math.abs(source[dirAccessor]-target[dirAccessor]);if(diff<=offset){let gapOffset=Math.min(offset-1,offset-diff);sourceDir[dirAccessor]===currDir?sourceGapOffset[dirAccessor]=(sourceGapped[dirAccessor]>source[dirAccessor]?-1:1)*gapOffset:targetGapOffset[dirAccessor]=(targetGapped[dirAccessor]>target[dirAccessor]?-1:1)*gapOffset}}if(sourcePosition!==targetPosition){let dirAccessorOpposite="x"===dirAccessor?"y":"x",isSameDir=sourceDir[dirAccessor]===targetDir[dirAccessorOpposite],sourceGtTargetOppo=sourceGapped[dirAccessorOpposite]>targetGapped[dirAccessorOpposite],sourceLtTargetOppo=sourceGapped[dirAccessorOpposite]<targetGapped[dirAccessorOpposite];(1===sourceDir[dirAccessor]&&(!isSameDir&&sourceGtTargetOppo||isSameDir&&sourceLtTargetOppo)||1!==sourceDir[dirAccessor]&&(!isSameDir&&sourceLtTargetOppo||isSameDir&&sourceGtTargetOppo))&&(points="x"===dirAccessor?sourceTarget:targetSource)}let sourceGapPoint={x:sourceGapped.x+sourceGapOffset.x,y:sourceGapped.y+sourceGapOffset.y},targetGapPoint={x:targetGapped.x+targetGapOffset.x,y:targetGapped.y+targetGapOffset.y};Math.max(Math.abs(sourceGapPoint.x-points[0].x),Math.abs(targetGapPoint.x-points[0].x))>=Math.max(Math.abs(sourceGapPoint.y-points[0].y),Math.abs(targetGapPoint.y-points[0].y))?(centerX=(sourceGapPoint.x+targetGapPoint.x)/2,centerY=points[0].y):(centerX=points[0].x,centerY=(sourceGapPoint.y+targetGapPoint.y)/2)}return[[source,{x:sourceGapped.x+sourceGapOffset.x,y:sourceGapped.y+sourceGapOffset.y},...points,{x:targetGapped.x+targetGapOffset.x,y:targetGapped.y+targetGapOffset.y},target],centerX,centerY,defaultOffsetX,defaultOffsetY]}function getBend(a,b,c,size){let bendSize=Math.min(distance(a,b)/2,distance(b,c)/2,size),{x,y}=b;if(a.x===x&&x===c.x||a.y===y&&y===c.y)return`L${x} ${y}`;if(a.y===y){let xDir=a.x<c.x?-1:1,yDir=a.y<c.y?1:-1;return`L ${x+bendSize*xDir},${y}Q ${x},${y} ${x},${y+bendSize*yDir}`}let xDir=a.x<c.x?1:-1,yDir=a.y<c.y?-1:1;return`L ${x},${y+bendSize*yDir}Q ${x},${y} ${x+bendSize*xDir},${y}`}function getSmoothStepPath({sourceX,sourceY,sourcePosition=Position.Bottom,targetX,targetY,targetPosition=Position.Top,borderRadius=5,centerX,centerY,offset=20}){let[points,labelX,labelY,offsetX,offsetY]=getPoints({source:{x:sourceX,y:sourceY},sourcePosition,target:{x:targetX,y:targetY},targetPosition,center:{x:centerX,y:centerY},offset});return[points.reduce((res,p,i)=>{let segment="";return res+(i>0&&i<points.length-1?getBend(points[i-1],p,points[i+1],borderRadius):`${0===i?"M":"L"}${p.x} ${p.y}`)},""),labelX,labelY,offsetX,offsetY]}function isNodeInitialized(node){return node&&!!(node.internals.handleBounds||node.handles?.length)&&!!(node.measured.width||node.width||node.initialWidth)}function getEdgePosition(params){let{sourceNode,targetNode}=params;if(!isNodeInitialized(sourceNode)||!isNodeInitialized(targetNode))return null;let sourceHandleBounds=sourceNode.internals.handleBounds||toHandleBounds(sourceNode.handles),targetHandleBounds=targetNode.internals.handleBounds||toHandleBounds(targetNode.handles),sourceHandle=getHandle$1(sourceHandleBounds?.source??[],params.sourceHandle),targetHandle=getHandle$1(params.connectionMode===ConnectionMode.Strict?targetHandleBounds?.target??[]:(targetHandleBounds?.target??[]).concat(targetHandleBounds?.source??[]),params.targetHandle);if(!sourceHandle||!targetHandle)return params.onError?.("008",errorMessages.error008(sourceHandle?"target":"source",{id:params.id,sourceHandle:params.sourceHandle,targetHandle:params.targetHandle})),null;let sourcePosition=sourceHandle?.position||Position.Bottom,targetPosition=targetHandle?.position||Position.Top,source=getHandlePosition(sourceNode,sourceHandle,sourcePosition),target=getHandlePosition(targetNode,targetHandle,targetPosition);return{sourceX:source.x,sourceY:source.y,targetX:target.x,targetY:target.y,sourcePosition,targetPosition}}function toHandleBounds(handles){if(!handles)return null;let source=[],target=[];for(let handle of handles)handle.width=handle.width??1,handle.height=handle.height??1,"source"===handle.type?source.push(handle):"target"===handle.type&&target.push(handle);return{source,target}}function getHandlePosition(node,handle,fallbackPosition=Position.Left,center=!1){let x=(handle?.x??0)+node.internals.positionAbsolute.x,y=(handle?.y??0)+node.internals.positionAbsolute.y,{width,height}=handle??getNodeDimensions(node);if(center)return{x:x+width/2,y:y+height/2};switch(handle?.position??fallbackPosition){case Position.Top:return{x:x+width/2,y};case Position.Right:return{x:x+width,y:y+height/2};case Position.Bottom:return{x:x+width/2,y:y+height};case Position.Left:return{x,y:y+height/2}}}function getHandle$1(bounds,handleId){return bounds&&(handleId?bounds.find(d=>d.id===handleId):bounds[0])||null}function getMarkerId(marker,id){if(!marker)return"";if("string"==typeof marker)return marker;let idPrefix=id?`${id}__`:"";return`${idPrefix}${Object.keys(marker).sort().map(key=>`${key}=${marker[key]}`).join("&")}`}function createMarkerIds(edges,{id,defaultColor,defaultMarkerStart,defaultMarkerEnd}){let ids=new Set;return edges.reduce((markers,edge)=>([edge.markerStart||defaultMarkerStart,edge.markerEnd||defaultMarkerEnd].forEach(marker=>{if(marker&&"object"==typeof marker){let markerId=getMarkerId(marker,id);ids.has(markerId)||(markers.push({id:markerId,color:marker.color||defaultColor,...marker}),ids.add(markerId))}}),markers),[]).sort((a,b)=>a.id.localeCompare(b.id))}let defaultOptions={nodeOrigin:[0,0],nodeExtent:infiniteExtent,elevateNodesOnSelect:!0,defaults:{}},adoptUserNodesDefaultOptions={...defaultOptions,checkEquality:!0};function mergeObjects(base,incoming){let result={...base};for(let key in incoming)void 0!==incoming[key]&&(result[key]=incoming[key]);return result}function updateAbsolutePositions(nodeLookup,parentLookup,options){let _options=mergeObjects(defaultOptions,options);for(let node of nodeLookup.values())if(node.parentId)updateChildNode(node,nodeLookup,parentLookup,_options);else{let clampedPosition=clampPosition(getNodePositionWithOrigin(node,_options.nodeOrigin),isCoordinateExtent(node.extent)?node.extent:_options.nodeExtent,getNodeDimensions(node));node.internals.positionAbsolute=clampedPosition}}function adoptUserNodes(nodes,nodeLookup,parentLookup,options){let _options=mergeObjects(adoptUserNodesDefaultOptions,options),nodesInitialized=nodes.length>0,tmpLookup=new Map(nodeLookup),selectedNodeZ=1e3*!!_options?.elevateNodesOnSelect;for(let userNode of(nodeLookup.clear(),parentLookup.clear(),nodes)){let internalNode=tmpLookup.get(userNode.id);if(_options.checkEquality&&userNode===internalNode?.internals.userNode)nodeLookup.set(userNode.id,internalNode);else{let clampedPosition=clampPosition(getNodePositionWithOrigin(userNode,_options.nodeOrigin),isCoordinateExtent(userNode.extent)?userNode.extent:_options.nodeExtent,getNodeDimensions(userNode));internalNode={..._options.defaults,...userNode,measured:{width:userNode.measured?.width,height:userNode.measured?.height},internals:{positionAbsolute:clampedPosition,handleBounds:userNode.measured?internalNode?.internals.handleBounds:void 0,z:calculateZ(userNode,selectedNodeZ),userNode}},nodeLookup.set(userNode.id,internalNode)}void 0!==internalNode.measured&&void 0!==internalNode.measured.width&&void 0!==internalNode.measured.height||internalNode.hidden||(nodesInitialized=!1),userNode.parentId&&updateChildNode(internalNode,nodeLookup,parentLookup,options)}return nodesInitialized}function updateParentLookup(node,parentLookup){if(!node.parentId)return;let childNodes=parentLookup.get(node.parentId);childNodes?childNodes.set(node.id,node):parentLookup.set(node.parentId,new Map([[node.id,node]]))}function updateChildNode(node,nodeLookup,parentLookup,options){let{elevateNodesOnSelect,nodeOrigin,nodeExtent}=mergeObjects(defaultOptions,options),parentId=node.parentId,parentNode=nodeLookup.get(parentId);if(!parentNode){console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);return}updateParentLookup(node,parentLookup);let{x,y,z}=calculateChildXYZ(node,parentNode,nodeOrigin,nodeExtent,1e3*!!elevateNodesOnSelect),{positionAbsolute}=node.internals,positionChanged=x!==positionAbsolute.x||y!==positionAbsolute.y;(positionChanged||z!==node.internals.z)&&nodeLookup.set(node.id,{...node,internals:{...node.internals,positionAbsolute:positionChanged?{x,y}:positionAbsolute,z}})}function calculateZ(node,selectedNodeZ){return(isNumeric(node.zIndex)?node.zIndex:0)+(node.selected?selectedNodeZ:0)}function calculateChildXYZ(childNode,parentNode,nodeOrigin,nodeExtent,selectedNodeZ){let{x:parentX,y:parentY}=parentNode.internals.positionAbsolute,childDimensions=getNodeDimensions(childNode),positionWithOrigin=getNodePositionWithOrigin(childNode,nodeOrigin),clampedPosition=isCoordinateExtent(childNode.extent)?clampPosition(positionWithOrigin,childNode.extent,childDimensions):positionWithOrigin,absolutePosition=clampPosition({x:parentX+clampedPosition.x,y:parentY+clampedPosition.y},nodeExtent,childDimensions);"parent"===childNode.extent&&(absolutePosition=clampPositionToParent(absolutePosition,childDimensions,parentNode));let childZ=calculateZ(childNode,selectedNodeZ),parentZ=parentNode.internals.z??0;return{x:absolutePosition.x,y:absolutePosition.y,z:parentZ>childZ?parentZ:childZ}}function handleExpandParent(children,nodeLookup,parentLookup,nodeOrigin=[0,0]){let changes=[],parentExpansions=new Map;for(let child of children){let parent=nodeLookup.get(child.parentId);if(!parent)continue;let expandedRect=getBoundsOfRects(parentExpansions.get(child.parentId)?.expandedRect??nodeToRect(parent),child.rect);parentExpansions.set(child.parentId,{expandedRect,parent})}return parentExpansions.size>0&&parentExpansions.forEach(({expandedRect,parent},parentId)=>{let positionAbsolute=parent.internals.positionAbsolute,dimensions=getNodeDimensions(parent),origin=parent.origin??nodeOrigin,xChange=expandedRect.x<positionAbsolute.x?Math.round(Math.abs(positionAbsolute.x-expandedRect.x)):0,yChange=expandedRect.y<positionAbsolute.y?Math.round(Math.abs(positionAbsolute.y-expandedRect.y)):0,newWidth=Math.max(dimensions.width,Math.round(expandedRect.width)),newHeight=Math.max(dimensions.height,Math.round(expandedRect.height)),widthChange=(newWidth-dimensions.width)*origin[0],heightChange=(newHeight-dimensions.height)*origin[1];(xChange>0||yChange>0||widthChange||heightChange)&&(changes.push({id:parentId,type:"position",position:{x:parent.position.x-xChange+widthChange,y:parent.position.y-yChange+heightChange}}),parentLookup.get(parentId)?.forEach(childNode=>{children.some(child=>child.id===childNode.id)||changes.push({id:childNode.id,type:"position",position:{x:childNode.position.x+xChange,y:childNode.position.y+yChange}})})),(dimensions.width<expandedRect.width||dimensions.height<expandedRect.height||xChange||yChange)&&changes.push({id:parentId,type:"dimensions",setAttributes:!0,dimensions:{width:newWidth+(xChange?origin[0]*xChange-widthChange:0),height:newHeight+(yChange?origin[1]*yChange-heightChange:0)}})}),changes}function updateNodeInternals(updates,nodeLookup,parentLookup,domNode,nodeOrigin,nodeExtent){let viewportNode=domNode?.querySelector(".xyflow__viewport"),updatedInternals=!1;if(!viewportNode)return{changes:[],updatedInternals};let changes=[],style=window.getComputedStyle(viewportNode),{m22:zoom}=new window.DOMMatrixReadOnly(style.transform),parentExpandChildren=[];for(let update of updates.values()){let node=nodeLookup.get(update.id);if(!node)continue;if(node.hidden){nodeLookup.set(node.id,{...node,internals:{...node.internals,handleBounds:void 0}}),updatedInternals=!0;continue}let dimensions=getDimensions(update.nodeElement),dimensionChanged=node.measured.width!==dimensions.width||node.measured.height!==dimensions.height;if(dimensions.width&&dimensions.height&&(dimensionChanged||!node.internals.handleBounds||update.force)){let nodeBounds=update.nodeElement.getBoundingClientRect(),extent=isCoordinateExtent(node.extent)?node.extent:nodeExtent,{positionAbsolute}=node.internals;node.parentId&&"parent"===node.extent?positionAbsolute=clampPositionToParent(positionAbsolute,dimensions,nodeLookup.get(node.parentId)):extent&&(positionAbsolute=clampPosition(positionAbsolute,extent,dimensions));let newNode={...node,measured:dimensions,internals:{...node.internals,positionAbsolute,handleBounds:{source:getHandleBounds("source",update.nodeElement,nodeBounds,zoom,node.id),target:getHandleBounds("target",update.nodeElement,nodeBounds,zoom,node.id)}}};nodeLookup.set(node.id,newNode),node.parentId&&updateChildNode(newNode,nodeLookup,parentLookup,{nodeOrigin}),updatedInternals=!0,dimensionChanged&&(changes.push({id:node.id,type:"dimensions",dimensions}),node.expandParent&&node.parentId&&parentExpandChildren.push({id:node.id,parentId:node.parentId,rect:nodeToRect(newNode,nodeOrigin)}))}}if(parentExpandChildren.length>0){let parentExpandChanges=handleExpandParent(parentExpandChildren,nodeLookup,parentLookup,nodeOrigin);changes.push(...parentExpandChanges)}return{changes,updatedInternals}}async function panBy({delta,panZoom,transform,translateExtent,width,height}){if(!panZoom||!delta.x&&!delta.y)return Promise.resolve(!1);let nextViewport=await panZoom.setViewportConstrained({x:transform[0]+delta.x,y:transform[1]+delta.y,zoom:transform[2]},[[0,0],[width,height]],translateExtent);return Promise.resolve(!!nextViewport&&(nextViewport.x!==transform[0]||nextViewport.y!==transform[1]||nextViewport.k!==transform[2]))}function addConnectionToLookup(type,connection,connectionKey,connectionLookup,nodeId,handleId){let key=nodeId,nodeMap=connectionLookup.get(key)||new Map;connectionLookup.set(key,nodeMap.set(connectionKey,connection)),key=`${nodeId}-${type}`;let typeMap=connectionLookup.get(key)||new Map;if(connectionLookup.set(key,typeMap.set(connectionKey,connection)),handleId){key=`${nodeId}-${type}-${handleId}`;let handleMap=connectionLookup.get(key)||new Map;connectionLookup.set(key,handleMap.set(connectionKey,connection))}}function updateConnectionLookup(connectionLookup,edgeLookup,edges){for(let edge of(connectionLookup.clear(),edgeLookup.clear(),edges)){let{source:sourceNode,target:targetNode,sourceHandle=null,targetHandle=null}=edge,connection={edgeId:edge.id,source:sourceNode,target:targetNode,sourceHandle,targetHandle},sourceKey=`${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;addConnectionToLookup("source",connection,`${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`,connectionLookup,sourceNode,sourceHandle),addConnectionToLookup("target",connection,sourceKey,connectionLookup,targetNode,targetHandle),edgeLookup.set(edge.id,edge)}}function isParentSelected(node,nodeLookup){if(!node.parentId)return!1;let parentNode=nodeLookup.get(node.parentId);return!!parentNode&&(!!parentNode.selected||isParentSelected(parentNode,nodeLookup))}function hasSelector(target,selector,domNode){let current=target;do{if(current?.matches?.(selector))return!0;if(current===domNode)break;current=current?.parentElement}while(current)return!1}function getDragItems(nodeLookup,nodesDraggable,mousePos,nodeId){let dragItems=new Map;for(let[id,node]of nodeLookup)if((node.selected||node.id===nodeId)&&(!node.parentId||!isParentSelected(node,nodeLookup))&&(node.draggable||nodesDraggable&&void 0===node.draggable)){let internalNode=nodeLookup.get(id);internalNode&&dragItems.set(id,{id,position:internalNode.position||{x:0,y:0},distance:{x:mousePos.x-internalNode.internals.positionAbsolute.x,y:mousePos.y-internalNode.internals.positionAbsolute.y},extent:internalNode.extent,parentId:internalNode.parentId,origin:internalNode.origin,expandParent:internalNode.expandParent,internals:{positionAbsolute:internalNode.internals.positionAbsolute||{x:0,y:0}},measured:{width:internalNode.measured.width??0,height:internalNode.measured.height??0}})}return dragItems}function getEventHandlerParams({nodeId,dragItems,nodeLookup,dragging=!0}){let nodesFromDragItems=[];for(let[id,dragItem]of dragItems){let node=nodeLookup.get(id)?.internals.userNode;node&&nodesFromDragItems.push({...node,position:dragItem.position,dragging})}if(!nodeId)return[nodesFromDragItems[0],nodesFromDragItems];let node=nodeLookup.get(nodeId)?.internals.userNode;return[node?{...node,position:dragItems.get(nodeId)?.position||node.position,dragging}:nodesFromDragItems[0],nodesFromDragItems]}function XYDrag({onNodeMouseDown,getStoreItems,onDragStart,onDrag,onDragStop}){let lastPos={x:null,y:null},autoPanId=0,dragItems=new Map,autoPanStarted=!1,mousePosition={x:0,y:0},containerBounds=null,dragStarted=!1,d3Selection=null,abortDrag=!1;return{update:function update({noDragClassName,handleSelector,domNode,isSelectable,nodeId,nodeClickDistance=0}){function updateNodes({x,y},dragEvent){let{nodeLookup,nodeExtent,snapGrid,snapToGrid,nodeOrigin,onNodeDrag,onSelectionDrag,onError,updateNodePositions}=getStoreItems();lastPos={x,y};let hasChange=!1,nodesBox={x:0,y:0,x2:0,y2:0};for(let[id,dragItem]of(dragItems.size>1&&nodeExtent&&(nodesBox=rectToBox(getInternalNodesBounds(dragItems))),dragItems)){if(!nodeLookup.has(id))continue;let nextPosition={x:x-dragItem.distance.x,y:y-dragItem.distance.y};snapToGrid&&(nextPosition=snapPosition(nextPosition,snapGrid));let adjustedNodeExtent=[[nodeExtent[0][0],nodeExtent[0][1]],[nodeExtent[1][0],nodeExtent[1][1]]];if(dragItems.size>1&&nodeExtent&&!dragItem.extent){let{positionAbsolute}=dragItem.internals,x1=positionAbsolute.x-nodesBox.x+nodeExtent[0][0],x2=positionAbsolute.x+dragItem.measured.width-nodesBox.x2+nodeExtent[1][0];adjustedNodeExtent=[[x1,positionAbsolute.y-nodesBox.y+nodeExtent[0][1]],[x2,positionAbsolute.y+dragItem.measured.height-nodesBox.y2+nodeExtent[1][1]]]}let{position,positionAbsolute}=calculateNodePosition({nodeId:id,nextPosition,nodeLookup,nodeExtent:adjustedNodeExtent,nodeOrigin,onError});hasChange=hasChange||dragItem.position.x!==position.x||dragItem.position.y!==position.y,dragItem.position=position,dragItem.internals.positionAbsolute=positionAbsolute}if(hasChange&&(updateNodePositions(dragItems,!0),dragEvent&&(onDrag||onNodeDrag||!nodeId&&onSelectionDrag))){let[currentNode,currentNodes]=getEventHandlerParams({nodeId,dragItems,nodeLookup});onDrag?.(dragEvent,dragItems,currentNode,currentNodes),onNodeDrag?.(dragEvent,currentNode,currentNodes),nodeId||onSelectionDrag?.(dragEvent,currentNodes)}}async function autoPan(){if(!containerBounds)return;let{transform,panBy,autoPanSpeed,autoPanOnNodeDrag}=getStoreItems();if(!autoPanOnNodeDrag){autoPanStarted=!1,cancelAnimationFrame(autoPanId);return}let[xMovement,yMovement]=calcAutoPan(mousePosition,containerBounds,autoPanSpeed);(0!==xMovement||0!==yMovement)&&(lastPos.x=(lastPos.x??0)-xMovement/transform[2],lastPos.y=(lastPos.y??0)-yMovement/transform[2],await panBy({x:xMovement,y:yMovement})&&updateNodes(lastPos,null)),autoPanId=requestAnimationFrame(autoPan)}function startDrag(event){let{nodeLookup,multiSelectionActive,nodesDraggable,transform,snapGrid,snapToGrid,selectNodesOnDrag,onNodeDragStart,onSelectionDragStart,unselectNodesAndEdges}=getStoreItems();dragStarted=!0,selectNodesOnDrag&&isSelectable||multiSelectionActive||!nodeId||nodeLookup.get(nodeId)?.selected||unselectNodesAndEdges(),isSelectable&&selectNodesOnDrag&&nodeId&&onNodeMouseDown?.(nodeId);let pointerPos=getPointerPosition(event.sourceEvent,{transform,snapGrid,snapToGrid,containerBounds});if(lastPos=pointerPos,(dragItems=getDragItems(nodeLookup,nodesDraggable,pointerPos,nodeId)).size>0&&(onDragStart||onNodeDragStart||!nodeId&&onSelectionDragStart)){let[currentNode,currentNodes]=getEventHandlerParams({nodeId,dragItems,nodeLookup});onDragStart?.(event.sourceEvent,dragItems,currentNode,currentNodes),onNodeDragStart?.(event.sourceEvent,currentNode,currentNodes),nodeId||onSelectionDragStart?.(event.sourceEvent,currentNodes)}}d3Selection=(0,src_select.Z)(domNode);let d3DragInstance=drag().clickDistance(nodeClickDistance).on("start",event=>{let{domNode,nodeDragThreshold,transform,snapGrid,snapToGrid}=getStoreItems();containerBounds=domNode?.getBoundingClientRect()||null,abortDrag=!1,0===nodeDragThreshold&&startDrag(event),lastPos=getPointerPosition(event.sourceEvent,{transform,snapGrid,snapToGrid,containerBounds}),mousePosition=getEventPosition(event.sourceEvent,containerBounds)}).on("drag",event=>{let{autoPanOnNodeDrag,transform,snapGrid,snapToGrid,nodeDragThreshold,nodeLookup}=getStoreItems(),pointerPos=getPointerPosition(event.sourceEvent,{transform,snapGrid,snapToGrid,containerBounds});if(("touchmove"===event.sourceEvent.type&&event.sourceEvent.touches.length>1||nodeId&&!nodeLookup.has(nodeId))&&(abortDrag=!0),!abortDrag){if(!autoPanStarted&&autoPanOnNodeDrag&&dragStarted&&(autoPanStarted=!0,autoPan()),!dragStarted){let x=pointerPos.xSnapped-(lastPos.x??0),y=pointerPos.ySnapped-(lastPos.y??0);Math.sqrt(x*x+y*y)>nodeDragThreshold&&startDrag(event)}(lastPos.x!==pointerPos.xSnapped||lastPos.y!==pointerPos.ySnapped)&&dragItems&&dragStarted&&(mousePosition=getEventPosition(event.sourceEvent,containerBounds),updateNodes(pointerPos,event.sourceEvent))}}).on("end",event=>{if(dragStarted&&!abortDrag&&(autoPanStarted=!1,dragStarted=!1,cancelAnimationFrame(autoPanId),dragItems.size>0)){let{nodeLookup,updateNodePositions,onNodeDragStop,onSelectionDragStop}=getStoreItems();if(updateNodePositions(dragItems,!1),onDragStop||onNodeDragStop||!nodeId&&onSelectionDragStop){let[currentNode,currentNodes]=getEventHandlerParams({nodeId,dragItems,nodeLookup,dragging:!1});onDragStop?.(event.sourceEvent,dragItems,currentNode,currentNodes),onNodeDragStop?.(event.sourceEvent,currentNode,currentNodes),nodeId||onSelectionDragStop?.(event.sourceEvent,currentNodes)}}}).filter(event=>{let target=event.target;return!event.button&&(!noDragClassName||!hasSelector(target,`.${noDragClassName}`,domNode))&&(!handleSelector||hasSelector(target,handleSelector,domNode))});d3Selection.call(d3DragInstance)},destroy:function destroy(){d3Selection?.on(".drag",null)}}}function getNodesWithinDistance(position,nodeLookup,distance){let nodes=[],rect={x:position.x-distance,y:position.y-distance,width:2*distance,height:2*distance};for(let node of nodeLookup.values())getOverlappingArea(rect,nodeToRect(node))>0&&nodes.push(node);return nodes}function getClosestHandle(position,connectionRadius,nodeLookup,fromHandle){let closestHandles=[],minDistance=1/0;for(let node of getNodesWithinDistance(position,nodeLookup,connectionRadius+250))for(let handle of[...node.internals.handleBounds?.source??[],...node.internals.handleBounds?.target??[]]){if(fromHandle.nodeId===handle.nodeId&&fromHandle.type===handle.type&&fromHandle.id===handle.id)continue;let{x,y}=getHandlePosition(node,handle,handle.position,!0),distance=Math.sqrt(Math.pow(x-position.x,2)+Math.pow(y-position.y,2));!(distance>connectionRadius)&&(distance<minDistance?(closestHandles=[{...handle,x,y}],minDistance=distance):distance===minDistance&&closestHandles.push({...handle,x,y}))}if(!closestHandles.length)return null;if(closestHandles.length>1){let oppositeHandleType="source"===fromHandle.type?"target":"source";return closestHandles.find(handle=>handle.type===oppositeHandleType)??closestHandles[0]}return closestHandles[0]}function getHandle(nodeId,handleType,handleId,nodeLookup,connectionMode,withAbsolutePosition=!1){let node=nodeLookup.get(nodeId);if(!node)return null;let handles="strict"===connectionMode?node.internals.handleBounds?.[handleType]:[...node.internals.handleBounds?.source??[],...node.internals.handleBounds?.target??[]],handle=(handleId?handles?.find(h=>h.id===handleId):handles?.[0])??null;return handle&&withAbsolutePosition?{...handle,...getHandlePosition(node,handle,handle.position,!0)}:handle}function getHandleType(edgeUpdaterType,handleDomNode){return edgeUpdaterType?edgeUpdaterType:handleDomNode?.classList.contains("target")?"target":handleDomNode?.classList.contains("source")?"source":null}function isConnectionValid(isInsideConnectionRadius,isHandleValid){let isValid=null;return isHandleValid?isValid=!0:isInsideConnectionRadius&&!isHandleValid&&(isValid=!1),isValid}let alwaysValid=()=>!0;function isValidHandle(event,{handle,connectionMode,fromNodeId,fromHandleId,fromType,doc,lib,flowId,isValidConnection=alwaysValid,nodeLookup}){let isTarget="target"===fromType,handleDomNode=handle?doc.querySelector(`.${lib}-flow__handle[data-id="${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}"]`):null,{x,y}=getEventPosition(event),handleBelow=doc.elementFromPoint(x,y),handleToCheck=handleBelow?.classList.contains(`${lib}-flow__handle`)?handleBelow:handleDomNode,result={handleDomNode:handleToCheck,isValid:!1,connection:null,toHandle:null};if(handleToCheck){let handleType=getHandleType(void 0,handleToCheck),handleNodeId=handleToCheck.getAttribute("data-nodeid"),handleId=handleToCheck.getAttribute("data-handleid"),connectable=handleToCheck.classList.contains("connectable"),connectableEnd=handleToCheck.classList.contains("connectableend");if(!handleNodeId||!handleType)return result;let connection={source:isTarget?handleNodeId:fromNodeId,sourceHandle:isTarget?handleId:fromHandleId,target:isTarget?fromNodeId:handleNodeId,targetHandle:isTarget?fromHandleId:handleId};result.connection=connection,result.isValid=connectable&&connectableEnd&&(connectionMode===ConnectionMode.Strict?isTarget&&"source"===handleType||!isTarget&&"target"===handleType:handleNodeId!==fromNodeId||handleId!==fromHandleId)&&isValidConnection(connection),result.toHandle=getHandle(handleNodeId,handleType,handleId,nodeLookup,connectionMode,!1)}return result}let XYHandle={onPointerDown:function onPointerDown(event,{connectionMode,connectionRadius,handleId,nodeId,edgeUpdaterType,isTarget,domNode,nodeLookup,lib,autoPanOnConnect,flowId,panBy,cancelConnection,onConnectStart,onConnect,onConnectEnd,isValidConnection=alwaysValid,onReconnectEnd,updateConnection,getTransform,getFromHandle,autoPanSpeed}){let closestHandle;let doc=getHostForElement(event.target),autoPanId=0,{x,y}=getEventPosition(event),handleType=getHandleType(edgeUpdaterType,doc?.elementFromPoint(x,y)),containerBounds=domNode?.getBoundingClientRect();if(!containerBounds||!handleType)return;let fromHandleInternal=getHandle(nodeId,handleType,handleId,nodeLookup,connectionMode);if(!fromHandleInternal)return;let position=getEventPosition(event,containerBounds),autoPanStarted=!1,connection=null,isValid=!1,handleDomNode=null;function autoPan(){if(!autoPanOnConnect||!containerBounds)return;let[x,y]=calcAutoPan(position,containerBounds,autoPanSpeed);panBy({x,y}),autoPanId=requestAnimationFrame(autoPan)}let fromHandle={...fromHandleInternal,nodeId,type:handleType,position:fromHandleInternal.position},fromNodeInternal=nodeLookup.get(nodeId),newConnection={inProgress:!0,isValid:null,from:getHandlePosition(fromNodeInternal,fromHandle,Position.Left,!0),fromHandle,fromPosition:fromHandle.position,fromNode:fromNodeInternal,to:position,toHandle:null,toPosition:oppositePosition[fromHandle.position],toNode:null};updateConnection(newConnection);let previousConnection=newConnection;function onPointerMove(event){if(!getFromHandle()||!fromHandle){onPointerUp(event);return}let transform=getTransform();closestHandle=getClosestHandle(pointToRendererPoint(position=getEventPosition(event,containerBounds),transform,!1,[1,1]),connectionRadius,nodeLookup,fromHandle),autoPanStarted||(autoPan(),autoPanStarted=!0);let result=isValidHandle(event,{handle:closestHandle,connectionMode,fromNodeId:nodeId,fromHandleId:handleId,fromType:isTarget?"target":"source",isValidConnection,doc,lib,flowId,nodeLookup});handleDomNode=result.handleDomNode,connection=result.connection,isValid=isConnectionValid(!!closestHandle,result.isValid);let newConnection={...previousConnection,isValid,to:closestHandle&&isValid?rendererPointToPoint({x:closestHandle.x,y:closestHandle.y},transform):position,toHandle:result.toHandle,toPosition:isValid&&result.toHandle?result.toHandle.position:oppositePosition[fromHandle.position],toNode:result.toHandle?nodeLookup.get(result.toHandle.nodeId):null};(!isValid||!closestHandle||!previousConnection.toHandle||!newConnection.toHandle||previousConnection.toHandle.type!==newConnection.toHandle.type||previousConnection.toHandle.nodeId!==newConnection.toHandle.nodeId||previousConnection.toHandle.id!==newConnection.toHandle.id||previousConnection.to.x!==newConnection.to.x||previousConnection.to.y!==newConnection.to.y)&&(updateConnection(newConnection),previousConnection=newConnection)}function onPointerUp(event){(closestHandle||handleDomNode)&&connection&&isValid&&onConnect?.(connection);let{inProgress,...connectionState}=previousConnection,finalConnectionState={...connectionState,toPosition:previousConnection.toHandle?previousConnection.toPosition:null};onConnectEnd?.(event,finalConnectionState),edgeUpdaterType&&onReconnectEnd?.(event,finalConnectionState),cancelConnection(),cancelAnimationFrame(autoPanId),autoPanStarted=!1,isValid=!1,connection=null,handleDomNode=null,doc.removeEventListener("mousemove",onPointerMove),doc.removeEventListener("mouseup",onPointerUp),doc.removeEventListener("touchmove",onPointerMove),doc.removeEventListener("touchend",onPointerUp)}onConnectStart?.(event,{nodeId,handleId,handleType}),doc.addEventListener("mousemove",onPointerMove),doc.addEventListener("mouseup",onPointerUp),doc.addEventListener("touchmove",onPointerMove),doc.addEventListener("touchend",onPointerUp)},isValid:isValidHandle};function XYMinimap({domNode,panZoom,getTransform,getViewScale}){let selection=(0,src_select.Z)(domNode);return{update:function update({translateExtent,width,height,zoomStep=10,pannable=!0,zoomable=!0,inversePan=!1}){let panStart=[0,0],zoomAndPanHandler=(0,src.sP)().on("start",event=>{("mousedown"===event.sourceEvent.type||"touchstart"===event.sourceEvent.type)&&(panStart=[event.sourceEvent.clientX??event.sourceEvent.touches[0].clientX,event.sourceEvent.clientY??event.sourceEvent.touches[0].clientY])}).on("zoom",pannable?event=>{let transform=getTransform();if("mousemove"!==event.sourceEvent.type&&"touchmove"!==event.sourceEvent.type||!panZoom)return;let panCurrent=[event.sourceEvent.clientX??event.sourceEvent.touches[0].clientX,event.sourceEvent.clientY??event.sourceEvent.touches[0].clientY],panDelta=[panCurrent[0]-panStart[0],panCurrent[1]-panStart[1]];panStart=panCurrent;let moveScale=getViewScale()*Math.max(transform[2],Math.log(transform[2]))*(inversePan?-1:1),position={x:transform[0]-panDelta[0]*moveScale,y:transform[1]-panDelta[1]*moveScale};panZoom.setViewportConstrained({x:position.x,y:position.y,zoom:transform[2]},[[0,0],[width,height]],translateExtent)}:null).on("zoom.wheel",zoomable?event=>{let transform=getTransform();if("wheel"!==event.sourceEvent.type||!panZoom)return;let pinchDelta=-event.sourceEvent.deltaY*(1===event.sourceEvent.deltaMode?.05:event.sourceEvent.deltaMode?1:.002)*zoomStep,nextZoom=transform[2]*Math.pow(2,pinchDelta);panZoom.scaleTo(nextZoom)}:null);selection.call(zoomAndPanHandler,{})},destroy:function destroy(){selection.on("zoom",null)},pointer:pointer.Z}}let viewChanged=(prevViewport,eventViewport)=>prevViewport.x!==eventViewport.x||prevViewport.y!==eventViewport.y||prevViewport.zoom!==eventViewport.k,transformToViewport=transform=>({x:transform.x,y:transform.y,zoom:transform.k}),viewportToTransform=({x,y,zoom})=>src.CR.translate(x,y).scale(zoom),isWrappedWithClass=(event,className)=>event.target.closest(`.${className}`),isRightClickPan=(panOnDrag,usedButton)=>2===usedButton&&Array.isArray(panOnDrag)&&panOnDrag.includes(2),getD3Transition=(selection,duration=0,onEnd=()=>{})=>{let hasDuration="number"==typeof duration&&duration>0;return hasDuration||onEnd(),hasDuration?selection.transition().duration(duration).on("end",onEnd):selection},wheelDelta=event=>{let factor=event.ctrlKey&&isMacOs()?10:1;return-event.deltaY*(1===event.deltaMode?.05:event.deltaMode?1:.002)*factor};function createPanOnScrollHandler({zoomPanValues,noWheelClassName,d3Selection,d3Zoom,panOnScrollMode,panOnScrollSpeed,zoomOnPinch,onPanZoomStart,onPanZoom,onPanZoomEnd}){return event=>{if(isWrappedWithClass(event,noWheelClassName))return!1;event.preventDefault(),event.stopImmediatePropagation();let currentZoom=d3Selection.property("__zoom").k||1;if(event.ctrlKey&&zoomOnPinch){let point=(0,pointer.Z)(event),zoom=currentZoom*Math.pow(2,wheelDelta(event));d3Zoom.scaleTo(d3Selection,zoom,point,event);return}let deltaNormalize=1===event.deltaMode?20:1,deltaX=panOnScrollMode===PanOnScrollMode.Vertical?0:event.deltaX*deltaNormalize,deltaY=panOnScrollMode===PanOnScrollMode.Horizontal?0:event.deltaY*deltaNormalize;!isMacOs()&&event.shiftKey&&panOnScrollMode!==PanOnScrollMode.Vertical&&(deltaX=event.deltaY*deltaNormalize,deltaY=0),d3Zoom.translateBy(d3Selection,-(deltaX/currentZoom)*panOnScrollSpeed,-(deltaY/currentZoom)*panOnScrollSpeed,{internal:!0});let nextViewport=transformToViewport(d3Selection.property("__zoom"));clearTimeout(zoomPanValues.panScrollTimeout),zoomPanValues.isPanScrolling||(zoomPanValues.isPanScrolling=!0,onPanZoomStart?.(event,nextViewport)),zoomPanValues.isPanScrolling&&(onPanZoom?.(event,nextViewport),zoomPanValues.panScrollTimeout=setTimeout(()=>{onPanZoomEnd?.(event,nextViewport),zoomPanValues.isPanScrolling=!1},150))}}function createZoomOnScrollHandler({noWheelClassName,preventScrolling,d3ZoomHandler}){return function(event,d){let isWheel="wheel"===event.type,preventZoom=!preventScrolling&&isWheel&&!event.ctrlKey,hasNoWheelClass=isWrappedWithClass(event,noWheelClassName);if(event.ctrlKey&&isWheel&&hasNoWheelClass&&event.preventDefault(),preventZoom||hasNoWheelClass)return null;event.preventDefault(),d3ZoomHandler.call(this,event,d)}}function createPanZoomStartHandler({zoomPanValues,onDraggingChange,onPanZoomStart}){return event=>{if(event.sourceEvent?.internal)return;let viewport=transformToViewport(event.transform);zoomPanValues.mouseButton=event.sourceEvent?.button||0,zoomPanValues.isZoomingOrPanning=!0,zoomPanValues.prevViewport=viewport,event.sourceEvent?.type==="mousedown"&&onDraggingChange(!0),onPanZoomStart&&onPanZoomStart?.(event.sourceEvent,viewport)}}function createPanZoomHandler({zoomPanValues,panOnDrag,onPaneContextMenu,onTransformChange,onPanZoom}){return event=>{zoomPanValues.usedRightMouseButton=!!(onPaneContextMenu&&isRightClickPan(panOnDrag,zoomPanValues.mouseButton??0)),event.sourceEvent?.sync||onTransformChange([event.transform.x,event.transform.y,event.transform.k]),onPanZoom&&!event.sourceEvent?.internal&&onPanZoom?.(event.sourceEvent,transformToViewport(event.transform))}}function createPanZoomEndHandler({zoomPanValues,panOnDrag,panOnScroll,onDraggingChange,onPanZoomEnd,onPaneContextMenu}){return event=>{if(!event.sourceEvent?.internal&&(zoomPanValues.isZoomingOrPanning=!1,onPaneContextMenu&&isRightClickPan(panOnDrag,zoomPanValues.mouseButton??0)&&!zoomPanValues.usedRightMouseButton&&event.sourceEvent&&onPaneContextMenu(event.sourceEvent),zoomPanValues.usedRightMouseButton=!1,onDraggingChange(!1),onPanZoomEnd&&viewChanged(zoomPanValues.prevViewport,event.transform))){let viewport=transformToViewport(event.transform);zoomPanValues.prevViewport=viewport,clearTimeout(zoomPanValues.timerId),zoomPanValues.timerId=setTimeout(()=>{onPanZoomEnd?.(event.sourceEvent,viewport)},150*!!panOnScroll)}}}function createFilter({zoomActivationKeyPressed,zoomOnScroll,zoomOnPinch,panOnDrag,panOnScroll,zoomOnDoubleClick,userSelectionActive,noWheelClassName,noPanClassName,lib}){return event=>{let zoomScroll=zoomActivationKeyPressed||zoomOnScroll,pinchZoom=zoomOnPinch&&event.ctrlKey;if(1===event.button&&"mousedown"===event.type&&(isWrappedWithClass(event,`${lib}-flow__node`)||isWrappedWithClass(event,`${lib}-flow__edge`)))return!0;if(!panOnDrag&&!zoomScroll&&!panOnScroll&&!zoomOnDoubleClick&&!zoomOnPinch||userSelectionActive||isWrappedWithClass(event,noWheelClassName)&&"wheel"===event.type||isWrappedWithClass(event,noPanClassName)&&("wheel"!==event.type||panOnScroll&&"wheel"===event.type&&!zoomActivationKeyPressed)||!zoomOnPinch&&event.ctrlKey&&"wheel"===event.type)return!1;if(!zoomOnPinch&&"touchstart"===event.type&&event.touches?.length>1)return event.preventDefault(),!1;if(!zoomScroll&&!panOnScroll&&!pinchZoom&&"wheel"===event.type||!panOnDrag&&("mousedown"===event.type||"touchstart"===event.type)||Array.isArray(panOnDrag)&&!panOnDrag.includes(event.button)&&"mousedown"===event.type)return!1;let buttonAllowed=Array.isArray(panOnDrag)&&panOnDrag.includes(event.button)||!event.button||event.button<=1;return(!event.ctrlKey||"wheel"===event.type)&&buttonAllowed}}function XYPanZoom({domNode,minZoom,maxZoom,paneClickDistance,translateExtent,viewport,onPanZoom,onPanZoomStart,onPanZoomEnd,onDraggingChange}){let zoomPanValues={isZoomingOrPanning:!1,usedRightMouseButton:!1,prevViewport:{x:0,y:0,zoom:0},mouseButton:0,timerId:void 0,panScrollTimeout:void 0,isPanScrolling:!1},bbox=domNode.getBoundingClientRect(),d3ZoomInstance=(0,src.sP)().clickDistance(!isNumeric(paneClickDistance)||paneClickDistance<0?0:paneClickDistance).scaleExtent([minZoom,maxZoom]).translateExtent(translateExtent),d3Selection=(0,src_select.Z)(domNode).call(d3ZoomInstance);setViewportConstrained({x:viewport.x,y:viewport.y,zoom:clamp(viewport.zoom,minZoom,maxZoom)},[[0,0],[bbox.width,bbox.height]],translateExtent);let d3ZoomHandler=d3Selection.on("wheel.zoom"),d3DblClickZoomHandler=d3Selection.on("dblclick.zoom");function setTransform(transform,options){return d3Selection?new Promise(resolve=>{d3ZoomInstance?.transform(getD3Transition(d3Selection,options?.duration,()=>resolve(!0)),transform)}):Promise.resolve(!1)}function destroy(){d3ZoomInstance.on("zoom",null)}async function setViewportConstrained(viewport,extent,translateExtent){let nextTransform=viewportToTransform(viewport),contrainedTransform=d3ZoomInstance?.constrain()(nextTransform,extent,translateExtent);return contrainedTransform&&await setTransform(contrainedTransform),new Promise(resolve=>resolve(contrainedTransform))}return d3ZoomInstance.wheelDelta(wheelDelta),{update:function update({noWheelClassName,noPanClassName,onPaneContextMenu,userSelectionActive,panOnScroll,panOnDrag,panOnScrollMode,panOnScrollSpeed,preventScrolling,zoomOnPinch,zoomOnScroll,zoomOnDoubleClick,zoomActivationKeyPressed,lib,onTransformChange}){userSelectionActive&&!zoomPanValues.isZoomingOrPanning&&destroy();let wheelHandler=!panOnScroll||zoomActivationKeyPressed||userSelectionActive?createZoomOnScrollHandler({noWheelClassName,preventScrolling,d3ZoomHandler}):createPanOnScrollHandler({zoomPanValues,noWheelClassName,d3Selection,d3Zoom:d3ZoomInstance,panOnScrollMode,panOnScrollSpeed,zoomOnPinch,onPanZoomStart,onPanZoom,onPanZoomEnd});if(d3Selection.on("wheel.zoom",wheelHandler,{passive:!1}),!userSelectionActive){let startHandler=createPanZoomStartHandler({zoomPanValues,onDraggingChange,onPanZoomStart});d3ZoomInstance.on("start",startHandler);let panZoomHandler=createPanZoomHandler({zoomPanValues,panOnDrag,onPaneContextMenu:!!onPaneContextMenu,onPanZoom,onTransformChange});d3ZoomInstance.on("zoom",panZoomHandler);let panZoomEndHandler=createPanZoomEndHandler({zoomPanValues,panOnDrag,panOnScroll,onPaneContextMenu,onPanZoomEnd,onDraggingChange});d3ZoomInstance.on("end",panZoomEndHandler)}let filter=createFilter({zoomActivationKeyPressed,panOnDrag,zoomOnScroll,panOnScroll,zoomOnDoubleClick,zoomOnPinch,userSelectionActive,noPanClassName,noWheelClassName,lib});d3ZoomInstance.filter(filter),zoomOnDoubleClick?d3Selection.on("dblclick.zoom",d3DblClickZoomHandler):d3Selection.on("dblclick.zoom",null)},destroy,setViewport:async function setViewport(viewport,options){let nextTransform=viewportToTransform(viewport);return await setTransform(nextTransform,options),new Promise(resolve=>resolve(nextTransform))},setViewportConstrained,getViewport:function getViewport(){let transform=d3Selection?(0,src.P2)(d3Selection.node()):{x:0,y:0,k:1};return{x:transform.x,y:transform.y,zoom:transform.k}},scaleTo:function scaleTo(zoom,options){return d3Selection?new Promise(resolve=>{d3ZoomInstance?.scaleTo(getD3Transition(d3Selection,options?.duration,()=>resolve(!0)),zoom)}):Promise.resolve(!1)},scaleBy:function scaleBy(factor,options){return d3Selection?new Promise(resolve=>{d3ZoomInstance?.scaleBy(getD3Transition(d3Selection,options?.duration,()=>resolve(!0)),factor)}):Promise.resolve(!1)},setScaleExtent:function setScaleExtent(scaleExtent){d3ZoomInstance?.scaleExtent(scaleExtent)},setTranslateExtent:function setTranslateExtent(translateExtent){d3ZoomInstance?.translateExtent(translateExtent)},syncViewport:function syncViewport(viewport){if(d3Selection){let nextTransform=viewportToTransform(viewport),currentTransform=d3Selection.property("__zoom");(currentTransform.k!==viewport.zoom||currentTransform.x!==viewport.x||currentTransform.y!==viewport.y)&&d3ZoomInstance?.transform(d3Selection,nextTransform,null,{sync:!0})}},setClickDistance:function setClickDistance(distance){let validDistance=!isNumeric(distance)||distance<0?0:distance;d3ZoomInstance?.clickDistance(validDistance)}}}function getResizeDirection({width,prevWidth,height,prevHeight,affectsX,affectsY}){let deltaWidth=width-prevWidth,deltaHeight=height-prevHeight,direction=[deltaWidth>0?1:deltaWidth<0?-1:0,deltaHeight>0?1:deltaHeight<0?-1:0];return deltaWidth&&affectsX&&(direction[0]=-1*direction[0]),deltaHeight&&affectsY&&(direction[1]=-1*direction[1]),direction}function getControlDirection(controlPosition){let isHorizontal=controlPosition.includes("right")||controlPosition.includes("left"),isVertical=controlPosition.includes("bottom")||controlPosition.includes("top");return{isHorizontal,isVertical,affectsX:controlPosition.includes("left"),affectsY:controlPosition.includes("top")}}function getLowerExtentClamp(lowerExtent,lowerBound){return Math.max(0,lowerBound-lowerExtent)}function getUpperExtentClamp(upperExtent,upperBound){return Math.max(0,upperExtent-upperBound)}function getSizeClamp(size,minSize,maxSize){return Math.max(0,minSize-size,size-maxSize)}function getDimensionsAfterResize(startValues,controlDirection,pointerPosition,boundaries,keepAspectRatio,nodeOrigin,extent,childExtent){let{affectsX,affectsY}=controlDirection,{isHorizontal,isVertical}=controlDirection,isDiagonal=isHorizontal&&isVertical,{xSnapped,ySnapped}=pointerPosition,{minWidth,maxWidth,minHeight,maxHeight}=boundaries,{x:startX,y:startY,width:startWidth,height:startHeight,aspectRatio}=startValues,distX=Math.floor(isHorizontal?xSnapped-startValues.pointerX:0),distY=Math.floor(isVertical?ySnapped-startValues.pointerY:0),newWidth=startWidth+(affectsX?-distX:distX),newHeight=startHeight+(affectsY?-distY:distY),originOffsetX=-nodeOrigin[0]*startWidth,originOffsetY=-nodeOrigin[1]*startHeight,clampX=getSizeClamp(newWidth,minWidth,maxWidth),clampY=getSizeClamp(newHeight,minHeight,maxHeight);if(extent){let xExtentClamp=0,yExtentClamp=0;affectsX&&distX<0?xExtentClamp=getLowerExtentClamp(startX+distX+originOffsetX,extent[0][0]):!affectsX&&distX>0&&(xExtentClamp=getUpperExtentClamp(startX+newWidth+originOffsetX,extent[1][0])),affectsY&&distY<0?yExtentClamp=getLowerExtentClamp(startY+distY+originOffsetY,extent[0][1]):!affectsY&&distY>0&&(yExtentClamp=getUpperExtentClamp(startY+newHeight+originOffsetY,extent[1][1])),clampX=Math.max(clampX,xExtentClamp),clampY=Math.max(clampY,yExtentClamp)}if(childExtent){let xExtentClamp=0,yExtentClamp=0;affectsX&&distX>0?xExtentClamp=getUpperExtentClamp(startX+distX,childExtent[0][0]):!affectsX&&distX<0&&(xExtentClamp=getLowerExtentClamp(startX+newWidth,childExtent[1][0])),affectsY&&distY>0?yExtentClamp=getUpperExtentClamp(startY+distY,childExtent[0][1]):!affectsY&&distY<0&&(yExtentClamp=getLowerExtentClamp(startY+newHeight,childExtent[1][1])),clampX=Math.max(clampX,xExtentClamp),clampY=Math.max(clampY,yExtentClamp)}if(keepAspectRatio){if(isHorizontal){if(clampX=Math.max(clampX,getSizeClamp(newWidth/aspectRatio,minHeight,maxHeight)*aspectRatio),extent){let aspectExtentClamp=0;clampX=Math.max(clampX,(affectsX||affectsY)&&(!affectsX||affectsY||!isDiagonal)?getLowerExtentClamp(startY+originOffsetY+(affectsX?distX:-distX)/aspectRatio,extent[0][1])*aspectRatio:getUpperExtentClamp(startY+originOffsetY+newWidth/aspectRatio,extent[1][1])*aspectRatio)}if(childExtent){let aspectExtentClamp=0;clampX=Math.max(clampX,(affectsX||affectsY)&&(!affectsX||affectsY||!isDiagonal)?getUpperExtentClamp(startY+(affectsX?distX:-distX)/aspectRatio,childExtent[0][1])*aspectRatio:getLowerExtentClamp(startY+newWidth/aspectRatio,childExtent[1][1])*aspectRatio)}}if(isVertical){if(clampY=Math.max(clampY,getSizeClamp(newHeight*aspectRatio,minWidth,maxWidth)/aspectRatio),extent){let aspectExtentClamp=0;clampY=Math.max(clampY,(affectsX||affectsY)&&(!affectsY||affectsX||!isDiagonal)?getLowerExtentClamp(startX+(affectsY?distY:-distY)*aspectRatio+originOffsetX,extent[0][0])/aspectRatio:getUpperExtentClamp(startX+newHeight*aspectRatio+originOffsetX,extent[1][0])/aspectRatio)}if(childExtent){let aspectExtentClamp=0;clampY=Math.max(clampY,(affectsX||affectsY)&&(!affectsY||affectsX||!isDiagonal)?getUpperExtentClamp(startX+(affectsY?distY:-distY)*aspectRatio,childExtent[0][0])/aspectRatio:getLowerExtentClamp(startX+newHeight*aspectRatio,childExtent[1][0])/aspectRatio)}}}if(distY+=distY<0?clampY:-clampY,distX+=distX<0?clampX:-clampX,keepAspectRatio){if(isDiagonal){var a,b,a1,b1;newWidth>newHeight*aspectRatio?distY=((a=affectsX,b=affectsY,a?!b:b)?-distX:distX)/aspectRatio:distX=((a1=affectsX,b1=affectsY,a1?!b1:b1)?-distY:distY)*aspectRatio}else isHorizontal?(distY=distX/aspectRatio,affectsY=affectsX):(distX=distY*aspectRatio,affectsX=affectsY)}let x=affectsX?startX+distX:startX,y=affectsY?startY+distY:startY;return{width:startWidth+(affectsX?-distX:distX),height:startHeight+(affectsY?-distY:distY),x:nodeOrigin[0]*distX*(affectsX?-1:1)+x,y:nodeOrigin[1]*distY*(affectsY?-1:1)+y}}!function(ResizeControlVariant){ResizeControlVariant.Line="line",ResizeControlVariant.Handle="handle"}(ResizeControlVariant||(ResizeControlVariant={}));let initPrevValues={width:0,height:0,x:0,y:0},initStartValues={...initPrevValues,pointerX:0,pointerY:0,aspectRatio:1};function nodeToParentExtent(node){return[[0,0],[node.measured.width,node.measured.height]]}function nodeToChildExtent(child,parent,nodeOrigin){let x=parent.position.x+child.position.x,y=parent.position.y+child.position.y,width=child.measured.width??0,height=child.measured.height??0,originOffsetX=nodeOrigin[0]*width,originOffsetY=nodeOrigin[1]*height;return[[x-originOffsetX,y-originOffsetY],[x+width-originOffsetX,y+height-originOffsetY]]}function XYResizer({domNode,nodeId,getStoreItems,onChange,onEnd}){let selection=(0,src_select.Z)(domNode);return{update:function update({controlPosition,boundaries,keepAspectRatio,resizeDirection,onResizeStart,onResize,onResizeEnd,shouldResize}){let node,parentNode,parentExtent,childExtent,prevValues={...initPrevValues},startValues={...initStartValues},controlDirection=getControlDirection(controlPosition),containerBounds=null,childNodes=[],dragHandler=drag().on("start",event=>{let{nodeLookup,transform,snapGrid,snapToGrid,nodeOrigin,paneDomNode}=getStoreItems();if(!(node=nodeLookup.get(nodeId)))return;containerBounds=paneDomNode?.getBoundingClientRect()??null;let{xSnapped,ySnapped}=getPointerPosition(event.sourceEvent,{transform,snapGrid,snapToGrid,containerBounds});for(let[childId,child]of(startValues={...prevValues={width:node.measured.width??0,height:node.measured.height??0,x:node.position.x??0,y:node.position.y??0},pointerX:xSnapped,pointerY:ySnapped,aspectRatio:prevValues.width/prevValues.height},parentNode=void 0,node.parentId&&("parent"===node.extent||node.expandParent)&&(parentExtent=(parentNode=nodeLookup.get(node.parentId))&&"parent"===node.extent?nodeToParentExtent(parentNode):void 0),childNodes=[],childExtent=void 0,nodeLookup))if(child.parentId===nodeId&&(childNodes.push({id:childId,position:{...child.position},extent:child.extent}),"parent"===child.extent||child.expandParent)){let extent=nodeToChildExtent(child,node,child.origin??nodeOrigin);childExtent=childExtent?[[Math.min(extent[0][0],childExtent[0][0]),Math.min(extent[0][1],childExtent[0][1])],[Math.max(extent[1][0],childExtent[1][0]),Math.max(extent[1][1],childExtent[1][1])]]:extent}onResizeStart?.(event,{...prevValues})}).on("drag",event=>{let{transform,snapGrid,snapToGrid,nodeOrigin:storeNodeOrigin}=getStoreItems(),pointerPosition=getPointerPosition(event.sourceEvent,{transform,snapGrid,snapToGrid,containerBounds}),childChanges=[];if(!node)return;let{x:prevX,y:prevY,width:prevWidth,height:prevHeight}=prevValues,change={},nodeOrigin=node.origin??storeNodeOrigin,{width,height,x,y}=getDimensionsAfterResize(startValues,controlDirection,pointerPosition,boundaries,keepAspectRatio,nodeOrigin,parentExtent,childExtent),isWidthChange=width!==prevWidth,isHeightChange=height!==prevHeight,isXPosChange=x!==prevX&&isWidthChange,isYPosChange=y!==prevY&&isHeightChange;if(!isXPosChange&&!isYPosChange&&!isWidthChange&&!isHeightChange)return;if((isXPosChange||isYPosChange||1===nodeOrigin[0]||1===nodeOrigin[1])&&(change.x=isXPosChange?x:prevValues.x,change.y=isYPosChange?y:prevValues.y,prevValues.x=change.x,prevValues.y=change.y,childNodes.length>0)){let xChange=x-prevX,yChange=y-prevY;for(let childNode of childNodes)childNode.position={x:childNode.position.x-xChange+nodeOrigin[0]*(width-prevWidth),y:childNode.position.y-yChange+nodeOrigin[1]*(height-prevHeight)},childChanges.push(childNode)}if((isWidthChange||isHeightChange)&&(change.width=isWidthChange&&(!resizeDirection||"horizontal"===resizeDirection)?width:prevValues.width,change.height=isHeightChange&&(!resizeDirection||"vertical"===resizeDirection)?height:prevValues.height,prevValues.width=change.width,prevValues.height=change.height),parentNode&&node.expandParent){let xLimit=nodeOrigin[0]*(change.width??0);change.x&&change.x<xLimit&&(prevValues.x=xLimit,startValues.x=startValues.x-(change.x-xLimit));let yLimit=nodeOrigin[1]*(change.height??0);change.y&&change.y<yLimit&&(prevValues.y=yLimit,startValues.y=startValues.y-(change.y-yLimit))}let direction=getResizeDirection({width:prevValues.width,prevWidth,height:prevValues.height,prevHeight,affectsX:controlDirection.affectsX,affectsY:controlDirection.affectsY}),nextValues={...prevValues,direction};!1!==shouldResize?.(event,nextValues)&&(onResize?.(event,nextValues),onChange(change,childChanges))}).on("end",event=>{onResizeEnd?.(event,{...prevValues}),onEnd?.({...prevValues})});selection.call(dragHandler)},destroy:function destroy(){selection.on(".drag",null)}}}},"../../node_modules/.pnpm/css-loader@3.6.0_webpack@5.88.2/node_modules/css-loader/dist/cjs.js!../../node_modules/.pnpm/postcss-loader@4.3.0_postcss@8.5.6_webpack@5.88.2/node_modules/postcss-loader/dist/cjs.js!../../node_modules/.pnpm/sass-loader@10.3.1_sass@1.56.0_webpack@5.88.2/node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[2].use[3]!../../node_modules/.pnpm/@xyflow+react@12.6.0_@types+react@17.0.52_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@xyflow/react/dist/style.css":(module,exports,__webpack_require__)=>{(exports=__webpack_require__("../../node_modules/.pnpm/css-loader@3.6.0_webpack@5.88.2/node_modules/css-loader/dist/runtime/api.js")(!1)).push([module.id,".react-flow{direction:ltr;--xy-edge-stroke-default:#b1b1b7;--xy-edge-stroke-width-default:1;--xy-edge-stroke-selected-default:#555;--xy-connectionline-stroke-default:#b1b1b7;--xy-connectionline-stroke-width-default:1;--xy-attribution-background-color-default:hsla(0,0%,100%,.5);--xy-minimap-background-color-default:#fff;--xy-minimap-mask-background-color-default:hsla(0,0%,94%,.6);--xy-minimap-mask-stroke-color-default:transparent;--xy-minimap-mask-stroke-width-default:1;--xy-minimap-node-background-color-default:#e2e2e2;--xy-minimap-node-stroke-color-default:transparent;--xy-minimap-node-stroke-width-default:2;--xy-background-color-default:transparent;--xy-background-pattern-dots-color-default:#91919a;--xy-background-pattern-lines-color-default:#eee;--xy-background-pattern-cross-color-default:#e2e2e2;background-color:var(--xy-background-color,var(--xy-background-color-default));--xy-node-color-default:inherit;--xy-node-border-default:1px solid #1a192b;--xy-node-background-color-default:#fff;--xy-node-group-background-color-default:hsla(0,0%,94%,.25);--xy-node-boxshadow-hover-default:0 1px 4px 1px rgba(0,0,0,.08);--xy-node-boxshadow-selected-default:0 0 0 0.5px #1a192b;--xy-node-border-radius-default:3px;--xy-handle-background-color-default:#1a192b;--xy-handle-border-color-default:#fff;--xy-selection-background-color-default:rgba(0,89,220,.08);--xy-selection-border-default:1px dotted rgba(0,89,220,.8);--xy-controls-button-background-color-default:#fefefe;--xy-controls-button-background-color-hover-default:#f4f4f4;--xy-controls-button-color-default:inherit;--xy-controls-button-color-hover-default:inherit;--xy-controls-button-border-color-default:#eee;--xy-controls-box-shadow-default:0 0 2px 1px rgba(0,0,0,.08);--xy-edge-label-background-color-default:#fff;--xy-edge-label-color-default:inherit;--xy-resize-background-color-default:#3367d9}.react-flow.dark{--xy-edge-stroke-default:#3e3e3e;--xy-edge-stroke-width-default:1;--xy-edge-stroke-selected-default:#727272;--xy-connectionline-stroke-default:#b1b1b7;--xy-connectionline-stroke-width-default:1;--xy-attribution-background-color-default:hsla(0,0%,59%,.25);--xy-minimap-background-color-default:#141414;--xy-minimap-mask-background-color-default:rgba(60,60,60,.6);--xy-minimap-mask-stroke-color-default:transparent;--xy-minimap-mask-stroke-width-default:1;--xy-minimap-node-background-color-default:#2b2b2b;--xy-minimap-node-stroke-color-default:transparent;--xy-minimap-node-stroke-width-default:2;--xy-background-color-default:#141414;--xy-background-pattern-dots-color-default:#777;--xy-background-pattern-lines-color-default:#777;--xy-background-pattern-cross-color-default:#777;--xy-node-color-default:#f8f8f8;--xy-node-border-default:1px solid #3c3c3c;--xy-node-background-color-default:#1e1e1e;--xy-node-group-background-color-default:hsla(0,0%,94%,.25);--xy-node-boxshadow-hover-default:0 1px 4px 1px hsla(0,0%,100%,.08);--xy-node-boxshadow-selected-default:0 0 0 0.5px #999;--xy-handle-background-color-default:#bebebe;--xy-handle-border-color-default:#1e1e1e;--xy-selection-background-color-default:rgba(200,200,220,.08);--xy-selection-border-default:1px dotted rgba(200,200,220,.8);--xy-controls-button-background-color-default:#2b2b2b;--xy-controls-button-background-color-hover-default:#3e3e3e;--xy-controls-button-color-default:#f8f8f8;--xy-controls-button-color-hover-default:#fff;--xy-controls-button-border-color-default:#5b5b5b;--xy-controls-box-shadow-default:0 0 2px 1px rgba(0,0,0,.08);--xy-edge-label-background-color-default:#141414;--xy-edge-label-color-default:#f8f8f8}.react-flow__background{background-color:var(--xy-background-color,var(--xy-background-color-props,var(--xy-background-color-default)));pointer-events:none;z-index:-1}.react-flow__container{height:100%;left:0;position:absolute;top:0;width:100%}.react-flow__pane{z-index:1}.react-flow__pane.draggable{cursor:grab}.react-flow__pane.dragging{cursor:grabbing}.react-flow__pane.selection{cursor:pointer}.react-flow__viewport{pointer-events:none;transform-origin:0 0;z-index:2}.react-flow__renderer{z-index:4}.react-flow__selection{z-index:6}.react-flow__nodesselection-rect:focus,.react-flow__nodesselection-rect:focus-visible{outline:none}.react-flow__edge-path{stroke:var(--xy-edge-stroke,var(--xy-edge-stroke-default));stroke-width:var(--xy-edge-stroke-width,var(--xy-edge-stroke-width-default));fill:none}.react-flow__connection-path{stroke:var(--xy-connectionline-stroke,var(--xy-connectionline-stroke-default));stroke-width:var(--xy-connectionline-stroke-width,var(--xy-connectionline-stroke-width-default));fill:none}.react-flow .react-flow__edges{position:absolute}.react-flow .react-flow__edges svg{overflow:visible;pointer-events:none;position:absolute}.react-flow__edge{pointer-events:visibleStroke}.react-flow__edge.selectable{cursor:pointer}.react-flow__edge.animated path{stroke-dasharray:5;animation:dashdraw .5s linear infinite}.react-flow__edge.animated path.react-flow__edge-interaction{stroke-dasharray:none;animation:none}.react-flow__edge.inactive{pointer-events:none}.react-flow__edge.selected,.react-flow__edge:focus,.react-flow__edge:focus-visible{outline:none}.react-flow__edge.selectable:focus .react-flow__edge-path,.react-flow__edge.selectable:focus-visible .react-flow__edge-path,.react-flow__edge.selected .react-flow__edge-path{stroke:var(--xy-edge-stroke-selected,var(--xy-edge-stroke-selected-default))}.react-flow__edge-textwrapper{pointer-events:all}.react-flow__edge .react-flow__edge-text{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__connection{pointer-events:none}.react-flow__connection .animated{stroke-dasharray:5;animation:dashdraw .5s linear infinite}svg.react-flow__connectionline{overflow:visible;position:absolute;z-index:1001}.react-flow__nodes{pointer-events:none;transform-origin:0 0}.react-flow__node{box-sizing:border-box;cursor:default;pointer-events:all;position:absolute;transform-origin:0 0;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__node.selectable{cursor:pointer}.react-flow__node.draggable{cursor:grab;pointer-events:all}.react-flow__node.draggable.dragging{cursor:grabbing}.react-flow__nodesselection{pointer-events:none;transform-origin:left top;z-index:3}.react-flow__nodesselection-rect{cursor:grab;pointer-events:all;position:absolute}.react-flow__handle{background-color:var(--xy-handle-background-color,var(--xy-handle-background-color-default));border:1px solid var(--xy-handle-border-color,var(--xy-handle-border-color-default));border-radius:100%;height:6px;min-height:5px;min-width:5px;pointer-events:none;position:absolute;width:6px}.react-flow__handle.connectingfrom{pointer-events:all}.react-flow__handle.connectionindicator{cursor:crosshair;pointer-events:all}.react-flow__handle-bottom{bottom:0;left:50%;top:auto;transform:translate(-50%,50%)}.react-flow__handle-top{left:50%;top:0;transform:translate(-50%,-50%)}.react-flow__handle-left{left:0;top:50%;transform:translate(-50%,-50%)}.react-flow__handle-right{right:0;top:50%;transform:translate(50%,-50%)}.react-flow__edgeupdater{cursor:move;pointer-events:all}.react-flow__panel{margin:15px;position:absolute;z-index:5}.react-flow__panel.top{top:0}.react-flow__panel.bottom{bottom:0}.react-flow__panel.bottom.center,.react-flow__panel.top.center{left:50%;transform:translateX(-50%)}.react-flow__panel.left{left:0}.react-flow__panel.right{right:0}.react-flow__panel.left.center,.react-flow__panel.right.center{top:50%;transform:translateY(-50%)}.react-flow__attribution{background:var(--xy-attribution-background-color,var(--xy-attribution-background-color-default));font-size:10px;margin:0;padding:2px 3px}.react-flow__attribution a{color:#999;-webkit-text-decoration:none;text-decoration:none}@keyframes dashdraw{0%{stroke-dashoffset:10}}.react-flow__edgelabel-renderer{pointer-events:none}.react-flow__edgelabel-renderer,.react-flow__viewport-portal{height:100%;left:0;position:absolute;top:0;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:100%}.react-flow__minimap{background:var(--xy-minimap-background-color-props,var(--xy-minimap-background-color,var(--xy-minimap-background-color-default)))}.react-flow__minimap-svg{display:block}.react-flow__minimap-mask{fill:var(--xy-minimap-mask-background-color-props,var(--xy-minimap-mask-background-color,var(--xy-minimap-mask-background-color-default)));stroke:var(--xy-minimap-mask-stroke-color-props,var(--xy-minimap-mask-stroke-color,var(--xy-minimap-mask-stroke-color-default)));stroke-width:var(--xy-minimap-mask-stroke-width-props,var(--xy-minimap-mask-stroke-width,var(--xy-minimap-mask-stroke-width-default)))}.react-flow__minimap-node{fill:var(--xy-minimap-node-background-color-props,var(--xy-minimap-node-background-color,var(--xy-minimap-node-background-color-default)));stroke:var(--xy-minimap-node-stroke-color-props,var(--xy-minimap-node-stroke-color,var(--xy-minimap-node-stroke-color-default)));stroke-width:var(--xy-minimap-node-stroke-width-props,var(--xy-minimap-node-stroke-width,var(--xy-minimap-node-stroke-width-default)))}.react-flow__background-pattern.dots{fill:var(--xy-background-pattern-color-props,var(--xy-background-pattern-color,var(--xy-background-pattern-dots-color-default)))}.react-flow__background-pattern.lines{stroke:var(--xy-background-pattern-color-props,var(--xy-background-pattern-color,var(--xy-background-pattern-lines-color-default)))}.react-flow__background-pattern.cross{stroke:var(--xy-background-pattern-color-props,var(--xy-background-pattern-color,var(--xy-background-pattern-cross-color-default)))}.react-flow__controls{box-shadow:var(--xy-controls-box-shadow,var(--xy-controls-box-shadow-default));display:flex;flex-direction:column}.react-flow__controls.horizontal{flex-direction:row}.react-flow__controls-button{align-items:center;background:var(--xy-controls-button-background-color,var(--xy-controls-button-background-color-default));border:none;border-bottom:1px solid var(--xy-controls-button-border-color-props,var(--xy-controls-button-border-color,var(--xy-controls-button-border-color-default)));color:var(--xy-controls-button-color-props,var(--xy-controls-button-color,var(--xy-controls-button-color-default)));cursor:pointer;display:flex;height:26px;justify-content:center;padding:4px;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:26px}.react-flow__controls-button svg{max-height:12px;max-width:12px;width:100%;fill:currentColor}.react-flow__edge.updating .react-flow__edge-path{stroke:#777}.react-flow__edge-text{font-size:10px}.react-flow__node.selectable:focus,.react-flow__node.selectable:focus-visible{outline:none}.react-flow__node-default,.react-flow__node-group,.react-flow__node-input,.react-flow__node-output{background-color:var(--xy-node-background-color,var(--xy-node-background-color-default));border:var(--xy-node-border,var(--xy-node-border-default));border-radius:var(--xy-node-border-radius,var(--xy-node-border-radius-default));color:var(--xy-node-color,var(--xy-node-color-default));font-size:12px;padding:10px;text-align:center;width:150px}.react-flow__node-default.selectable:hover,.react-flow__node-group.selectable:hover,.react-flow__node-input.selectable:hover,.react-flow__node-output.selectable:hover{box-shadow:var(--xy-node-boxshadow-hover,var(--xy-node-boxshadow-hover-default))}.react-flow__node-default.selectable.selected,.react-flow__node-default.selectable:focus,.react-flow__node-default.selectable:focus-visible,.react-flow__node-group.selectable.selected,.react-flow__node-group.selectable:focus,.react-flow__node-group.selectable:focus-visible,.react-flow__node-input.selectable.selected,.react-flow__node-input.selectable:focus,.react-flow__node-input.selectable:focus-visible,.react-flow__node-output.selectable.selected,.react-flow__node-output.selectable:focus,.react-flow__node-output.selectable:focus-visible{box-shadow:var(--xy-node-boxshadow-selected,var(--xy-node-boxshadow-selected-default))}.react-flow__node-group{background-color:var(--xy-node-group-background-color,var(--xy-node-group-background-color-default))}.react-flow__nodesselection-rect,.react-flow__selection{background:var(--xy-selection-background-color,var(--xy-selection-background-color-default));border:var(--xy-selection-border,var(--xy-selection-border-default))}.react-flow__nodesselection-rect:focus,.react-flow__nodesselection-rect:focus-visible,.react-flow__selection:focus,.react-flow__selection:focus-visible{outline:none}.react-flow__controls-button:hover{background:var(--xy-controls-button-background-color-hover-props,var(--xy-controls-button-background-color-hover,var(--xy-controls-button-background-color-hover-default)));color:var(--xy-controls-button-color-hover-props,var(--xy-controls-button-color-hover,var(--xy-controls-button-color-hover-default)))}.react-flow__controls-button:disabled{pointer-events:none}.react-flow__controls-button:disabled svg{fill-opacity:.4}.react-flow__controls-button:last-child{border-bottom:none}.react-flow__controls.horizontal .react-flow__controls-button{border-bottom:none;border-right:1px solid var(--xy-controls-button-border-color-props,var(--xy-controls-button-border-color,var(--xy-controls-button-border-color-default)))}.react-flow__controls.horizontal .react-flow__controls-button:last-child{border-right:none}.react-flow__resize-control{position:absolute}.react-flow__resize-control.left,.react-flow__resize-control.right{cursor:ew-resize}.react-flow__resize-control.bottom,.react-flow__resize-control.top{cursor:ns-resize}.react-flow__resize-control.bottom.right,.react-flow__resize-control.top.left{cursor:nwse-resize}.react-flow__resize-control.bottom.left,.react-flow__resize-control.top.right{cursor:nesw-resize}.react-flow__resize-control.handle{background-color:var(--xy-resize-background-color,var(--xy-resize-background-color-default));border:1px solid #fff;border-radius:1px;height:4px;transform:translate(-50%,-50%);width:4px}.react-flow__resize-control.handle.left{left:0;top:50%}.react-flow__resize-control.handle.right{left:100%;top:50%}.react-flow__resize-control.handle.top{left:50%;top:0}.react-flow__resize-control.handle.bottom{left:50%;top:100%}.react-flow__resize-control.handle.bottom.left,.react-flow__resize-control.handle.top.left{left:0}.react-flow__resize-control.handle.bottom.right,.react-flow__resize-control.handle.top.right{left:100%}.react-flow__resize-control.line{border-color:var(--xy-resize-background-color,var(--xy-resize-background-color-default));border-style:solid;border-width:0}.react-flow__resize-control.line.left,.react-flow__resize-control.line.right{height:100%;top:0;transform:translate(-50%);width:1px}.react-flow__resize-control.line.left{border-left-width:1px;left:0}.react-flow__resize-control.line.right{border-right-width:1px;left:100%}.react-flow__resize-control.line.bottom,.react-flow__resize-control.line.top{height:1px;left:0;transform:translateY(-50%);width:100%}.react-flow__resize-control.line.top{border-top-width:1px;top:0}.react-flow__resize-control.line.bottom{border-bottom-width:1px;top:100%}.react-flow__edge-textbg{fill:var(--xy-edge-label-background-color,var(--xy-edge-label-background-color-default))}.react-flow__edge-text{fill:var(--xy-edge-label-color,var(--xy-edge-label-color-default))}",""]),module.exports=exports},"../../node_modules/.pnpm/@xyflow+react@12.6.0_@types+react@17.0.52_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@xyflow/react/dist/style.css":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";var _style_loader_2_0_0_webpack_5_88_2_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("../../node_modules/.pnpm/style-loader@2.0.0_webpack@5.88.2/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"),_style_loader_2_0_0_webpack_5_88_2_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_style_loader_2_0_0_webpack_5_88_2_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__),_css_loader_3_6_0_webpack_5_88_2_node_modules_css_loader_dist_cjs_js_postcss_loader_4_3_0_postcss_8_5_6_webpack_5_88_2_node_modules_postcss_loader_dist_cjs_js_sass_loader_10_3_1_sass_1_56_0_webpack_5_88_2_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_2_use_3_style_css__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("../../node_modules/.pnpm/css-loader@3.6.0_webpack@5.88.2/node_modules/css-loader/dist/cjs.js!../../node_modules/.pnpm/postcss-loader@4.3.0_postcss@8.5.6_webpack@5.88.2/node_modules/postcss-loader/dist/cjs.js!../../node_modules/.pnpm/sass-loader@10.3.1_sass@1.56.0_webpack@5.88.2/node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[2].use[3]!../../node_modules/.pnpm/@xyflow+react@12.6.0_@types+react@17.0.52_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@xyflow/react/dist/style.css"),_css_loader_3_6_0_webpack_5_88_2_node_modules_css_loader_dist_cjs_js_postcss_loader_4_3_0_postcss_8_5_6_webpack_5_88_2_node_modules_postcss_loader_dist_cjs_js_sass_loader_10_3_1_sass_1_56_0_webpack_5_88_2_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_2_use_3_style_css__WEBPACK_IMPORTED_MODULE_1___default=__webpack_require__.n(_css_loader_3_6_0_webpack_5_88_2_node_modules_css_loader_dist_cjs_js_postcss_loader_4_3_0_postcss_8_5_6_webpack_5_88_2_node_modules_postcss_loader_dist_cjs_js_sass_loader_10_3_1_sass_1_56_0_webpack_5_88_2_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_2_use_3_style_css__WEBPACK_IMPORTED_MODULE_1__),options={};options.insert="head",options.singleton=!1,_style_loader_2_0_0_webpack_5_88_2_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_3_6_0_webpack_5_88_2_node_modules_css_loader_dist_cjs_js_postcss_loader_4_3_0_postcss_8_5_6_webpack_5_88_2_node_modules_postcss_loader_dist_cjs_js_sass_loader_10_3_1_sass_1_56_0_webpack_5_88_2_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_2_use_3_style_css__WEBPACK_IMPORTED_MODULE_1___default(),options),_css_loader_3_6_0_webpack_5_88_2_node_modules_css_loader_dist_cjs_js_postcss_loader_4_3_0_postcss_8_5_6_webpack_5_88_2_node_modules_postcss_loader_dist_cjs_js_sass_loader_10_3_1_sass_1_56_0_webpack_5_88_2_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_2_use_3_style_css__WEBPACK_IMPORTED_MODULE_1___default().locals},"../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var React=__webpack_require__("../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js");function is(x,y){return x===y&&(0!==x||1/x==1/y)||x!=x&&y!=y}var objectIs="function"==typeof Object.is?Object.is:is,useState=React.useState,useEffect=React.useEffect,useLayoutEffect=React.useLayoutEffect,useDebugValue=React.useDebugValue;function useSyncExternalStore$2(subscribe,getSnapshot){var value=getSnapshot(),_useState=useState({inst:{value:value,getSnapshot:getSnapshot}}),inst=_useState[0].inst,forceUpdate=_useState[1];return useLayoutEffect(function(){inst.value=value,inst.getSnapshot=getSnapshot,checkIfSnapshotChanged(inst)&&forceUpdate({inst:inst})},[subscribe,value,getSnapshot]),useEffect(function(){return checkIfSnapshotChanged(inst)&&forceUpdate({inst:inst}),subscribe(function(){checkIfSnapshotChanged(inst)&&forceUpdate({inst:inst})})},[subscribe]),useDebugValue(value),value}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot;inst=inst.value;try{var nextValue=latestGetSnapshot();return!objectIs(inst,nextValue)}catch(error){return!0}}function useSyncExternalStore$1(subscribe,getSnapshot){return getSnapshot()}var shim="undefined"==typeof window||void 0===window.document||void 0===window.document.createElement?useSyncExternalStore$1:useSyncExternalStore$2;exports.useSyncExternalStore=void 0!==React.useSyncExternalStore?React.useSyncExternalStore:shim},"../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var React=__webpack_require__("../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js"),shim=__webpack_require__("../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js");function is(x,y){return x===y&&(0!==x||1/x==1/y)||x!=x&&y!=y}var objectIs="function"==typeof Object.is?Object.is:is,useSyncExternalStore=shim.useSyncExternalStore,useRef=React.useRef,useEffect=React.useEffect,useMemo=React.useMemo,useDebugValue=React.useDebugValue;exports.useSyncExternalStoreWithSelector=function(subscribe,getSnapshot,getServerSnapshot,selector,isEqual){var instRef=useRef(null);if(null===instRef.current){var inst={hasValue:!1,value:null};instRef.current=inst}else inst=instRef.current;var value=useSyncExternalStore(subscribe,(instRef=useMemo(function(){function memoizedSelector(nextSnapshot){if(!hasMemo){if(hasMemo=!0,memoizedSnapshot=nextSnapshot,nextSnapshot=selector(nextSnapshot),void 0!==isEqual&&inst.hasValue){var currentSelection=inst.value;if(isEqual(currentSelection,nextSnapshot))return memoizedSelection=currentSelection}return memoizedSelection=nextSnapshot}if(currentSelection=memoizedSelection,objectIs(memoizedSnapshot,nextSnapshot))return currentSelection;var nextSelection=selector(nextSnapshot);return void 0!==isEqual&&isEqual(currentSelection,nextSelection)?(memoizedSnapshot=nextSnapshot,currentSelection):(memoizedSnapshot=nextSnapshot,memoizedSelection=nextSelection)}var memoizedSnapshot,memoizedSelection,hasMemo=!1,maybeGetServerSnapshot=void 0===getServerSnapshot?null:getServerSnapshot;return[function(){return memoizedSelector(getSnapshot())},null===maybeGetServerSnapshot?void 0:function(){return memoizedSelector(maybeGetServerSnapshot())}]},[getSnapshot,getServerSnapshot,selector,isEqual]))[0],instRef[1]);return useEffect(function(){inst.hasValue=!0,inst.value=value},[value]),useDebugValue(value),value}},"../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=__webpack_require__("../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js")},"../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=__webpack_require__("../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js")}}]);
//# sourceMappingURL=39796.8e04e8a1.iframe.bundle.js.map