{"version":3,"file":"70770.19f5b498.iframe.bundle.js","mappings":";;;;;AAwGA;;AAEA;;;;;;;;AAqBA","sources":["webpack://@posthog/storybook/../../frontend/src/scenes/heatmaps/heatmapsBrowserLogic.ts"],"sourcesContent":["import { actions, afterMount, connect, kea, listeners, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl, router, urlToAction } from 'kea-router'\nimport posthog from 'posthog-js'\nimport { RefObject } from 'react'\n\nimport api from 'lib/api'\nimport {\n    AuthorizedUrlListType,\n    authorizedUrlListLogic,\n    defaultAuthorizedUrlProperties,\n} from 'lib/components/AuthorizedUrlList/authorizedUrlListLogic'\nimport {\n    DEFAULT_HEATMAP_FILTERS,\n    PostHogAppToolbarEvent,\n    calculateViewportRange,\n} from 'lib/components/IframedToolbarBrowser/utils'\nimport { heatmapDataLogic } from 'lib/components/heatmaps/heatmapDataLogic'\nimport { CommonFilters, HeatmapFilters, HeatmapFixedPositionMode } from 'lib/components/heatmaps/types'\nimport { LemonBannerProps } from 'lib/lemon-ui/LemonBanner'\nimport { objectsEqual } from 'lib/utils'\nimport { removeReplayIframeDataFromLocalStorage } from 'scenes/session-recordings/player/sessionRecordingPlayerLogic'\n\nimport { hogql } from '~/queries/utils'\n\nimport type { heatmapsBrowserLogicType } from './heatmapsBrowserLogicType'\n\nexport type HeatmapsBrowserLogicProps = {\n    iframeRef: RefObject<HTMLIFrameElement | null>\n}\n\nexport interface IFrameBanner {\n    level: LemonBannerProps['type']\n    message: string | JSX.Element\n}\n\nexport interface ReplayIframeData {\n    html: string\n    width: number // NB this should be meta width\n    height: number // NB this should be meta height\n    startDateTime: string | undefined\n    url: string | undefined\n}\n\n// team id is always available on window\nconst teamId = window.POSTHOG_APP_CONTEXT?.current_team?.id\n\nexport const heatmapsBrowserLogic = kea<heatmapsBrowserLogicType>([\n    path(['scenes', 'heatmaps', 'heatmapsBrowserLogic']),\n    props({} as HeatmapsBrowserLogicProps),\n\n    connect(() => ({\n        values: [\n            authorizedUrlListLogic({\n                ...defaultAuthorizedUrlProperties,\n                type: AuthorizedUrlListType.TOOLBAR_URLS,\n            }),\n            ['urlsKeyed', 'checkUrlIsAuthorized'],\n            heatmapDataLogic({ context: 'in-app' }),\n            ['heatmapEmpty'],\n        ],\n        actions: [heatmapDataLogic({ context: 'in-app' }), ['loadHeatmap', 'setHref', 'setHrefMatchType']],\n    })),\n\n    actions({\n        setBrowserSearch: (searchTerm: string) => ({ searchTerm }),\n        setBrowserUrl: (url: string | null) => ({ url }),\n        onIframeLoad: true,\n        sendToolbarMessage: (type: PostHogAppToolbarEvent, payload?: Record<string, any>) => ({\n            type,\n            payload,\n        }),\n        loadTopUrls: true,\n        maybeLoadTopUrls: true,\n        loadBrowserSearchResults: true,\n        // TRICKY: duplicated with the heatmapLogic so that we can share the settings picker\n        patchHeatmapFilters: (filters: Partial<HeatmapFilters>) => ({ filters }),\n        setHeatmapColorPalette: (Palette: string | null) => ({ Palette }),\n        setHeatmapFixedPositionMode: (mode: HeatmapFixedPositionMode) => ({ mode }),\n        setCommonFilters: (filters: CommonFilters) => ({ filters }),\n        // TRICKY: duplication ends\n        setIframeWidth: (width: number | null) => ({ width }),\n        toggleFilterPanelCollapsed: true,\n        setIframeBanner: (banner: IFrameBanner | null) => ({ banner }),\n        startTrackingLoading: true,\n        stopTrackingLoading: true,\n        setReplayIframeData: (replayIframeData: ReplayIframeData | null) => ({ replayIframeData }),\n        setReplayIframeDataURL: (url: string | null) => ({ url }),\n    }),\n\n    loaders(({ values }) => ({\n        browserSearchResults: [\n            null as string[] | null,\n            {\n                loadBrowserSearchResults: async () => {\n                    if (!values.browserSearchTerm) {\n                        return []\n                    }\n\n                    const query = hogql`\n                        SELECT distinct properties.$current_url AS urls\n                        FROM events\n                        WHERE timestamp >= now() - INTERVAL 7 DAY\n                        AND timestamp <= now()\n                        AND properties.$current_url like '%${hogql.identifier(values.browserSearchTerm)}%'\n                        ORDER BY timestamp DESC\n                        LIMIT 100`\n\n                    const res = await api.queryHogQL(query)\n\n                    return res.results?.map((x) => x[0]) as string[]\n                },\n            },\n        ],\n\n        topUrls: [\n            null as { url: string; count: number }[] | null,\n            {\n                loadTopUrls: async () => {\n                    const query = hogql`\n                        SELECT properties.$current_url AS url, count() as count\n                        FROM events\n                        WHERE timestamp >= now() - INTERVAL 7 DAY\n                        AND event in ('$pageview', '$autocapture')\n                        AND timestamp <= now()\n                        GROUP BY properties.$current_url\n                        ORDER BY count DESC\n                        LIMIT 10`\n\n                    const res = await api.queryHogQL(query)\n\n                    return res.results?.map((x) => ({ url: x[0], count: x[1] })) as { url: string; count: number }[]\n                },\n            },\n        ],\n    })),\n\n    reducers({\n        hasValidReplayIframeData: [\n            false,\n            {\n                setReplayIframeData: (_, { replayIframeData }) =>\n                    !!replayIframeData?.url?.trim().length && !!replayIframeData?.html.trim().length,\n            },\n        ],\n        replayIframeData: [\n            null as ReplayIframeData | null,\n            {\n                setReplayIframeData: (_, { replayIframeData }) => replayIframeData,\n                setReplayIframeDataURL: (state, { url }) => {\n                    if (state === null) {\n                        return null\n                    }\n                    return { ...state, url } as ReplayIframeData\n                },\n            },\n        ],\n        filterPanelCollapsed: [\n            false as boolean,\n            { persist: true },\n            {\n                toggleFilterPanelCollapsed: (state) => !state,\n            },\n        ],\n        // they're called common filters in the toolbar because they're shared between heatmaps and clickmaps\n        // the name is continued here since they're passed down into the embedded iframe\n        commonFilters: [\n            { date_from: '-7d' } as CommonFilters,\n            {\n                setCommonFilters: (_, { filters }) => filters,\n            },\n        ],\n        heatmapColorPalette: [\n            'default' as string | null,\n            {\n                setHeatmapColorPalette: (_, { Palette }) => Palette,\n            },\n        ],\n        heatmapFilters: [\n            DEFAULT_HEATMAP_FILTERS,\n            {\n                patchHeatmapFilters: (state, { filters }) => ({ ...state, ...filters }),\n            },\n        ],\n        heatmapFixedPositionMode: [\n            'fixed' as HeatmapFixedPositionMode,\n            {\n                setHeatmapFixedPositionMode: (_, { mode }) => mode,\n            },\n        ],\n        iframeWidth: [\n            null as number | null,\n            {\n                setIframeWidth: (_, { width }) => width,\n            },\n        ],\n        browserSearchTerm: [\n            '',\n            {\n                setBrowserSearch: (_, { searchTerm }) => searchTerm,\n            },\n        ],\n        browserUrl: [\n            null as string | null,\n            { persist: true, prefix: `${teamId}__` },\n            {\n                setBrowserUrl: (_, { url }) => url,\n            },\n        ],\n        loading: [\n            false as boolean,\n            {\n                setBrowserUrl: (state, { url }) => (url?.trim().length ? true : state),\n                setIframeBanner: (state, { banner }) => (banner?.level == 'error' ? false : state),\n                startTrackingLoading: () => true,\n                stopTrackingLoading: () => false,\n            },\n        ],\n        iframeBanner: [\n            null as IFrameBanner | null,\n            {\n                setIframeBanner: (_, { banner }) => banner,\n            },\n        ],\n        widthOverride: [\n            null as number | null,\n            {\n                setIframeWidth: (_, { width }) => width,\n            },\n        ],\n    }),\n\n    selectors({\n        browserUrlSearchOptions: [\n            (s) => [s.browserSearchResults, s.topUrls, s.browserSearchTerm],\n            (browserSearchResults, topUrls, browserSearchTerm) => {\n                return browserSearchTerm ? browserSearchResults : (topUrls?.map((x) => x.url) ?? [])\n            },\n        ],\n\n        isBrowserUrlAuthorized: [\n            (s) => [s.browserUrl, s.checkUrlIsAuthorized],\n            (browserUrl, checkUrlIsAuthorized) => {\n                if (!browserUrl) {\n                    return false\n                }\n                return checkUrlIsAuthorized(browserUrl)\n            },\n        ],\n        isBrowserUrlValid: [\n            (s) => [s.browserUrl],\n            (browserUrl) => {\n                if (!browserUrl) {\n                    // an empty browserUrl is valid\n                    // since we just won't do anything with it\n                    return true\n                }\n\n                try {\n                    // must be something that can be parsed as a URL\n                    new URL(browserUrl)\n                    // and must be a valid URL that our redirects can cope with\n                    // this is a very loose check, but `http:/blaj` is not valid for PostHog\n                    // but survives new URL(http:/blaj)\n                    return browserUrl.includes('://')\n                } catch {\n                    return false\n                }\n            },\n        ],\n\n        viewportRange: [\n            (s) => [s.heatmapFilters, s.iframeWidth],\n            (heatmapFilters, iframeWidth) => {\n                return iframeWidth ? calculateViewportRange(heatmapFilters, iframeWidth) : { min: 0, max: 1800 }\n            },\n        ],\n\n        noPageviews: [\n            (s) => [s.topUrlsLoading, s.topUrls],\n            (topUrlsLoading, topUrls) => !topUrlsLoading && (!topUrls || topUrls.length === 0),\n        ],\n    }),\n\n    listeners(({ actions, cache, props, values }) => ({\n        setReplayIframeData: ({ replayIframeData }) => {\n            if (replayIframeData && replayIframeData.url) {\n                actions.setHref(replayIframeData.url)\n                // TODO we need to be able to handle regex values\n                actions.setHrefMatchType('exact')\n            } else {\n                removeReplayIframeDataFromLocalStorage()\n            }\n        },\n\n        setBrowserSearch: async (_, breakpoint) => {\n            await breakpoint(200)\n            actions.loadBrowserSearchResults()\n        },\n\n        sendToolbarMessage: ({ type, payload }) => {\n            props.iframeRef?.current?.contentWindow?.postMessage(\n                {\n                    type,\n                    payload,\n                },\n                '*'\n            )\n        },\n\n        onIframeLoad: () => {\n            // it should be impossible to load an iframe without a browserUrl\n            // right?!\n            actions.setHref(values.browserUrl ?? '')\n            actions.loadHeatmap()\n            posthog.capture('in-app heatmap iframe loaded', {\n                inapp_heatmap_page_url_visited: values.browserUrl,\n                inapp_heatmap_filters: values.heatmapFilters,\n                inapp_heatmap_color_palette: values.heatmapColorPalette,\n                inapp_heatmap_fixed_position_mode: values.heatmapFixedPositionMode,\n            })\n        },\n\n        maybeLoadTopUrls: () => {\n            if (!values.topUrls && !values.topUrlsLoading) {\n                actions.loadTopUrls()\n            }\n        },\n\n        setReplayIframeDataURL: async ({ url }, breakpoint) => {\n            await breakpoint(150)\n            if (url?.trim().length) {\n                actions.setHref(url)\n                // TODO we need to be able to handle regex values\n                actions.setHrefMatchType('exact')\n            }\n        },\n\n        setBrowserUrl: ({ url }) => {\n            actions.maybeLoadTopUrls()\n            if (url?.trim().length) {\n                actions.startTrackingLoading()\n            }\n        },\n\n        startTrackingLoading: () => {\n            actions.setIframeBanner(null)\n\n            clearTimeout(cache.errorTimeout)\n            cache.errorTimeout = setTimeout(() => {\n                actions.setIframeBanner({ level: 'error', message: 'The heatmap failed to load (or is very slow).' })\n            }, 7500)\n        },\n\n        stopTrackingLoading: () => {\n            actions.setIframeBanner(null)\n\n            clearTimeout(cache.errorTimeout)\n            clearTimeout(cache.warnTimeout)\n        },\n    })),\n\n    afterMount(({ actions, values }) => {\n        if (values.browserUrl?.trim().length) {\n            actions.startTrackingLoading()\n        } else {\n            actions.maybeLoadTopUrls()\n        }\n    }),\n\n    urlToAction(({ actions, values }) => ({\n        '/heatmaps': (_, searchParams) => {\n            if (searchParams.pageURL && searchParams.pageURL !== values.browserUrl) {\n                actions.setBrowserUrl(searchParams.pageURL)\n            }\n            if (searchParams.heatmapFilters && !objectsEqual(searchParams.heatmapFilters, values.heatmapFilters)) {\n                actions.patchHeatmapFilters(searchParams.heatmapFilters)\n            }\n            if (searchParams.heatmapPalette && searchParams.heatmapPalette !== values.heatmapColorPalette) {\n                actions.setHeatmapColorPalette(searchParams.heatmapPalette)\n            }\n            if (\n                searchParams.heatmapFixedPositionMode &&\n                searchParams.heatmapFixedPositionMode !== values.heatmapFixedPositionMode\n            ) {\n                actions.setHeatmapFixedPositionMode(searchParams.heatmapFixedPositionMode as HeatmapFixedPositionMode)\n            }\n            if (searchParams.commonFilters && !objectsEqual(searchParams.commonFilters, values.commonFilters)) {\n                actions.setCommonFilters(searchParams.commonFilters as CommonFilters)\n            }\n            if (searchParams.iframeStorage) {\n                const replayFrameData = JSON.parse(\n                    localStorage.getItem(searchParams.iframeStorage) || '{}'\n                ) as ReplayIframeData\n                actions.setReplayIframeData(replayFrameData)\n            }\n        },\n    })),\n\n    actionToUrl(({ values }) => ({\n        setBrowserUrl: ({ url }) => {\n            const searchParams = { ...router.values.searchParams, pageURL: url }\n            if (!url || url.trim() === '') {\n                delete searchParams.pageURL\n            }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n        patchHeatmapFilters: () => {\n            const searchParams = { ...router.values.searchParams, heatmapFilters: values.heatmapFilters }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n        setHeatmapColorPalette: ({ Palette }) => {\n            const searchParams = { ...router.values.searchParams, heatmapPalette: Palette }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n        setHeatmapFixedPositionMode: ({ mode }) => {\n            const searchParams = { ...router.values.searchParams, heatmapFixedPositionMode: mode }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n        setCommonFilters: ({ filters }) => {\n            const searchParams = { ...router.values.searchParams, commonFilters: filters }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n    })),\n])\n"],"names":[],"sourceRoot":""}