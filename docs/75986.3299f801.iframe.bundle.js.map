{"version":3,"file":"75986.3299f801.iframe.bundle.js","mappings":";;;;;;;;;AA6CA","sources":["webpack://posthog/./frontend/src/scenes/session-recordings/mobile-replay/androidRecordingPromptBannerLogic.ts"],"sourcesContent":["import { afterMount, kea, key, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { subscriptions } from 'kea-subscriptions'\nimport api from 'lib/api'\nimport posthog from 'posthog-js'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { hogql } from '~/queries/utils'\n\nimport type { androidRecordingPromptBannerLogicType } from './androidRecordingPromptBannerLogicType'\n\nexport interface AndroidRecordingPromptBannerLogicProps {\n    context: 'home' | 'events' | 'replay'\n}\n\nexport type AndroidEventCount = {\n    version: string\n    count?: number\n}\n\nexport const androidRecordingPromptBannerLogic = kea<androidRecordingPromptBannerLogicType>([\n    path(['scenes', 'session-recordings', 'SessionRecordings']),\n    key((props) => props.context),\n    props({} as AndroidRecordingPromptBannerLogicProps),\n    loaders(({ values }) => ({\n        androidVersions: [\n            [] as AndroidEventCount[],\n            {\n                loadAndroidLibVersions: async () => {\n                    if (values.androidVersions && values.androidVersions.length > 0) {\n                        // if we know they ever had android events, don't check again\n                        return values.androidVersions\n                    }\n\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$lib_version AS lib_version,\n                                       max(timestamp)          AS latest_timestamp,\n                                       count(lib_version) as count\n                                FROM events\n                                WHERE timestamp >= now() - INTERVAL 30 DAY\n                                  AND timestamp <= now()\n                                  AND properties.$lib = 'posthog-android'\n                                GROUP BY lib_version\n                                ORDER BY latest_timestamp DESC\n                                    limit 10`,\n                    }\n\n                    const res = await api.query(query)\n\n                    return (\n                        res.results?.map((x) => ({\n                            version: x[0],\n                            count: x[2],\n                        })) ?? []\n                    )\n                },\n            },\n        ],\n    })),\n    reducers({\n        androidVersions: [\n            // as a reducer only so we can persist it\n            [] as AndroidEventCount[],\n            { persist: true },\n            {\n                loadAndroidLibVersionsSuccess: (_, { androidVersions }) => {\n                    return androidVersions ?? []\n                },\n            },\n        ],\n    }),\n\n    selectors({\n        shouldPromptUser: [\n            (s) => [s.androidVersions],\n            (androidVersions) => {\n                return (androidVersions?.length || 0) > 0\n            },\n        ],\n    }),\n\n    subscriptions(({ values, props }) => ({\n        shouldPromptUser: (value, oldvalue) => {\n            // not a falsy check since we don't care when oldvalue is undefined\n            // we don't need multiple copies of this event so try to only emit it when `shouldPromptUser` changes to true\n            if (value === true && oldvalue === false) {\n                posthog.capture('visitor has android events', {\n                    androidVersions: values.androidVersions,\n                    scene: props.context,\n                })\n            }\n        },\n    })),\n\n    afterMount(({ actions }) => {\n        actions.loadAndroidLibVersions()\n    }),\n])\n"],"names":[],"sourceRoot":""}