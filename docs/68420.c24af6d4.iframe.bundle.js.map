{"version":3,"file":"68420.c24af6d4.iframe.bundle.js","mappings":";;;AAmEA;;;;AAIA","sources":["webpack://@posthog/storybook/../../products/messaging/frontend/Campaigns/campaignMetricsLogic.ts"],"sourcesContent":["import { actions, kea, key, listeners, path, props, reducers } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { MetricsFilters } from 'scenes/hog-functions/metrics/hogFunctionMetricsLogic'\n\nimport { hogql } from '~/queries/utils'\n\nimport type { campaignMetricsLogicType } from './campaignMetricsLogicType'\n\nexport type CampaignMetricsLogicProps = {\n    id: string\n}\n\nexport const ALL_METRIC_TYPES = [\n    { label: 'Succeeded', value: 'succeeded' },\n    { label: 'Failed', value: 'failed' },\n    { label: 'Filtered', value: 'filtered' },\n    { label: 'Disabled temporarily', value: 'disabled_temporarily' },\n    { label: 'Disabled permanently', value: 'disabled_permanently' },\n    { label: 'Masked', value: 'masked' },\n    { label: 'Filtering failed', value: 'filtering_failed' },\n    { label: 'Inputs failed', value: 'inputs_failed' },\n    { label: 'Fetch', value: 'fetch' },\n]\n\nconst DEFAULT_FILTERS: MetricsFilters = {\n    before: undefined,\n    after: '-7d',\n    interval: 'day',\n    name: ALL_METRIC_TYPES.filter(({ value }) => value !== 'filtered')\n        .map(({ value }) => value)\n        .join(','),\n}\n\nexport type CampaignMetricsDetails = {\n    name: string\n    labels: string[]\n    values: number[]\n    total: number\n}\n\nexport const campaignMetricsLogic = kea<campaignMetricsLogicType>([\n    props({} as CampaignMetricsLogicProps),\n    key(({ id }: CampaignMetricsLogicProps) => id),\n    path((id) => ['messaging', 'campaigns', 'campaignMetricsLogic', id]),\n    actions({\n        setFilters: (filters: Partial<MetricsFilters>) => ({ filters }),\n    }),\n    loaders(({ values, props }) => ({\n        metricsByKind: [\n            null as Record<string, CampaignMetricsDetails> | null,\n            {\n                loadMetricsByKind: async () => {\n                    const { before, after, interval } = values.filters\n\n                    const dateClause =\n                        interval === 'day'\n                            ? 'toStartOfDay(timestamp)'\n                            : interval === 'week'\n                            ? 'toStartOfWeek(timestamp)'\n                            : 'toStartOfHour(timestamp)'\n\n                    const query = hogql`SELECT ${hogql.raw(\n                        dateClause\n                    )} AS timestamp, metric_name, count() AS total_count\n                        FROM app_metrics\n                        WHERE app_source = 'hog_flow'\n                        AND app_source_id = ${props.id}\n                        AND timestamp >= {filters.dateRange.from}\n                        AND timestamp <= {filters.dateRange.to}\n                        GROUP BY timestamp, metric_name\n                        ORDER BY timestamp, metric_name`\n\n                    const response = await api.queryHogQL(query, {\n                        refresh: 'force_blocking',\n                        filtersOverride: {\n                            date_from: after ?? '-7d',\n                            date_to: before,\n                        },\n                    })\n\n                    const byKind: Record<string, CampaignMetricsDetails> = {}\n\n                    // TODO: The results don't include empty values in the sense that they aren't creating a full time series.\n                    for (const result of response.results) {\n                        const [time, name, count] = result\n\n                        if (!byKind[name]) {\n                            byKind[name] = {\n                                name,\n                                labels: [],\n                                values: [],\n                                total: 0,\n                            }\n                        }\n\n                        byKind[name].labels.push(time)\n                        byKind[name].values.push(count)\n                        byKind[name].total += count\n                    }\n\n                    return byKind\n                },\n            },\n        ],\n    })),\n    reducers({\n        filters: [\n            DEFAULT_FILTERS,\n            {\n                setFilters: (state, { filters }) => ({ ...state, ...filters }),\n            },\n        ],\n    }),\n    listeners(({ actions }) => ({\n        setFilters: async (_, breakpoint) => {\n            await breakpoint(100)\n            actions.loadMetricsByKind()\n        },\n    })),\n])\n"],"names":[],"sourceRoot":""}