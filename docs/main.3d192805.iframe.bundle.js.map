{"version":3,"file":"main.3d192805.iframe.bundle.js","mappings":";AAiQA;AACA;AA+GA;AAAA;;;;;;;AChVA;AC2MA;;;ACzKA;;AAEA;AACA;AAmBA;AACA;AACA;AACA;;AA4BA;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCA;;;;;AAKA;AACA;;;;;;;;;;;;;;;AAiCA;;;;;;;;;AC2CA;AA+JA;AACA;AACA;AACA;AACA;AACA;;;;AC/XA;;;;AAoBA;;AAEA;ACsaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChbA;AAAA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA;AASA;AAOA;AAiCA;AAaA;AAOA;AAiiBA;AAAA;AAAA;AAAA;AAAA;ACtgBA;AAAA;AC1FA;AAAA;ACwMA;AACA;AACA;AACA;AACA;;;;;;ACpPA;ACqRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAmDA;AACA;AACA;AACA;AACA;AACA;AACA;ACHA;AC/UA;AACA;AACA;ACgbA;AClYA;ACq1BA;AACA;AACA;ACpxBA;AC4sBA;AACA;AC2XA;AAAA;ACxsCA;AAqBA;AAMA;AASA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AAEA;AAEA;AACA;AAUA;AACA;AACA;AACA;AA6BA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAUA;AACA;AACA;AACA;AAuBA;AAMA;AASA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AAsBA;AAMA;AASA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AASA;AACA;AACA;AACA;AA2BA;AAMA;AASA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AASA;AACA;AACA;AACA;AA+BA;AAMA;AASA;AACA;AAEA;AACA;AAOA;AAKA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAoBA;AACA;AACA;AAGA;AACA;AA6BA;AACA;AACA;AAuBA;AACA;AACA;AAsBA;AACA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AASA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AA2BA;AACA;AACA;AAIA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AChKA;;AAEA;AC3BA;;;;;AC9BA;;;;;;;;;;;;;;AAcA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;ACkCA;AC9CA;AACA;AACA;AACA;AACA;;;ACIA;AACA;AACA;;AAEA;;;AAKA;AACA;;AAEA;;;;;;;AA0FA;AACA;AACA;AACA;AChEA;AAAA;ACzDA;AACA;AAQA;AAEA;AACA;AACA;ACuzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC50CA;AACA;;;;;AAKA;AACA;AACA;AC8FA;AAiBA;ACpCA;AC3EA;AAAA;AAAA;ACjCA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC+qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAsZA;AACA;AACA;ACv/BA;AACA;AACA;AACA;AAIA;AACA;AACA;AA0LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AACA;AACA;AAyIA;AAuBA;;;;;ACs3DA;AC33EA;AASA;AASA;AACA;AACA;;ACkHA;AACA;ACqjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5aA;AAAA;AAKA;AAAA;AAMA;AAAA;AAUA;AAAA;;;;;;;;;;;;;ACmQA;;;AAGA","sources":["webpack://@posthog/storybook/common/hogvm/typescript/src/stl/print.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/ReverseProxyChecker/reverseProxyCheckerLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/Alerts/views/EditAlertModal.tsx","webpack://@posthog/storybook/../../frontend/src/lib/components/AppMetrics/appMetricsLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/AuthorizedUrlList/authorizedUrlListLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/Metalytics/metalyticsLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/Sharing/SharingModal.tsx","webpack://@posthog/storybook/../../frontend/src/lib/components/Support/SupportForm.tsx","webpack://@posthog/storybook/../../frontend/src/lib/utils/exceptionUtils.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/Support/supportLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/lemon-ui/LemonRichContent/LemonRichContentEditor.tsx","webpack://@posthog/storybook/../../frontend/src/lib/lemon-ui/LemonTextArea/LemonTextAreaMarkdown.tsx","webpack://@posthog/storybook/../../frontend/src/lib/monaco/CodeEditor.tsx","webpack://@posthog/storybook/../../frontend/src/lib/utils/cssEscape.ts","webpack://@posthog/storybook/../../frontend/src/queries/examples.ts","webpack://@posthog/storybook/../../frontend/src/queries/nodes/DataTable/DataTable.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/insights/filters/RetentionCumulativeButton.tsx","webpack://@posthog/storybook/../../frontend/src/queries/nodes/InsightViz/EditorFilters.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/paths/renderPaths.ts","webpack://@posthog/storybook/../../frontend/src/lib/KeaDevTools.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/authentication/loginLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/billing/billingLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/experiments/experimentLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/feature-flags/FeatureFlagSnippets.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/notebooks/Notebook/SlashCommands.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/persons/personLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/notebooks/Nodes/NotebookNodeReplayTimestamp.tsx","webpack://@posthog/storybook/../../products/customer_analytics/frontend/queries/ZendeskTicketsQuery.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/persons/person-utils.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/player/controller/UserActivity.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/player/sessionEventsDataLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/player/share/playerShareLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/player/sidebar/PlayerSidebarSessionSummary.tsx","webpack://@posthog/storybook/../../ee/frontend/mobile-replay/transformer/transformers.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/playlist/sessionRecordingsListPropertiesLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/settings/environment/replayTriggersLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/settings/environment/ManagedReverseProxy.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/settings/organization/VerifiedDomains/ConfigureSAMLModal.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/surveys/SurveySQLHelper.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/surveys/surveyLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/surveys/utils.ts","webpack://@posthog/storybook/../../frontend/src/scenes/web-analytics/webAnalyticsLogic.tsx","webpack://@posthog/storybook/../../products/early_access_features/frontend/InstructionsModal.tsx","webpack://@posthog/storybook/../../products/error_tracking/frontend/queries.ts","webpack://@posthog/storybook/../../products/llm_analytics/frontend/llmAnalyticsLogic.tsx","webpack://@posthog/storybook/../../products/llm_analytics/frontend/llmAnalyticsPlaygroundLogic.ts","webpack://@posthog/storybook/../../products/llm_analytics/frontend/utils.ts"],"sourcesContent":["import { isHogAST, isHogCallable, isHogClosure, isHogDate, isHogDateTime, isHogError } from '../objects'\nimport { convertJSToHog } from '../utils'\n\nconst escapeCharsMap: Record<string, string> = {\n    '\\b': '\\\\b',\n    '\\f': '\\\\f',\n    '\\r': '\\\\r',\n    '\\n': '\\\\n',\n    '\\t': '\\\\t',\n    '\\0': '\\\\0',\n    '\\v': '\\\\v',\n    '\\\\': '\\\\\\\\',\n}\n\nconst singlequoteEscapeCharsMap: Record<string, string> = {\n    ...escapeCharsMap,\n    \"'\": \"\\\\'\",\n}\n\nconst backquoteEscapeCharsMap: Record<string, string> = {\n    ...escapeCharsMap,\n    '`': '\\\\`',\n}\n\nexport function escapeString(value: string): string {\n    return `'${value\n        .split('')\n        .map((c) => singlequoteEscapeCharsMap[c] || c)\n        .join('')}'`\n}\n\nexport function escapeIdentifier(identifier: string | number): string {\n    if (typeof identifier === 'number') {\n        return identifier.toString()\n    }\n    if (/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(identifier)) {\n        return identifier\n    }\n    return `\\`${identifier\n        .split('')\n        .map((c) => backquoteEscapeCharsMap[c] || c)\n        .join('')}\\``\n}\n\nexport function printHogValue(obj: any, marked: Set<any> | undefined = undefined): string {\n    if (!marked) {\n        marked = new Set()\n    }\n    if (typeof obj === 'object' && obj !== null && obj !== undefined) {\n        if (\n            marked.has(obj) &&\n            !isHogDateTime(obj) &&\n            !isHogDate(obj) &&\n            !isHogError(obj) &&\n            !isHogClosure(obj) &&\n            !isHogCallable(obj) &&\n            !isHogAST(obj)\n        ) {\n            return 'null'\n        }\n        marked.add(obj)\n        try {\n            if (Array.isArray(obj)) {\n                if ((obj as any).__isHogTuple) {\n                    if (obj.length < 2) {\n                        return `tuple(${obj.map((o) => printHogValue(o, marked)).join(', ')})`\n                    }\n                    return `(${obj.map((o) => printHogValue(o, marked)).join(', ')})`\n                }\n                return `[${obj.map((o) => printHogValue(o, marked)).join(', ')}]`\n            }\n            if (isHogDateTime(obj)) {\n                const millis = String(obj.dt)\n                return `DateTime(${millis}${millis.includes('.') ? '' : '.0'}, ${escapeString(obj.zone)})`\n            }\n            if (isHogDate(obj)) {\n                return `Date(${obj.year}, ${obj.month}, ${obj.day})`\n            }\n            if (isHogError(obj)) {\n                return `${String(obj.type)}(${escapeString(obj.message)}${\n                    obj.payload ? `, ${printHogValue(obj.payload, marked)}` : ''\n                })`\n            }\n            if (isHogClosure(obj)) {\n                return printHogValue(obj.callable, marked)\n            }\n            if (isHogCallable(obj)) {\n                return `fn<${escapeIdentifier(obj.name ?? 'lambda')}(${printHogValue(obj.argCount)})>`\n            }\n            if (isHogAST(obj)) {\n                return `sql(${new HogQLPrinter(false, marked).print(obj)})`\n            }\n            if (obj instanceof Map) {\n                return `{${Array.from(obj.entries())\n                    .map(([key, value]) => `${printHogValue(key, marked)}: ${printHogValue(value, marked)}`)\n                    .join(', ')}}`\n            }\n            return `{${Object.entries(obj)\n                .map(([key, value]) => `${printHogValue(key, marked)}: ${printHogValue(value, marked)}`)\n                .join(', ')}}`\n        } finally {\n            marked.delete(obj)\n        }\n    } else if (typeof obj === 'boolean') {\n        return obj ? 'true' : 'false'\n    } else if (obj === null || obj === undefined) {\n        return 'null'\n    } else if (typeof obj === 'string') {\n        return escapeString(obj)\n    }\n    return obj.toString()\n}\n\nexport function printHogStringOutput(obj: any): string {\n    if (typeof obj === 'string') {\n        return obj\n    }\n    return printHogValue(obj)\n}\n\ntype ASTNode = Map<string, any> | null\n\n// Note: this printer currently is experimental and used for debugging/printing SQL only.\n// When making queries via run(query), we send the AST nodes directly to the server.\nexport class HogQLPrinter {\n    private stack: ASTNode[] = []\n    private indentLevel: number = -1\n    private tabSize: number = 4\n    private pretty: boolean\n    private marked: Set<any>\n\n    constructor(pretty: boolean = false, marked: Set<any> | undefined = undefined) {\n        this.pretty = pretty\n        this.marked = marked || new Set()\n    }\n\n    private indent(extra: number = 0): string {\n        return ' '.repeat(this.tabSize * (this.indentLevel + extra))\n    }\n\n    public print(node: ASTNode): string {\n        return this.visit(node)\n    }\n\n    private visit(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        if (!(node instanceof Map)) {\n            if (isHogAST(node)) {\n                node = convertJSToHog(node)\n            } else {\n                return this.escapeValue(node)\n            }\n        }\n\n        this.stack.push(node)\n        this.indentLevel += 1\n\n        let result: string\n        const nodeType = node?.get('__hx_ast') as string | undefined\n\n        if (!nodeType) {\n            throw new Error('Node type is missing or undefined.')\n        }\n\n        switch (nodeType) {\n            case 'SelectQuery':\n                result = this.visitSelectQuery(node)\n                break\n            case 'SelectSetQuery':\n                result = this.visitSelectSetQuery(node)\n                break\n            case 'Call':\n                result = this.visitCall(node)\n                break\n            case 'Constant':\n                result = this.visitConstant(node)\n                break\n            case 'Field':\n                result = this.visitField(node)\n                break\n            case 'Alias':\n                result = this.visitAlias(node)\n                break\n            case 'And':\n                result = this.visitAnd(node)\n                break\n            case 'Or':\n                result = this.visitOr(node)\n                break\n            case 'Not':\n                result = this.visitNot(node)\n                break\n            case 'CompareOperation':\n                result = this.visitCompareOperation(node)\n                break\n            case 'Tuple':\n                result = this.visitTuple(node)\n                break\n            case 'Array':\n                result = this.visitArray(node)\n                break\n            case 'Lambda':\n                result = this.visitLambda(node)\n                break\n            case 'OrderExpr':\n                result = this.visitOrderExpr(node)\n                break\n            case 'ArithmeticOperation':\n                result = this.visitArithmeticOperation(node)\n                break\n            case 'Asterisk':\n                result = this.visitAsterisk(node)\n                break\n            case 'JoinExpr':\n                result = this.visitJoinExpr(node)\n                break\n            case 'JoinConstraint':\n                result = this.visitJoinConstraint(node)\n                break\n            case 'WindowExpr':\n                result = this.visitWindowExpr(node)\n                break\n            case 'WindowFunction':\n                result = this.visitWindowFunction(node)\n                break\n            case 'WindowFrameExpr':\n                result = this.visitWindowFrameExpr(node)\n                break\n            case 'SampleExpr':\n                result = this.visitSampleExpr(node)\n                break\n            case 'RatioExpr':\n                result = this.visitRatioExpr(node)\n                break\n            case 'HogQLXTag':\n                result = this.visitHogQLXTag(node)\n                break\n            default:\n                throw new Error(`Unknown AST node type: ${nodeType}`)\n        }\n\n        this.indentLevel -= 1\n        this.stack.pop()\n\n        return result\n    }\n\n    private visitSelectQuery(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const isTopLevelQuery = this.stack.length <= 1\n\n        const selectNodes = node.get('select') as ASTNode[] | undefined\n        const selectExpressions = selectNodes ? selectNodes.map((expr) => this.visit(expr)) : []\n        const space = this.pretty ? `\\n${this.indent(1)}` : ' '\n        const comma = this.pretty ? `,\\n${this.indent(1)}` : ', '\n\n        const clauses: string[] = [\n            `SELECT${node.get('distinct') ? ' DISTINCT' : ''}${space}${selectExpressions.join(comma)}`,\n        ]\n\n        if (node.has('select_from')) {\n            const fromExpr = this.visitJoinExpression(node.get('select_from'))\n            if (fromExpr) {\n                clauses.push(`FROM${space}${fromExpr}`)\n            }\n        }\n\n        if (node.has('prewhere')) {\n            const prewhereExpr = this.visit(node.get('prewhere'))\n            if (prewhereExpr) {\n                clauses.push(`PREWHERE${space}${prewhereExpr}`)\n            }\n        }\n\n        if (node.has('where')) {\n            const whereExpr = this.visit(node.get('where'))\n            if (whereExpr) {\n                clauses.push(`WHERE${space}${whereExpr}`)\n            }\n        }\n\n        if (\n            node.has('group_by') &&\n            Array.isArray(node.get('group_by')) &&\n            (node.get('group_by') as ASTNode[]).length > 0\n        ) {\n            const groupByExpressions = (node.get('group_by') as ASTNode[]).map((expr) => this.visit(expr))\n            clauses.push(`GROUP BY${space}${groupByExpressions.join(comma)}`)\n        }\n\n        if (node.has('having')) {\n            const havingExpr = this.visit(node.get('having'))\n            if (havingExpr) {\n                clauses.push(`HAVING${space}${havingExpr}`)\n            }\n        }\n\n        if (\n            node.has('order_by') &&\n            Array.isArray(node.get('order_by')) &&\n            (node.get('order_by') as ASTNode[]).length > 0\n        ) {\n            const orderByExpressions = (node.get('order_by') as ASTNode[]).map((expr) => this.visit(expr))\n            clauses.push(`ORDER BY${space}${orderByExpressions.join(comma)}`)\n        }\n\n        if (node.has('limit')) {\n            const limitExpr = this.visit(node.get('limit'))\n            if (limitExpr) {\n                clauses.push(`LIMIT ${limitExpr}`)\n            }\n            if (node.get('limit_with_ties')) {\n                clauses.push('WITH TIES')\n            }\n            if (node.has('offset')) {\n                const offsetExpr = this.visit(node.get('offset'))\n                if (offsetExpr) {\n                    clauses.push(`OFFSET ${offsetExpr}`)\n                }\n            }\n        }\n\n        if (node.has('window_exprs')) {\n            const windowExprs = node.get('window_exprs') as Map<string, ASTNode> | undefined\n            if (windowExprs) {\n                const windowExpressions = Array.from(windowExprs.entries())\n                    .map(([name, expr]) => `${escapeIdentifier(name)} AS (${this.visit(expr)})`)\n                    .join(comma)\n                if (windowExpressions) {\n                    clauses.push(`WINDOW${space}${windowExpressions}`)\n                }\n            }\n        }\n\n        let response = this.pretty ? clauses.map((clause) => `${this.indent()}${clause}`).join('\\n') : clauses.join(' ')\n\n        if (!isTopLevelQuery) {\n            response = `(${response})`\n        }\n\n        return response\n    }\n\n    private visitSelectSetQuery(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        this.indentLevel -= 1\n        const initialSelectQuery = node.get('initial_select_query') as ASTNode\n        let result = this.visit(initialSelectQuery)\n\n        if (this.pretty) {\n            result = result.trim()\n        }\n\n        const subsequentQueries = node.get('subsequent_select_queries') as {\n            select_query: ASTNode\n            set_operator: string\n        }[]\n        if (subsequentQueries) {\n            for (const expr of subsequentQueries) {\n                const query = this.visit(expr.select_query)\n                const trimmedQuery = this.pretty ? query.trim() : query\n\n                if (expr.set_operator) {\n                    if (this.pretty) {\n                        result += `\\n${this.indent(1)}${expr.set_operator}\\n${this.indent(1)}`\n                    } else {\n                        result += ` ${expr.set_operator} `\n                    }\n                }\n                result += trimmedQuery\n            }\n        }\n        this.indentLevel += 1\n\n        if (this.stack.length > 1) {\n            return `(${result.trim()})`\n        }\n        return result\n    }\n\n    // Helper method to handle join expressions in the FROM clause\n    private visitJoinExpression(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const nodeType = node.get('__hx_ast') as string\n\n        if (nodeType === 'JoinExpr') {\n            return this.visitJoinExpr(node)\n        }\n        // If it's not a JoinExpr, treat it as a regular table or subquery\n        return this.visit(node)\n    }\n\n    private visitJoinExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const joinParts: string[] = []\n\n        // Handle the initial table or subquery\n        const initialTable = this.visit(node.get('table'))\n\n        // Add alias if present\n        if (node.has('alias') && node.get('alias') !== initialTable) {\n            joinParts.push(`${initialTable} AS ${escapeIdentifier(node.get('alias'))}`)\n        } else {\n            joinParts.push(initialTable)\n        }\n\n        // Process the chain of joins via next_join\n        let currentJoin = node.get('next_join') as ASTNode | undefined\n        while (currentJoin) {\n            const joinType = currentJoin.get('join_type') || 'JOIN'\n            const table = this.visit(currentJoin.get('table'))\n            const constraint = currentJoin.get('constraint') as ASTNode | undefined\n            const constraintClause = constraint ? `${constraint.get('constraint_type')} ${this.visit(constraint)}` : ''\n\n            // Add alias if present\n            let tableWithAlias = table\n            if (currentJoin.has('alias') && currentJoin.get('alias') !== table) {\n                tableWithAlias = `${table} AS ${escapeIdentifier(currentJoin.get('alias'))}`\n            }\n\n            joinParts.push(`${joinType} ${tableWithAlias} ${constraintClause}`.trim())\n\n            currentJoin = currentJoin.get('next_join') as ASTNode | undefined\n        }\n\n        return joinParts.join(' ')\n    }\n\n    private visitJoinConstraint(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        return this.visit(node.get('expr'))\n    }\n\n    private visitCall(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const name = node.get('name') as string\n        const args = (node.get('args') as ASTNode[])?.map((arg) => this.visit(arg)) || []\n        return `${name}(${args.join(', ')})`\n    }\n\n    private visitConstant(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const value = node.get('value')\n        return this.escapeValue(value)\n    }\n\n    private visitField(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const chain = node.get('chain') as Array<string | number>\n        if (chain.length === 1 && chain[0] === '*') {\n            return '*'\n        }\n        return chain.map((identifier) => this.escapeIdentifierOrIndex(identifier)).join('.')\n    }\n\n    private visitAlias(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        if (node.get('hidden')) {\n            return this.visit(node.get('expr'))\n        }\n        let expr = node.get('expr') as ASTNode\n        while (expr && expr instanceof Map && expr.get('__hx_ast') === 'Alias' && expr.get('hidden')) {\n            expr = expr.get('expr')\n        }\n        const inside = this.visit(expr)\n        const alias = escapeIdentifier(node.get('alias') as string)\n        return `${inside} AS ${alias}`\n    }\n\n    private visitAnd(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const exprs = node.get('exprs') as ASTNode[] | undefined\n        if (!exprs || exprs.length === 0) {\n            return ''\n        }\n        if (exprs.length === 1) {\n            return this.visit(exprs[0])\n        }\n        const expressions = exprs.map((expr) => this.visit(expr))\n        return `and(${expressions.join(', ')})`\n    }\n\n    private visitOr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const exprs = node.get('exprs') as ASTNode[] | undefined\n        if (!exprs || exprs.length === 0) {\n            return ''\n        }\n        if (exprs.length === 1) {\n            return this.visit(exprs[0])\n        }\n        const expressions = exprs.map((expr) => this.visit(expr))\n        return `or(${expressions.join(', ')})`\n    }\n\n    private visitNot(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        return `not(${this.visit(node.get('expr'))})`\n    }\n\n    private visitCompareOperation(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const left = this.visit(node.get('left'))\n        const right = this.visit(node.get('right'))\n        const op = node.get('op') as string\n        const opMap: { [key: string]: string } = {\n            '==': 'equals',\n            '!=': 'notEquals',\n            '<': 'less',\n            '>': 'greater',\n            '<=': 'lessOrEquals',\n            '>=': 'greaterOrEquals',\n            in: 'in',\n            'not in': 'notIn',\n            like: 'like',\n            'not like': 'notLike',\n            ilike: 'ilike',\n            'not ilike': 'notILike',\n            '=~': 'match',\n            '!~': 'match',\n            '=~*': 'match',\n            '!~*': 'match',\n        }\n\n        const functionName = opMap[op] || op\n        if (op === '!~*') {\n            return `not(${functionName}(${left}, concat('(?i)', ${right})))`\n        }\n        if (op === '=~*') {\n            return `${functionName}(${left}, concat('(?i)', ${right}))`\n        }\n        if (op === '!~') {\n            return `not(${functionName}(${left}, ${right}))`\n        }\n        return `${functionName}(${left}, ${right})`\n    }\n\n    private visitTuple(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const exprs = node.get('exprs') as ASTNode[] | undefined\n        if (!exprs) {\n            return ''\n        }\n        const expressions = exprs.map((expr) => this.visit(expr))\n        return `tuple(${expressions.join(', ')})`\n    }\n\n    private visitArray(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const exprs = node.get('exprs') as ASTNode[] | undefined\n        if (!exprs) {\n            return ''\n        }\n        const expressions = exprs.map((expr) => this.visit(expr))\n        return `[${expressions.join(', ')}]`\n    }\n\n    private visitLambda(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const args = node.get('args') as string[] | undefined\n        if (!args || args.length === 0) {\n            throw new Error('Lambdas require at least one argument')\n        }\n        const escapedArgs = args.map((arg) => escapeIdentifier(arg))\n        const argList = escapedArgs.length === 1 ? escapedArgs[0] : `(${escapedArgs.join(', ')})`\n        return `${argList} -> ${this.visit(node.get('expr'))}`\n    }\n\n    private visitOrderExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        return `${this.visit(node.get('expr'))} ${node.get('order')}`\n    }\n\n    private visitArithmeticOperation(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const left = this.visit(node.get('left'))\n        const right = this.visit(node.get('right'))\n        const op = node.get('op') as string\n        switch (op) {\n            case '+':\n                return `plus(${left}, ${right})`\n            case '-':\n                return `minus(${left}, ${right})`\n            case '*':\n                return `multiply(${left}, ${right})`\n            case '/':\n                return `divide(${left}, ${right})`\n            case '%':\n                return `modulo(${left}, ${right})`\n            default:\n                throw new Error(`Unknown ArithmeticOperation operator: ${op}`)\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    private visitAsterisk(_: ASTNode): string {\n        return '*'\n    }\n\n    private visitWindowExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const parts: string[] = []\n        if (\n            node.has('partition_by') &&\n            Array.isArray(node.get('partition_by')) &&\n            (node.get('partition_by') as ASTNode[]).length > 0\n        ) {\n            const partitions = (node.get('partition_by') as ASTNode[]).map((expr) => this.visit(expr)).join(', ')\n            parts.push(`PARTITION BY ${partitions}`)\n        }\n        if (\n            node.has('order_by') &&\n            Array.isArray(node.get('order_by')) &&\n            (node.get('order_by') as ASTNode[]).length > 0\n        ) {\n            const orders = (node.get('order_by') as ASTNode[]).map((expr) => this.visit(expr)).join(', ')\n            parts.push(`ORDER BY ${orders}`)\n        }\n        if (node.has('frame_method')) {\n            const frameMethod = node.get('frame_method') as string\n            if (node.has('frame_start') && node.has('frame_end')) {\n                parts.push(\n                    `${frameMethod} BETWEEN ${this.visitWindowFrameExpr(\n                        node.get('frame_start')\n                    )} AND ${this.visitWindowFrameExpr(node.get('frame_end'))}`\n                )\n            } else if (node.has('frame_start')) {\n                parts.push(`${frameMethod} ${this.visitWindowFrameExpr(node.get('frame_start'))}`)\n            }\n        }\n        return parts.join(' ')\n    }\n\n    private visitWindowFunction(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const name = node.get('name') as string\n        const exprs = node.has('exprs')\n            ? (node.get('exprs') as ASTNode[]).map((expr) => this.visit(expr)).join(', ')\n            : ''\n        const args = node.has('args')\n            ? `(${(node.get('args') as ASTNode[]).map((arg) => this.visit(arg)).join(', ')})`\n            : ''\n        let over = ''\n        if (node.has('over_expr')) {\n            over = `(${this.visit(node.get('over_expr'))})`\n        } else if (node.has('over_identifier')) {\n            over = escapeIdentifier(node.get('over_identifier') as string)\n        } else {\n            over = '()'\n        }\n        return `${name}(${exprs})${args} OVER ${over}`\n    }\n\n    private visitWindowFrameExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const frameType = node.get('frame_type') as string\n        const frameValue = node.has('frame_value') ? node.get('frame_value').toString() : 'UNBOUNDED'\n        return `${frameValue} ${frameType}`\n    }\n\n    private visitSampleExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const sampleValue = this.visitRatioExpr(node.get('sample_value'))\n        const offsetClause = node.has('offset_value') ? ` OFFSET ${this.visitRatioExpr(node.get('offset_value'))}` : ''\n        return `SAMPLE ${sampleValue}${offsetClause}`\n    }\n\n    private visitHogQLXTag(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const tagName = node.get('kind') as string\n        const args = (node.get('attributes') || []) as ASTNode[]\n        const argsString = args.length > 0 ? ` ${args.map((a) => this.visitHogQLXAttribute(a)).join(' ')}` : ''\n        return `<${tagName}${argsString} />`\n    }\n\n    private visitHogQLXAttribute(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const name = node.get('name') as string\n        const value = this.visit(node.get('value'))\n        if (typeof node.get('value') === 'string') {\n            return `${escapeIdentifier(name)}=${value}`\n        }\n        return `${escapeIdentifier(name)}={${value}}`\n    }\n\n    private visitRatioExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        if (node.has('right')) {\n            return `${this.visit(node.get('left'))}/${this.visit(node.get('right'))}`\n        }\n        return this.visit(node.get('left'))\n    }\n\n    private escapeIdentifierOrIndex(name: string | number): string {\n        if (typeof name === 'number' && /^\\d+$/.test(name.toString())) {\n            return name.toString()\n        }\n        return escapeIdentifier(name.toString())\n    }\n\n    private escapeValue(value: any): string {\n        return printHogValue(value, this.marked)\n    }\n}\n","import { kea, listeners, path } from 'kea'\nimport { loaders } from 'kea-loaders'\n\nimport api from 'lib/api'\n\nimport { ActivationTask } from '~/layout/navigation-3000/sidepanel/panels/activation/activationLogic'\nimport { activationLogic } from '~/layout/navigation-3000/sidepanel/panels/activation/activationLogic'\nimport { hogql } from '~/queries/utils'\n\nimport type { reverseProxyCheckerLogicType } from './reverseProxyCheckerLogicType'\n\nconst CHECK_INTERVAL_MS = 1000 * 60 * 60 // 1 hour\n\nexport const reverseProxyCheckerLogic = kea<reverseProxyCheckerLogicType>([\n    path(['components', 'ReverseProxyChecker', 'reverseProxyCheckerLogic']),\n    loaders(({ values, cache }) => ({\n        hasReverseProxy: [\n            false as boolean | null,\n            {\n                loadHasReverseProxy: async () => {\n                    if (cache.lastCheckedTimestamp > Date.now() - CHECK_INTERVAL_MS) {\n                        return values.hasReverseProxy\n                    }\n\n                    cache.lastCheckedTimestamp = Date.now()\n\n                    const query = hogql`\n                        SELECT DISTINCT properties.$lib_custom_api_host AS lib_custom_api_host\n                        FROM events\n                        WHERE timestamp >= now() - INTERVAL 1 DAY \n                        AND timestamp <= now()\n                        AND properties.$lib_custom_api_host IS NOT NULL\n                        AND event IN ('$pageview', '$screen')\n                        LIMIT 10`\n\n                    const res = await api.queryHogQL(query)\n                    return !!res.results?.find((x) => !!x[0])\n                },\n            },\n        ],\n    })),\n    listeners(({ values }) => ({\n        loadHasReverseProxySuccess: () => {\n            if (values.hasReverseProxy) {\n                activationLogic.findMounted()?.actions.markTaskAsCompleted(ActivationTask.SetUpReverseProxy)\n            }\n        },\n    })),\n])\n","import { useActions, useValues } from 'kea'\nimport { Form, Group } from 'kea-forms'\nimport { useCallback } from 'react'\n\nimport { IconInfo } from '@posthog/icons'\nimport {\n    LemonBanner,\n    LemonCheckbox,\n    LemonCollapse,\n    LemonInput,\n    LemonSegmentedButton,\n    LemonSelect,\n    SpinnerOverlay,\n    Tooltip,\n} from '@posthog/lemon-ui'\n\nimport { AlertStateIndicator } from 'lib/components/Alerts/views/ManageAlertsModal'\nimport { MemberSelectMultiple } from 'lib/components/MemberSelectMultiple'\nimport { TZLabel } from 'lib/components/TZLabel'\nimport { UserActivityIndicator } from 'lib/components/UserActivityIndicator/UserActivityIndicator'\nimport { dayjs } from 'lib/dayjs'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonModal } from 'lib/lemon-ui/LemonModal'\nimport { IconChevronLeft } from 'lib/lemon-ui/icons'\nimport { alphabet, formatDate } from 'lib/utils'\nimport { trendsDataLogic } from 'scenes/trends/trendsDataLogic'\n\nimport {\n    AlertCalculationInterval,\n    AlertConditionType,\n    AlertState,\n    InsightThresholdType,\n} from '~/queries/schema/schema-general'\nimport { InsightLogicProps, InsightShortId, QueryBasedInsightModel } from '~/types'\n\nimport { SnoozeButton } from '../SnoozeButton'\nimport { alertFormLogic, canCheckOngoingInterval } from '../alertFormLogic'\nimport { alertLogic } from '../alertLogic'\nimport { AlertType } from '../types'\nimport { AlertDestinationSelector } from './AlertDestinationSelector'\n\nfunction alertCalculationIntervalToLabel(interval: AlertCalculationInterval): string {\n    switch (interval) {\n        case AlertCalculationInterval.HOURLY:\n            return 'hour'\n        case AlertCalculationInterval.DAILY:\n            return 'day'\n        case AlertCalculationInterval.WEEKLY:\n            return 'week'\n        case AlertCalculationInterval.MONTHLY:\n            return 'month'\n    }\n}\n\nexport function AlertStateTable({ alert }: { alert: AlertType }): JSX.Element | null {\n    if (!alert.checks || alert.checks.length === 0) {\n        return null\n    }\n\n    return (\n        <div className=\"bg-primary p-4 mt-10 rounded-lg\">\n            <div className=\"flex flex-row gap-2 items-center mb-2\">\n                <h3 className=\"m-0\">Current status: </h3>\n                <AlertStateIndicator alert={alert} />\n                <h3 className=\"m-0\">\n                    {alert.snoozed_until && ` until ${formatDate(dayjs(alert?.snoozed_until), 'MMM D, HH:mm')}`}\n                </h3>\n            </div>\n            <table className=\"w-full table-auto border-spacing-2 border-collapse\">\n                <thead>\n                    <tr className=\"text-left\">\n                        <th>Status</th>\n                        <th className=\"text-right\">Time</th>\n                        <th className=\"text-right pr-4\">Value</th>\n                        <th>Targets notified</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    {alert.checks.map((check) => (\n                        <tr key={check.id}>\n                            <td>{check.state}</td>\n                            <td className=\"text-right\">\n                                <TZLabel time={check.created_at} />\n                            </td>\n                            <td className=\"text-right pr-4\">{check.calculated_value}</td>\n                            <td>{check.targets_notified ? 'Yes' : 'No'}</td>\n                        </tr>\n                    ))}\n                </tbody>\n            </table>\n        </div>\n    )\n}\n\ninterface EditAlertModalProps {\n    isOpen: boolean | undefined\n    alertId?: AlertType['id']\n    insightId: QueryBasedInsightModel['id']\n    insightShortId: InsightShortId\n    onEditSuccess: (alertId?: AlertType['id'] | undefined) => void\n    onClose?: () => void\n    insightLogicProps?: InsightLogicProps\n}\n\nexport function EditAlertModal({\n    isOpen,\n    alertId,\n    insightId,\n    insightShortId,\n    onClose,\n    onEditSuccess,\n    insightLogicProps,\n}: EditAlertModalProps): JSX.Element {\n    const _alertLogic = alertLogic({ alertId })\n    const { alert, alertLoading } = useValues(_alertLogic)\n    const { loadAlert } = useActions(_alertLogic)\n\n    // need to reload edited alert as well\n    const _onEditSuccess = useCallback(\n        (alertId: AlertType['id'] | undefined) => {\n            if (alertId) {\n                loadAlert()\n            }\n            onEditSuccess(alertId)\n        },\n        [loadAlert, onEditSuccess]\n    )\n\n    const formLogicProps = {\n        alert,\n        insightId,\n        onEditSuccess: _onEditSuccess,\n        insightVizDataLogicProps: insightLogicProps,\n    }\n    const formLogic = alertFormLogic(formLogicProps)\n    const { alertForm, isAlertFormSubmitting, alertFormChanged } = useValues(formLogic)\n    const { deleteAlert, snoozeAlert, clearSnooze } = useActions(formLogic)\n    const { setAlertFormValue } = useActions(formLogic)\n\n    const trendsLogic = trendsDataLogic({ dashboardItemId: insightShortId })\n    const {\n        alertSeries,\n        isNonTimeSeriesDisplay,\n        isBreakdownValid,\n        formulaNodes,\n        interval: trendInterval,\n    } = useValues(trendsLogic)\n\n    const creatingNewAlert = alertForm.id === undefined\n    // can only check ongoing interval for absolute value/increase alerts with upper threshold\n    const can_check_ongoing_interval = canCheckOngoingInterval(alertForm)\n\n    return (\n        <LemonModal onClose={onClose} isOpen={isOpen} width={600} simple title=\"\">\n            {alertLoading ? (\n                <SpinnerOverlay />\n            ) : (\n                <Form\n                    logic={alertFormLogic}\n                    props={formLogicProps}\n                    formKey=\"alertForm\"\n                    enableFormOnSubmit\n                    className=\"LemonModal__layout\"\n                >\n                    <LemonModal.Header>\n                        <div className=\"flex items-center gap-2\">\n                            <LemonButton icon={<IconChevronLeft />} onClick={onClose} size=\"xsmall\" />\n\n                            <h3>{creatingNewAlert ? 'New' : 'Edit '} Alert</h3>\n                        </div>\n                    </LemonModal.Header>\n\n                    <LemonModal.Content>\n                        <div className=\"deprecated-space-y-8\">\n                            <div className=\"deprecated-space-y-4\">\n                                <div className=\"flex gap-4 items-center\">\n                                    <LemonField className=\"flex-auto\" name=\"name\">\n                                        <LemonInput placeholder=\"Alert name\" data-attr=\"alertForm-name\" />\n                                    </LemonField>\n                                    <LemonField name=\"enabled\">\n                                        <LemonCheckbox\n                                            checked={alertForm?.enabled}\n                                            data-attr=\"alertForm-enabled\"\n                                            fullWidth\n                                            label=\"Enabled\"\n                                        />\n                                    </LemonField>\n                                </div>\n                                {alert?.created_by ? (\n                                    <UserActivityIndicator\n                                        at={alert.created_at}\n                                        by={alert.created_by}\n                                        prefix=\"Created\"\n                                    />\n                                ) : null}\n                            </div>\n\n                            <div className=\"deprecated-space-y-6\">\n                                <h3>Definition</h3>\n                                <div className=\"deprecated-space-y-5\">\n                                    {isBreakdownValid && (\n                                        <LemonBanner type=\"warning\">\n                                            For trends with breakdown, the alert will fire if any of the breakdown\n                                            values breaches the threshold.\n                                        </LemonBanner>\n                                    )}\n                                    <div className=\"flex gap-4 items-center\">\n                                        <div>When</div>\n                                        <Group name={['config']}>\n                                            <LemonField name=\"series_index\" className=\"flex-auto\">\n                                                <LemonSelect\n                                                    fullWidth\n                                                    data-attr=\"alertForm-series-index\"\n                                                    options={\n                                                        formulaNodes?.length > 0\n                                                            ? formulaNodes.map(({ formula, custom_name }, index) => ({\n                                                                  label: `${\n                                                                      custom_name ? custom_name : 'Formula'\n                                                                  } (${formula})`,\n                                                                  value: index,\n                                                              }))\n                                                            : (alertSeries?.map(\n                                                                  ({ custom_name, name, event }, index) => ({\n                                                                      label: isBreakdownValid\n                                                                          ? 'any breakdown value'\n                                                                          : `${alphabet[index]} - ${\n                                                                                custom_name ?? name ?? event\n                                                                            }`,\n                                                                      value: isBreakdownValid ? 0 : index,\n                                                                  })\n                                                              ) ?? [])\n                                                    }\n                                                    disabledReason={\n                                                        isBreakdownValid &&\n                                                        `For trends with breakdown, the alert will fire if any of the breakdown\n                                            values breaches the threshold.`\n                                                    }\n                                                />\n                                            </LemonField>\n                                        </Group>\n                                        <Group name={['condition']}>\n                                            <LemonField name=\"type\">\n                                                <LemonSelect\n                                                    fullWidth\n                                                    className=\"w-40\"\n                                                    data-attr=\"alertForm-condition\"\n                                                    options={[\n                                                        {\n                                                            label: 'has value',\n                                                            value: AlertConditionType.ABSOLUTE_VALUE,\n                                                        },\n                                                        {\n                                                            label: 'increases by',\n                                                            value: AlertConditionType.RELATIVE_INCREASE,\n                                                            disabledReason:\n                                                                isNonTimeSeriesDisplay &&\n                                                                'This condition is only supported for time series trends',\n                                                        },\n                                                        {\n                                                            label: 'decreases by',\n                                                            value: AlertConditionType.RELATIVE_DECREASE,\n                                                            disabledReason:\n                                                                isNonTimeSeriesDisplay &&\n                                                                'This condition is only supported for time series trends',\n                                                        },\n                                                    ]}\n                                                />\n                                            </LemonField>\n                                        </Group>\n                                    </div>\n                                    <div className=\"flex gap-4 items-center\">\n                                        <div>less than</div>\n                                        <LemonField name=\"lower\">\n                                            <LemonInput\n                                                type=\"number\"\n                                                className=\"w-30\"\n                                                data-attr=\"alertForm-lower-threshold\"\n                                                value={\n                                                    alertForm.threshold.configuration.type ===\n                                                        InsightThresholdType.PERCENTAGE &&\n                                                    alertForm.threshold.configuration.bounds?.lower\n                                                        ? alertForm.threshold.configuration.bounds?.lower * 100\n                                                        : alertForm.threshold.configuration.bounds?.lower\n                                                }\n                                                onChange={(value) =>\n                                                    setAlertFormValue('threshold', {\n                                                        configuration: {\n                                                            type: alertForm.threshold.configuration.type,\n                                                            bounds: {\n                                                                ...alertForm.threshold.configuration.bounds,\n                                                                lower:\n                                                                    value &&\n                                                                    alertForm.threshold.configuration.type ===\n                                                                        InsightThresholdType.PERCENTAGE\n                                                                        ? value / 100\n                                                                        : value,\n                                                            },\n                                                        },\n                                                    })\n                                                }\n                                            />\n                                        </LemonField>\n                                        <div>or more than</div>\n                                        <LemonField name=\"upper\">\n                                            <LemonInput\n                                                type=\"number\"\n                                                className=\"w-30\"\n                                                data-attr=\"alertForm-upper-threshold\"\n                                                value={\n                                                    alertForm.threshold.configuration.type ===\n                                                        InsightThresholdType.PERCENTAGE &&\n                                                    alertForm.threshold.configuration.bounds?.upper\n                                                        ? alertForm.threshold.configuration.bounds?.upper * 100\n                                                        : alertForm.threshold.configuration.bounds?.upper\n                                                }\n                                                onChange={(value) =>\n                                                    setAlertFormValue('threshold', {\n                                                        configuration: {\n                                                            type: alertForm.threshold.configuration.type,\n                                                            bounds: {\n                                                                ...alertForm.threshold.configuration.bounds,\n                                                                upper:\n                                                                    value &&\n                                                                    alertForm.threshold.configuration.type ===\n                                                                        InsightThresholdType.PERCENTAGE\n                                                                        ? value / 100\n                                                                        : value,\n                                                            },\n                                                        },\n                                                    })\n                                                }\n                                            />\n                                        </LemonField>\n                                        {alertForm.condition.type !== AlertConditionType.ABSOLUTE_VALUE && (\n                                            <Group name={['threshold', 'configuration']}>\n                                                <LemonField name=\"type\">\n                                                    <LemonSegmentedButton\n                                                        options={[\n                                                            {\n                                                                value: InsightThresholdType.PERCENTAGE,\n                                                                label: '%',\n                                                                tooltip: 'Percent',\n                                                            },\n                                                            {\n                                                                value: InsightThresholdType.ABSOLUTE,\n                                                                label: '#',\n                                                                tooltip: 'Absolute number',\n                                                            },\n                                                        ]}\n                                                    />\n                                                </LemonField>\n                                            </Group>\n                                        )}\n                                    </div>\n                                    <div className=\"flex gap-4 items-center\">\n                                        <div>Run alert every</div>\n                                        <LemonField name=\"calculation_interval\">\n                                            <LemonSelect\n                                                fullWidth\n                                                className=\"w-28\"\n                                                data-attr=\"alertForm-calculation-interval\"\n                                                options={Object.values(AlertCalculationInterval).map((interval) => ({\n                                                    label: alertCalculationIntervalToLabel(interval),\n                                                    value: interval,\n                                                }))}\n                                            />\n                                        </LemonField>\n                                        <div>\n                                            and check {alertForm?.config.check_ongoing_interval ? 'current' : 'last'}\n                                        </div>\n                                        <LemonSelect\n                                            fullWidth\n                                            className=\"w-28\"\n                                            data-attr=\"alertForm-trend-interval\"\n                                            disabledReason={\n                                                <>\n                                                    To change the interval being checked, edit and <b>save</b> the\n                                                    interval which the insight is 'grouped by'\n                                                </>\n                                            }\n                                            value={trendInterval ?? 'day'}\n                                            options={[\n                                                {\n                                                    label: trendInterval ?? 'day',\n                                                    value: trendInterval ?? 'day',\n                                                },\n                                            ]}\n                                        />\n                                    </div>\n                                </div>\n                            </div>\n\n                            <div>\n                                <h3>Notification</h3>\n                                <div className=\"flex gap-4 items-center mt-2\">\n                                    <div>E-mail</div>\n                                    <div className=\"flex-auto\">\n                                        <MemberSelectMultiple\n                                            value={alertForm.subscribed_users?.map((u) => u.id) ?? []}\n                                            idKey=\"id\"\n                                            onChange={(value) => setAlertFormValue('subscribed_users', value)}\n                                        />\n                                    </div>\n                                </div>\n\n                                <h4 className=\"mt-4\">CDP Destinations</h4>\n                                <div className=\"mt-2\">\n                                    {alertId ? (\n                                        <div className=\"flex flex-col\">\n                                            <AlertDestinationSelector alertId={alertId} />\n                                        </div>\n                                    ) : (\n                                        <div className=\"text-muted-alt\">\n                                            Save alert first to add destinations (e.g. Slack, Webhooks)\n                                        </div>\n                                    )}\n                                </div>\n                            </div>\n\n                            <div className=\"deprecated-space-y-2\">\n                                <LemonCollapse\n                                    panels={[\n                                        {\n                                            key: 'advanced',\n                                            header: 'Advanced options',\n                                            content: (\n                                                <div className=\"space-y-2\">\n                                                    <Group name={['config']}>\n                                                        <div className=\"flex gap-1\">\n                                                            <LemonField name=\"check_ongoing_interval\">\n                                                                <LemonCheckbox\n                                                                    checked={\n                                                                        can_check_ongoing_interval &&\n                                                                        alertForm?.config.check_ongoing_interval\n                                                                    }\n                                                                    data-attr=\"alertForm-check-ongoing-interval\"\n                                                                    fullWidth\n                                                                    label=\"Check ongoing period\"\n                                                                    disabledReason={\n                                                                        !can_check_ongoing_interval &&\n                                                                        'Can only alert for ongoing period when checking for absolute value/increase above a set upper threshold.'\n                                                                    }\n                                                                />\n                                                            </LemonField>\n                                                            <Tooltip\n                                                                title={`Checks the insight value for the ongoing period (current week/month) that hasn't yet completed. Use this if you want to be alerted right away when the insight value rises/increases above threshold`}\n                                                                placement=\"right\"\n                                                                delayMs={0}\n                                                            >\n                                                                <IconInfo />\n                                                            </Tooltip>\n                                                        </div>\n                                                    </Group>\n                                                    <LemonField name=\"skip_weekend\">\n                                                        <LemonCheckbox\n                                                            checked={\n                                                                (alertForm?.calculation_interval ===\n                                                                    AlertCalculationInterval.DAILY ||\n                                                                    alertForm?.calculation_interval ===\n                                                                        AlertCalculationInterval.HOURLY) &&\n                                                                alertForm?.skip_weekend\n                                                            }\n                                                            data-attr=\"alertForm-skip-weekend\"\n                                                            fullWidth\n                                                            label=\"Skip checking on weekends\"\n                                                            disabledReason={\n                                                                alertForm?.calculation_interval !==\n                                                                    AlertCalculationInterval.DAILY &&\n                                                                alertForm?.calculation_interval !==\n                                                                    AlertCalculationInterval.HOURLY &&\n                                                                'Can only skip weekend checking for hourly/daily alerts'\n                                                            }\n                                                        />\n                                                    </LemonField>\n                                                </div>\n                                            ),\n                                        },\n                                    ]}\n                                />\n                            </div>\n                        </div>\n\n                        {alert && <AlertStateTable alert={alert} />}\n                    </LemonModal.Content>\n\n                    <LemonModal.Footer>\n                        <div className=\"flex-1\">\n                            <div className=\"flex gap-2\">\n                                {!creatingNewAlert ? (\n                                    <LemonButton type=\"secondary\" status=\"danger\" onClick={deleteAlert}>\n                                        Delete alert\n                                    </LemonButton>\n                                ) : null}\n                                {!creatingNewAlert && alert?.state === AlertState.FIRING ? (\n                                    <SnoozeButton onChange={snoozeAlert} value={alert?.snoozed_until} />\n                                ) : null}\n                                {!creatingNewAlert && alert?.state === AlertState.SNOOZED ? (\n                                    <LemonButton\n                                        type=\"secondary\"\n                                        status=\"default\"\n                                        onClick={clearSnooze}\n                                        tooltip={`Currently snoozed until ${formatDate(\n                                            dayjs(alert?.snoozed_until),\n                                            'MMM D, HH:mm'\n                                        )}`}\n                                    >\n                                        Clear snooze\n                                    </LemonButton>\n                                ) : null}\n                            </div>\n                        </div>\n                        <LemonButton\n                            type=\"primary\"\n                            htmlType=\"submit\"\n                            loading={isAlertFormSubmitting}\n                            disabledReason={!alertFormChanged && 'No changes to save'}\n                        >\n                            {creatingNewAlert ? 'Create alert' : 'Save'}\n                        </LemonButton>\n                    </LemonModal.Footer>\n                </Form>\n            )}\n        </LemonModal>\n    )\n}\n","import { actions, afterMount, connect, kea, key, listeners, path, props, propsChanged, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { subscriptions } from 'kea-subscriptions'\n\nimport api from 'lib/api'\nimport { Dayjs, dayjs } from 'lib/dayjs'\nimport { dateStringToDayJs, objectsEqual } from 'lib/utils'\nimport { teamLogic } from 'scenes/teamLogic'\n\nimport { HogQLQueryString, hogql } from '~/queries/utils'\n\nimport type { appMetricsLogicType } from './appMetricsLogicType'\n\nconst DEFAULT_INTERVAL = 'day'\n\nexport type AppMetricsCommonParams = {\n    appSource?: string\n    appSourceId?: string\n    instanceId?: string\n    metricName?: string | string[]\n    metricKind?: string | string[]\n    breakdownBy?: 'metric_name' | 'metric_kind' | 'app_source_id'\n    interval?: 'day' | 'hour' | 'minute'\n    dateFrom?: string\n    dateTo?: string\n}\n\nexport type AppMetricsLogicProps = {\n    logicKey: string\n    forceParams?: Partial<AppMetricsCommonParams>\n    defaultParams?: Partial<AppMetricsCommonParams>\n    loadOnChanges?: boolean\n    /** If true, loads data immediately when logic mounts. Default: false */\n    loadOnMount?: boolean\n}\n\nexport type AppMetricsTimeSeriesRequest = AppMetricsCommonParams\n\nexport type AppMetricsTimeSeriesResponse = {\n    labels: string[]\n    series: {\n        name: string\n        values: number[]\n    }[]\n}\n\nexport type AppMetricsTotalsRequest = Omit<AppMetricsCommonParams, 'interval' | 'breakdownBy'> & {\n    breakdownBy: ('metric_name' | 'metric_kind' | 'app_source_id' | 'instance_id')[]\n}\n\nexport type AppMetricsTotalsResponse = Record<\n    string,\n    {\n        total: number\n        breakdowns: string[]\n    }\n>\n\nexport const loadAppMetricsTotals = async (\n    request: AppMetricsTotalsRequest,\n    timezone: string\n): Promise<AppMetricsTotalsResponse> => {\n    const breakdownBy = request.breakdownBy || ['metric_name']\n\n    let query = hogql`\n        SELECT\n            sum(count) AS total,\n            ${hogql.raw(breakdownBy.join(', '))}\n        FROM app_metrics\n        WHERE app_source = ${request.appSource}\n    `\n\n    if (request.appSourceId) {\n        query = (query + hogql`\\nAND app_source_id = ${request.appSourceId}`) as HogQLQueryString\n    }\n    if (typeof request.instanceId === 'string') {\n        query = (query + hogql`\\nAND instance_id = ${request.instanceId}`) as HogQLQueryString\n    }\n    if (request.metricName) {\n        const metricNames = Array.isArray(request.metricName) ? request.metricName : [request.metricName]\n        query = (query + hogql`\\nAND metric_name IN ${metricNames}`) as HogQLQueryString\n    }\n    if (request.metricKind) {\n        const metricKinds = Array.isArray(request.metricKind) ? request.metricKind : [request.metricKind]\n        query = (query + hogql`\\nAND metric_kind IN ${metricKinds}`) as HogQLQueryString\n    }\n\n    query = (query +\n        hogql`\n            AND toTimeZone(timestamp, ${timezone}) >= toDateTime(${request.dateFrom}, ${timezone})\n            AND toTimeZone(timestamp, ${timezone}) < toDateTime(${request.dateTo}, ${timezone})\n            GROUP BY ${hogql.raw(breakdownBy.join(', '))}\n        `) as HogQLQueryString\n\n    const response = await api.queryHogQL(query, {\n        refresh: 'async',\n    })\n\n    const res: AppMetricsTotalsResponse = {}\n\n    response.results?.forEach((result) => {\n        const total = result[0] as number\n        const groups = result.slice(1)\n\n        // Create a key that combines instanceId and metricName\n        const key = groups.join('_')\n        res[key] = { total, breakdowns: groups }\n    })\n\n    return res\n}\n\nconst loadAppMetricsTimeSeries = async (\n    request: AppMetricsTimeSeriesRequest,\n    timezone: string\n): Promise<AppMetricsTimeSeriesResponse> => {\n    const interval = request.interval || DEFAULT_INTERVAL\n\n    let query = hogql`\n        WITH\n            ${timezone} AS tz,\n            ${interval} AS g,\n\n            -- Interpret the input bounds in the user's TZ\n            toDateTime(${request.dateFrom}, tz) AS from_local,\n            toDateTime(${request.dateTo},   tz) AS to_local,\n\n            -- Snap to buckets in that TZ\n            dateTrunc(g, from_local, tz) AS start_bucket,\n            dateTrunc(g, to_local,   tz) AS end_bucket,\n\n            -- Number of buckets (inclusive), DST-safe\n            multiIf(\n                g = 'minute', dateDiff('minute', start_bucket, end_bucket) + 1,\n                g = 'hour',   dateDiff('hour',   start_bucket, end_bucket) + 1,\n                g = 'day',    dateDiff('day',    start_bucket, end_bucket) + 1,\n                g = 'week',   dateDiff('week',   start_bucket, end_bucket) + 1,\n                0\n            ) AS steps,\n\n            -- Calendar of bucket starts, stepped by units (not seconds), DST-safe\n            arrayMap(n ->\n                multiIf(\n                    g = 'minute', addMinutes(start_bucket, n),\n                    g = 'hour',   addHours(start_bucket, n),\n                    g = 'day',    addDays(start_bucket, n),\n                    g = 'week',   addWeeks(start_bucket, n),\n                    start_bucket\n                ),\n                range(0, steps)\n            ) AS calendar\n\n        SELECT\n            calendar AS date,\n            breakdown,\n            arrayMap(d -> if(indexOf(buckets, d) = 0, 0, counts[indexOf(buckets, d)]), calendar) AS total\n        FROM\n        (\n            SELECT\n                breakdown,\n                groupArray(bucket) AS buckets,\n                groupArray(cnt)    AS counts\n            FROM\n            (\n                SELECT\n                    ${hogql.raw(request.breakdownBy!)} AS breakdown,\n                    -- Convert data to user's TZ before truncating\n                    dateTrunc(g, toTimeZone(timestamp, tz), tz) AS bucket,\n                    sum(count) AS cnt\n                FROM app_metrics\n                WHERE app_source = ${request.appSource}\n    `\n\n    if (request.appSourceId) {\n        query = (query + hogql`\\nAND app_source_id = ${request.appSourceId}`) as HogQLQueryString\n    }\n    if (typeof request.instanceId === 'string') {\n        query = (query + hogql`\\nAND instance_id = ${request.instanceId}`) as HogQLQueryString\n    }\n    if (request.metricName) {\n        const metricNames = Array.isArray(request.metricName) ? request.metricName : [request.metricName]\n        query = (query + hogql`\\nAND metric_name IN ${metricNames}`) as HogQLQueryString\n    }\n    if (request.metricKind) {\n        const metricKinds = Array.isArray(request.metricKind) ? request.metricKind : [request.metricKind]\n        query = (query + hogql`\\nAND metric_kind IN ${metricKinds}`) as HogQLQueryString\n    }\n\n    query = (query +\n        hogql`\n                AND toTimeZone(timestamp, tz) >= start_bucket\n                AND toTimeZone(timestamp, tz) < multiIf(\n                        g = 'minute', addMinutes(end_bucket, 1),\n                        g = 'hour',   addHours(end_bucket,   1),\n                        g = 'day',    addDays(end_bucket,    1),\n                        g = 'week',   addWeeks(end_bucket,   1),\n                        end_bucket\n                )\n                GROUP BY breakdown, bucket\n                ORDER BY breakdown, bucket\n            )\n            GROUP BY breakdown\n        )\n        ORDER BY breakdown\n        `) as HogQLQueryString\n\n    const response = await api.queryHogQL(query, {\n        refresh: 'async',\n    })\n\n    const labels = response.results?.[0]?.[0].map((label: string) => {\n        switch (interval) {\n            case 'day':\n                return dayjs(label).tz(timezone).format('YYYY-MM-DD')\n            case 'hour':\n                return dayjs(label).tz(timezone).format('YYYY-MM-DD HH:mm')\n            case 'minute':\n                return dayjs(label).tz(timezone).format('YYYY-MM-DD HH:mm')\n        }\n    })\n\n    return {\n        labels: labels || [],\n        series:\n            response.results?.map((result) => ({\n                name: result[1],\n                values: result[2],\n            })) || [],\n    }\n}\n\nconst convertDateFieldToDayJs = (date: string, timezone: string): Dayjs => {\n    return dateStringToDayJs(date, timezone) ?? dayjs().tz(timezone)\n}\n\n// IDEA - have a generic helper logic that can be used anywhere for rendering metrics\nexport const appMetricsLogic = kea<appMetricsLogicType>([\n    props({} as unknown as AppMetricsLogicProps),\n    key(({ logicKey }: AppMetricsLogicProps) => logicKey),\n    path((id) => ['scenes', 'hog-functions', 'metrics', 'appMetricsLogic', id]),\n    connect(() => ({\n        values: [teamLogic, ['currentTeam']],\n    })),\n    actions({\n        setParams: (params: Partial<AppMetricsCommonParams>) => ({ params }),\n        loadAppMetricsTrends: true,\n        loadAppMetricsTrendsPreviousPeriod: true,\n    }),\n    reducers(({ props }) => ({\n        params: [\n            {\n                interval: DEFAULT_INTERVAL,\n                dateFrom: '-7d',\n                ...props.defaultParams,\n                ...props.forceParams,\n            } as Partial<AppMetricsCommonParams>,\n            {\n                setParams: (state, { params }) => ({ ...state, ...params }),\n            },\n        ],\n    })),\n    loaders(({ values }) => ({\n        appMetricsTrends: [\n            null as AppMetricsTimeSeriesResponse | null,\n            {\n                loadAppMetricsTrends: async (_, breakpoint) => {\n                    await breakpoint(10)\n                    const dateRange = values.getDateRangeAbsolute()\n                    const params: AppMetricsTimeSeriesRequest = {\n                        ...values.params,\n                        dateFrom: dateRange.dateFrom.toISOString(),\n                        dateTo: dateRange.dateTo.toISOString(),\n                    }\n\n                    const result = await loadAppMetricsTimeSeries(params, values.currentTeam?.timezone ?? 'UTC')\n                    await breakpoint(10)\n\n                    return result\n                },\n            },\n        ],\n        appMetricsTrendsPreviousPeriod: [\n            null as AppMetricsTimeSeriesResponse | null,\n            {\n                loadAppMetricsTrendsPreviousPeriod: async (_, breakpoint) => {\n                    await breakpoint(10)\n                    const dateRange = values.getDateRangeAbsolute()\n                    const params: AppMetricsTimeSeriesRequest = {\n                        ...values.params,\n                        dateFrom: dateRange.dateFrom.subtract(dateRange.diffMs).toISOString(),\n                        dateTo: dateRange.dateTo.subtract(dateRange.diffMs).toISOString(),\n                    }\n\n                    const result = await loadAppMetricsTimeSeries(params, values.currentTeam?.timezone ?? 'UTC')\n                    await breakpoint(10)\n\n                    return result\n                },\n            },\n        ],\n    })),\n    selectors(() => ({\n        getSingleTrendSeries: [\n            (s) => [s.appMetricsTrends, s.appMetricsTrendsPreviousPeriod],\n            (appMetricsTrends, appMetricsTrendsPreviousPeriod) =>\n                (name: string, previousPeriod: boolean = false): AppMetricsTimeSeriesResponse | null => {\n                    const targetTrend = previousPeriod ? appMetricsTrendsPreviousPeriod : appMetricsTrends\n                    if (!targetTrend) {\n                        return null\n                    }\n                    const series = targetTrend.series.find((s) => s.name === name) || {\n                        name,\n                        values: Array.from({ length: targetTrend.labels.length }, () => 0),\n                    }\n\n                    return {\n                        labels: targetTrend.labels,\n                        series: [series],\n                    }\n                },\n        ],\n\n        getDateRangeAbsolute: [\n            (s) => [s.params, s.currentTeam],\n            (params, currentTeam) => (): { dateFrom: Dayjs; dateTo: Dayjs; diffMs: number } => {\n                const dateFrom = convertDateFieldToDayJs(params.dateFrom ?? '-7d', currentTeam?.timezone ?? 'UTC')\n                const dateTo = params.dateTo\n                    ? convertDateFieldToDayJs(params.dateTo, currentTeam?.timezone ?? 'UTC')\n                    : dayjs()\n                          .tz(currentTeam?.timezone ?? 'UTC')\n                          .endOf(params.interval ?? DEFAULT_INTERVAL)\n\n                const diffMs = dateTo.diff(dateFrom)\n\n                return { dateFrom, dateTo, diffMs }\n            },\n        ],\n\n        availableIntervals: [\n            (s) => [s.getDateRangeAbsolute],\n            (getDateRangeAbsolute): AppMetricsCommonParams['interval'][] => {\n                const diffMs = getDateRangeAbsolute().diffMs\n\n                // If the diff is less than 2 days (ish), we can show the minute interval but not day\n                if (diffMs <= 1000 * 60 * 60 * 49) {\n                    return ['hour']\n                }\n\n                // If the diff is less than 8 days, we can show the hour interval but not minute\n                if (diffMs <= 1000 * 60 * 60 * 24 * 8) {\n                    return ['day', 'hour']\n                }\n\n                // If the diff is greater than 8 days, we limit to day interval\n                return ['day']\n            },\n        ],\n    })),\n\n    subscriptions(({ values, actions }) => ({\n        availableIntervals: (availableIntervals) => {\n            if (!availableIntervals.includes(values.params.interval)) {\n                actions.setParams({ interval: availableIntervals[0] })\n            }\n        },\n    })),\n\n    afterMount(({ actions, props }) => {\n        // Auto-load data immediately on mount if explicitly requested\n        if (props.loadOnMount) {\n            actions.loadAppMetricsTrends()\n            actions.loadAppMetricsTrendsPreviousPeriod()\n        }\n    }),\n\n    propsChanged(({ actions, props }, oldProps) => {\n        if (props.forceParams && !objectsEqual(props.forceParams, oldProps.forceParams)) {\n            actions.setParams({ ...props.forceParams })\n        }\n    }),\n\n    listeners(({ actions, values, props }) => ({\n        setParams: async (_, breakpoint) => {\n            await breakpoint(100)\n\n            if (props.loadOnChanges ?? true) {\n                if (values.appMetricsTrends !== null) {\n                    actions.loadAppMetricsTrends()\n                    actions.loadAppMetricsTrendsPreviousPeriod()\n                }\n            }\n        },\n    })),\n])\n","import {\n    actions,\n    afterMount,\n    connect,\n    kea,\n    key,\n    listeners,\n    path,\n    props,\n    reducers,\n    selectors,\n    sharedListeners,\n} from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { encodeParams, urlToAction } from 'kea-router'\nimport { subscriptions } from 'kea-subscriptions'\n\nimport api from 'lib/api'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { isDomain, isURL } from 'lib/utils'\nimport { apiHostOrigin } from 'lib/utils/apiHost'\nimport { copyToClipboard } from 'lib/utils/copyToClipboard'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { hogql } from '~/queries/utils'\nimport { ExperimentIdType, ToolbarParams, ToolbarUserIntent } from '~/types'\n\nimport type { authorizedUrlListLogicType } from './authorizedUrlListLogicType'\n\nexport interface ProposeNewUrlFormType {\n    url: string\n}\n\nexport enum AuthorizedUrlListType {\n    TOOLBAR_URLS = 'TOOLBAR_URLS',\n    RECORDING_DOMAINS = 'RECORDING_DOMAINS',\n    WEB_ANALYTICS = 'WEB_ANALYTICS',\n    WEB_EXPERIMENTS = 'WEB_EXPERIMENTS',\n}\n\n/**\n * Firefox does not allow you construct a new URL with e.g. https://*.example.com (which is to be fair more standards compliant than Chrome)\n * when used to probe for e.g. for authorized urls we only care if the proposed URL has a path so we can safely replace the wildcard with a character\n */\nexport function sanitizePossibleWildCardedURL(url: string): URL {\n    const deWildCardedURL = url.replace(/\\*/g, 'x')\n    return new URL(deWildCardedURL)\n}\n\n/**\n * Checks if the URL has a wildcard (*) in the port position e.g. http://localhost:*\n */\nexport function hasWildcardInPort(input: unknown): boolean {\n    if (!input || typeof input !== 'string') {\n        return false\n    }\n    // This regex matches URLs with a wildcard (*) in the port position\n    const portWildcardRegex = /^(https?:\\/\\/[^:/]+):\\*(.*)$/\n    return portWildcardRegex.test(input.trim())\n}\n\nexport const validateProposedUrl = (\n    proposedUrl: string,\n    currentUrls: string[],\n    onlyAllowDomains: boolean = false,\n    allowWildCards: boolean = true\n): string | undefined => {\n    if (!isURL(proposedUrl)) {\n        return 'Please enter a valid URL'\n    }\n\n    if (hasWildcardInPort(proposedUrl)) {\n        return 'Wildcards are not allowed in the port position'\n    }\n\n    if (onlyAllowDomains && !isDomain(sanitizePossibleWildCardedURL(proposedUrl))) {\n        return \"Please enter a valid domain (URLs with a path aren't allowed)\"\n    }\n\n    const hasWildCard = proposedUrl.indexOf('*') > -1\n    if (hasWildCard && allowWildCards === false) {\n        return 'Wildcards are not allowed'\n    }\n\n    if (\n        hasWildCard &&\n        !/^https?:\\/\\/((\\*\\.)?localhost|localhost)(:\\d+)?$/.test(proposedUrl) && // Allow http://*.localhost and localhost with ports\n        !proposedUrl.match(/^(.*)\\*[^*]*\\.[^*]+\\.[^*]+$/)\n    ) {\n        return 'Wildcards can only be used for subdomains'\n    }\n\n    if (currentUrls.indexOf(proposedUrl) > -1) {\n        return `This ${onlyAllowDomains ? 'domains' : 'URL'} already is registered`\n    }\n\n    return\n}\n\nfunction buildToolbarParams(options?: {\n    actionId?: number | null\n    experimentId?: ExperimentIdType\n    userIntent?: ToolbarUserIntent\n}): ToolbarParams {\n    return {\n        userIntent:\n            options?.userIntent ??\n            (options?.actionId ? 'edit-action' : options?.experimentId ? 'edit-experiment' : 'add-action'),\n        // Make sure to pass the app url, otherwise the api_host will be used by\n        // the toolbar, which isn't correct when used behind a reverse proxy as\n        // we require e.g. SSO login to the app, which will not work when placed\n        // behind a proxy unless we register each domain with the OAuth2 client.\n        apiURL: apiHostOrigin(),\n        ...(options?.actionId ? { actionId: options.actionId } : {}),\n        ...(options?.experimentId ? { experimentId: options.experimentId } : {}),\n    }\n}\n\n/** defaultIntent: whether to launch with empty intent (i.e. toolbar mode is default) */\nexport function appEditorUrl(\n    appUrl: string,\n    options?: {\n        actionId?: number | null\n        experimentId?: ExperimentIdType\n        userIntent?: ToolbarUserIntent\n        generateOnly?: boolean\n    }\n): string {\n    const params = buildToolbarParams(options) as Record<string, unknown>\n    // See https://github.com/PostHog/posthog-js/blob/f7119c/src/extensions/toolbar.ts#L52 for where these params\n    // are passed. `appUrl` is an extra `redirect_to_site` param.\n    params['appUrl'] = appUrl\n    params['generateOnly'] = options?.generateOnly\n    return '/api/user/redirect_to_site/' + encodeParams(params, '?')\n}\n\nexport const checkUrlIsAuthorized = (url: string | URL, authorizedUrls: string[]): boolean => {\n    try {\n        const parsedUrl = typeof url === 'string' ? sanitizePossibleWildCardedURL(url) : url\n        const urlWithoutPath = parsedUrl.protocol + '//' + parsedUrl.host\n        // Is this domain already in the list of urls?\n        const exactMatch =\n            authorizedUrls.filter((authorizedUrl) => authorizedUrl.indexOf(urlWithoutPath) > -1).length > 0\n\n        if (exactMatch) {\n            return true\n        }\n\n        const wildcardMatch = !!authorizedUrls.find((authorizedUrl) => {\n            // Matches something like `https://*.example.com` against the urlWithoutPath\n            const regex = new RegExp(authorizedUrl.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'))\n            return urlWithoutPath.match(regex)\n        })\n\n        if (wildcardMatch) {\n            return true\n        }\n    } catch {\n        // Ignore invalid URLs\n    }\n\n    return false\n}\n\nexport interface SuggestedDomain {\n    url: string\n    count: number\n}\n\nexport const filterNotAuthorizedUrls = (\n    suggestions: SuggestedDomain[],\n    authorizedUrls: string[]\n): SuggestedDomain[] => {\n    const suggestedDomains: SuggestedDomain[] = []\n\n    suggestions.forEach(({ url, count }) => {\n        const parsedUrl = sanitizePossibleWildCardedURL(url)\n        const urlWithoutPath = parsedUrl.protocol + '//' + parsedUrl.host\n        // Have we already added this domain?\n        if (suggestedDomains.some((sd) => sd.url === urlWithoutPath)) {\n            return\n        }\n\n        if (!checkUrlIsAuthorized(parsedUrl, authorizedUrls)) {\n            suggestedDomains.push({ url: urlWithoutPath, count })\n        }\n    })\n\n    return suggestedDomains\n}\n\nexport const NEW_URL = 'https://'\n\nexport interface KeyedAppUrl {\n    url: string\n    type: 'authorized' | 'suggestion'\n    originalIndex: number\n    // how many seen in the last three days\n    count?: number\n}\n\nexport interface AuthorizedUrlListLogicProps {\n    actionId: number | null\n    experimentId: ExperimentIdType | null\n    type: AuthorizedUrlListType\n    allowWildCards?: boolean\n}\n\nexport const defaultAuthorizedUrlProperties = {\n    actionId: null,\n    experimentId: null,\n}\n\nexport const authorizedUrlListLogic = kea<authorizedUrlListLogicType>([\n    path((key) => ['lib', 'components', 'AuthorizedUrlList', 'authorizedUrlListLogic', key]),\n    key((props) => `${props.type}-${props.experimentId}-${props.actionId}`), // Some will be undefined but that's ok, this avoids experiment/action with same ID sharing same store\n    props({} as AuthorizedUrlListLogicProps),\n    connect(() => ({\n        values: [teamLogic, ['currentTeam', 'currentTeamId']],\n        actions: [teamLogic, ['updateCurrentTeam']],\n    })),\n    actions(() => ({\n        setAuthorizedUrls: (authorizedUrls: string[]) => ({ authorizedUrls }),\n        addUrl: (url: string, launch?: boolean) => ({ url, launch }),\n        newUrl: true,\n        removeUrl: (index: number) => ({ index }),\n        updateUrl: (index: number, url: string) => ({ index, url }),\n        launchAtUrl: (url: string) => ({ url }),\n        setEditUrlIndex: (originalIndex: number | null) => ({ originalIndex }),\n        cancelProposingUrl: true,\n        copyLaunchCode: (url: string) => ({ url }),\n    })),\n    loaders(({ values, props }) => ({\n        suggestions: {\n            __default: [] as SuggestedDomain[],\n            loadSuggestions: async () => {\n                const query = hogql`\n                    select properties.$current_url, count()\n                    from events\n                        where event = '$pageview'\n                        and timestamp >= now() - interval 3 day \n                        and timestamp <= now()\n                        and properties.$current_url is not null\n                        group by properties.$current_url\n                        order by count() desc\n                    limit 25`\n\n                const response = await api.queryHogQL(query)\n                const result = response.results as [string, number][]\n\n                if (result && result.length === 0) {\n                    return []\n                }\n\n                const suggestedDomains = filterNotAuthorizedUrls(\n                    result.map(([url, count]) => ({ url, count })),\n                    values.authorizedUrls\n                )\n\n                return suggestedDomains.slice(0, 20)\n            },\n        },\n        manualLaunchParams: {\n            loadManualLaunchParams: async (url: string): Promise<string | undefined> => {\n                const response = await api.get(\n                    appEditorUrl(url, {\n                        ...(props?.actionId ? { actionId: props.actionId } : {}),\n                        ...(props?.experimentId ? { experimentId: props.experimentId } : {}),\n                        generateOnly: true,\n                    })\n                )\n\n                let decoded: string | undefined = undefined\n                try {\n                    if (response?.toolbarParams) {\n                        decoded = decodeURIComponent(response.toolbarParams)\n                    }\n                } catch {\n                    lemonToast.error('Failed to generate toolbar params')\n                }\n                return decoded\n            },\n        },\n    })),\n    subscriptions(({ props, actions }) => ({\n        currentTeam: (currentTeam) => {\n            const urls =\n                (props.type === AuthorizedUrlListType.RECORDING_DOMAINS\n                    ? currentTeam.recording_domains\n                    : currentTeam.app_urls) || []\n            actions.setAuthorizedUrls(urls.filter(Boolean))\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadSuggestions()\n    }),\n    forms(({ values, actions, props }) => ({\n        proposedUrl: {\n            defaults: { url: '' } as ProposeNewUrlFormType,\n            errors: ({ url }) => ({\n                // default to allowing wildcards because that was the original behavior\n                url: validateProposedUrl(\n                    url,\n                    values.authorizedUrls,\n                    values.onlyAllowDomains,\n                    props.allowWildCards ?? true\n                ),\n            }),\n            submit: async ({ url }) => {\n                if (values.editUrlIndex !== null && values.editUrlIndex >= 0) {\n                    actions.updateUrl(values.editUrlIndex, url)\n                } else {\n                    actions.addUrl(url)\n                }\n            },\n        },\n    })),\n    reducers(() => ({\n        showProposedURLForm: [\n            false as boolean,\n            {\n                newUrl: () => true,\n                submitProposedUrlSuccess: () => false,\n                cancelProposingUrl: () => false,\n            },\n        ],\n        authorizedUrls: [\n            [] as string[],\n            {\n                setAuthorizedUrls: (_, { authorizedUrls }) => authorizedUrls,\n                addUrl: (state, { url }) => (url && !state.includes(url) ? state.concat([url]) : state),\n                updateUrl: (state, { index, url }) => (url ? Object.assign([...state], { [index]: url }) : state),\n                removeUrl: (state, { index }) => {\n                    const newUrls = [...state]\n                    newUrls.splice(index, 1)\n                    return newUrls\n                },\n            },\n        ],\n        suggestions: [\n            [],\n            {\n                addUrl: (state, { url }) => [...state].filter((sd) => url !== sd.url),\n            },\n        ],\n        editUrlIndex: [\n            null as number | null,\n            {\n                setEditUrlIndex: (_, { originalIndex }) => originalIndex,\n                removeUrl: (editUrlIndex, { index }) =>\n                    editUrlIndex && index < editUrlIndex\n                        ? editUrlIndex - 1\n                        : index === editUrlIndex\n                          ? null\n                          : editUrlIndex,\n                newUrl: () => -1,\n                updateUrl: () => null,\n                addUrl: () => null,\n                cancelProposingUrl: () => null,\n            },\n        ],\n    })),\n    sharedListeners(({ values, props }) => ({\n        saveUrls: async () => {\n            if (props.type === AuthorizedUrlListType.RECORDING_DOMAINS) {\n                await teamLogic.asyncActions.updateCurrentTeam({ recording_domains: values.authorizedUrls })\n            } else {\n                await teamLogic.asyncActions.updateCurrentTeam({ app_urls: values.authorizedUrls })\n            }\n        },\n    })),\n    listeners(({ sharedListeners, values, actions }) => ({\n        setEditUrlIndex: () => {\n            actions.setProposedUrlValue('url', values.urlToEdit)\n        },\n        newUrl: () => {\n            actions.setProposedUrlValue('url', NEW_URL)\n        },\n        addUrl: [\n            sharedListeners.saveUrls,\n            ({ url, launch }) => {\n                if (launch) {\n                    actions.launchAtUrl(url)\n                }\n            },\n        ],\n        removeUrl: sharedListeners.saveUrls,\n        updateUrl: sharedListeners.saveUrls,\n        launchAtUrl: ({ url }) => {\n            window.location.href = values.launchUrl(url)\n        },\n        cancelProposingUrl: () => {\n            actions.resetProposedUrl()\n        },\n        submitProposedUrlSuccess: () => {\n            actions.setEditUrlIndex(null)\n            actions.resetProposedUrl()\n        },\n        copyLaunchCode: ({ url }) => {\n            actions.loadManualLaunchParams(url)\n        },\n        loadManualLaunchParamsSuccess: async ({ manualLaunchParams }) => {\n            if (manualLaunchParams) {\n                const templateScript = `\n                if (!window?.posthog) {\n                    console.warn('PostHog must be added to the window object on this page, for this to work. This is normally done in the loaded callback of your posthog init code.')\n                } else {\n                    window.posthog.loadToolbar(${manualLaunchParams})\n                }\n                `\n                await copyToClipboard(templateScript, 'code to paste into the console')\n            }\n        },\n    })),\n    selectors({\n        urlToEdit: [\n            (s) => [s.authorizedUrls, s.editUrlIndex],\n            (authorizedUrls, editUrlIndex) => {\n                if (editUrlIndex === null || editUrlIndex === -1) {\n                    return NEW_URL\n                }\n                return authorizedUrls[editUrlIndex]\n            },\n        ],\n        urlsKeyed: [\n            (s) => [s.authorizedUrls, s.suggestions],\n            (authorizedUrls, suggestions): KeyedAppUrl[] => {\n                const keyedUrls = authorizedUrls\n                    .map((url, index) => ({\n                        url,\n                        type: 'authorized',\n                        originalIndex: index,\n                    }))\n                    .concat(\n                        suggestions.map(({ url, count }, index) => ({\n                            url,\n                            type: 'suggestion',\n                            originalIndex: index,\n                            count,\n                        }))\n                    ) as KeyedAppUrl[]\n\n                return keyedUrls\n            },\n        ],\n        launchUrl: [\n            (_, p) => [p.actionId, p.experimentId],\n            (actionId, experimentId) => (url: string) => {\n                if (experimentId) {\n                    return appEditorUrl(url, {\n                        experimentId,\n                    })\n                }\n\n                return appEditorUrl(url, {\n                    actionId,\n                })\n            },\n        ],\n        isAddUrlFormVisible: [(s) => [s.editUrlIndex], (editUrlIndex) => editUrlIndex === -1],\n        onlyAllowDomains: [(_, p) => [p.type], (type) => type === AuthorizedUrlListType.RECORDING_DOMAINS],\n\n        checkUrlIsAuthorized: [\n            (s) => [s.authorizedUrls],\n            (authorizedUrls) => (url: string) => {\n                return checkUrlIsAuthorized(url, authorizedUrls)\n            },\n        ],\n    }),\n    urlToAction(({ actions }) => ({\n        [urls.toolbarLaunch()]: (_, searchParams) => {\n            if (searchParams.addNew) {\n                actions.newUrl()\n            }\n        },\n    })),\n])\n","import { connect, kea, path, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { subscriptions } from 'kea-subscriptions'\n\nimport api from 'lib/api'\nimport { membersLogic } from 'scenes/organization/membersLogic'\n\nimport { sidePanelContextLogic } from '~/layout/navigation-3000/sidepanel/panels/sidePanelContextLogic'\nimport { SidePanelSceneContext } from '~/layout/navigation-3000/sidepanel/types'\nimport { hogql } from '~/queries/utils'\n\nimport type { metalyticsLogicType } from './metalyticsLogicType'\n\nexport const metalyticsLogic = kea<metalyticsLogicType>([\n    path(['lib', 'components', 'metalytics', 'metalyticsLogic']),\n    connect(() => ({\n        values: [sidePanelContextLogic, ['sceneSidePanelContext'], membersLogic, ['members']],\n    })),\n\n    loaders(({ values }) => ({\n        viewCount: [\n            null as { views: number; users: number } | null,\n            {\n                loadViewCount: async () => {\n                    const query = hogql`\n                        SELECT SUM(count) AS count, COUNT(DISTINCT app_source_id) AS unique_users\n                        FROM app_metrics\n                        WHERE app_source = 'metalytics'\n                        AND instance_id = ${values.instanceId}`\n\n                    // NOTE: I think this gets cached heavily - how to correctly invalidate?\n                    const response = await api.queryHogQL(query, { refresh: 'force_blocking' })\n                    const result = response.results as number[][]\n                    return {\n                        views: result[0][0],\n                        users: result[0][1],\n                    }\n                },\n            },\n        ],\n        recentUsers: [\n            [] as string[],\n            {\n                loadUsersLast30days: async () => {\n                    const query = hogql`\n                        SELECT DISTINCT app_source_id\n                        FROM app_metrics\n                        WHERE app_source = 'metalytics'\n                        AND instance_id = ${values.instanceId}\n                        AND timestamp >= NOW() - INTERVAL 30 DAY\n                        ORDER BY timestamp DESC`\n\n                    const response = await api.queryHogQL(query, { refresh: 'force_blocking' })\n                    return response.results.map((result) => result[0]) as string[]\n                },\n            },\n        ],\n    })),\n\n    selectors({\n        instanceId: [\n            (s) => [s.sceneSidePanelContext],\n            (sidePanelContext: SidePanelSceneContext) =>\n                sidePanelContext?.activity_item_id\n                    ? `${sidePanelContext.activity_scope}:${sidePanelContext.activity_item_id}`\n                    : null,\n        ],\n        scope: [\n            (s) => [s.sceneSidePanelContext],\n            (sidePanelContext: SidePanelSceneContext) => sidePanelContext?.activity_scope,\n        ],\n\n        recentUserMembers: [\n            (s) => [s.recentUsers, s.members],\n            (recentUsers, members) => {\n                if (!members || !recentUsers) {\n                    return []\n                }\n                // Filter members whose IDs match the recentUsers array\n                const filteredMembers = members.filter((member) => recentUsers.includes(String(member.user.id)))\n                return filteredMembers\n            },\n        ],\n    }),\n\n    subscriptions(({ actions }) => ({\n        instanceId: async (instanceId) => {\n            if (instanceId) {\n                actions.loadViewCount()\n                actions.loadUsersLast30days()\n\n                await api.create('/api/projects/@current/metalytics/', {\n                    metric_name: 'viewed',\n                    instance_id: instanceId,\n                })\n            }\n        },\n    })),\n])\n","import './SharingModal.scss'\n\nimport { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\nimport { router } from 'kea-router'\nimport posthog from 'posthog-js'\nimport { ReactNode, useEffect, useState } from 'react'\n\nimport { IconCollapse, IconExpand, IconInfo, IconLock } from '@posthog/icons'\nimport { LemonBanner, LemonButton, LemonDivider, LemonModal, LemonSkeleton, LemonSwitch } from '@posthog/lemon-ui'\n\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { TemplateLinkSection } from 'lib/components/Sharing/TemplateLinkSection'\nimport { TEMPLATE_LINK_HEADING, TEMPLATE_LINK_PII_WARNING } from 'lib/components/Sharing/templateLinkMessages'\nimport { TitleWithIcon } from 'lib/components/TitleWithIcon'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { LemonDialog } from 'lib/lemon-ui/LemonDialog'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { Spinner } from 'lib/lemon-ui/Spinner/Spinner'\nimport { Tooltip } from 'lib/lemon-ui/Tooltip'\nimport { IconLink } from 'lib/lemon-ui/icons'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { accessLevelSatisfied } from 'lib/utils/accessControlUtils'\nimport { copyToClipboard } from 'lib/utils/copyToClipboard'\nimport { getInsightDefinitionUrl } from 'lib/utils/insightLinks'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { insightVizDataLogic } from 'scenes/insights/insightVizDataLogic'\nimport { projectLogic } from 'scenes/projectLogic'\nimport { urls } from 'scenes/urls'\n\nimport { AccessControlPopoutCTA } from '~/layout/navigation-3000/sidepanel/panels/access_control/AccessControlPopoutCTA'\nimport { AnyResponseType, Node } from '~/queries/schema/schema-general'\nimport { isDataTableNode, isDataVisualizationNode, isInsightVizNode } from '~/queries/utils'\nimport {\n    AccessControlLevel,\n    AccessControlResourceType,\n    AvailableFeature,\n    InsightShortId,\n    QueryBasedInsightModel,\n} from '~/types'\n\nimport { AccessControlAction } from '../AccessControlAction'\nimport { upgradeModalLogic } from '../UpgradeModal/upgradeModalLogic'\nimport { SharePasswordsTable } from './SharePasswordsTable'\nimport { sharingLogic } from './sharingLogic'\n\nfunction getResourceType(\n    dashboardId?: number,\n    insightShortId?: InsightShortId,\n    recordingId?: string\n): AccessControlResourceType {\n    if (dashboardId) {\n        return AccessControlResourceType.Dashboard\n    }\n    if (insightShortId) {\n        return AccessControlResourceType.Insight\n    }\n    if (recordingId) {\n        return AccessControlResourceType.SessionRecording\n    }\n    return AccessControlResourceType.Project\n}\n\nexport const SHARING_MODAL_WIDTH = 600\n\nexport interface SharingModalBaseProps {\n    dashboardId?: number\n    insightShortId?: InsightShortId\n    insight?: Partial<QueryBasedInsightModel>\n    cachedResults?: AnyResponseType\n    recordingId?: string\n\n    title?: string\n    previewIframe?: boolean\n    additionalParams?: Record<string, any>\n    /**\n     * When generating a link to a recording, this form can be used to allow the user to specify a timestamp\n     */\n    recordingLinkTimeForm?: ReactNode\n    userAccessLevel?: AccessControlLevel\n}\n\nexport interface SharingModalProps extends SharingModalBaseProps {\n    isOpen: boolean\n    closeModal: () => void\n    inline?: boolean\n}\n\nexport function SharingModalContent({\n    dashboardId,\n    insightShortId,\n    insight,\n    cachedResults,\n    recordingId,\n    additionalParams,\n    previewIframe = false,\n    recordingLinkTimeForm = undefined,\n    userAccessLevel,\n}: SharingModalBaseProps): JSX.Element {\n    const logicProps = {\n        dashboardId,\n        insightShortId,\n        recordingId,\n        additionalParams,\n    }\n    const {\n        whitelabelAvailable,\n        advancedPermissionsAvailable,\n        sharingConfiguration,\n        sharingConfigurationLoading,\n        showPreview,\n        embedCode,\n        iframeProperties,\n        shareLink,\n        sharingAllowed,\n    } = useValues(sharingLogic(logicProps))\n    const { setIsEnabled, setPasswordRequired, togglePreview, setSharingSettingsValue } = useActions(\n        sharingLogic(logicProps)\n    )\n    const { guardAvailableFeature } = useValues(upgradeModalLogic)\n    const { preflight } = useValues(preflightLogic)\n    const siteUrl = preflight?.site_url || window.location.origin\n    const { featureFlags } = useValues(featureFlagLogic)\n    const passwordProtectedSharesEnabled = !!featureFlags[FEATURE_FLAGS.PASSWORD_PROTECTED_SHARES]\n    const { currentProjectId } = useValues(projectLogic)\n\n    const { push } = useActions(router)\n\n    const [iframeLoaded, setIframeLoaded] = useState(false)\n\n    const renderQueryUrl = insight?.query ? new URL('render_query', siteUrl).toString() : null\n    const renderQuerySnippet = renderQueryUrl\n        ? createRenderQuerySnippet({\n              renderQueryUrl,\n              iframeId: getRenderQueryIframeId(insightShortId),\n              cachedResults,\n              query: insight?.query,\n          })\n        : null\n\n    const apiQueryUrl =\n        insight?.query && currentProjectId\n            ? new URL(`api/projects/${currentProjectId}/query/`, siteUrl).toString()\n            : null\n    const apiQuerySnippet = apiQueryUrl\n        ? createApiQuerySnippet({\n              apiQueryUrl,\n              query: insight?.query\n                  ? isInsightVizNode(insight.query) ||\n                    isDataVisualizationNode(insight.query) ||\n                    isDataTableNode(insight.query)\n                      ? insight.query.source\n                      : insight.query\n                  : null,\n          })\n        : null\n\n    const resource = dashboardId ? 'dashboard' : insightShortId ? 'insight' : recordingId ? 'recording' : 'this'\n    const hasEditAccess = userAccessLevel\n        ? accessLevelSatisfied(resource as AccessControlResourceType, userAccessLevel, AccessControlLevel.Editor)\n        : true\n\n    useEffect(() => {\n        setIframeLoaded(false)\n    }, [iframeProperties.src, iframeProperties.key, sharingConfiguration?.enabled, showPreview])\n\n    return (\n        <div className=\"deprecated-space-y-4\">\n            {dashboardId ? (\n                <>\n                    <AccessControlPopoutCTA\n                        resourceType={AccessControlResourceType.Dashboard}\n                        callback={() => {\n                            push(urls.dashboard(dashboardId))\n                        }}\n                    />\n                    <LemonDivider />\n                </>\n            ) : undefined}\n\n            {insightShortId ? (\n                <>\n                    <AccessControlPopoutCTA\n                        resourceType={AccessControlResourceType.Insight}\n                        callback={() => {\n                            push(urls.insightView(insightShortId))\n                        }}\n                    />\n                    <LemonDivider />\n                </>\n            ) : undefined}\n\n            <div className=\"deprecated-space-y-2\">\n                {!sharingConfiguration && sharingConfigurationLoading ? (\n                    <LemonSkeleton.Row repeat={3} />\n                ) : !sharingConfiguration ? (\n                    <p>Something went wrong...</p>\n                ) : (\n                    <>\n                        <h3>Sharing</h3>\n                        {!sharingAllowed ? (\n                            <LemonBanner type=\"warning\">Public sharing is disabled for this organization.</LemonBanner>\n                        ) : (\n                            <AccessControlAction\n                                resourceType={getResourceType(dashboardId, insightShortId, recordingId)}\n                                minAccessLevel={AccessControlLevel.Editor}\n                                userAccessLevel={userAccessLevel}\n                            >\n                                <LemonSwitch\n                                    id=\"sharing-switch\"\n                                    label={`Share ${resource} publicly`}\n                                    checked={sharingConfiguration.enabled}\n                                    data-attr=\"sharing-switch\"\n                                    onChange={(active) => setIsEnabled(active)}\n                                    bordered\n                                    fullWidth\n                                    loading={sharingConfigurationLoading}\n                                />\n                            </AccessControlAction>\n                        )}\n\n                        {sharingAllowed && sharingConfiguration.enabled && sharingConfiguration.access_token ? (\n                            <>\n                                <div className=\"deprecated-space-y-2\">\n                                    {passwordProtectedSharesEnabled && (\n                                        <div className=\"LemonSwitch LemonSwitch--medium LemonSwitch--bordered LemonSwitch--full-width flex-col py-1.5\">\n                                            <LemonSwitch\n                                                className=\"px-0\"\n                                                fullWidth\n                                                label={\n                                                    <div className=\"flex items-center\">\n                                                        Password protect\n                                                        {!advancedPermissionsAvailable && (\n                                                            <Tooltip title=\"This is a premium feature, click to learn more.\">\n                                                                <IconLock className=\"ml-1.5 text-muted text-lg\" />\n                                                            </Tooltip>\n                                                        )}\n                                                    </div>\n                                                }\n                                                onChange={(passwordRequired: boolean) =>\n                                                    guardAvailableFeature(AvailableFeature.ADVANCED_PERMISSIONS, () =>\n                                                        setPasswordRequired(passwordRequired)\n                                                    )\n                                                }\n                                                checked={sharingConfiguration.password_required}\n                                            />\n                                            {sharingConfiguration.password_required && (\n                                                <div className=\"mt-1 w-full\">\n                                                    <SharePasswordsTable\n                                                        dashboardId={dashboardId}\n                                                        insightId={insight?.id}\n                                                        recordingId={recordingId}\n                                                    />\n                                                </div>\n                                            )}\n                                        </div>\n                                    )}\n                                    <LemonButton\n                                        data-attr=\"sharing-link-button\"\n                                        type=\"secondary\"\n                                        onClick={() => {\n                                            // TRICKY: there's a chance this was sending useless errors to error tracking\n                                            // even when it succeeded, so we're explicitly ignoring the promise success\n                                            // and naming the error when reported to error tracking - @pauldambra\n                                            copyToClipboard(shareLink, shareLink).catch((e) =>\n                                                posthog.captureException(\n                                                    new Error('unexpected sharing modal clipboard error: ' + e.message)\n                                                )\n                                            )\n                                        }}\n                                        icon={<IconLink />}\n                                        fullWidth\n                                        className=\"mb-4\"\n                                    >\n                                        Copy public link\n                                    </LemonButton>\n                                    {recordingLinkTimeForm}\n                                    <TitleWithIcon\n                                        icon={\n                                            <Tooltip\n                                                title={`Use the HTML snippet below to embed the ${resource} on your website`}\n                                            >\n                                                <IconInfo />\n                                            </Tooltip>\n                                        }\n                                    >\n                                        <b>Embed {resource}</b>\n                                    </TitleWithIcon>\n                                    <CodeSnippet language={Language.HTML}>{embedCode}</CodeSnippet>\n                                </div>\n                                {hasEditAccess && (\n                                    <Form\n                                        logic={sharingLogic}\n                                        props={logicProps}\n                                        formKey=\"sharingSettings\"\n                                        className=\"deprecated-space-y-2\"\n                                    >\n                                        <div className=\"grid grid-cols-2 gap-2 grid-flow *:odd:last:col-span-2\">\n                                            {insight && (\n                                                <LemonField name=\"noHeader\">\n                                                    {({ value, onChange }) => (\n                                                        <LemonSwitch\n                                                            fullWidth\n                                                            bordered\n                                                            label={<div>Show title and description</div>}\n                                                            onChange={() => onChange(!value)}\n                                                            checked={!value}\n                                                        />\n                                                    )}\n                                                </LemonField>\n                                            )}\n                                            <LemonField name=\"whitelabel\">\n                                                {({ value }) => (\n                                                    <LemonSwitch\n                                                        fullWidth\n                                                        bordered\n                                                        label={\n                                                            <div className=\"flex items-center\">\n                                                                <span>Show PostHog branding</span>\n                                                                {!whitelabelAvailable && (\n                                                                    <Tooltip title=\"This is a premium feature, click to learn more.\">\n                                                                        <IconLock className=\"ml-1.5 text-secondary text-lg\" />\n                                                                    </Tooltip>\n                                                                )}\n                                                            </div>\n                                                        }\n                                                        onChange={() =>\n                                                            guardAvailableFeature(\n                                                                AvailableFeature.WHITE_LABELLING,\n                                                                () => {\n                                                                    // setSharingSettingsValue is used to update the form state and report the event\n                                                                    setSharingSettingsValue('whitelabel', !value)\n                                                                }\n                                                            )\n                                                        }\n                                                        checked={!value}\n                                                    />\n                                                )}\n                                            </LemonField>\n\n                                            {isInsightVizNode(insight?.query) && insightShortId && (\n                                                // These options are only valid for `InsightVizNode`s, and they rely on `insightVizDataLogic`\n                                                <>\n                                                    <LegendCheckbox insightShortId={insightShortId} />\n                                                    <DetailedResultsCheckbox insightShortId={insightShortId} />\n                                                </>\n                                            )}\n\n                                            {recordingId && (\n                                                <LemonField name=\"showInspector\">\n                                                    {({ value, onChange }) => (\n                                                        <LemonSwitch\n                                                            fullWidth\n                                                            bordered\n                                                            label={<div>Show inspector panel</div>}\n                                                            onChange={onChange}\n                                                            checked={value}\n                                                        />\n                                                    )}\n                                                </LemonField>\n                                            )}\n\n                                            {dashboardId && (\n                                                <LemonField name=\"hideExtraDetails\">\n                                                    {({ value, onChange }) => (\n                                                        <LemonSwitch\n                                                            fullWidth\n                                                            bordered\n                                                            label={\n                                                                <div className=\"flex items-center\">\n                                                                    <span>Show insight details</span>\n                                                                    <Tooltip title=\"When disabled, viewers won't see the extra insights details like the who created the insight and the applied filters.\">\n                                                                        <IconInfo className=\"ml-1.5 text-secondary text-lg\" />\n                                                                    </Tooltip>\n                                                                </div>\n                                                            }\n                                                            onChange={() => onChange(!value)}\n                                                            checked={!value}\n                                                        />\n                                                    )}\n                                                </LemonField>\n                                            )}\n                                        </div>\n\n                                        {previewIframe && (\n                                            <div className=\"rounded border\">\n                                                <LemonButton\n                                                    fullWidth\n                                                    sideIcon={showPreview ? <IconCollapse /> : <IconExpand />}\n                                                    onClick={togglePreview}\n                                                >\n                                                    Preview\n                                                    {showPreview && !iframeLoaded ? <Spinner className=\"ml-2\" /> : null}\n                                                </LemonButton>\n                                                {showPreview && (\n                                                    <div className=\"SharingPreview border-t\">\n                                                        <iframe\n                                                            className=\"block\"\n                                                            {...iframeProperties}\n                                                            onLoad={() => setIframeLoaded(true)}\n                                                        />\n                                                    </div>\n                                                )}\n                                            </div>\n                                        )}\n                                    </Form>\n                                )}\n                            </>\n                        ) : null}\n                    </>\n                )}\n            </div>\n            {insight?.query && (\n                <>\n                    <LemonDivider />\n                    <TemplateLinkSection\n                        collapsible\n                        defaultExpanded={false}\n                        templateLink={getInsightDefinitionUrl({ query: insight.query }, siteUrl)}\n                        heading={TEMPLATE_LINK_HEADING}\n                        piiWarning={TEMPLATE_LINK_PII_WARNING}\n                        copyButtonLabel=\"Copy link\"\n                    />\n                    {renderQuerySnippet && (\n                        <>\n                            <TemplateLinkSection\n                                collapsible\n                                defaultExpanded={false}\n                                templateLink={renderQuerySnippet}\n                                heading=\"Static iframe embed with pre-computed data\"\n                                piiWarning=\"Add this iframe to any site to embed a static PostHog chart. It will look identical to the chart you see here, but nothing will be editable. If any data is sensitive, consider that before sharing.\"\n                            />\n                            {apiQuerySnippet && (\n                                <TemplateLinkSection\n                                    templateLink={apiQuerySnippet}\n                                    heading=\"Fetch latest results for this insight\"\n                                    piiWarning='Use this snippet to retrieve the freshest results for the insight. Replace the \"cachedResults\" section in the iframe&apos;s payload with the results of this call to update it.'\n                                    collapsible\n                                    defaultExpanded={false}\n                                />\n                            )}\n                        </>\n                    )}\n                </>\n            )}\n        </div>\n    )\n}\n\nfunction getRenderQueryIframeId(insightShortId?: InsightShortId): string {\n    const suffix = (insightShortId || 'insight').replace(/[^a-zA-Z0-9_-]/g, '')\n    return `posthog-render-query-${suffix || 'embed'}`\n}\n\nfunction createRenderQuerySnippet({\n    renderQueryUrl,\n    iframeId,\n    cachedResults,\n    query,\n}: {\n    renderQueryUrl: string\n    iframeId: string\n    cachedResults: AnyResponseType | Partial<QueryBasedInsightModel> | null | undefined\n    query: Node | null | undefined\n}): string {\n    const preparedResults = prepareCachedResultsForSnippet(cachedResults)\n    const serializedResults = indentMultiline(JSON.stringify(preparedResults, null, 2), 8)\n    const serializedQuery = indentMultiline(JSON.stringify(query ?? null, null, 2), 8)\n    const escapedResults = escapeScriptJson(serializedResults)\n    const escapedQuery = escapeScriptJson(serializedQuery)\n\n    return `<iframe id=\"${iframeId}\" src=\"${renderQueryUrl}\" style=\"width: 100%; height: 600px; border: 0;\" loading=\"lazy\"></iframe>\n<script>\n  (function () {\n    const iframe = document.getElementById('${iframeId}')\n    if (!iframe) {\n      return\n    }\n    const payload = {\n        query: ${escapedQuery},\n        cachedResults: ${escapedResults},\n    }\n    const targetOrigin = new URL(${JSON.stringify(renderQueryUrl)}).origin\n    function send() {\n      if (!iframe.contentWindow) {\n        return\n      }\n      iframe.contentWindow.postMessage(payload, targetOrigin)\n    }\n    iframe.addEventListener('load', send)\n    send()\n  })()\n</script>`\n}\n\nfunction createApiQuerySnippet({\n    apiQueryUrl,\n    query,\n}: {\n    apiQueryUrl: string\n    query: Node | null | undefined\n}): string {\n    const serializedQuery = indentMultiline(JSON.stringify(query ?? null, null, 2), 8)\n    const escapedQuery = escapeScriptJson(serializedQuery)\n\n    return `fetch(${JSON.stringify(apiQueryUrl)}, {\n    method: 'POST',\n    headers: {\n        Authorization: 'Bearer <PERSONAL_API_KEY>',\n        'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n        query: ${escapedQuery},\n    }),\n})\n    .then((response) => response.json())\n    .then((data) => {\n        console.log('Latest results', data)\n    })`\n}\n\nfunction escapeScriptJson(value: string): string {\n    return value.replace(/</g, '\\\\u003C').replace(/>/g, '\\\\u003E').replace(/&/g, '\\\\u0026')\n}\n\nfunction indentMultiline(value: string, indent: number): string {\n    const indentation = ' '.repeat(indent)\n    return value\n        .split('\\n')\n        .map((line, index) => (index === 0 ? line : `${indentation}${line}`))\n        .join('\\n')\n}\n\nfunction prepareCachedResultsForSnippet(\n    cachedResults: AnyResponseType | Partial<QueryBasedInsightModel> | null | undefined\n): AnyResponseType | Partial<QueryBasedInsightModel> | null {\n    if (!cachedResults) {\n        return null\n    }\n\n    if (Array.isArray(cachedResults)) {\n        return cachedResults\n    }\n\n    if (typeof cachedResults !== 'object') {\n        return cachedResults\n    }\n\n    const source = cachedResults as Record<string, any>\n    const allowedKeys = [\n        'cache_key',\n        'error',\n        'results',\n        'last_refresh',\n        'next_allowed_client_refresh',\n        'timezone',\n        'query_metadata',\n    ]\n    const trimmed: Record<string, any> = {}\n\n    for (const key of allowedKeys) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            const value = source[key]\n            if (value !== undefined) {\n                trimmed[key] = value\n            }\n        }\n    }\n\n    if (trimmed.results === undefined && Object.prototype.hasOwnProperty.call(source, 'result')) {\n        const value = source.result\n        if (value !== undefined) {\n            trimmed.results = value\n        }\n    }\n\n    return Object.keys(trimmed).length > 0 ? trimmed : null\n}\n\nfunction DetailedResultsCheckbox({ insightShortId }: { insightShortId: InsightShortId }): JSX.Element | null {\n    const { hasDetailedResultsTable } = useValues(insightVizDataLogic({ dashboardItemId: insightShortId }))\n\n    if (!hasDetailedResultsTable) {\n        return null // No detailed results toggle\n    }\n\n    return (\n        <LemonField name=\"detailed\">\n            {({ value, onChange }) => (\n                <LemonSwitch\n                    fullWidth\n                    bordered\n                    label=\"Show detailed results\"\n                    onChange={() => onChange(!value)}\n                    checked={value}\n                />\n            )}\n        </LemonField>\n    )\n}\n\nfunction LegendCheckbox({ insightShortId }: { insightShortId: InsightShortId }): JSX.Element | null {\n    const { hasLegend } = useValues(insightVizDataLogic({ dashboardItemId: insightShortId }))\n\n    if (!hasLegend) {\n        return null // No legend to toggle\n    }\n\n    return (\n        <LemonField name=\"legend\">\n            {({ value, onChange }) => (\n                <LemonSwitch fullWidth bordered label=\"Show legend\" onChange={() => onChange(!value)} checked={value} />\n            )}\n        </LemonField>\n    )\n}\n\nexport function SharingModal({ closeModal, isOpen, inline, title, ...props }: SharingModalProps): JSX.Element {\n    return (\n        <LemonModal\n            onClose={closeModal}\n            isOpen={isOpen}\n            width={SHARING_MODAL_WIDTH}\n            title={title ?? 'Sharing'}\n            footer={\n                <LemonButton type=\"secondary\" onClick={closeModal}>\n                    Done\n                </LemonButton>\n            }\n            inline={inline}\n        >\n            <SharingModalContent {...props} />\n        </LemonModal>\n    )\n}\n\nSharingModal.open = (props: SharingModalBaseProps) => {\n    LemonDialog.open({\n        title: props.title ?? 'Sharing',\n        content: (\n            <>\n                <SharingModalContent {...props} />\n            </>\n        ),\n        width: SHARING_MODAL_WIDTH,\n        primaryButton: {\n            children: 'Close',\n            type: 'secondary',\n        },\n    })\n}\n","import { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\nimport { useRef } from 'react'\n\nimport { IconBug, IconInfo, IconQuestion } from '@posthog/icons'\nimport {\n    LemonBanner,\n    LemonInput,\n    LemonSegmentedButton,\n    LemonSegmentedButtonOption,\n    Link,\n    Tooltip,\n    lemonToast,\n} from '@posthog/lemon-ui'\n\nimport { useUploadFiles } from 'lib/hooks/useUploadFiles'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonFileInput } from 'lib/lemon-ui/LemonFileInput/LemonFileInput'\nimport { LemonSelect } from 'lib/lemon-ui/LemonSelect/LemonSelect'\nimport { LemonTextArea } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { IconFeedback } from 'lib/lemon-ui/icons'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport {\n    SEVERITY_LEVEL_TO_NAME,\n    SUPPORT_TICKET_TEMPLATES,\n    SupportTicketKind,\n    TARGET_AREA_TO_NAME,\n    supportLogic,\n} from './supportLogic'\n\nconst SUPPORT_TICKET_OPTIONS: LemonSegmentedButtonOption<SupportTicketKind>[] = [\n    {\n        value: 'support',\n        label: 'Question',\n        icon: <IconQuestion />,\n    },\n    {\n        value: 'feedback',\n        label: 'Feedback',\n        icon: <IconFeedback />,\n    },\n    {\n        value: 'bug',\n        label: 'Bug',\n        icon: <IconBug />,\n    },\n]\n\nconst SUPPORT_TICKET_KIND_TO_PROMPT: Record<SupportTicketKind, string> = {\n    bug: \"What's the bug?\",\n    feedback: 'What feedback do you have?',\n    support: 'What can we help you with?',\n}\n\nexport function SupportForm(): JSX.Element | null {\n    const { sendSupportRequest } = useValues(supportLogic)\n    const { setSendSupportRequestValue } = useActions(supportLogic)\n    const { objectStorageAvailable } = useValues(preflightLogic)\n    // the support model can be shown when logged out, file upload is not offered to anonymous users\n    const { user } = useValues(userLogic)\n    // only allow authentication issues for logged out users\n\n    const dropRef = useRef<HTMLDivElement>(null)\n\n    const handlePaste = (e: React.ClipboardEvent<HTMLDivElement>): void => {\n        const items = e.clipboardData?.items\n        if (!items) {\n            return\n        }\n\n        // Convert DataTransferItemList to array for iteration\n        const itemsArray = Array.from(items)\n        for (const item of itemsArray) {\n            if (item.type.startsWith('image/')) {\n                const file = item.getAsFile()\n                if (file) {\n                    setFilesToUpload([...filesToUpload, file])\n                }\n            }\n        }\n    }\n\n    const { setFilesToUpload, filesToUpload, uploading } = useUploadFiles({\n        onUpload: (url, fileName) => {\n            setSendSupportRequestValue('message', sendSupportRequest.message + `\\n\\nAttachment \"${fileName}\": ${url}`)\n        },\n        onError: (detail) => {\n            lemonToast.error(`Error uploading image: ${detail}`)\n        },\n    })\n\n    const changeKind = (kind: SupportTicketKind): void => {\n        setSendSupportRequestValue('kind', kind)\n        if (kind === 'bug') {\n            setSendSupportRequestValue('severity_level', 'medium')\n        } else {\n            setSendSupportRequestValue('severity_level', 'low')\n        }\n    }\n\n    return (\n        <Form\n            logic={supportLogic}\n            formKey=\"sendSupportRequest\"\n            id=\"support-modal-form\"\n            enableFormOnSubmit\n            className=\"deprecated-space-y-4\"\n        >\n            {!user && (\n                <>\n                    <LemonField name=\"name\" label=\"Name\">\n                        <LemonInput data-attr=\"name\" placeholder=\"Jane\" />\n                    </LemonField>\n                    <LemonField name=\"email\" label=\"Email\">\n                        <LemonInput data-attr=\"email\" placeholder=\"your@email.com\" />\n                    </LemonField>\n                </>\n            )}\n            <LemonField name=\"kind\" label=\"Message type\">\n                <LemonSegmentedButton onChange={changeKind} fullWidth options={SUPPORT_TICKET_OPTIONS} />\n            </LemonField>\n            <LemonField name=\"target_area\" label=\"Topic\">\n                <LemonSelect\n                    disabledReason={\n                        !user\n                            ? 'Please login to your account before opening a ticket unrelated to authentication issues.'\n                            : null\n                    }\n                    fullWidth\n                    options={TARGET_AREA_TO_NAME}\n                />\n            </LemonField>\n            {sendSupportRequest.target_area === 'error_tracking' && (\n                <LemonBanner type=\"warning\">\n                    This topic is for our Error Tracking <i>product</i>. If you're reporting an error in PostHog please\n                    choose the relevant topic so your submission is sent to the correct team.\n                </LemonBanner>\n            )}\n            <LemonField\n                name=\"message\"\n                label={sendSupportRequest.kind ? SUPPORT_TICKET_KIND_TO_PROMPT[sendSupportRequest.kind] : 'Content'}\n            >\n                {(props) => (\n                    <div ref={dropRef} className=\"flex flex-col gap-2\" onPaste={handlePaste}>\n                        <LemonTextArea\n                            placeholder={SUPPORT_TICKET_TEMPLATES[sendSupportRequest.kind] ?? 'Type your message here'}\n                            data-attr=\"support-form-content-input\"\n                            minRows={5}\n                            {...props}\n                        />\n                        {objectStorageAvailable && !!user && (\n                            <LemonFileInput\n                                accept=\"image/*\"\n                                multiple={false}\n                                alternativeDropTargetRef={dropRef}\n                                onChange={setFilesToUpload}\n                                loading={uploading}\n                                value={filesToUpload}\n                            />\n                        )}\n                    </div>\n                )}\n            </LemonField>\n            <div className=\"flex gap-2 flex-col\">\n                <div className=\"flex justify-between items-center\">\n                    <label className=\"LemonLabel\">\n                        Severity level\n                        <Tooltip title=\"Severity levels help us prioritize your request.\">\n                            <span>\n                                <IconInfo className=\"opacity-75\" />\n                            </span>\n                        </Tooltip>\n                    </label>\n                    <Link\n                        target=\"_blank\"\n                        disableDocsPanel\n                        to=\"https://posthog.com/docs/support-options#severity-levels\"\n                    >\n                        Definitions\n                    </Link>\n                </div>\n                <LemonField name=\"severity_level\">\n                    <LemonSelect\n                        fullWidth\n                        options={Object.entries(SEVERITY_LEVEL_TO_NAME).map(([key, value]) => ({\n                            label: value,\n                            value: key,\n                        }))}\n                    />\n                </LemonField>\n            </div>\n        </Form>\n    )\n}\n","// Utility functions for parsing PostHog exception events\n\nexport interface ExceptionMetadata {\n    uuid: string\n    commitSha: string\n    feature: string\n    exceptionType: string\n    exceptionValue: string\n}\n\nexport interface StackTraceInfo {\n    filename: string\n    functionName: string\n    lineNumber: string\n}\n\nexport type ParsedExceptionData = string\n\n/**\n * Extracts basic metadata from a PostHog exception event\n */\nfunction extractExceptionMetadata(event: any): ExceptionMetadata {\n    return {\n        uuid: event?.uuid || 'Unknown',\n        commitSha: event?.properties?.commit_sha || 'Unknown',\n        feature: event?.properties?.feature || 'Unknown',\n        exceptionType: event?.properties?.$exception_list?.[0]?.type || 'Unknown',\n        exceptionValue: event?.properties?.$exception_list?.[0]?.value || 'Unknown',\n    }\n}\n\n/**\n * Extracts stack trace information from exception frames\n */\nfunction extractStackTraceInfo(event: any): StackTraceInfo {\n    let filename = 'Unknown'\n    let functionName = 'Unknown'\n    let lineNumber = 'Unknown'\n\n    const exceptionList = event?.properties?.$exception_list\n    if (exceptionList && Array.isArray(exceptionList) && exceptionList[0]) {\n        const exception = exceptionList[0]\n\n        // Check if there's a stack trace in the exception\n        if (exception.stacktrace && exception.stacktrace.frames) {\n            const frames = exception.stacktrace.frames\n            const appFrames = frames.filter((frame: any) => frame.in_app === true)\n            const componentFrame = appFrames[appFrames.length - 1]\n            if (componentFrame) {\n                filename = componentFrame.filename || 'Unknown'\n                functionName = componentFrame.function || 'Unknown'\n                lineNumber = componentFrame.lineno || 'Unknown'\n            }\n        }\n    }\n\n    return { filename, functionName, lineNumber }\n}\n\n/**\n * Formats exception metadata and stack trace into a readable string\n */\nfunction formatExceptionSummary(metadata: ExceptionMetadata, stackTrace: StackTraceInfo): string {\n    return `UUID: ${metadata.uuid}\nCommit SHA: ${metadata.commitSha}\nFeature: ${metadata.feature}\nType: ${metadata.exceptionType}\nValue: ${metadata.exceptionValue}\nFilename: ${stackTrace.filename}\nFunction: ${stackTrace.functionName}\nLine: ${stackTrace.lineNumber}`\n}\n\n/**\n * Main function to parse a PostHog exception event into a structured format\n */\nexport function parseExceptionEvent(event: any): ParsedExceptionData {\n    const metadata = extractExceptionMetadata(event)\n    const stackTrace = extractStackTraceInfo(event)\n    const parsedData = formatExceptionSummary(metadata, stackTrace)\n\n    return parsedData\n}\n","import { actions, connect, kea, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { urlToAction } from 'kea-router'\nimport posthog from 'posthog-js'\n\nimport api from 'lib/api'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'\nimport { uuid } from 'lib/utils'\nimport { parseExceptionEvent } from 'lib/utils/exceptionUtils'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { billingLogic } from 'scenes/billing/billingLogic'\nimport { organizationLogic } from 'scenes/organizationLogic'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { sidePanelStateLogic } from '~/layout/navigation-3000/sidepanel/sidePanelStateLogic'\nimport {\n    AvailableFeature,\n    BillingPlan,\n    OrganizationBasicType,\n    Region,\n    SidePanelTab,\n    StartupProgramLabel,\n    TeamPublicType,\n    UserType,\n} from '~/types'\n\nimport { openSupportModal } from './SupportModal'\nimport type { supportLogicType } from './supportLogicType'\n\nexport function getPublicSupportSnippet(\n    cloudRegion: Region | null | undefined,\n    currentOrganization: OrganizationBasicType | null,\n    currentTeam: TeamPublicType | null,\n    includeCurrentLocation = true\n): string {\n    if (!cloudRegion) {\n        // we don't call this without region being available, so we return some value so we can see errors in visual regression tests\n        return '🚫'\n    }\n    return (\n        (includeCurrentLocation ? getCurrentLocationLink() : '') +\n        getSessionReplayLink() +\n        `\\nAdmin: http://go/adminOrg${cloudRegion}/${currentOrganization?.id} (project ID ${currentTeam?.id})`\n    ).trimStart()\n}\n\nfunction getCurrentLocationLink(): string {\n    const cleanedCurrentUrl = window.location.href.replace(/panel=support[^&]*(&)?/, '').replace(/#$/, '')\n    return `\\nLocation: ${cleanedCurrentUrl}`\n}\n\nfunction getSessionReplayLink(): string {\n    const replayUrl = posthog\n        .get_session_replay_url({ withTimestamp: true, timestampLookBack: 30 })\n        .replace(window.location.origin + '/replay/', 'http://go/session/')\n    return `\\nSession: ${replayUrl}`\n}\n\nfunction getErrorTrackingLink(uuid?: string): string {\n    const values = [\n        {\n            key: '$session_id',\n            value: [posthog.get_session_id()],\n            operator: 'exact',\n            type: 'event',\n        },\n    ]\n\n    if (uuid) {\n        values.push({\n            type: 'hogql',\n            key: `uuid = '${uuid}'`,\n            value: null,\n        } as any)\n    }\n\n    const filterGroup = encodeURIComponent(\n        JSON.stringify({\n            type: 'AND',\n            values: [\n                {\n                    type: 'AND',\n                    values,\n                },\n            ],\n        })\n    )\n\n    return `\\nExceptions: https://us.posthog.com/project/2/error_tracking?filterGroup=${filterGroup}`\n}\n\nfunction getDjangoAdminLink(\n    user: UserType | null,\n    cloudRegion: Region | null | undefined,\n    currentOrganization: OrganizationBasicType | null,\n    currentTeam: TeamPublicType | null\n): string {\n    if (!user || !cloudRegion) {\n        return ''\n    }\n    const link = `http://go/admin${cloudRegion}/${user.email}`\n    return `\\nAdmin: ${link} (organization ID ${currentOrganization?.id}: ${currentOrganization?.name}, project ID ${currentTeam?.id}: ${currentTeam?.name})`\n}\n\nfunction getBillingAdminLink(currentOrganization: OrganizationBasicType | null): string {\n    if (!currentOrganization) {\n        return ''\n    }\n    return `\\nBilling admin: http://go/billing/${currentOrganization.id}`\n}\n\nconst SUPPORT_TICKET_KIND_TO_TITLE: Record<SupportTicketKind, string> = {\n    support: 'Contact support',\n    feedback: 'Give feedback',\n    bug: 'Report a bug',\n}\n\nexport const TARGET_AREA_TO_NAME = [\n    {\n        title: 'General',\n        options: [\n            {\n                value: 'login',\n                'data-attr': `support-form-target-area-login`,\n                label: 'Authentication (incl. login, sign-up, invites)',\n            },\n            {\n                value: 'analytics_platform',\n                'data-attr': `support-form-target-area-analytics_platform`,\n                label: 'Analytics features (incl. alerts, subscriptions, exports, etc.)',\n            },\n            {\n                value: 'billing',\n                'data-attr': `support-form-target-area-billing`,\n                label: 'Billing',\n            },\n            {\n                value: 'cohorts',\n                'data-attr': `support-form-target-area-cohorts`,\n                label: 'Cohorts',\n            },\n            {\n                value: 'data_ingestion',\n                'data-attr': `support-form-target-area-data_ingestion`,\n                label: 'Data ingestion',\n            },\n            {\n                value: 'data_management',\n                'data-attr': `support-form-target-area-data_management`,\n                label: 'Data management (incl. events, actions, properties)',\n            },\n            {\n                value: 'mobile',\n                'data-attr': `support-form-target-area-mobile`,\n                label: 'Mobile',\n            },\n            {\n                value: 'notebooks',\n                'data-attr': `support-form-target-area-notebooks`,\n                label: 'Notebooks',\n            },\n            {\n                value: 'onboarding',\n                'data-attr': `support-form-target-area-onboarding`,\n                label: 'Onboarding',\n            },\n            {\n                value: 'platform_addons',\n                'data-attr': `support-form-target-area-platform_addons`,\n                label: 'Platform addons',\n            },\n            {\n                value: 'sdk',\n                'data-attr': `support-form-target-area-onboarding`,\n                label: 'SDK / Implementation',\n            },\n        ],\n    },\n    {\n        title: 'Individual product',\n        options: [\n            {\n                value: 'data_warehouse',\n                'data-attr': `support-form-target-area-data_warehouse`,\n                label: 'Data warehouse (sources)',\n            },\n            {\n                value: 'batch_exports',\n                'data-attr': `support-form-target-area-batch_exports`,\n                label: 'Destinations (batch exports)',\n            },\n            {\n                value: 'cdp_destinations',\n                'data-attr': `support-form-target-area-cdp_destinations`,\n                label: 'Destinations (real-time)',\n            },\n            {\n                value: 'error_tracking',\n                'data-attr': `support-form-target-area-error_tracking`,\n                label: 'Error tracking',\n            },\n            {\n                value: 'experiments',\n                'data-attr': `support-form-target-area-experiments`,\n                label: 'Experiments',\n            },\n            {\n                value: 'feature_flags',\n                'data-attr': `support-form-target-area-feature_flags`,\n                label: 'Feature flags',\n            },\n            {\n                value: 'group_analytics',\n                'data-attr': `support-form-target-area-group-analytics`,\n                label: 'Group analytics',\n            },\n            {\n                value: 'customer_analytics',\n                'data-attr': `support-form-target-area-customer-analytics`,\n                label: 'Customer analytics',\n            },\n            {\n                value: 'llm-analytics',\n                'data-attr': `support-form-target-area-llm-analytics`,\n                label: 'LLM analytics',\n            },\n            {\n                value: 'max-ai',\n                'data-attr': `support-form-target-area-max-ai`,\n                label: 'PostHog AI',\n            },\n            {\n                value: 'workflows',\n                'data-attr': `support-form-target-area-workflows`,\n                label: 'Workflows / Messaging',\n            },\n            {\n                value: 'analytics',\n                'data-attr': `support-form-target-area-analytics`,\n                label: 'Product analytics (incl. insights, dashboards, etc.)',\n            },\n            {\n                value: 'revenue_analytics',\n                'data-attr': `support-form-target-area-revenue-analytics`,\n                label: 'Revenue analytics',\n            },\n            {\n                value: 'session_replay',\n                'data-attr': `support-form-target-area-session_replay`,\n                label: 'Session replay (incl. recordings)',\n            },\n            {\n                value: 'surveys',\n                'data-attr': `support-form-target-area-surveys`,\n                label: 'Surveys',\n            },\n            {\n                value: 'toolbar',\n                'data-attr': `support-form-target-area-toolbar`,\n                label: 'Toolbar (incl. heatmaps)',\n            },\n            {\n                value: 'web_analytics',\n                'data-attr': `support-form-target-area-web_analytics`,\n                label: 'Web analytics',\n            },\n        ],\n    },\n]\n\nexport const SEVERITY_LEVEL_TO_NAME = {\n    critical: 'Outage, data loss, or data breach',\n    high: 'Feature is not working at all',\n    medium: 'Feature not working as expected',\n    low: 'Question or feature request',\n}\n\nexport const SUPPORT_KIND_TO_SUBJECT = {\n    bug: 'Bug Report',\n    feedback: 'Feedback',\n    support: 'Support Ticket',\n}\n\nexport type SupportTicketTargetArea =\n    | 'experiments'\n    | 'apps'\n    | 'login'\n    | 'billing'\n    | 'onboarding'\n    | 'cohorts'\n    | 'data_management'\n    | 'notebooks'\n    | 'data_warehouse'\n    | 'feature_flags'\n    | 'analytics'\n    | 'session_replay'\n    | 'toolbar'\n    | 'surveys'\n    | 'web_analytics'\n    | 'error_tracking'\n    | 'cdp_destinations'\n    | 'data_ingestion'\n    | 'batch_exports'\n    | 'workflows'\n    | 'platform_addons'\n    | 'max-ai'\n    | 'customer-analytics'\nexport type SupportTicketSeverityLevel = keyof typeof SEVERITY_LEVEL_TO_NAME\nexport type SupportTicketKind = keyof typeof SUPPORT_KIND_TO_SUBJECT\n\nexport type SupportTicketExceptionEvent = { uuid: string; event: string; properties?: Record<string, any> }\n\nexport const getLabelBasedOnTargetArea = (target_area: SupportTicketTargetArea): null | string => {\n    for (const category of TARGET_AREA_TO_NAME) {\n        for (const option of category.options) {\n            if (option.value === target_area) {\n                return option.label\n            }\n        }\n    }\n    return null // Return null if the value is not found\n}\n\nexport const URL_PATH_TO_TARGET_AREA: Record<string, SupportTicketTargetArea> = {\n    insights: 'analytics',\n    recordings: 'session_replay',\n    replay: 'session_replay',\n    dashboard: 'analytics',\n    feature_flags: 'feature_flags',\n    experiments: 'experiments',\n    'web-performance': 'session_replay',\n    events: 'analytics',\n    'data-management': 'data_management',\n    cohorts: 'cohorts',\n    annotations: 'analytics',\n    persons: 'analytics',\n    groups: 'analytics',\n    app: 'apps',\n    toolbar: 'session_replay',\n    warehouse: 'data_warehouse',\n    surveys: 'surveys',\n    web: 'web_analytics',\n    destination: 'cdp_destinations',\n    destinations: 'cdp_destinations',\n    transformation: 'cdp_destinations',\n    transformations: 'cdp_destinations',\n    source: 'data_warehouse',\n    sources: 'data_warehouse',\n    workflows: 'workflows',\n    billing: 'billing',\n}\n\nexport const SUPPORT_TICKET_TEMPLATES = {\n    bug: 'Please describe the bug you saw, and how to reproduce it.\\n\\nIf the bug appeared on a specific insight or dashboard, please include a link to it.',\n    feedback:\n        \"If your request is due to a problem, please describe the problem as best you can.\\n\\nPlease also describe the solution you'd like to see, and any alternatives you considered.\\n\\nYou can add images below to help illustrate your request, if needed!\",\n    support:\n        \"Please explain as fully as possible what you're aiming to do, and what you'd like help with.\\n\\nIf your question involves an existing insight or dashboard, please include a link to it.\",\n}\n\nexport function getURLPathToTargetArea(pathname: string): SupportTicketTargetArea | null {\n    const pathParts = pathname.split('/')\n\n    if (pathname.includes('pipeline/destinations/') && !pathname.includes('/hog-')) {\n        return 'batch_exports'\n    }\n\n    for (const part of pathParts) {\n        if (URL_PATH_TO_TARGET_AREA[part]) {\n            return URL_PATH_TO_TARGET_AREA[part]\n        }\n    }\n\n    return null\n}\n\nexport type SupportFormLogicProps = {\n    onClose?: () => void\n}\n\nexport type SupportFormFields = {\n    name: string\n    email: string\n    kind: SupportTicketKind\n    target_area: SupportTicketTargetArea | null\n    severity_level: SupportTicketSeverityLevel | null\n    message: string\n    exception_event?: SupportTicketExceptionEvent\n    isEmailFormOpen?: boolean | 'true' | 'false'\n}\n\nexport const supportLogic = kea<supportLogicType>([\n    props({} as SupportFormLogicProps),\n    path(['lib', 'components', 'support', 'supportLogic']),\n    connect(() => ({\n        values: [\n            userLogic,\n            ['user'],\n            preflightLogic,\n            ['preflight'],\n            sidePanelStateLogic,\n            ['sidePanelAvailable'],\n            userLogic,\n            ['hasAvailableFeature'],\n            billingLogic,\n            ['billing'],\n            organizationLogic,\n            ['isCurrentOrganizationNew'],\n        ],\n        actions: [sidePanelStateLogic, ['openSidePanel', 'setSidePanelOptions']],\n    })),\n    actions(() => ({\n        closeSupportForm: true,\n        openSupportForm: (values: Partial<SupportFormFields>) => values,\n        submitZendeskTicket: (form: SupportFormFields) => form,\n        ensureZendeskOrganization: true,\n        updateUrlParams: true,\n        openEmailForm: true,\n        closeEmailForm: true,\n    })),\n    reducers(() => ({\n        isSupportFormOpen: [\n            false,\n            {\n                openSupportForm: () => true,\n                closeSupportForm: () => false,\n            },\n        ],\n        isEmailFormOpen: [\n            false,\n            {\n                openEmailForm: () => true,\n                closeEmailForm: () => false,\n            },\n        ],\n    })),\n    forms(({ actions, values }) => ({\n        sendSupportRequest: {\n            defaults: {\n                name: '',\n                email: '',\n                kind: 'support',\n                severity_level: null,\n                target_area: null,\n                message: '',\n            } as SupportFormFields,\n            errors: ({ name, email, message, kind, target_area, severity_level }) => {\n                return {\n                    name: !values.user ? (!name ? 'Please enter your name' : '') : '',\n                    email: !values.user ? (!email ? 'Please enter your email' : '') : '',\n                    message: !message ? 'Please enter a message' : '',\n                    kind: !kind ? 'Please choose' : undefined,\n                    severity_level: !severity_level ? 'Please choose' : undefined,\n                    target_area: !target_area ? 'Please choose' : undefined,\n                }\n            },\n            submit: async (formValues) => {\n                // name must be present for zendesk to accept the ticket\n                formValues.name = values.user?.first_name ?? formValues.name ?? 'name not set'\n                formValues.email = values.user?.email ?? formValues.email ?? ''\n                actions.submitZendeskTicket(formValues)\n                // Form closing and resetting is now handled in submitZendeskTicket listener\n                // based on success/failure of the submission\n            },\n        },\n    })),\n    selectors({\n        title: [\n            (s) => [s.sendSupportRequest ?? null],\n            (sendSupportRequest) =>\n                sendSupportRequest.kind\n                    ? SUPPORT_TICKET_KIND_TO_TITLE[sendSupportRequest.kind]\n                    : 'Leave a message with PostHog',\n        ],\n        targetArea: [\n            (s) => [s.sendSupportRequest],\n            (sendSupportRequest: SupportFormFields) => sendSupportRequest.target_area,\n        ],\n    }),\n    listeners(({ actions, props, values }) => ({\n        updateUrlParams: async () => {\n            // Only include non-text fields in the URL parameters\n            // This prevents focus loss when typing in text fields\n            const panelOptions = [\n                values.sendSupportRequest.kind ?? '',\n                values.sendSupportRequest.target_area ?? '',\n                values.sendSupportRequest.severity_level ?? '',\n                values.isEmailFormOpen ?? 'false',\n                // Explicitly exclude message, name, and email fields\n            ].join(':')\n\n            if (panelOptions !== ':') {\n                actions.setSidePanelOptions(panelOptions)\n            }\n        },\n        openSupportForm: async ({\n            name,\n            email,\n            isEmailFormOpen,\n            kind,\n            target_area,\n            severity_level,\n            message,\n            exception_event,\n        }: Partial<SupportFormFields>) => {\n            let area = target_area ?? getURLPathToTargetArea(window.location.pathname)\n            if (!userLogic.values.user) {\n                area = 'login'\n            }\n            kind = kind ?? 'support'\n            actions.resetSendSupportRequest({\n                name: name ?? '',\n                email: email ?? '',\n                kind,\n                target_area: area,\n                severity_level: severity_level ?? null,\n                message: message ?? values.sendSupportRequest.message ?? '',\n                exception_event,\n            })\n\n            if (isEmailFormOpen === 'true' || isEmailFormOpen === true) {\n                actions.openEmailForm()\n            } else {\n                actions.closeEmailForm()\n            }\n\n            if (values.sidePanelAvailable) {\n                const panelOptions = [kind ?? '', area ?? ''].join(':')\n                actions.openSidePanel(SidePanelTab.Support, panelOptions === ':' ? undefined : panelOptions)\n            } else {\n                openSupportModal()\n            }\n\n            actions.updateUrlParams()\n        },\n        submitZendeskTicket: async ({\n            name,\n            email,\n            kind,\n            target_area,\n            severity_level,\n            message,\n            exception_event,\n        }: SupportFormFields) => {\n            const zendesk_ticket_uuid = uuid()\n            const subject =\n                SUPPORT_KIND_TO_SUBJECT[kind ?? 'support'] +\n                ': ' +\n                (target_area\n                    ? (getLabelBasedOnTargetArea(target_area) ?? `${target_area} (feature preview)`)\n                    : 'General') +\n                ' (' +\n                zendesk_ticket_uuid +\n                ')'\n            const cloudRegion = preflightLogic.values.preflight?.region\n\n            const billing = billingLogic.values.billing\n            const billingPlan = billingLogic.values.billingPlan\n\n            let planLevelTag = 'plan_free'\n\n            const knownEnterpriseOrgIds = ['018713f3-8d56-0000-32fa-75ce97e6662f']\n            const isKnownEnterpriseOrg = knownEnterpriseOrgIds.includes(userLogic?.values?.user?.organization?.id || '')\n\n            const isNewOrganization = values.isCurrentOrganizationNew\n\n            const hasBoostTrial = billing?.trial?.status === 'active' && (billing.trial?.target as any) === 'boost'\n            const hasScaleTrial = billing?.trial?.status === 'active' && (billing.trial?.target as any) === 'scale'\n            const hasEnterpriseTrial = billing?.trial?.status === 'active' && billing.trial?.target === 'enterprise'\n\n            if (isKnownEnterpriseOrg || hasEnterpriseTrial || billingPlan === BillingPlan.Enterprise) {\n                planLevelTag = 'plan_enterprise'\n            } else if (isNewOrganization) {\n                planLevelTag = 'plan_onboarding'\n            } else if (hasScaleTrial) {\n                planLevelTag = 'plan_scale'\n            } else if (hasBoostTrial) {\n                planLevelTag = 'plan_boost'\n            } else if (billingPlan) {\n                switch (billingPlan) {\n                    case BillingPlan.Scale:\n                        planLevelTag = 'plan_scale'\n                        break\n                    case BillingPlan.Boost:\n                        planLevelTag = 'plan_boost'\n                        break\n                    case BillingPlan.Teams:\n                        planLevelTag = 'plan_teams_legacy'\n                        break\n                    case BillingPlan.Paid:\n                        const projectedAmount = parseFloat(billing?.projected_total_amount_usd_with_limit || '0')\n                        const shouldMarkAsFree = projectedAmount === 0\n\n                        planLevelTag = shouldMarkAsFree ? 'plan_pay-as-you-go_free' : 'plan_pay-as-you-go_paying'\n                        break\n                    case BillingPlan.Free:\n                        planLevelTag = 'plan_free'\n                        break\n                }\n            }\n\n            const startupProgramLabel = billing?.startup_program_label\n            if (startupProgramLabel === StartupProgramLabel.YC) {\n                planLevelTag = 'plan_yc'\n            } else if (startupProgramLabel === StartupProgramLabel.Startup) {\n                planLevelTag = 'plan_startup'\n            }\n\n            const { accountOwner } = billingLogic.values\n\n            const ownerName = accountOwner?.name?.toLowerCase().replace(/[^a-z0-9]/g, '_') || 'unassigned'\n            const accountOwnerTag = `owner_${ownerName}`\n\n            const payload = {\n                request: {\n                    requester: { name: name, email: email },\n                    subject: subject,\n                    tags: [planLevelTag, accountOwnerTag],\n                    custom_fields: [\n                        {\n                            id: 22084126888475,\n                            value: severity_level,\n                        },\n                        {\n                            id: 22129191462555,\n                            value: posthog.get_distinct_id(),\n                        },\n                        {\n                            id: 27242745654043,\n                            value: target_area ?? '',\n                        },\n                        {\n                            id: 27031528411291,\n                            value: userLogic?.values?.user?.organization?.id ?? '',\n                        },\n                        {\n                            id: 26073267652251,\n                            value: values.hasAvailableFeature(AvailableFeature.PRIORITY_SUPPORT)\n                                ? 'priority_support'\n                                : values.hasAvailableFeature(AvailableFeature.EMAIL_SUPPORT)\n                                  ? 'email_support'\n                                  : 'free_support',\n                        },\n                        {\n                            id: 37742340880411,\n                            value: accountOwner?.name || 'unassigned',\n                        },\n                        {\n                            id: 39967113285659,\n                            value: exception_event ? parseExceptionEvent(exception_event) : '',\n                        },\n                    ],\n                    comment: {\n                        body:\n                            message +\n                            `\\n\\n-----` +\n                            `\\nKind: ${kind}` +\n                            `\\nTarget area: ${target_area}` +\n                            `\\nReport event: http://go/ticketByUUID/${zendesk_ticket_uuid}` +\n                            getSessionReplayLink() +\n                            getErrorTrackingLink(exception_event?.uuid) +\n                            getCurrentLocationLink() +\n                            getDjangoAdminLink(\n                                userLogic.values.user,\n                                cloudRegion,\n                                organizationLogic.values.currentOrganization,\n                                teamLogic.values.currentTeam\n                            ) +\n                            (target_area === 'billing' || target_area === 'login' || target_area === 'onboarding'\n                                ? getBillingAdminLink(organizationLogic.values.currentOrganization)\n                                : '') +\n                            (cloudRegion && teamLogic.values.currentTeam\n                                ? '\\nPersons-on-events mode for project: ' +\n                                  (teamLogic.values.currentTeam.modifiers?.personsOnEventsMode ??\n                                      teamLogic.values.currentTeam.default_modifiers?.personsOnEventsMode ??\n                                      'unknown')\n                                : ''),\n                    },\n                },\n            }\n\n            try {\n                const zendeskRequestBody = JSON.stringify(payload, undefined, 4)\n\n                // First attempt with standard fetch (unchanged from original)\n                const response = await fetch('https://posthoghelp.zendesk.com/api/v2/requests.json', {\n                    method: 'POST',\n                    body: zendeskRequestBody,\n                    headers: { 'Content-Type': 'application/json' },\n                })\n\n                // If the fetch request fails, try the Beacon API as a fallback\n                if (!response.ok) {\n                    console.warn('Fetch attempt to submit support ticket failed, trying Beacon API as fallback')\n\n                    // Detect Firefox\n                    const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1\n\n                    // Try Beacon API\n                    const beaconSuccess = navigator.sendBeacon(\n                        'https://posthoghelp.zendesk.com/api/v2/requests.json',\n                        zendeskRequestBody\n                    )\n\n                    if (beaconSuccess) {\n                        // Track success\n                        const properties = {\n                            zendesk_ticket_uuid,\n                            kind,\n                            target_area,\n                            message,\n                            submission_method: 'beacon',\n                            browser: isFirefox ? 'firefox' : 'other',\n                        }\n                        posthog.capture('support_ticket', properties)\n                        lemonToast.success(\n                            \"Got the message! If we have follow-up information for you, we'll reply via email.\"\n                        )\n                        // Only close and reset the form on success\n                        actions.closeSupportForm()\n                        actions.resetSendSupportRequest()\n                        return\n                    }\n\n                    // If both fetch and beacon fail, show the original error message\n                    const error = new Error(`There was an error creating the support ticket with zendesk.`)\n                    const extra: Record<string, any> = { zendeskBody: zendeskRequestBody }\n                    Object.entries(payload).forEach(([key, value]) => {\n                        extra[`payload_${key}`] = value\n                    })\n                    const body = await response.text()\n                    const contexts = {\n                        response: {\n                            status_code: response.status,\n                            data: body,\n                            body_size: body?.length,\n                        },\n                    }\n                    posthog.captureException(error, {\n                        ...extra,\n                        ...contexts,\n                    })\n                    lemonToast.error(\n                        `Oops, the message couldn't be sent. Please change your browser's privacy level to the standard or default level, then try again. (E.g. In Firefox: Settings > Privacy & Security > Standard)`,\n                        { hideButton: true }\n                    )\n                    // Don't close the form or reset the data so user can try again\n                    return\n                }\n\n                const json = await response.json()\n\n                const zendesk_ticket_id = json.request.id\n                const zendesk_ticket_link = `https://posthoghelp.zendesk.com/agent/tickets/${zendesk_ticket_id}`\n                const properties = {\n                    zendesk_ticket_uuid,\n                    kind,\n                    target_area,\n                    message,\n                    zendesk_ticket_id,\n                    zendesk_ticket_link,\n                }\n                posthog.capture('support_ticket', properties)\n                lemonToast.success(\"Got the message! If we have follow-up information for you, we'll reply via email.\")\n\n                actions.ensureZendeskOrganization()\n\n                // Only close and reset the form on success\n                actions.closeSupportForm()\n                actions.resetSendSupportRequest()\n            } catch (e) {\n                posthog.captureException(e)\n\n                // More helpful error message\n                // Use the same error message regardless of browser\n                lemonToast.error(\n                    `Oops, the message couldn't be sent. Please change your browser's privacy level to the standard or default level, then try again. (E.g. In Firefox: Settings > Privacy & Security > Standard)`,\n                    { hideButton: true }\n                )\n                // Don't close the form or reset the data so user can try again\n            }\n        },\n\n        closeSupportForm: () => {\n            // Form is only reset by explicit Cancel button or successful submission\n            props.onClose?.()\n        },\n\n        setSendSupportRequestValue: ({ name }) => {\n            // Only update URL params for non-text fields to prevent focus loss during typing\n            if (name !== 'message' && name !== 'name' && name !== 'email') {\n                actions.updateUrlParams()\n            }\n        },\n\n        ensureZendeskOrganization: async () => {\n            try {\n                const currentOrganization = organizationLogic.values.currentOrganization\n\n                if (!currentOrganization?.id || !currentOrganization?.name) {\n                    return\n                }\n\n                await api.create('/api/support/ensure-zendesk-organization', {\n                    organization_id: currentOrganization.id,\n                    organization_name: currentOrganization.name,\n                })\n            } catch (error) {\n                posthog.captureException(error, {\n                    context: 'zendesk_organization_creation',\n                    organization_id: organizationLogic.values.currentOrganization?.id,\n                    organization_name: organizationLogic.values.currentOrganization?.name,\n                    error_message: error instanceof Error ? error.message : String(error),\n                    error_status: error && typeof error === 'object' && 'status' in error ? error.status : undefined,\n                })\n            }\n        },\n    })),\n\n    urlToAction(({ actions, values }) => ({\n        '*': (_, _search, hashParams) => {\n            if (values.isSupportFormOpen) {\n                return\n            }\n\n            const [panel, ...panelOptions] = (hashParams['panel'] ?? '').split(':')\n\n            if (panel === SidePanelTab.Support) {\n                const [kind, area, severity, isEmailFormOpen] = panelOptions\n\n                actions.openSupportForm({\n                    kind: Object.keys(SUPPORT_KIND_TO_SUBJECT).includes(kind) ? kind : null,\n                    target_area: getLabelBasedOnTargetArea(area) ? area : null,\n                    severity_level: Object.keys(SEVERITY_LEVEL_TO_NAME).includes(severity) ? severity : null,\n                    isEmailFormOpen: isEmailFormOpen ?? 'false',\n                })\n                return\n            }\n\n            // Legacy supportModal param\n            if ('supportModal' in hashParams) {\n                const [kind, area, severity] = (hashParams['supportModal'] || '').split(':')\n\n                actions.openSupportForm({\n                    kind: Object.keys(SUPPORT_KIND_TO_SUBJECT).includes(kind) ? kind : null,\n                    target_area: Object.keys(TARGET_AREA_TO_NAME).includes(area) ? area : null,\n                    severity_level: Object.keys(SEVERITY_LEVEL_TO_NAME).includes(severity) ? severity : null,\n                })\n            }\n        },\n    })),\n])\n","import './LemonRichContentEditor.scss'\n\nimport { JSONContent, TextSerializer } from '@tiptap/core'\nimport ExtensionDocument from '@tiptap/extension-document'\nimport { Placeholder } from '@tiptap/extensions'\nimport { EditorContent } from '@tiptap/react'\nimport StarterKit from '@tiptap/starter-kit'\nimport { useActions, useValues } from 'kea'\nimport posthog from 'posthog-js'\nimport { useRef, useState } from 'react'\n\nimport { IconEye, IconImage, IconPencil } from '@posthog/icons'\n\nimport { TextContent } from 'lib/components/Cards/TextCard/TextCard'\nimport { EmojiPickerPopover } from 'lib/components/EmojiPicker/EmojiPickerPopover'\nimport { useRichContentEditor } from 'lib/components/RichContentEditor'\nimport { CommandEnterExtension } from 'lib/components/RichContentEditor/CommandEnterExtension'\nimport { MentionsExtension } from 'lib/components/RichContentEditor/MentionsExtension'\nimport { RichContentNodeMention } from 'lib/components/RichContentEditor/RichContentNodeMention'\nimport { RichContentEditorType, RichContentNodeType, TTEditor } from 'lib/components/RichContentEditor/types'\nimport { createEditor } from 'lib/components/RichContentEditor/utils'\nimport { useUploadFiles } from 'lib/hooks/useUploadFiles'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonFileInput } from 'lib/lemon-ui/LemonFileInput'\nimport { emojiUsageLogic } from 'lib/lemon-ui/LemonTextArea/emojiUsageLogic'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { Spinner } from 'lib/lemon-ui/Spinner'\nimport { cn } from 'lib/utils/css-classes'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\n\nexport type LemonRichContentEditorProps = {\n    logicKey?: string\n    initialContent?: JSONContent | null\n    placeholder?: string\n    onCreate?: (editor: RichContentEditorType) => void\n    onUpdate?: (isEmpty: boolean) => void\n    onPressCmdEnter?: () => void\n    disabled?: boolean\n    minRows?: number\n}\n\nconst DEFAULT_INITIAL_CONTENT: JSONContent = {\n    type: 'doc',\n    content: [\n        {\n            type: 'paragraph',\n            content: [],\n        },\n    ],\n}\n\nexport const DEFAULT_EXTENSIONS = [\n    MentionsExtension,\n    RichContentNodeMention,\n    ExtensionDocument,\n    StarterKit.configure({\n        document: false,\n        link: false,\n        heading: false,\n        blockquote: false,\n        bold: false,\n        bulletList: false,\n        code: false,\n        codeBlock: false,\n        hardBreak: false,\n        dropcursor: false,\n        gapcursor: false,\n        horizontalRule: false,\n        italic: false,\n        listItem: false,\n        listKeymap: false,\n        orderedList: false,\n        strike: false,\n        underline: false,\n    }),\n]\n\nexport const serializationOptions: { textSerializers?: Record<string, TextSerializer> } = {\n    textSerializers: { [RichContentNodeType.Mention]: ({ node }) => `@member:${node.attrs.id}` },\n}\n\nexport function RichContentPreview({\n    content,\n    className,\n}: {\n    content: JSONContent | null\n    className?: string\n}): JSX.Element {\n    const editor = useRichContentEditor({\n        extensions: [...DEFAULT_EXTENSIONS],\n        // preview isn't editable\n        disabled: true,\n        initialContent: content ?? DEFAULT_INITIAL_CONTENT,\n    })\n    return <RichContent editor={editor} className={className} />\n}\n\nexport function LemonRichContentEditor({\n    initialContent,\n    placeholder,\n    onCreate,\n    onUpdate,\n    onPressCmdEnter,\n    disabled = false,\n    minRows,\n}: LemonRichContentEditorProps): JSX.Element {\n    const [isPreviewShown, setIsPreviewShown] = useState<boolean>(false)\n    const [ttEditor, setTTEditor] = useState<TTEditor | null>(null)\n    const { objectStorageAvailable } = useValues(preflightLogic)\n    const { emojiUsed } = useActions(emojiUsageLogic)\n    const editor = useRichContentEditor({\n        extensions: [\n            ...DEFAULT_EXTENSIONS,\n            Placeholder.configure({ placeholder }),\n            CommandEnterExtension.configure({ onPressCmdEnter }),\n        ],\n        disabled,\n        initialContent: initialContent ?? DEFAULT_INITIAL_CONTENT,\n        onCreate: (editor) => {\n            if (onCreate) {\n                onCreate(createEditor(editor))\n            }\n            setTTEditor(editor)\n        },\n        onUpdate: () => {\n            if (onUpdate && ttEditor) {\n                onUpdate(ttEditor.isEmpty)\n            }\n        },\n    })\n\n    const dropRef = useRef<HTMLDivElement>(null)\n\n    const { setFilesToUpload, filesToUpload, uploading } = useUploadFiles({\n        onUpload: (url, fileName) => {\n            if (ttEditor) {\n                ttEditor.commands.insertContent(`\\n\\n![${fileName}](${url})`)\n            }\n            posthog.capture('rich text image uploaded', { name: fileName })\n        },\n        onError: (detail) => {\n            posthog.capture('rich text image upload failed', { error: detail })\n            lemonToast.error(`Error uploading image: ${detail}`)\n        },\n    })\n\n    return (\n        <div ref={dropRef} className=\"LemonRichContentEditor flex flex-col border rounded divide-y mt-4\">\n            {isPreviewShown && ttEditor ? (\n                <RichContent editor={ttEditor} className=\"bg-fill-input\" />\n            ) : (\n                <EditorContent\n                    editor={editor}\n                    className=\"RichContentEditor p-2\"\n                    autoFocus\n                    style={minRows ? { minHeight: `${minRows * 1.5}em` } : undefined}\n                />\n            )}\n            <div className=\"flex justify-between p-0.5\">\n                <div className=\"flex\">\n                    {!isPreviewShown && (\n                        <LemonFileInput\n                            key=\"file-upload\"\n                            accept={'image/*'}\n                            multiple={false}\n                            alternativeDropTargetRef={dropRef}\n                            onChange={setFilesToUpload}\n                            loading={uploading}\n                            value={filesToUpload}\n                            showUploadedFiles={false}\n                            callToAction={\n                                <LemonButton\n                                    size=\"small\"\n                                    icon={\n                                        uploading ? (\n                                            <Spinner className=\"text-lg\" textColored={true} />\n                                        ) : (\n                                            <IconImage className=\"text-lg\" />\n                                        )\n                                    }\n                                    disabledReason={\n                                        objectStorageAvailable\n                                            ? undefined\n                                            : 'Enable object storage to add images by dragging and dropping'\n                                    }\n                                    tooltip={\n                                        objectStorageAvailable ? 'Click here or drag and drop to upload images' : null\n                                    }\n                                />\n                            }\n                        />\n                    )}\n                    {!isPreviewShown && (\n                        <EmojiPickerPopover\n                            key=\"emoj-picker\"\n                            data-attr=\"lemon-rich-text-editor-emoji-popover\"\n                            onSelect={(emoji: string) => {\n                                if (ttEditor) {\n                                    ttEditor.commands.insertContent(emoji)\n                                    emojiUsed(emoji)\n                                }\n                            }}\n                        />\n                    )}\n                </div>\n                <div className=\"flex items-center gap-0.5\">\n                    <LemonButton size=\"small\" active={!isPreviewShown} onClick={() => setIsPreviewShown(false)}>\n                        <IconPencil />\n                    </LemonButton>\n                    <LemonButton size=\"small\" active={isPreviewShown} onClick={() => setIsPreviewShown(true)}>\n                        <IconEye />\n                    </LemonButton>\n                </div>\n            </div>\n        </div>\n    )\n}\n\nconst RichContent = ({ editor, className }: { editor: TTEditor; className?: string }): JSX.Element => {\n    const text = editor?.getText(serializationOptions)\n\n    return (\n        <TextContent\n            text={text && text.length != 0 ? text : '_Nothing to preview_'}\n            className={cn('p-2 rounded-t', className)}\n        />\n    )\n}\n","import { useActions, useValues } from 'kea'\nimport posthog from 'posthog-js'\nimport React, { useCallback, useRef, useState } from 'react'\n\nimport { IconImage } from '@posthog/icons'\n\nimport { TextContent } from 'lib/components/Cards/TextCard/TextCard'\nimport { EmojiPickerPopover } from 'lib/components/EmojiPicker/EmojiPickerPopover'\nimport { useUploadFiles } from 'lib/hooks/useUploadFiles'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonFileInput } from 'lib/lemon-ui/LemonFileInput'\nimport { LemonTabs } from 'lib/lemon-ui/LemonTabs'\nimport { LemonTextArea, LemonTextAreaProps } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { emojiUsageLogic } from 'lib/lemon-ui/LemonTextArea/emojiUsageLogic'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { Spinner } from 'lib/lemon-ui/Spinner'\nimport { Tooltip } from 'lib/lemon-ui/Tooltip'\nimport { IconMarkdown } from 'lib/lemon-ui/icons'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\n\nexport const LemonTextAreaMarkdown = React.forwardRef<HTMLTextAreaElement, LemonTextAreaProps>(\n    function LemonTextAreaMarkdown({ value, onChange, className, ...editAreaProps }, ref): JSX.Element {\n        const { objectStorageAvailable } = useValues(preflightLogic)\n        const { emojiUsed } = useActions(emojiUsageLogic)\n\n        const [isPreviewShown, setIsPreviewShown] = useState(false)\n        const dropRef = useRef<HTMLDivElement>(null)\n\n        // we need a local ref so we can insert emojis at the cursor's location\n        const textAreaRef = useRef<HTMLTextAreaElement>(null)\n        const combinedRef = useCallback(\n            (element: HTMLTextAreaElement | null) => {\n                // Store reference in our local ref\n                ;(textAreaRef as React.MutableRefObject<HTMLTextAreaElement | null>).current = element\n                // Forward to the original ref\n                if (typeof ref === 'function') {\n                    ref(element)\n                } else if (ref) {\n                    ;(ref as React.MutableRefObject<HTMLTextAreaElement | null>).current = element\n                }\n            },\n            [ref]\n        )\n\n        const { setFilesToUpload, filesToUpload, uploading } = useUploadFiles({\n            onUpload: (url, fileName) => {\n                onChange?.(value + `\\n\\n![${fileName}](${url})`)\n                posthog.capture('markdown image uploaded', { name: fileName })\n            },\n            onError: (detail) => {\n                posthog.capture('markdown image upload failed', { error: detail })\n                lemonToast.error(`Error uploading image: ${detail}`)\n            },\n        })\n\n        return (\n            <LemonTabs\n                activeKey={isPreviewShown ? 'preview' : 'write'}\n                onChange={(key) => setIsPreviewShown(key === 'preview')}\n                className={className}\n                tabs={[\n                    {\n                        key: 'write',\n                        label: 'Write',\n                        content: (\n                            <div ref={dropRef} className=\"LemonTextMarkdown flex flex-col gap-y-1 rounded\">\n                                <LemonTextArea\n                                    ref={combinedRef}\n                                    {...editAreaProps}\n                                    autoFocus\n                                    value={value}\n                                    onChange={onChange}\n                                    rightFooter={\n                                        <>\n                                            <Tooltip title=\"Markdown formatting supported\">\n                                                <div>\n                                                    <IconMarkdown className=\"text-xl\" />\n                                                </div>\n                                            </Tooltip>\n                                        </>\n                                    }\n                                    actions={[\n                                        <LemonFileInput\n                                            key=\"file-upload\"\n                                            accept={'image/*'}\n                                            multiple={false}\n                                            alternativeDropTargetRef={dropRef}\n                                            onChange={setFilesToUpload}\n                                            loading={uploading}\n                                            value={filesToUpload}\n                                            showUploadedFiles={false}\n                                            callToAction={\n                                                <LemonButton\n                                                    size=\"small\"\n                                                    icon={\n                                                        uploading ? (\n                                                            <Spinner className=\"text-lg\" textColored={true} />\n                                                        ) : (\n                                                            <IconImage className=\"text-lg\" />\n                                                        )\n                                                    }\n                                                    disabledReason={\n                                                        objectStorageAvailable\n                                                            ? undefined\n                                                            : 'Enable object storage to add images by dragging and dropping'\n                                                    }\n                                                    tooltip={\n                                                        objectStorageAvailable\n                                                            ? 'Click here or drag and drop to upload images'\n                                                            : null\n                                                    }\n                                                />\n                                            }\n                                        />,\n                                        <EmojiPickerPopover\n                                            key=\"emoj-picker\"\n                                            data-attr=\"lemon-text-area-markdown-emoji-popover\"\n                                            onSelect={(emoji: string) => {\n                                                const textArea = textAreaRef.current\n                                                if (textArea) {\n                                                    const start = textArea.selectionStart || 0\n                                                    const end = textArea.selectionEnd || 0\n                                                    const currentValue = value || ''\n                                                    const newValue =\n                                                        currentValue.slice(0, start) + emoji + currentValue.slice(end)\n                                                    onChange?.(newValue)\n\n                                                    // Set cursor position after the emoji\n                                                    setTimeout(() => {\n                                                        textArea.focus()\n                                                        textArea.setSelectionRange(\n                                                            start + emoji.length,\n                                                            start + emoji.length\n                                                        )\n                                                    }, 0)\n                                                } else {\n                                                    // Fallback to appending at the end\n                                                    onChange?.((value || '') + emoji)\n                                                }\n                                                emojiUsed(emoji)\n                                            }}\n                                        />,\n                                    ]}\n                                />\n                            </div>\n                        ),\n                    },\n                    {\n                        key: 'preview',\n                        label: 'Preview',\n                        content: value ? (\n                            <TextContent text={value} className=\"LemonTextArea--preview\" />\n                        ) : (\n                            <i>Nothing to preview</i>\n                        ),\n                    },\n                ]}\n            />\n        )\n    }\n)\n","import './CodeEditor.scss'\n\nimport MonacoEditor, { type EditorProps, Monaco, DiffEditor as MonacoDiffEditor, loader } from '@monaco-editor/react'\nimport { BuiltLogic, useMountedLogic, useValues } from 'kea'\nimport { IDisposable, editor, editor as importedEditor } from 'monaco-editor'\nimport * as monaco from 'monaco-editor'\nimport { useEffect, useMemo, useRef, useState } from 'react'\n\nimport { useOnMountEffect } from 'lib/hooks/useOnMountEffect'\nimport { Spinner } from 'lib/lemon-ui/Spinner'\nimport { codeEditorLogic } from 'lib/monaco/codeEditorLogic'\nimport { codeEditorLogicType } from 'lib/monaco/codeEditorLogicType'\nimport { findNextFocusableElement, findPreviousFocusableElement } from 'lib/monaco/domUtils'\nimport { initHogLanguage } from 'lib/monaco/languages/hog'\nimport { initHogJsonLanguage } from 'lib/monaco/languages/hogJson'\nimport { initHogQLLanguage } from 'lib/monaco/languages/hogQL'\nimport { initHogTemplateLanguage } from 'lib/monaco/languages/hogTemplate'\nimport { initLiquidLanguage } from 'lib/monaco/languages/liquid'\nimport { inStorybookTestRunner } from 'lib/utils'\n\nimport { themeLogic } from '~/layout/navigation-3000/themeLogic'\nimport { AnyDataNode, HogLanguage, HogQLMetadataResponse, NodeKind } from '~/queries/schema/schema-general'\n\nif (loader) {\n    loader.config({ monaco })\n}\n\nexport interface CodeEditorProps extends Omit<EditorProps, 'loading' | 'theme'> {\n    queryKey?: string\n    autocompleteContext?: string\n    onPressCmdEnter?: (value: string, selectionType: 'selection' | 'full') => void\n    /** Pressed up in an empty code editor, likely to edit the previous message in a list */\n    onPressUpNoValue?: () => void\n    autoFocus?: boolean\n    sourceQuery?: AnyDataNode\n    globals?: Record<string, any>\n    schema?: Record<string, any> | null\n    onMetadata?: (metadata: HogQLMetadataResponse | null) => void\n    onMetadataLoading?: (loading: boolean) => void\n    onError?: (error: string | null) => void\n    /** The original value to compare against - renders it in diff mode */\n    originalValue?: string\n}\nlet codeEditorIndex = 0\n\nexport function initModel(model: editor.ITextModel, builtCodeEditorLogic: BuiltLogic<codeEditorLogicType>): void {\n    ;(model as any).codeEditorLogic = builtCodeEditorLogic\n}\n\nfunction initEditor(\n    monaco: Monaco,\n    editor: importedEditor.IStandaloneCodeEditor,\n    editorProps: Omit<CodeEditorProps, 'options' | 'onMount' | 'queryKey' | 'value'>,\n    options: editor.IStandaloneEditorConstructionOptions,\n    builtCodeEditorLogic: BuiltLogic<codeEditorLogicType>\n): void {\n    // This gives autocomplete access to the specific editor\n    const model = editor.getModel()\n    if (model) {\n        initModel(model, builtCodeEditorLogic)\n    }\n\n    if (editorProps?.language === 'hog') {\n        initHogLanguage(monaco)\n    }\n    if (editorProps?.language === 'hogQL' || editorProps?.language === 'hogQLExpr') {\n        initHogQLLanguage(monaco, editorProps.language as HogLanguage)\n    }\n    if (editorProps?.language === 'hogTemplate') {\n        initHogTemplateLanguage(monaco)\n    }\n    if (editorProps?.language === 'hogJson') {\n        initHogJsonLanguage(monaco)\n    }\n    if (editorProps?.language === 'liquid') {\n        initLiquidLanguage(monaco)\n    }\n    if (options.tabFocusMode || editorProps.onPressUpNoValue) {\n        editor.onKeyDown((evt) => {\n            if (options.tabFocusMode) {\n                if (evt.keyCode === monaco.KeyCode.Tab && !evt.metaKey && !evt.ctrlKey) {\n                    const selection = editor.getSelection()\n                    if (\n                        selection &&\n                        (selection.startColumn !== selection.endColumn ||\n                            selection.startLineNumber !== selection.endLineNumber)\n                    ) {\n                        return\n                    }\n                    evt.preventDefault()\n                    evt.stopPropagation()\n\n                    const element: HTMLElement | null = evt.target?.parentElement?.parentElement?.parentElement ?? null\n                    if (!element) {\n                        return\n                    }\n                    const nextElement = evt.shiftKey\n                        ? findPreviousFocusableElement(element)\n                        : findNextFocusableElement(element)\n\n                    if (nextElement && 'focus' in nextElement) {\n                        nextElement.focus()\n                    }\n                }\n            }\n            if (editorProps.onPressUpNoValue) {\n                if (\n                    evt.keyCode === monaco.KeyCode.UpArrow &&\n                    !evt.metaKey &&\n                    !evt.ctrlKey &&\n                    editor.getValue() === ''\n                ) {\n                    evt.preventDefault()\n                    evt.stopPropagation()\n                    editorProps.onPressUpNoValue()\n                }\n            }\n        })\n    }\n}\n\nexport function CodeEditor({\n    queryKey,\n    options,\n    onMount,\n    value,\n    onPressCmdEnter,\n    autoFocus,\n    globals,\n    sourceQuery,\n    schema,\n    onError,\n    onMetadata,\n    onMetadataLoading,\n    originalValue,\n    ...editorProps\n}: CodeEditorProps): JSX.Element {\n    const { isDarkModeOn } = useValues(themeLogic)\n    const scrollbarRendering = !inStorybookTestRunner() ? 'auto' : 'hidden'\n    const [monacoAndEditor, setMonacoAndEditor] = useState(\n        null as [Monaco, importedEditor.IStandaloneCodeEditor] | null\n    )\n    const [monaco, editor] = monacoAndEditor ?? []\n\n    const [realKey] = useState(() => codeEditorIndex++)\n    const builtCodeEditorLogic = codeEditorLogic({\n        key: queryKey ?? `new/${realKey}`,\n        query: value ?? '',\n        language: editorProps.language ?? 'text',\n        globals,\n        sourceQuery,\n        monaco: monaco,\n        editor: editor,\n        onError,\n        onMetadata,\n        onMetadataLoading,\n        metadataFilters: sourceQuery?.kind === NodeKind.HogQLQuery ? sourceQuery.filters : undefined,\n    })\n    useMountedLogic(builtCodeEditorLogic)\n\n    // Create DIV with .monaco-editor inside <body> for monaco's popups.\n    // Without this monaco's tooltips will be mispositioned if inside another modal or popup.\n    const monacoRoot = useMemo(() => {\n        const body = (typeof document !== 'undefined' && document.getElementsByTagName('body')[0]) || null\n        const monacoRoot = document.createElement('div')\n        monacoRoot.classList.add('monaco-editor')\n        monacoRoot.style.zIndex = 'var(--z-tooltip)'\n        body?.appendChild(monacoRoot)\n        return monacoRoot\n    }, [])\n\n    useOnMountEffect(() => {\n        return () => monacoRoot?.remove()\n    })\n\n    useEffect(() => {\n        if (!monaco) {\n            return\n        }\n        monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n            jsx: editorProps?.path?.endsWith('.tsx')\n                ? monaco.languages.typescript.JsxEmit.React\n                : monaco.languages.typescript.JsxEmit.Preserve,\n            esModuleInterop: true,\n        })\n    }, [monaco, editorProps.path])\n\n    useEffect(() => {\n        if (!monaco) {\n            return\n        }\n        monaco.languages.json.jsonDefaults.setDiagnosticsOptions({\n            validate: true,\n            schemas: schema\n                ? [\n                      {\n                          uri: 'http://internal/node-schema.json',\n                          fileMatch: ['*'],\n                          schema: schema,\n                      },\n                  ]\n                : [],\n        })\n    }, [monaco, schema])\n\n    // Using useRef, not useState, as we don't want to reload the component when this changes.\n    const monacoDisposables = useRef([] as IDisposable[])\n    useOnMountEffect(() => {\n        return () => {\n            monacoDisposables.current.forEach((d) => d?.dispose())\n        }\n    })\n\n    const editorOptions: editor.IStandaloneEditorConstructionOptions = {\n        minimap: {\n            enabled: false,\n        },\n        scrollBeyondLastLine: false,\n        automaticLayout: true,\n        fixedOverflowWidgets: true,\n        glyphMargin: false,\n        folding: true,\n        wordWrap: 'off',\n        lineNumbers: 'on',\n        tabFocusMode: false,\n        overviewRulerBorder: true,\n        hideCursorInOverviewRuler: false,\n        overviewRulerLanes: 3,\n        overflowWidgetsDomNode: monacoRoot,\n        ...options,\n        padding: { bottom: 8, top: 8 },\n        scrollbar: {\n            vertical: scrollbarRendering,\n            horizontal: scrollbarRendering,\n            ...options?.scrollbar,\n        },\n    }\n\n    const editorOnMount = (editor: importedEditor.IStandaloneCodeEditor, monaco: Monaco): void => {\n        setMonacoAndEditor([monaco, editor])\n        initEditor(monaco, editor, editorProps, options ?? {}, builtCodeEditorLogic)\n\n        // Override Monaco's suggestion widget styling to prevent truncation\n        const overrideSuggestionWidgetStyling = (): void => {\n            const style = document.createElement('style')\n            style.textContent = `\n            .monaco-editor .suggest-widget .monaco-list .monaco-list-row.string-label>.contents>.main>.left>.monaco-icon-label {\n               flex-shrink: 0;\n            }\n\n            `\n            document.head.appendChild(style)\n        }\n\n        // Apply styling immediately and also when suggestion widget appears\n        overrideSuggestionWidgetStyling()\n\n        // Monitor for suggestion widget creation and apply styling\n        const observer = new MutationObserver(() => {\n            const suggestWidget = document.querySelector('.monaco-editor .suggest-widget')\n            if (suggestWidget) {\n                overrideSuggestionWidgetStyling()\n            }\n        })\n        observer.observe(document.body, { childList: true, subtree: true })\n\n        // Clean up observer\n        monacoDisposables.current.push({\n            dispose: () => observer.disconnect(),\n        })\n\n        if (onPressCmdEnter) {\n            monacoDisposables.current.push(\n                editor.addAction({\n                    id: 'saveAndRunPostHog',\n                    label: 'Save and run query',\n                    keybindings: [monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter],\n                    run: () => {\n                        const selection = editor.getSelection()\n                        const model = editor.getModel()\n                        if (selection && model) {\n                            const highlightedText = model.getValueInRange(selection)\n                            onPressCmdEnter(highlightedText, 'selection')\n                            return\n                        }\n\n                        onPressCmdEnter(editor.getValue(), 'full')\n                    },\n                })\n            )\n        }\n        if (autoFocus) {\n            editor.focus()\n            const model = editor.getModel()\n            if (model) {\n                editor.setPosition({\n                    column: model.getLineContent(model.getLineCount()).length + 1,\n                    lineNumber: model.getLineCount(),\n                })\n            }\n        }\n\n        onMount?.(editor, monaco)\n    }\n\n    if (originalValue) {\n        // If originalValue is provided, we render a diff editor instead\n        const diffEditorOnMount = (diff: importedEditor.IStandaloneDiffEditor, monaco: Monaco): void => {\n            const modifiedEditor = diff.getModifiedEditor()\n            setMonacoAndEditor([monaco, modifiedEditor])\n\n            if (editorProps.onChange) {\n                const disposable = modifiedEditor.onDidChangeModelContent((event: editor.IModelContentChangedEvent) => {\n                    editorProps.onChange?.(modifiedEditor.getValue(), event)\n                })\n                monacoDisposables.current.push(disposable)\n            }\n            onMount?.(modifiedEditor, monaco)\n        }\n\n        return (\n            <MonacoDiffEditor\n                key={queryKey}\n                loading={<Spinner />}\n                theme={isDarkModeOn ? 'vs-dark' : 'vs-light'}\n                original={originalValue}\n                modified={value}\n                options={{\n                    ...editorOptions,\n                    renderSideBySide: false,\n                    acceptSuggestionOnEnter: 'on',\n                    renderGutterMenu: false,\n                }}\n                onMount={diffEditorOnMount}\n                {...editorProps}\n            />\n        )\n    }\n\n    return (\n        <MonacoEditor // eslint-disable-line react/forbid-elements\n            key={queryKey}\n            theme={isDarkModeOn ? 'vs-dark' : 'vs-light'}\n            loading={<Spinner />}\n            value={value}\n            options={editorOptions}\n            onMount={editorOnMount}\n            {...editorProps}\n        />\n    )\n}\n","/*!\n we used to use https://mths.be/cssescape v1.5.1 by @mathias | MIT license\n but the `finder` dependency has always been using `CSS.escape` from the browser\n and nobody has ever pointed out an error\n cssEscape function was only for IE11 users\n and they mustn't be using this anyway\n */\nexport const cssEscape = CSS.escape\n","// This file contains example queries, used in storybook and in the /query interface.\nimport { RETENTION_FIRST_OCCURRENCE_MATCHING_FILTERS } from 'lib/constants'\n\nimport { defaultDataTableColumns } from '~/queries/nodes/DataTable/utils'\nimport {\n    ActionsNode,\n    DataTableNode,\n    DataVisualizationNode,\n    EventsNode,\n    EventsQuery,\n    FunnelsQuery,\n    HogQLQuery,\n    HogQuery,\n    InsightVizNode,\n    LifecycleQuery,\n    Node,\n    NodeKind,\n    PathsQuery,\n    PersonsNode,\n    RetentionQuery,\n    StickinessQuery,\n    TrendsQuery,\n    WebStatsBreakdown,\n    WebVitalsMetric,\n    WebVitalsPathBreakdownQuery,\n    WebVitalsPercentile,\n    WebVitalsQuery,\n} from '~/queries/schema/schema-general'\nimport {\n    BaseMathType,\n    ChartDisplayType,\n    FilterLogicalOperator,\n    InsightType,\n    PropertyFilterType,\n    PropertyGroupFilter,\n    PropertyMathType,\n    PropertyOperator,\n    RetentionPeriod,\n    StepOrderValue,\n} from '~/types'\n\nimport { WEB_VITALS_THRESHOLDS } from './nodes/WebVitals/definitions'\nimport { setLatestVersionsOnQuery } from './utils'\n\nconst Events: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: defaultDataTableColumns(NodeKind.EventsQuery),\n    properties: [\n        { type: PropertyFilterType.Event, key: '$browser', operator: PropertyOperator.Exact, value: 'Chrome' },\n    ],\n    after: '-24h',\n    limit: 100,\n}\n\nconst EventsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: Events,\n}\nconst EventsTableFull: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: Events,\n}\n\nconst TotalEvents: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: ['count()'],\n}\n\nexport const TotalEventsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: TotalEvents,\n}\n\nconst PropertyFormulas: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: [\n        '1 + 2 + 3',\n        'event',\n        'person.created_at',\n        \"concat(properties['$browser'], ' 💚 ', properties['$geoip_city_name']) -- Browser 💚 City\",\n        \"'random string'\",\n    ],\n    limit: 100,\n}\n\nconst PropertyFormulasTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: PropertyFormulas,\n}\n\nconst EventAggregations: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: {\n        kind: NodeKind.EventsQuery,\n        select: [\n            \"concat(properties['$geoip_city_name'], ' ', 'Rocks') -- City\",\n            'event',\n            'count() + 100000 -- Inflamed total',\n            '1 + 2',\n        ],\n        orderBy: ['-count()'],\n    },\n}\n\nconst Persons: PersonsNode = {\n    kind: NodeKind.PersonsNode,\n    properties: [\n        { type: PropertyFilterType.Person, key: '$browser', operator: PropertyOperator.Exact, value: 'Chrome' },\n    ],\n}\n\nconst PersonsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    columns: defaultDataTableColumns(NodeKind.PersonsNode),\n    source: Persons,\n}\n\nconst PersonsTableFull: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    columns: defaultDataTableColumns(NodeKind.PersonsNode),\n    source: Persons,\n}\n\nconst properties: PropertyGroupFilter = {\n    type: FilterLogicalOperator.And,\n    values: [\n        {\n            type: FilterLogicalOperator.Or,\n            values: [\n                {\n                    type: PropertyFilterType.Event,\n                    key: '$current_url',\n                    operator: PropertyOperator.Exact,\n                    value: ['https://hedgebox.net/files/'],\n                },\n                {\n                    type: PropertyFilterType.Event,\n                    key: '$geoip_country_code',\n                    operator: PropertyOperator.Exact,\n                    value: ['US', 'AU'],\n                },\n            ],\n        },\n    ],\n}\n\nconst filterTestAccounts = false\nconst series: (EventsNode | ActionsNode)[] = [\n    {\n        kind: NodeKind.EventsNode,\n        name: '$pageview',\n        custom_name: 'Views',\n        event: '$pageview',\n        properties: [\n            {\n                type: PropertyFilterType.Event,\n                key: '$browser',\n                operator: PropertyOperator.Exact,\n                value: 'Chrome',\n            },\n            {\n                type: PropertyFilterType.Cohort,\n                key: 'id',\n                operator: PropertyOperator.In,\n                value: 2,\n            },\n        ],\n    },\n    // {\n    //     kind: NodeKind.ActionsNode,\n    //     id: 1,\n    //     name: 'Interacted with file',\n    //     custom_name: 'Interactions',\n    //     properties: [\n    //         {\n    //             type: PropertyFilterType.Event,\n    //             key: '$geoip_country_code',\n    //             operator: PropertyOperator.Exact,\n    //             value: ['US'],\n    //         },\n    //     ],\n    //     math: PropertyMathType.Average,\n    //     math_property: '$session_duration',\n    // },\n]\n\nconst InsightTrendsQuery: TrendsQuery = {\n    kind: NodeKind.TrendsQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    trendsFilter: {\n        display: ChartDisplayType.ActionsAreaGraph,\n    },\n    breakdownFilter: {\n        breakdown: '$geoip_country_code',\n        breakdown_type: 'event',\n    },\n}\n\nconst InsightCalendarHeatmapQuery: TrendsQuery = {\n    kind: NodeKind.TrendsQuery,\n    properties: [],\n    filterTestAccounts,\n    series,\n    dateRange: {\n        date_from: '-7d',\n    },\n    trendsFilter: {\n        display: ChartDisplayType.CalendarHeatmap,\n    },\n}\n\nconst InsightFunnelsQuery: FunnelsQuery = {\n    kind: NodeKind.FunnelsQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    funnelsFilter: {\n        funnelOrderType: StepOrderValue.ORDERED,\n    },\n    breakdownFilter: {\n        breakdown: '$geoip_country_code',\n        breakdown_type: 'event',\n    },\n}\n\nconst InsightRetentionQuery: RetentionQuery = {\n    kind: NodeKind.RetentionQuery,\n    properties,\n    filterTestAccounts,\n    retentionFilter: {\n        // TODO: this should be typed as (EventsNode | ActionsNode)[] without math and properties\n        targetEntity: { type: 'events', id: '$pageview', name: '$pageview' },\n        returningEntity: { type: 'events', id: '$pageview', name: '$pageview' },\n    },\n}\n\nconst InsightPathsQuery: PathsQuery = {\n    kind: NodeKind.PathsQuery,\n    properties,\n    filterTestAccounts,\n    pathsFilter: {},\n}\n\nconst InsightStickinessQuery: StickinessQuery = {\n    kind: NodeKind.StickinessQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    stickinessFilter: {},\n}\n\nconst InsightLifecycleQuery: LifecycleQuery = {\n    kind: NodeKind.LifecycleQuery,\n    properties,\n    filterTestAccounts,\n    dateRange: {\n        date_from: '-7d',\n    },\n    series, // TODO: Visualization only supports one event or action\n}\n\nconst HogQLRaw: HogQLQuery = {\n    kind: NodeKind.HogQLQuery,\n    query: `   select event,\n          person.properties.email,\n          properties.$browser,\n          count()\n     from events\n    where {filters} -- replaced with global date and property filters\n      and person.properties.email is not null\n group by event,\n          properties.$browser,\n          person.properties.email\n order by count() desc\n    limit 100`,\n    filters: {\n        dateRange: {\n            date_from: '-24h',\n        },\n    },\n}\n\nconst HogQLForDataVisualization: HogQLQuery = {\n    kind: NodeKind.HogQLQuery,\n    query: `select toDate(timestamp) as timestamp, count()\nfrom events\nwhere timestamp >= now() - interval '7 days'\ngroup by timestamp\norder by timestamp asc\nlimit 100`,\n}\n\nconst HogQLForDataWarehouse: HogQLQuery = {\n    kind: NodeKind.HogQLQuery,\n    query: `select toDate(timestamp) as timestamp, count()\nfrom events\ngroup by timestamp\nlimit 100`,\n    explain: true,\n}\n\nconst DataWarehouse: DataVisualizationNode = {\n    kind: NodeKind.DataVisualizationNode,\n    source: HogQLForDataWarehouse,\n}\n\nconst HogQLTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: HogQLRaw,\n}\n\nconst DataVisualization: DataVisualizationNode = {\n    kind: NodeKind.DataVisualizationNode,\n    source: HogQLForDataVisualization,\n    tableSettings: {\n        columns: [\n            {\n                column: 'timestamp',\n                settings: {\n                    formatting: {\n                        prefix: '',\n                        suffix: '',\n                    },\n                },\n            },\n            {\n                column: 'count()',\n                settings: {\n                    formatting: {\n                        prefix: '',\n                        suffix: '',\n                    },\n                },\n            },\n        ],\n    },\n    chartSettings: { goalLines: undefined },\n}\n\nconst Hog: HogQuery = {\n    kind: NodeKind.HogQuery,\n    code: 'return 1 + 2;',\n}\n\nconst Hoggonacci: HogQuery = {\n    kind: NodeKind.HogQuery,\n    code: `fn fibonacci(number) {\n    if (number < 2) {\n        return number;\n    } else {\n        return fibonacci(number - 1) + fibonacci(number - 2);\n    }\n}\nreturn fibonacci(16);`,\n}\n\nconst WebVitals: WebVitalsQuery = {\n    kind: NodeKind.WebVitalsQuery,\n    properties: [],\n    dateRange: {\n        date_from: '-7d',\n    },\n    source: {\n        kind: NodeKind.TrendsQuery,\n        dateRange: {\n            date_from: '-7d',\n        },\n        interval: 'day',\n        series: (['INP', 'LCP', 'CLS', 'FCP'] as WebVitalsMetric[]).flatMap((name) =>\n            [PropertyMathType.P75, PropertyMathType.P90, PropertyMathType.P99].map((math) => ({\n                kind: NodeKind.EventsNode,\n                event: '$web_vitals',\n                name: '$web_vitals',\n                custom_name: name,\n                math: math,\n                math_property: `$web_vitals_${name}_value`,\n            }))\n        ),\n        trendsFilter: { display: ChartDisplayType.ActionsLineGraph },\n        filterTestAccounts,\n    },\n}\n\nconst WebVitalsPathBreakdown: WebVitalsPathBreakdownQuery = {\n    kind: NodeKind.WebVitalsPathBreakdownQuery,\n    properties: [],\n    dateRange: {\n        date_from: '-7d',\n    },\n    filterTestAccounts,\n    percentile: 'p90' as WebVitalsPercentile,\n    metric: 'CLS' as WebVitalsMetric,\n    doPathCleaning: true,\n    thresholds: [WEB_VITALS_THRESHOLDS['CLS'].good, WEB_VITALS_THRESHOLDS['CLS'].poor],\n}\n\nconst WebAnalyticsReferrerDomain: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: {\n        kind: NodeKind.WebStatsTableQuery,\n        properties: [],\n        breakdownBy: WebStatsBreakdown.InitialReferringDomain,\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        compareFilter: { compare: false },\n        limit: 10,\n        filterTestAccounts: false,\n        conversionGoal: null,\n    },\n}\n\nconst WebAnalyticsPath: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: {\n        kind: NodeKind.WebStatsTableQuery,\n        properties: [],\n        breakdownBy: WebStatsBreakdown.Page,\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        compareFilter: { compare: false },\n        limit: 10,\n        filterTestAccounts: false,\n        conversionGoal: null,\n    },\n}\n\nconst WebAnalyticsBrowser: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: {\n        kind: NodeKind.WebStatsTableQuery,\n        properties: [],\n        breakdownBy: WebStatsBreakdown.Browser,\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        compareFilter: { compare: false },\n        limit: 10,\n        filterTestAccounts: false,\n        conversionGoal: null,\n    },\n}\n\nconst WebAnalyticsWorldMap: InsightVizNode<TrendsQuery> = {\n    kind: NodeKind.InsightVizNode,\n    source: {\n        kind: NodeKind.TrendsQuery,\n        breakdownFilter: {\n            breakdown: '$geoip_country_code',\n            breakdown_type: 'event',\n        },\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        series: [\n            {\n                event: '$pageview',\n                name: 'Pageview',\n                kind: NodeKind.EventsNode,\n                math: BaseMathType.MonthlyActiveUsers, // Should be DAU, but it's not supported yet\n            },\n        ],\n        trendsFilter: { display: ChartDisplayType.WorldMap },\n        filterTestAccounts: false,\n        properties: [],\n    },\n}\n\nconst WebAnalyticsRetention: InsightVizNode<RetentionQuery> = {\n    kind: NodeKind.InsightVizNode,\n    source: {\n        kind: NodeKind.RetentionQuery,\n        properties: [],\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        filterTestAccounts: false,\n        retentionFilter: {\n            retentionType: RETENTION_FIRST_OCCURRENCE_MATCHING_FILTERS,\n            retentionReference: 'total',\n            totalIntervals: 8,\n            period: RetentionPeriod.Week,\n        },\n    },\n    vizSpecificOptions: {\n        [InsightType.RETENTION]: {\n            hideLineGraph: true,\n            hideSizeColumn: false,\n            useSmallLayout: false,\n        },\n    },\n}\n\n/* a subset of examples including only those we can show all users and that don't use HogQL */\nexport const queryExamples: Record<string, Node> = {\n    Events,\n    EventsTable,\n    EventsTableFull,\n    TotalEventsTable,\n    PropertyFormulasTable,\n    EventAggregations,\n    Persons,\n    PersonsTable,\n    PersonsTableFull,\n    InsightTrendsQuery,\n    InsightTrends: { kind: NodeKind.InsightVizNode, source: InsightTrendsQuery } as InsightVizNode<TrendsQuery>,\n    InsightCalendarHeatmapQuery,\n    InsightCalendarHeatmap: {\n        kind: NodeKind.InsightVizNode,\n        source: InsightCalendarHeatmapQuery,\n    } as InsightVizNode<TrendsQuery>,\n    InsightFunnelsQuery,\n    InsightFunnels: { kind: NodeKind.InsightVizNode, source: InsightFunnelsQuery } as InsightVizNode<FunnelsQuery>,\n    InsightRetentionQuery,\n    InsightRetention: {\n        kind: NodeKind.InsightVizNode,\n        source: InsightRetentionQuery,\n    } as InsightVizNode<RetentionQuery>,\n    InsightPathsQuery,\n    InsightPaths: { kind: NodeKind.InsightVizNode, source: InsightPathsQuery } as InsightVizNode<PathsQuery>,\n    InsightStickinessQuery,\n    InsightStickiness: {\n        kind: NodeKind.InsightVizNode,\n        source: InsightStickinessQuery,\n    } as InsightVizNode<StickinessQuery>,\n    InsightLifecycleQuery,\n    InsightLifecycle: {\n        kind: NodeKind.InsightVizNode,\n        source: InsightLifecycleQuery,\n    } as InsightVizNode<LifecycleQuery>,\n    WebVitals,\n    WebVitalsPathBreakdown,\n    WebAnalyticsWorldMap,\n    WebAnalyticsReferrerDomain,\n    WebAnalyticsPath,\n    WebAnalyticsBrowser,\n    WebAnalyticsRetention,\n}\n\nexport const stringifiedQueryExamples: Record<string, string> = Object.fromEntries(\n    Object.entries(queryExamples).map(([key, node]) => [key, JSON.stringify(node)])\n)\n\nexport const examples: Record<string, Node> = setLatestVersionsOnQuery({\n    ...queryExamples,\n    HogQLRaw,\n    HogQLTable,\n    DataVisualization,\n    HogQLForDataVisualization,\n    Hog,\n    Hoggonacci,\n    DataWarehouse,\n})\n\nexport const stringifiedExamples: Record<string, string> = Object.fromEntries(\n    Object.entries(examples).map(([key, node]) => [key, JSON.stringify(node)])\n)\n","import './DataTable.scss'\n\nimport clsx from 'clsx'\nimport { BindLogic, BuiltLogic, LogicWrapper, useActions, useValues } from 'kea'\nimport { useCallback, useState } from 'react'\n\nimport { PreAggregatedBadge } from 'lib/components/PreAggregatedBadge'\nimport { TaxonomicFilterGroupType } from 'lib/components/TaxonomicFilter/types'\nimport { TaxonomicPopover } from 'lib/components/TaxonomicPopover/TaxonomicPopover'\nimport { useFeatureFlag } from 'lib/hooks/useFeatureFlag'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonDivider } from 'lib/lemon-ui/LemonDivider'\nimport { LemonTable, LemonTableColumn } from 'lib/lemon-ui/LemonTable'\nimport { useAttachedLogic } from 'lib/logic/scenes/useAttachedLogic'\nimport { EventDetails } from 'scenes/activity/explore/EventDetails'\nimport { ViewLinkButton } from 'scenes/data-warehouse/ViewLinkModal'\nimport { groupViewLogic } from 'scenes/groups/groupViewLogic'\nimport { InsightEmptyState, InsightErrorState } from 'scenes/insights/EmptyStates'\nimport { PersonDeleteModal } from 'scenes/persons/PersonDeleteModal'\nimport { createMarketingAnalyticsOrderBy } from 'scenes/web-analytics/tabs/marketing-analytics/frontend/logic/utils'\n\nimport { DateRange } from '~/queries/nodes/DataNode/DateRange'\nimport { ElapsedTime } from '~/queries/nodes/DataNode/ElapsedTime'\nimport { LoadNext } from '~/queries/nodes/DataNode/LoadNext'\nimport { Reload } from '~/queries/nodes/DataNode/Reload'\nimport { TestAccountFilters } from '~/queries/nodes/DataNode/TestAccountFilters'\nimport { DataNodeLogicProps, dataNodeLogic } from '~/queries/nodes/DataNode/dataNodeLogic'\nimport { BackToSource } from '~/queries/nodes/DataTable/BackToSource'\nimport { ColumnConfigurator } from '~/queries/nodes/DataTable/ColumnConfigurator/ColumnConfigurator'\nimport { DataTableExport } from '~/queries/nodes/DataTable/DataTableExport'\nimport { DataTableSavedFilters } from '~/queries/nodes/DataTable/DataTableSavedFilters'\nimport { DataTableSavedFiltersButton } from '~/queries/nodes/DataTable/DataTableSavedFiltersButton'\nimport { EventRowActions } from '~/queries/nodes/DataTable/EventRowActions'\nimport { InsightActorsQueryOptions } from '~/queries/nodes/DataTable/InsightActorsQueryOptions'\nimport { SavedQueries } from '~/queries/nodes/DataTable/SavedQueries'\nimport { DataTableLogicProps, DataTableRow, dataTableLogic } from '~/queries/nodes/DataTable/dataTableLogic'\nimport { QueryFeature } from '~/queries/nodes/DataTable/queryFeatures'\nimport { getContextColumn, renderColumn } from '~/queries/nodes/DataTable/renderColumn'\nimport { renderColumnMeta } from '~/queries/nodes/DataTable/renderColumnMeta'\nimport {\n    extractExpressionComment,\n    getDataNodeDefaultColumns,\n    removeExpressionComment,\n} from '~/queries/nodes/DataTable/utils'\nimport { EventName } from '~/queries/nodes/EventsNode/EventName'\nimport { EventPropertyFilters } from '~/queries/nodes/EventsNode/EventPropertyFilters'\nimport { HogQLQueryEditor } from '~/queries/nodes/HogQLQuery/HogQLQueryEditor'\nimport { insightVizDataNodeKey } from '~/queries/nodes/InsightViz/InsightViz'\nimport { EditHogQLButton } from '~/queries/nodes/Node/EditHogQLButton'\nimport { OpenEditorButton } from '~/queries/nodes/Node/OpenEditorButton'\nimport { PersonPropertyFilters } from '~/queries/nodes/PersonsNode/PersonPropertyFilters'\nimport { PersonsSearch } from '~/queries/nodes/PersonsNode/PersonsSearch'\nimport {\n    ActorsQuery,\n    AnyResponseType,\n    DataTableNode,\n    EventsNode,\n    EventsQuery,\n    GroupsQuery,\n    HogQLQuery,\n    MarketingAnalyticsTableQuery,\n    NodeKind,\n    PersonsNode,\n    SessionAttributionExplorerQuery,\n    TracesQuery,\n} from '~/queries/schema/schema-general'\nimport { QueryContext } from '~/queries/types'\nimport {\n    isActorsQuery,\n    isEventsQuery,\n    isGroupsQuery,\n    isHogQLAggregation,\n    isHogQLQuery,\n    isInsightActorsQuery,\n    isMarketingAnalyticsTableQuery,\n    isRevenueExampleEventsQuery,\n    taxonomicEventFilterToHogQL,\n    taxonomicGroupFilterToHogQL,\n    taxonomicPersonFilterToHogQL,\n} from '~/queries/utils'\nimport { EventType, InsightLogicProps } from '~/types'\n\nimport { GroupPropertyFilters } from '../GroupsQuery/GroupPropertyFilters'\nimport { GroupsSearch } from '../GroupsQuery/GroupsSearch'\nimport { DataTableOpenEditor } from './DataTableOpenEditor'\n\nexport enum ColumnFeature {\n    canSort = 'canSort',\n    canEdit = 'canEdit',\n    canAddColumns = 'canAddColumns',\n    canRemove = 'canRemove',\n    canPin = 'canPin',\n}\n\ninterface DataTableProps {\n    uniqueKey?: string | number\n    query: DataTableNode\n    setQuery: (query: DataTableNode) => void\n    /** Custom table columns and export configuration */\n    context?: QueryContext<DataTableNode>\n    /* Cached Results are provided when shared or exported,\n    the data node logic becomes read only implicitly */\n    cachedResults?: AnyResponseType\n    // Override the data logic node key if needed\n    dataNodeLogicKey?: string\n    readOnly?: boolean\n    /*\n     Set a data-attr on the LemonTable component\n    */\n    dataAttr?: string\n    /** Attach ourselves to another logic, such as the scene logic */\n    attachTo?: BuiltLogic | LogicWrapper\n}\n\nconst eventGroupTypes = [\n    TaxonomicFilterGroupType.HogQLExpression,\n    TaxonomicFilterGroupType.EventProperties,\n    TaxonomicFilterGroupType.PersonProperties,\n    TaxonomicFilterGroupType.EventFeatureFlags,\n]\nconst personGroupTypes = [TaxonomicFilterGroupType.HogQLExpression, TaxonomicFilterGroupType.PersonProperties]\n\nlet uniqueNode = 0\n\nexport function DataTable({\n    uniqueKey,\n    query,\n    setQuery,\n    context,\n    cachedResults,\n    readOnly,\n    dataAttr,\n    attachTo,\n}: DataTableProps): JSX.Element {\n    const [uniqueNodeKey] = useState(() => uniqueNode++)\n    const [dataKey] = useState(() => `DataNode.${uniqueKey || uniqueNodeKey}`)\n    const insightProps: InsightLogicProps<DataTableNode> = context?.insightProps || {\n        dashboardItemId: `new-AdHoc.${dataKey}`,\n        dataNodeCollectionId: dataKey,\n    }\n\n    // support for existing column features by default\n    const columnFeatures = context?.columnFeatures || [\n        ColumnFeature.canSort,\n        ColumnFeature.canEdit,\n        ColumnFeature.canAddColumns,\n        ColumnFeature.canRemove,\n    ]\n    const vizKey = insightVizDataNodeKey(insightProps)\n    const dataNodeLogicProps: DataNodeLogicProps = {\n        query: query.source,\n        key: context?.dataNodeLogicKey ?? vizKey,\n        cachedResults: cachedResults,\n        dataNodeCollectionId: context?.insightProps?.dataNodeCollectionId || dataKey,\n        refresh: context?.refresh,\n        maxPaginationLimit: context?.dataTableMaxPaginationLimit,\n    }\n    const {\n        response,\n        responseLoading,\n        responseError,\n        queryCancelled,\n        nextDataLoading,\n        newDataLoading,\n        highlightedRows,\n        backToSourceQuery,\n    } = useValues(dataNodeLogic(dataNodeLogicProps))\n    const { setSaveGroupViewModalOpen } = useActions(groupViewLogic)\n\n    const canUseWebAnalyticsPreAggregatedTables = useFeatureFlag('SETTINGS_WEB_ANALYTICS_PRE_AGGREGATED_TABLES')\n    const hasCrmIterationOneEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n    const usedWebAnalyticsPreAggregatedTables =\n        canUseWebAnalyticsPreAggregatedTables &&\n        response &&\n        'usedPreAggregatedTables' in response &&\n        response.usedPreAggregatedTables &&\n        response?.hogql\n\n    const dataTableLogicProps: DataTableLogicProps = {\n        query,\n        vizKey,\n        dataKey,\n        dataNodeLogicKey: dataNodeLogicProps.key,\n        context,\n    }\n    const { dataTableRows, columnsInQuery, columnsInResponse, queryWithDefaults, canSort, sourceFeatures } = useValues(\n        dataTableLogic(dataTableLogicProps)\n    )\n\n    useAttachedLogic(dataNodeLogic(dataNodeLogicProps), attachTo)\n    useAttachedLogic(dataTableLogic(dataTableLogicProps), attachTo)\n\n    const {\n        showActions,\n        showDateRange,\n        showTestAccountFilters,\n        showSearch,\n        showEventFilter,\n        showPropertyFilter,\n        showHogQLEditor,\n        showReload,\n        showExport,\n        showElapsedTime,\n        showColumnConfigurator,\n        showPersistentColumnConfigurator,\n        showSavedQueries,\n        showSavedFilters,\n        expandable,\n        embedded,\n        showOpenEditorButton,\n        showResultsTable,\n        showTimings,\n    } = queryWithDefaults\n\n    const isReadOnly = !!readOnly\n\n    const eventActionsColumnShown =\n        showActions && sourceFeatures.has(QueryFeature.eventActionsColumn) && columnsInResponse?.includes('*')\n    const allColumns = sourceFeatures.has(QueryFeature.columnsInResponse)\n        ? (columnsInResponse ?? columnsInQuery)\n        : columnsInQuery\n    const columnsInLemonTable = allColumns.filter((colName) => {\n        const col = getContextColumn(colName, context?.columns)\n        return !col?.queryContextColumn?.hidden\n    })\n    const rowFillFractionIndex = allColumns.findIndex((colName) => {\n        const col = getContextColumn(colName, context?.columns)\n        return col?.queryContextColumn?.isRowFillFraction\n    })\n\n    const contextRowPropsFn = context?.rowProps\n    const onRow = useCallback(\n        (record) => {\n            const rowProps = contextRowPropsFn?.(record)\n            const rowFillFraction =\n                rowFillFractionIndex >= 0 && Array.isArray(record.result)\n                    ? record.result[rowFillFractionIndex]\n                    : undefined\n            if (\n                typeof rowFillFraction === 'number' &&\n                !Number.isNaN(rowFillFraction) &&\n                rowFillFraction >= 0 &&\n                rowFillFraction <= 1\n            ) {\n                return {\n                    ...rowProps,\n                    style: {\n                        ...rowProps?.style,\n                        '--data-table-fraction-fill': `${Math.round(rowFillFraction * 100)}%`,\n                    },\n                }\n            }\n            return rowProps ?? {}\n        },\n        [contextRowPropsFn, rowFillFractionIndex]\n    )\n\n    const groupTypes = isActorsQuery(query.source) ? personGroupTypes : eventGroupTypes\n\n    const lemonColumns: LemonTableColumn<DataTableRow, any>[] = [\n        ...columnsInLemonTable.map((key, index) => ({\n            dataIndex: key as any,\n            ...renderColumnMeta(key, query, context),\n            render: function RenderDataTableColumn(\n                _: any,\n                { result, label }: DataTableRow,\n                recordIndex: number,\n                rowCount: number\n            ) {\n                if (label) {\n                    if (index === (expandable ? 1 : 0)) {\n                        return {\n                            children: label,\n                            props: { colSpan: columnsInLemonTable.length + (eventActionsColumnShown ? 1 : 0) },\n                        }\n                    }\n                    return { props: { colSpan: 0 } }\n                } else if (result) {\n                    if (sourceFeatures.has(QueryFeature.resultIsArrayOfArrays)) {\n                        return renderColumn(key, result[index], result, recordIndex, rowCount, query, setQuery, context)\n                    }\n                    return renderColumn(key, result[key], result, recordIndex, rowCount, query, setQuery, context)\n                }\n            },\n            sorter: undefined, // using custom sorting code\n            more:\n                !isReadOnly && showActions && sourceFeatures.has(QueryFeature.selectAndOrderByColumns) ? (\n                    <>\n                        <div className=\"px-2 py-1 max-w-md\">\n                            <div className=\"font-mono font-bold truncate\">{extractExpressionComment(key)}</div>\n                            {extractExpressionComment(key) !== removeExpressionComment(key) && (\n                                <div className=\"font-mono truncate\">{removeExpressionComment(key)}</div>\n                            )}\n                        </div>\n                        {columnFeatures.includes(ColumnFeature.canEdit) && (\n                            <>\n                                <LemonDivider />\n                                <TaxonomicPopover\n                                    groupType={TaxonomicFilterGroupType.HogQLExpression}\n                                    value={key}\n                                    groupTypes={groupTypes}\n                                    metadataSource={query.source}\n                                    renderValue={() => <>Edit column</>}\n                                    type=\"tertiary\"\n                                    fullWidth\n                                    onChange={(v, g) => {\n                                        const hogQl = isActorsQuery(query.source)\n                                            ? taxonomicPersonFilterToHogQL(g, v)\n                                            : taxonomicEventFilterToHogQL(g, v)\n                                        if (\n                                            setQuery &&\n                                            hogQl &&\n                                            sourceFeatures.has(QueryFeature.selectAndOrderByColumns)\n                                        ) {\n                                            // Typecasting to a query type with select and order_by fields.\n                                            // The actual query may or may not be an events query.\n                                            const source = query.source as EventsQuery\n                                            const columns = columnsInLemonTable ?? getDataNodeDefaultColumns(source)\n                                            const isAggregation = isHogQLAggregation(hogQl)\n                                            const isOrderBy = source.orderBy?.[0] === key\n                                            const isDescOrderBy = source.orderBy?.[0] === `${key} DESC`\n                                            setQuery({\n                                                ...query,\n                                                source: {\n                                                    ...source,\n                                                    select: columns\n                                                        .map((s, i) => (i === index ? hogQl : s))\n                                                        .filter((c) =>\n                                                            isAggregation ? c !== '*' && c !== 'person.$delete' : true\n                                                        ),\n                                                    orderBy:\n                                                        isOrderBy || isDescOrderBy\n                                                            ? [isDescOrderBy ? `${hogQl} DESC` : hogQl]\n                                                            : source.orderBy,\n                                                },\n                                            })\n                                        }\n                                    }}\n                                />\n                            </>\n                        )}\n                        {canSort &&\n                        key !== 'person.$delete' &&\n                        key !== 'person' &&\n                        columnFeatures.includes(ColumnFeature.canSort) ? (\n                            <>\n                                <LemonDivider />\n                                <LemonButton\n                                    fullWidth\n                                    data-attr=\"datatable-sort-asc\"\n                                    onClick={() => {\n                                        const orderBy =\n                                            query.source.kind === NodeKind.MarketingAnalyticsTableQuery\n                                                ? createMarketingAnalyticsOrderBy(key, 'ASC')\n                                                : [key]\n                                        setQuery?.({\n                                            ...query,\n                                            source: {\n                                                ...query.source,\n                                                orderBy,\n                                            } as EventsQuery,\n                                        })\n                                    }}\n                                >\n                                    Sort ascending\n                                </LemonButton>\n                                <LemonButton\n                                    fullWidth\n                                    data-attr=\"datatable-sort-desc\"\n                                    onClick={() => {\n                                        const orderBy =\n                                            query.source.kind === NodeKind.MarketingAnalyticsTableQuery\n                                                ? createMarketingAnalyticsOrderBy(key, 'DESC')\n                                                : [`${key}\\n DESC`]\n                                        setQuery?.({\n                                            ...query,\n                                            source: {\n                                                ...query.source,\n                                                orderBy,\n                                            } as EventsQuery,\n                                        })\n                                    }}\n                                >\n                                    Sort descending\n                                </LemonButton>\n                                <LemonButton\n                                    fullWidth\n                                    data-attr=\"datatable-reset-sort\"\n                                    onClick={() => {\n                                        setQuery?.({\n                                            ...query,\n                                            source: {\n                                                ...query.source,\n                                                orderBy: [],\n                                            } as EventsQuery,\n                                        })\n                                    }}\n                                >\n                                    Reset sorting\n                                </LemonButton>\n                            </>\n                        ) : null}\n\n                        {columnFeatures.includes(ColumnFeature.canAddColumns) && (\n                            <>\n                                <LemonDivider />\n                                <TaxonomicPopover\n                                    groupType={TaxonomicFilterGroupType.HogQLExpression}\n                                    value=\"\"\n                                    groupTypes={groupTypes}\n                                    metadataSource={query.source}\n                                    placeholder={<span className=\"not-italic\">Add column left</span>}\n                                    data-attr=\"datatable-add-column-left\"\n                                    type=\"tertiary\"\n                                    fullWidth\n                                    onChange={(v, g) => {\n                                        const hogQl = isActorsQuery(query.source)\n                                            ? taxonomicPersonFilterToHogQL(g, v)\n                                            : isGroupsQuery(query.source)\n                                              ? taxonomicGroupFilterToHogQL(g, v)\n                                              : taxonomicEventFilterToHogQL(g, v)\n                                        if (\n                                            setQuery &&\n                                            hogQl &&\n                                            sourceFeatures.has(QueryFeature.selectAndOrderByColumns)\n                                        ) {\n                                            const isAggregation = isHogQLAggregation(hogQl)\n                                            const source = query.source as EventsQuery\n                                            const columns = columnsInLemonTable ?? getDataNodeDefaultColumns(source)\n                                            setQuery({\n                                                ...query,\n                                                source: {\n                                                    ...source,\n                                                    select: [\n                                                        ...columns.slice(0, index),\n                                                        hogQl,\n                                                        ...columns.slice(index),\n                                                    ].filter((c) =>\n                                                        isAggregation ? c !== '*' && c !== 'person.$delete' : true\n                                                    ),\n                                                } as EventsQuery | ActorsQuery,\n                                            })\n                                        }\n                                    }}\n                                />\n                                <TaxonomicPopover\n                                    groupType={TaxonomicFilterGroupType.HogQLExpression}\n                                    value=\"\"\n                                    groupTypes={groupTypes}\n                                    metadataSource={query.source}\n                                    placeholder={<span className=\"not-italic\">Add column right</span>}\n                                    data-attr=\"datatable-add-column-right\"\n                                    type=\"tertiary\"\n                                    fullWidth\n                                    onChange={(v, g) => {\n                                        const hogQl = isActorsQuery(query.source)\n                                            ? taxonomicPersonFilterToHogQL(g, v)\n                                            : isGroupsQuery(query.source)\n                                              ? taxonomicGroupFilterToHogQL(g, v)\n                                              : taxonomicEventFilterToHogQL(g, v)\n                                        if (\n                                            setQuery &&\n                                            hogQl &&\n                                            sourceFeatures.has(QueryFeature.selectAndOrderByColumns)\n                                        ) {\n                                            const isAggregation = isHogQLAggregation(hogQl)\n                                            const source = query.source as EventsQuery\n                                            const columns = columnsInLemonTable ?? getDataNodeDefaultColumns(source)\n                                            setQuery?.({\n                                                ...query,\n                                                source: {\n                                                    ...source,\n                                                    select: [\n                                                        ...columns.slice(0, index + 1),\n                                                        hogQl,\n                                                        ...columns.slice(index + 1),\n                                                    ].filter((c) =>\n                                                        isAggregation ? c !== '*' && c !== 'person.$delete' : true\n                                                    ),\n                                                } as EventsQuery | ActorsQuery,\n                                            })\n                                        }\n                                    }}\n                                />\n                            </>\n                        )}\n                        {columnsInQuery.filter((c) => c !== '*').length > 1 &&\n                            columnFeatures.includes(ColumnFeature.canRemove) && (\n                                <>\n                                    <LemonDivider />\n                                    <LemonButton\n                                        fullWidth\n                                        status=\"danger\"\n                                        data-attr=\"datatable-remove-column\"\n                                        onClick={() => {\n                                            const cleanColumnKey = removeExpressionComment(key)\n                                            const newSource: EventsQuery = {\n                                                ...(query.source as EventsQuery),\n                                                select: (query.source as EventsQuery).select.filter(\n                                                    (_, i) => i !== index\n                                                ),\n                                                // remove the current column from orderBy if it's there\n                                                orderBy: (\n                                                    query.source as EventsQuery | MarketingAnalyticsTableQuery\n                                                ).orderBy?.find((orderKey) => {\n                                                    if (\n                                                        typeof orderKey === 'object' &&\n                                                        isMarketingAnalyticsTableQuery(query.source)\n                                                    ) {\n                                                        return orderKey[0] === cleanColumnKey\n                                                    } else if (typeof orderKey === 'string') {\n                                                        return (\n                                                            removeExpressionComment(orderKey) === cleanColumnKey ||\n                                                            removeExpressionComment(orderKey) === `-${cleanColumnKey}`\n                                                        )\n                                                    }\n                                                })\n                                                    ? undefined\n                                                    : (query.source as EventsQuery).orderBy,\n                                            }\n                                            const newPinnedColumns = query.pinnedColumns?.filter(\n                                                (column) => column !== key\n                                            )\n                                            setQuery?.({\n                                                ...query,\n                                                source: newSource,\n                                                pinnedColumns: newPinnedColumns,\n                                            })\n                                        }}\n                                    >\n                                        Remove column\n                                    </LemonButton>\n                                </>\n                            )}\n                        {columnFeatures.includes(ColumnFeature.canPin) && (\n                            <>\n                                <LemonDivider />\n                                <LemonButton\n                                    fullWidth\n                                    data-attr=\"datatable-pin-column\"\n                                    onClick={() => {\n                                        let newPinnedColumns = new Set(query.pinnedColumns ?? [])\n                                        if (newPinnedColumns.has(key)) {\n                                            newPinnedColumns.delete(key)\n                                        } else {\n                                            newPinnedColumns.add(key)\n                                        }\n                                        setQuery?.({\n                                            ...query,\n                                            pinnedColumns: Array.from(newPinnedColumns),\n                                        })\n                                    }}\n                                >\n                                    {query.pinnedColumns?.includes(key) ? 'Unpin' : 'Pin column'}\n                                </LemonButton>\n                            </>\n                        )}\n                    </>\n                ) : undefined,\n        })),\n        ...(eventActionsColumnShown\n            ? [\n                  {\n                      dataIndex: '__more' as any,\n                      title: '',\n                      render: function RenderMore(_: any, { label, result }: DataTableRow) {\n                          if (label) {\n                              return { props: { colSpan: 0 } }\n                          }\n                          if (result && columnsInResponse?.includes('*')) {\n                              return <EventRowActions event={result[columnsInResponse.indexOf('*')]} />\n                          }\n                          return null\n                      },\n                      width: 0,\n                  },\n              ]\n            : []),\n    ].filter((column) => !query.hiddenColumns?.includes(column.dataIndex) && column.dataIndex !== '*')\n\n    const setQuerySource = useCallback(\n        (\n            source:\n                | EventsNode\n                | EventsQuery\n                | PersonsNode\n                | ActorsQuery\n                | GroupsQuery\n                | HogQLQuery\n                | SessionAttributionExplorerQuery\n                | TracesQuery\n                | MarketingAnalyticsTableQuery\n        ) => setQuery?.({ ...query, source }),\n        [setQuery, query]\n    )\n\n    const firstRowLeft = [\n        backToSourceQuery ? <BackToSource key=\"return-to-source\" /> : null,\n        backToSourceQuery && isActorsQuery(query.source) && isInsightActorsQuery(query.source.source) ? (\n            <InsightActorsQueryOptions\n                query={query.source.source}\n                setQuery={(q) =>\n                    setQuerySource({\n                        ...query.source,\n                        source: { ...(query.source as ActorsQuery).source, ...q },\n                    } as ActorsQuery)\n                }\n                key=\"source-query-options\"\n            />\n        ) : null,\n        showDateRange && sourceFeatures.has(QueryFeature.dateRangePicker) ? (\n            <DateRange\n                key=\"date-range\"\n                query={query.source as HogQLQuery | EventsQuery | SessionAttributionExplorerQuery | TracesQuery}\n                setQuery={setQuerySource}\n            />\n        ) : null,\n        showEventFilter && sourceFeatures.has(QueryFeature.eventNameFilter) ? (\n            <EventName key=\"event-name\" query={query.source as EventsQuery} setQuery={setQuerySource} />\n        ) : null,\n        showSearch && sourceFeatures.has(QueryFeature.personsSearch) ? (\n            <PersonsSearch key=\"persons-search\" query={query.source as PersonsNode} setQuery={setQuerySource} />\n        ) : null,\n        showSearch && sourceFeatures.has(QueryFeature.groupsSearch) ? (\n            <GroupsSearch\n                key=\"groups-search\"\n                query={query.source as GroupsQuery}\n                setQuery={setQuerySource}\n                groupTypeLabel={context?.groupTypeLabel}\n            />\n        ) : null,\n        showPropertyFilter && sourceFeatures.has(QueryFeature.eventPropertyFilters) ? (\n            <EventPropertyFilters\n                key=\"event-property\"\n                query={query.source as EventsQuery | HogQLQuery | SessionAttributionExplorerQuery | TracesQuery}\n                setQuery={setQuerySource}\n                taxonomicGroupTypes={Array.isArray(showPropertyFilter) ? showPropertyFilter : undefined}\n            />\n        ) : null,\n        showSavedFilters && uniqueKey ? (\n            <DataTableSavedFiltersButton\n                key=\"saved-filters-button\"\n                uniqueKey={String(uniqueKey)}\n                query={query}\n                setQuery={setQuery}\n            />\n        ) : null,\n        showPropertyFilter && sourceFeatures.has(QueryFeature.personPropertyFilters) ? (\n            <PersonPropertyFilters\n                key=\"person-property\"\n                query={query.source as PersonsNode}\n                setQuery={setQuerySource}\n            />\n        ) : null,\n        showPropertyFilter && sourceFeatures.has(QueryFeature.groupPropertyFilters) ? (\n            <div className=\"flex gap-2\">\n                <GroupPropertyFilters\n                    key=\"group-property\"\n                    query={query.source as GroupsQuery}\n                    setQuery={setQuerySource}\n                />\n                {hasCrmIterationOneEnabled && (\n                    <LemonButton\n                        data-attr=\"save-group-view\"\n                        type=\"primary\"\n                        size=\"small\"\n                        onClick={() => setSaveGroupViewModalOpen(true)}\n                    >\n                        Save view\n                    </LemonButton>\n                )}\n            </div>\n        ) : null,\n    ].filter((x) => !!x)\n\n    const firstRowRight = [\n        showTestAccountFilters && sourceFeatures.has(QueryFeature.testAccountFilters) ? (\n            <TestAccountFilters key=\"test-account-filters\" query={query.source} setQuery={setQuerySource} />\n        ) : null,\n        showSavedQueries && sourceFeatures.has(QueryFeature.savedEventsQueries) ? (\n            <SavedQueries key=\"saved-queries\" query={query} setQuery={setQuery} />\n        ) : null,\n    ].filter((x) => !!x)\n\n    const secondRowLeft = [\n        showReload ? <Reload key=\"reload\" /> : null,\n        showElapsedTime ? <ElapsedTime key=\"elapsed-time\" showTimings={showTimings} /> : null,\n    ].filter((x) => !!x)\n\n    const secondRowRight = [\n        sourceFeatures.has(QueryFeature.linkDataButton) && hasCrmIterationOneEnabled ? (\n            <ViewLinkButton tableName=\"groups\" />\n        ) : null,\n        (showColumnConfigurator || showPersistentColumnConfigurator) &&\n        sourceFeatures.has(QueryFeature.columnConfigurator) ? (\n            <ColumnConfigurator key=\"column-configurator\" query={query} setQuery={setQuery} />\n        ) : null,\n        showExport ? (\n            <DataTableExport\n                key=\"data-table-export\"\n                query={query}\n                setQuery={setQuery}\n                fileNameForExport={context?.fileNameForExport}\n            />\n        ) : null,\n        showExport && showOpenEditorButton ? (\n            <DataTableOpenEditor key=\"data-table-open-editor\" query={query} setQuery={setQuery} />\n        ) : null,\n    ].filter((x) => !!x)\n\n    const showFirstRow = !isReadOnly && (firstRowLeft.length > 0 || firstRowRight.length > 0)\n    const showSecondRow = !isReadOnly && (secondRowLeft.length > 0 || secondRowRight.length > 0)\n    const inlineEditorButtonOnRow = showFirstRow ? 1 : showSecondRow ? 2 : 0\n\n    const editorButton = (\n        <>\n            <OpenEditorButton query={query} />\n            {response && 'hogql' in response && response?.hogql ? <EditHogQLButton hogql={response.hogql} /> : null}\n        </>\n    )\n\n    // The editor button moved under \"export\". Show only if there's no export button.\n    if (!showExport && showOpenEditorButton && !isReadOnly) {\n        if (inlineEditorButtonOnRow === 1) {\n            firstRowRight.push(editorButton)\n        } else if (inlineEditorButtonOnRow === 2) {\n            secondRowRight.push(editorButton)\n        }\n    }\n    return (\n        <BindLogic logic={dataTableLogic} props={dataTableLogicProps}>\n            <BindLogic logic={dataNodeLogic} props={dataNodeLogicProps}>\n                <div className=\"relative w-full flex flex-col gap-4 flex-1 h-full\">\n                    {showHogQLEditor && isHogQLQuery(query.source) && !isReadOnly ? (\n                        <HogQLQueryEditor query={query.source} setQuery={setQuerySource} embedded={embedded} />\n                    ) : null}\n                    {showFirstRow && (\n                        <div className=\"flex gap-x-4 gap-y-2 items-center flex-wrap\">\n                            {firstRowLeft}\n                            {firstRowLeft.length > 0 && firstRowRight.length > 0 ? <div className=\"flex-1\" /> : null}\n                            {firstRowRight}\n                        </div>\n                    )}\n                    {showSavedFilters && uniqueKey && (\n                        <DataTableSavedFilters uniqueKey={String(uniqueKey)} query={query} setQuery={setQuery} />\n                    )}\n                    {showFirstRow && showSecondRow && <LemonDivider className=\"my-0\" />}\n                    {showSecondRow && (\n                        <div className=\"flex gap-4 justify-between flex-wrap DataTable__second-row\">\n                            <div className=\"flex gap-4 items-center\">{secondRowLeft}</div>\n                            <div className=\"flex gap-4 items-center\">{secondRowRight}</div>\n                        </div>\n                    )}\n                    {showOpenEditorButton && inlineEditorButtonOnRow === 0 && !isReadOnly ? (\n                        <div className=\"absolute right-0 z-10 p-1\">{editorButton}</div>\n                    ) : null}\n                    {showResultsTable && (\n                        <div className=\"relative\">\n                            {usedWebAnalyticsPreAggregatedTables && <PreAggregatedBadge />}\n                            <LemonTable\n                                data-attr={dataAttr}\n                                className=\"DataTable\"\n                                loading={responseLoading && !nextDataLoading && !newDataLoading}\n                                columns={lemonColumns}\n                                embedded={embedded}\n                                key={\n                                    [...(columnsInResponse ?? []), ...columnsInQuery].join(\n                                        '::'\n                                    ) /* Bust the LemonTable cache when columns change */\n                                }\n                                dataSource={dataTableRows ?? []}\n                                rowKey={(_, rowIndex) => {\n                                    return rowIndex\n                                }}\n                                sorting={null}\n                                useURLForSorting={false}\n                                emptyState={\n                                    responseError ? (\n                                        sourceFeatures.has(QueryFeature.displayResponseError) ? (\n                                            <InsightErrorState\n                                                query={query}\n                                                excludeDetail\n                                                title={\n                                                    queryCancelled\n                                                        ? 'The query was cancelled'\n                                                        : response && 'error' in response\n                                                          ? response.error\n                                                          : responseError\n                                                }\n                                            />\n                                        ) : (\n                                            <InsightErrorState query={query} />\n                                        )\n                                    ) : (\n                                        <InsightEmptyState\n                                            heading={context?.emptyStateHeading}\n                                            detail={context?.emptyStateDetail}\n                                        />\n                                    )\n                                }\n                                expandable={\n                                    context?.expandable\n                                        ? context.expandable\n                                        : expandable && columnsInResponse?.includes('*')\n                                          ? {\n                                                expandedRowRender: function renderExpand({ result }) {\n                                                    if (\n                                                        (isEventsQuery(query.source) ||\n                                                            isRevenueExampleEventsQuery(query.source)) &&\n                                                        Array.isArray(result)\n                                                    ) {\n                                                        return (\n                                                            <EventDetails\n                                                                event={result[columnsInResponse.indexOf('*')] ?? {}}\n                                                            />\n                                                        )\n                                                    }\n                                                    if (result && !Array.isArray(result)) {\n                                                        return <EventDetails event={result as EventType} />\n                                                    }\n                                                },\n                                                rowExpandable: ({ result }) => !!result,\n                                                noIndent: true,\n                                            }\n                                          : undefined\n                                }\n                                rowClassName={({ result, label }) =>\n                                    clsx('DataTable__row', {\n                                        'DataTable__row--highlight_once': result && highlightedRows.has(result),\n                                        'DataTable__row--category_row': !!label,\n                                        'border border-x-danger-dark bg-danger-highlight':\n                                            sourceFeatures.has(QueryFeature.highlightExceptionEventRows) &&\n                                            result &&\n                                            result[0] &&\n                                            result[0]['event'] === '$exception',\n                                        DataTable__has_pinned_columns: (query.pinnedColumns ?? []).length > 0,\n                                    })\n                                }\n                                footer={\n                                    (dataTableRows ?? []).length > 0 &&\n                                    !sourceFeatures.has(QueryFeature.hideLoadNextButton) ? (\n                                        <LoadNext query={query.source} />\n                                    ) : null\n                                }\n                                onRow={onRow}\n                                pinnedColumns={query.pinnedColumns}\n                            />\n                        </div>\n                    )}\n                    {/* TODO: this doesn't seem like the right solution... */}\n                    <PersonDeleteModal />\n                </div>\n            </BindLogic>\n        </BindLogic>\n    )\n}\n","import { useActions, useValues } from 'kea'\n\nimport { LemonSegmentedButton } from '@posthog/lemon-ui'\n\nimport { insightLogic } from 'scenes/insights/insightLogic'\nimport { insightVizDataLogic } from 'scenes/insights/insightVizDataLogic'\n\nexport function RetentionCumulativeButton(): JSX.Element | null {\n    const { insightProps, canEditInsight } = useValues(insightLogic)\n\n    const { retentionFilter } = useValues(insightVizDataLogic(insightProps))\n    const { updateInsightFilter } = useActions(insightVizDataLogic(insightProps))\n\n    const cumulativeRetention = retentionFilter?.cumulative || false\n\n    if (!canEditInsight) {\n        return null\n    }\n\n    return (\n        <LemonSegmentedButton\n            value={cumulativeRetention ? 1 : 0}\n            onChange={(value: number) => {\n                updateInsightFilter({ cumulative: value === 1 })\n            }}\n            options={[\n                {\n                    value: 0,\n                    label: 'on',\n                    tooltip: 'Retention value is the percentage of users who come back on a specific period',\n                },\n                {\n                    value: 1,\n                    label: 'on or after',\n                    tooltip: `\n                    Retention value is the percentage of users who come back on a specific time period or any of the following time periods.\n                    Also known as rolling, or unbounded retention.\n                    For example, if a user comes back on day 7, they are counted in all previous retention periods.`,\n                },\n            ]}\n        />\n    )\n}\n","import clsx from 'clsx'\nimport { useActions, useValues } from 'kea'\nimport { useEffect, useRef } from 'react'\nimport { CSSTransition } from 'react-transition-group'\n\nimport { IconInfo, IconX } from '@posthog/icons'\nimport { LemonBanner, LemonButton, Link, Tooltip } from '@posthog/lemon-ui'\n\nimport { NON_BREAKDOWN_DISPLAY_TYPES } from 'lib/constants'\nimport { pluralize } from 'lib/utils'\nimport { funnelDataLogic } from 'scenes/funnels/funnelDataLogic'\nimport { Attribution } from 'scenes/insights/EditorFilters/AttributionFilter'\nimport { FunnelsAdvanced } from 'scenes/insights/EditorFilters/FunnelsAdvanced'\nimport { FunnelsQuerySteps } from 'scenes/insights/EditorFilters/FunnelsQuerySteps'\nimport { GoalLines } from 'scenes/insights/EditorFilters/GoalLines'\nimport { PathsAdvanced } from 'scenes/insights/EditorFilters/PathsAdvanced'\nimport { PathsEventsTypes } from 'scenes/insights/EditorFilters/PathsEventTypes'\nimport { PathsExclusions } from 'scenes/insights/EditorFilters/PathsExclusions'\nimport { PathsHogQL } from 'scenes/insights/EditorFilters/PathsHogQL'\nimport { PathsTargetEnd, PathsTargetStart } from 'scenes/insights/EditorFilters/PathsTarget'\nimport { PathsWildcardGroups } from 'scenes/insights/EditorFilters/PathsWildcardGroups'\nimport { PoeFilter } from 'scenes/insights/EditorFilters/PoeFilter'\nimport { RetentionCondition } from 'scenes/insights/EditorFilters/RetentionCondition'\nimport { RetentionOptions } from 'scenes/insights/EditorFilters/RetentionOptions'\nimport { SamplingFilter } from 'scenes/insights/EditorFilters/SamplingFilter'\nimport { insightLogic } from 'scenes/insights/insightLogic'\nimport { insightVizDataLogic } from 'scenes/insights/insightVizDataLogic'\nimport { compareInsightTopLevelSections } from 'scenes/insights/utils'\nimport MaxTool from 'scenes/max/MaxTool'\nimport { castAssistantQuery } from 'scenes/max/utils'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { StickinessCriteria } from '~/queries/nodes/InsightViz/StickinessCriteria'\nimport {\n    AssistantFunnelsQuery,\n    AssistantHogQLQuery,\n    AssistantRetentionQuery,\n    AssistantTrendsQuery,\n} from '~/queries/schema/schema-assistant-queries'\nimport { DataVisualizationNode, InsightQueryNode, InsightVizNode, NodeKind } from '~/queries/schema/schema-general'\nimport { isHogQLQuery } from '~/queries/utils'\nimport {\n    AvailableFeature,\n    ChartDisplayType,\n    EditorFilterProps,\n    InsightEditorFilter,\n    InsightEditorFilterGroup,\n    PathType,\n} from '~/types'\n\nimport { Breakdown } from './Breakdown'\nimport { CumulativeStickinessFilter } from './CumulativeStickinessFilter'\nimport { EditorFilterGroup } from './EditorFilterGroup'\nimport { GlobalAndOrFilters } from './GlobalAndOrFilters'\nimport { LifecycleToggles } from './LifecycleToggles'\nimport { TrendsFormula } from './TrendsFormula'\nimport { TrendsSeries } from './TrendsSeries'\nimport { TrendsSeriesLabel } from './TrendsSeriesLabel'\n\nexport interface EditorFiltersProps {\n    query: InsightQueryNode\n    showing: boolean\n    embedded: boolean\n}\n\nexport function EditorFilters({ query, showing, embedded }: EditorFiltersProps): JSX.Element | null {\n    const { hasAvailableFeature } = useValues(userLogic)\n\n    const { insightProps } = useValues(insightLogic)\n    const {\n        isTrends,\n        isFunnels,\n        isRetention,\n        isPaths,\n        isLifecycle,\n        isStickiness,\n        isTrendsLike,\n        display,\n        pathsFilter,\n        querySource,\n        shouldShowSessionAnalysisWarning,\n        hasFormula,\n    } = useValues(insightVizDataLogic(insightProps))\n\n    const { handleInsightSuggested, onRejectSuggestedInsight } = useActions(insightLogic(insightProps))\n    const { previousQuery, suggestedQuery } = useValues(insightLogic(insightProps))\n    const { isStepsFunnel, isTrendsFunnel } = useValues(funnelDataLogic(insightProps))\n    const { setQuery } = useActions(insightVizDataLogic(insightProps))\n\n    const maxSuggestionActionsBanner = useRef<HTMLDivElement>(null)\n\n    useEffect(() => {\n        if (previousQuery && maxSuggestionActionsBanner.current) {\n            maxSuggestionActionsBanner.current.scrollIntoView({ behavior: 'smooth', block: 'center' })\n        }\n    }, [previousQuery])\n\n    if (!querySource) {\n        return null\n    }\n\n    // MaxTool should not be active when insights are embedded (e.g., in notebooks)\n    const maxToolActive = !embedded\n\n    const hasBreakdown =\n        (isTrends && !NON_BREAKDOWN_DISPLAY_TYPES.includes(display || ChartDisplayType.ActionsLineGraph)) ||\n        isStepsFunnel ||\n        isTrendsFunnel ||\n        isRetention\n    const hasPathsAdvanced = hasAvailableFeature(AvailableFeature.PATHS_ADVANCED)\n    const hasAttribution = isStepsFunnel || isTrendsFunnel\n    const hasPathsHogQL = isPaths && pathsFilter?.includeEventTypes?.includes(PathType.HogQL)\n    const displayGoalLines =\n        (isTrends &&\n            [ChartDisplayType.ActionsLineGraph, ChartDisplayType.ActionsLineGraphCumulative].includes(\n                display || ChartDisplayType.ActionsLineGraph\n            )) ||\n        (isFunnels && isTrendsFunnel)\n\n    const leftEditorFilterGroups: InsightEditorFilterGroup[] = [\n        {\n            title: 'General',\n            editorFilters: filterFalsy([\n                ...(isRetention\n                    ? [\n                          {\n                              key: 'retention-condition',\n                              label: 'Retention condition',\n                              component: RetentionCondition,\n                          },\n                          {\n                              key: 'retention-options',\n                              label: 'Calculation options',\n                              component: RetentionOptions,\n                          },\n                      ]\n                    : []),\n                isFunnels\n                    ? {\n                          key: 'query-steps',\n                          component: FunnelsQuerySteps,\n                      }\n                    : null,\n                ...(isPaths\n                    ? [\n                          {\n                              key: 'event-types',\n                              label: 'Event Types',\n                              component: PathsEventsTypes,\n                          },\n                          hasPathsHogQL && {\n                              key: 'hogql',\n                              label: 'SQL Expression',\n                              component: PathsHogQL,\n                          },\n                          hasPathsAdvanced && {\n                              key: 'wildcard-groups',\n                              label: 'Wildcard Groups',\n                              showOptional: true,\n                              component: PathsWildcardGroups,\n                              tooltip: (\n                                  <>\n                                      Use wildcard matching to group events by unique values in path item names. Use an\n                                      asterisk (*) in place of unique values. For example, instead of\n                                      /merchant/1234/payment, replace the unique value with an asterisk\n                                      /merchant/*/payment. <b>Use a comma to separate multiple wildcards.</b>\n                                  </>\n                              ),\n                          },\n                          {\n                              key: 'start-target',\n                              label: 'Starts at',\n                              component: PathsTargetStart,\n                          },\n                          hasPathsAdvanced && {\n                              key: 'ends-target',\n                              label: 'Ends at',\n                              component: PathsTargetEnd,\n                          },\n                      ]\n                    : []),\n            ]),\n        },\n        {\n            title: 'Series',\n            editorFilters: filterFalsy([\n                isTrendsLike && {\n                    key: 'series',\n                    label: isTrends && display !== ChartDisplayType.CalendarHeatmap ? TrendsSeriesLabel : undefined,\n                    component: TrendsSeries,\n                },\n                isTrends && hasFormula\n                    ? {\n                          key: 'formula',\n                          label: 'Formula',\n                          component: TrendsFormula,\n                      }\n                    : null,\n            ]),\n        },\n        {\n            title: 'Advanced options',\n            editorFilters: filterFalsy([\n                isPaths && {\n                    key: 'paths-advanced',\n                    component: PathsAdvanced,\n                },\n                isFunnels && {\n                    key: 'funnels-advanced',\n                    component: FunnelsAdvanced,\n                },\n            ]),\n        },\n    ]\n\n    const rightEditorFilterGroups: InsightEditorFilterGroup[] = [\n        {\n            title: 'Filters',\n            editorFilters: filterFalsy([\n                isLifecycle\n                    ? {\n                          key: 'toggles',\n                          label: 'Lifecycle Toggles',\n                          component: LifecycleToggles as (props: EditorFilterProps) => JSX.Element | null,\n                      }\n                    : null,\n                isStickiness\n                    ? {\n                          key: 'stickinessCriteria',\n                          label: () => (\n                              <div className=\"flex\">\n                                  <span>Stickiness Criteria</span>\n                                  <Tooltip\n                                      closeDelayMs={200}\n                                      title={\n                                          <div className=\"deprecated-space-y-2\">\n                                              <div>\n                                                  The stickiness criteria defines how many times a user must perform an\n                                                  event inside of a given interval in order to be considered \"sticky.\"\n                                              </div>\n                                          </div>\n                                      }\n                                  >\n                                      <IconInfo className=\"text-xl text-secondary shrink-0 ml-1\" />\n                                  </Tooltip>\n                              </div>\n                          ),\n                          component: StickinessCriteria as (props: EditorFilterProps) => JSX.Element | null,\n                      }\n                    : null,\n                isStickiness\n                    ? {\n                          key: 'cumulativeStickiness',\n                          label: () => (\n                              <div className=\"flex\">\n                                  <span>Compute as</span>\n                                  <Tooltip\n                                      closeDelayMs={200}\n                                      title={\n                                          <div className=\"deprecated-space-y-2\">\n                                              <div>\n                                                  Choose how to compute stickiness values. Non-cumulative shows exact\n                                                  numbers for each day count, while cumulative shows users active for at\n                                                  least that many days.\n                                              </div>\n                                          </div>\n                                      }\n                                  >\n                                      <IconInfo className=\"text-xl text-secondary shrink-0 ml-1\" />\n                                  </Tooltip>\n                              </div>\n                          ),\n                          component: CumulativeStickinessFilter as (props: EditorFilterProps) => JSX.Element | null,\n                      }\n                    : null,\n                {\n                    key: 'properties',\n                    label: 'Filters',\n                    component: GlobalAndOrFilters as (props: EditorFilterProps) => JSX.Element | null,\n                },\n            ]),\n        },\n        {\n            title: 'Breakdown',\n            editorFilters: filterFalsy([\n                hasBreakdown\n                    ? {\n                          key: 'breakdown',\n                          component: Breakdown,\n                      }\n                    : null,\n                hasAttribution\n                    ? {\n                          key: 'attribution',\n                          label: () => (\n                              <div className=\"flex\">\n                                  <span>Attribution type</span>\n                                  <Tooltip\n                                      closeDelayMs={200}\n                                      title={\n                                          <div className=\"deprecated-space-y-2\">\n                                              <div>\n                                                  When breaking down funnels, it's possible that the same properties\n                                                  don't exist on every event. For example, if you want to break down by\n                                                  browser on a funnel that contains both frontend and backend events.\n                                              </div>\n                                              <div>\n                                                  In this case, you can choose from which step the properties should be\n                                                  selected from by modifying the attribution type. There are four modes\n                                                  to choose from:\n                                              </div>\n                                              <ul className=\"list-disc pl-4\">\n                                                  <li>\n                                                      First touchpoint: the first property value seen in any of the\n                                                      steps is chosen.\n                                                  </li>\n                                                  <li>\n                                                      Last touchpoint: the last property value seen from all steps is\n                                                      chosen.\n                                                  </li>\n                                                  <li>\n                                                      All steps: the property value must be seen in all steps to be\n                                                      considered in the funnel.\n                                                  </li>\n                                                  <li>\n                                                      Specific step: only the property value seen at the selected step\n                                                      is chosen.\n                                                  </li>\n                                              </ul>\n                                              <div>\n                                                  Read more in the{' '}\n                                                  <Link to=\"https://posthog.com/docs/product-analytics/funnels#attribution-types\">\n                                                      documentation.\n                                                  </Link>\n                                              </div>\n                                          </div>\n                                      }\n                                  >\n                                      <IconInfo className=\"text-xl text-secondary shrink-0 ml-1\" />\n                                  </Tooltip>\n                              </div>\n                          ),\n                          component: Attribution,\n                      }\n                    : null,\n            ]),\n        },\n        {\n            title: 'Exclusions',\n            editorFilters: filterFalsy([\n                isPaths && {\n                    key: 'paths-exclusions',\n                    label: 'Exclusions',\n                    tooltip: (\n                        <>Exclude events from Paths visualisation. You can use wildcard groups in exclusions as well.</>\n                    ),\n                    component: PathsExclusions,\n                },\n            ]),\n        },\n        // Hide advanced options for calendar heatmap\n        display !== ChartDisplayType.CalendarHeatmap\n            ? {\n                  title: 'Advanced options',\n                  defaultExpanded: false,\n                  editorFilters: filterFalsy([\n                      {\n                          key: 'poe',\n                          component: PoeFilter,\n                      },\n                      {\n                          key: 'sampling',\n                          component: SamplingFilter,\n                      },\n                      displayGoalLines && {\n                          key: 'goal-lines',\n                          label: 'Goal lines',\n                          tooltip: (\n                              <>\n                                  Goal lines can be used to highlight specific goals (Revenue, Signups, etc.) or limits\n                                  (Web Vitals, etc.)\n                              </>\n                          ),\n                          component: GoalLines,\n                      },\n                  ]),\n              }\n            : null,\n    ].filter((group): group is InsightEditorFilterGroup => group !== null)\n\n    const filterGroupsGroups = [\n        { title: 'left', editorFilterGroups: leftEditorFilterGroups.filter((group) => group.editorFilters.length > 0) },\n        {\n            title: 'right',\n            editorFilterGroups: rightEditorFilterGroups.filter((group) => group.editorFilters.length > 0),\n        },\n    ]\n\n    return (\n        <CSSTransition in={showing} timeout={250} classNames=\"anim-\" mountOnEnter unmountOnExit>\n            <div className=\"EditorFiltersWrapper\">\n                {shouldShowSessionAnalysisWarning ? (\n                    <LemonBanner type=\"info\" className=\"mb-4\">\n                        When using sessions and session properties, events without session IDs will be excluded from the\n                        set of results.{' '}\n                        <Link to=\"https://posthog.com/docs/user-guides/sessions\">Learn more about sessions.</Link>\n                    </LemonBanner>\n                ) : null}\n\n                <div>\n                    <MaxTool\n                        identifier=\"edit_current_insight\"\n                        context={{\n                            current_query: querySource,\n                        }}\n                        callback={(\n                            toolOutput:\n                                | AssistantTrendsQuery\n                                | AssistantFunnelsQuery\n                                | AssistantRetentionQuery\n                                | AssistantHogQLQuery\n                        ) => {\n                            const source = castAssistantQuery(toolOutput)\n                            let node: DataVisualizationNode | InsightVizNode\n                            if (isHogQLQuery(source)) {\n                                node = {\n                                    kind: NodeKind.DataVisualizationNode,\n                                    source,\n                                } satisfies DataVisualizationNode\n                            } else {\n                                node = { kind: NodeKind.InsightVizNode, source } satisfies InsightVizNode\n                            }\n                            handleInsightSuggested(node)\n                            setQuery(node)\n                        }}\n                        initialMaxPrompt=\"Show me users who \"\n                        className=\"EditorFiltersWrapper\"\n                        active={maxToolActive}\n                    >\n                        <div\n                            className={clsx('flex flex-row flex-wrap gap-8 bg-surface-primary', {\n                                'p-4 rounded border': !embedded,\n                            })}\n                        >\n                            {filterGroupsGroups.map(({ title, editorFilterGroups }) => (\n                                <div key={title} className=\"flex-1 flex flex-col gap-4 max-w-full\">\n                                    {editorFilterGroups.map((editorFilterGroup) => (\n                                        <EditorFilterGroup\n                                            key={editorFilterGroup.title}\n                                            editorFilterGroup={editorFilterGroup}\n                                            insightProps={insightProps}\n                                            query={query}\n                                        />\n                                    ))}\n                                </div>\n                            ))}\n                        </div>\n                    </MaxTool>\n\n                    {previousQuery && (\n                        <div className=\"w-full px-2\" ref={maxSuggestionActionsBanner}>\n                            <div className=\"bg-surface-tertiary/80 w-full flex justify-between items-center p-1 pl-2 mx-auto rounded-bl rounded-br\">\n                                <div className=\"text-sm text-muted flex items-center gap-2 no-wrap\">\n                                    <span className=\"size-2 bg-accent-active rounded-full\" />\n                                    {(() => {\n                                        const changedLabels = compareInsightTopLevelSections(\n                                            previousQuery,\n                                            suggestedQuery\n                                        )\n                                        const diffString = `🔍 ${pluralize(\n                                            changedLabels.length,\n                                            'section'\n                                        )} changed: \\n${changedLabels.join('\\n')}`\n\n                                        return (\n                                            <div className=\"flex items-center gap-1\">\n                                                <span>{pluralize(changedLabels.length, 'change')}</span>\n                                                {diffString && (\n                                                    <Tooltip\n                                                        title={<div className=\"whitespace-pre-line\">{diffString}</div>}\n                                                    >\n                                                        <IconInfo className=\"text-sm text-muted cursor-help\" />\n                                                    </Tooltip>\n                                                )}\n                                            </div>\n                                        )\n                                    })()}\n                                </div>\n\n                                <LemonButton\n                                    status=\"danger\"\n                                    onClick={() => {\n                                        onRejectSuggestedInsight()\n                                    }}\n                                    tooltipPlacement=\"top\"\n                                    size=\"small\"\n                                    icon={<IconX />}\n                                >\n                                    Reject changes\n                                </LemonButton>\n                            </div>\n                        </div>\n                    )}\n                </div>\n            </div>\n        </CSSTransition>\n    )\n}\n\nfunction filterFalsy(a: (InsightEditorFilter | false | null | undefined)[]): InsightEditorFilter[] {\n    return a.filter((e): e is InsightEditorFilter => !!e)\n}\n","import * as d3 from 'd3'\nimport * as Sankey from 'd3-sankey'\nimport { Dispatch, RefObject, SetStateAction } from 'react'\n\nimport { D3Selector } from 'lib/hooks/useD3'\nimport { stripHTTP } from 'lib/utils'\n\nimport { FunnelPathsFilter, PathsFilter } from '~/queries/schema/schema-general'\n\nimport { FALLBACK_CANVAS_WIDTH, HIDE_PATH_CARD_HEIGHT } from './Paths'\nimport { PathNodeData, PathTargetLink, isSelectedPathStartOrEnd, roundedRect } from './pathUtils'\nimport { Paths } from './types'\n\nconst createCanvas = (canvasRef: RefObject<HTMLDivElement>, width: number, height: number): D3Selector => {\n    return d3\n        .select(canvasRef.current)\n        .append('svg')\n        .classed('Paths__canvas', true)\n        .style('background', 'var(--item-background)')\n        .style('width', `${width}px`)\n        .style('height', `${height}px`)\n}\n\nconst createSankeyGenerator = (width: number, height: number): Sankey.SankeyLayout<any, any, any> => {\n    // @ts-expect-error - d3 sankey typing things\n    return new Sankey.sankey()\n        .nodeId((d: PathNodeData) => d.name)\n        .nodeAlign(Sankey.sankeyJustify)\n        .nodeSort(null)\n        .nodeWidth(15)\n        .size([width, height])\n}\n\nconst appendPathNodes = (\n    svg: any,\n    nodes: PathNodeData[],\n    pathsFilter: PathsFilter,\n    funnelPathsFilter: FunnelPathsFilter,\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void => {\n    svg.append('g')\n        .selectAll('rect')\n        .data(nodes)\n        .join('rect')\n        .attr('x', (d: PathNodeData) => d.x0 + 1)\n        .attr('y', (d: PathNodeData) => d.y0)\n        .attr('height', (d: PathNodeData) => d.y1 - d.y0)\n        .attr('width', (d: PathNodeData) => d.x1 - d.x0 - 2)\n        .attr('fill', (d: PathNodeData) => {\n            let c\n            for (const link of d.sourceLinks) {\n                if (c === undefined) {\n                    c = link.color\n                } else if (c !== link.color) {\n                    c = null\n                }\n            }\n            if (c === undefined) {\n                for (const link of d.targetLinks) {\n                    if (c === undefined) {\n                        c = link.color\n                    } else if (c !== link.color) {\n                        c = null\n                    }\n                }\n            }\n            if (isSelectedPathStartOrEnd(pathsFilter, funnelPathsFilter, d)) {\n                return 'var(--paths-node-start-or-end)'\n            }\n            const startNodeColor = c && d3.color(c) ? d3.color(c) : 'var(--paths-node)'\n            return startNodeColor\n        })\n        .on('mouseover', (_event: MouseEvent, data: PathNodeData) => {\n            if (data.y1 - data.y0 > HIDE_PATH_CARD_HEIGHT) {\n                return\n            }\n            setNodeCards(\n                nodes.map((node: PathNodeData) =>\n                    node.index === data.index\n                        ? { ...node, visible: true }\n                        : { ...node, visible: node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT }\n                )\n            )\n        })\n        .append('title')\n        .text((d: PathNodeData) => `${stripHTTP(d.name)}\\n${d.value.toLocaleString()}`)\n}\n\nconst appendDropoffs = (svg: D3Selector): void => {\n    const dropOffGradient = svg\n        .append('defs')\n        .append('linearGradient')\n        .attr('id', 'dropoff-gradient')\n        .attr('gradientTransform', 'rotate(90)')\n\n    dropOffGradient.append('stop').attr('offset', '0%').attr('stop-color', 'var(--paths-dropoff)')\n\n    dropOffGradient.append('stop').attr('offset', '100%').attr('stop-color', 'var(--color-bg-surface-primary)')\n}\n\nconst appendPathLinks = (\n    svg: any,\n    links: PathNodeData[],\n    nodes: PathNodeData[],\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void => {\n    const link = svg\n        .append('g')\n        .attr('fill', 'none')\n        .selectAll('g')\n        .data(links)\n        .join('g')\n        .attr('stroke', 'var(--paths-link)')\n        .attr('opacity', 0.35)\n\n    link.append('path')\n        .attr('d', Sankey.sankeyLinkHorizontal())\n        .attr('id', (d: PathNodeData) => `path-${d.index}`)\n        .attr('stroke-width', (d: PathNodeData) => {\n            return Math.max(1, d.width)\n        })\n        .on('mouseover', (_event: MouseEvent, data: PathNodeData) => {\n            svg.select(`#path-${data.index}`).attr('stroke', 'var(--paths-link-hover)')\n            if (data?.source?.targetLinks.length === 0) {\n                return\n            }\n            const nodesToColor = [data.source]\n            const pathCardsToShow: number[] = []\n            while (nodesToColor.length > 0) {\n                const _node = nodesToColor.pop()\n                _node?.targetLinks.forEach((_link: PathTargetLink) => {\n                    svg.select(`#path-${_link.index}`).attr('stroke', 'var(--paths-link-hover)')\n                    nodesToColor.push(_link.source)\n                    pathCardsToShow.push(_link.source.index)\n                })\n            }\n            const pathCards = [data.target]\n            pathCardsToShow.push(data.target.index, data.source.index)\n            while (pathCards.length > 0) {\n                const node = pathCards.pop()\n                node?.sourceLinks.forEach((l: PathTargetLink) => {\n                    pathCards.push(l.target)\n                    pathCardsToShow.push(l.target.index)\n                })\n            }\n            setNodeCards(\n                nodes.map((node: PathNodeData) => ({\n                    ...node,\n\n                    visible: pathCardsToShow.includes(node.index) ? true : node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT,\n                }))\n            )\n        })\n        .on('mouseleave', () => {\n            svg.selectAll('path').attr('stroke', 'var(--paths-link)')\n        })\n\n    link.append('g')\n        .append('path')\n        .attr('d', (data: PathNodeData) => {\n            if (data.source.layer === 0) {\n                return\n            }\n            const _height =\n                data.source.y1 - data.source.y0 - data.source.sourceLinks.reduce((prev, curr) => prev + curr.width, 0)\n            return roundedRect(0, 0, 30, _height, Math.min(25, _height), false, true, false, false)\n        })\n        .attr('fill', 'url(#dropoff-gradient)')\n        .attr('stroke-width', 0)\n        .attr('transform', (data: PathNodeData) => {\n            return (\n                'translate(' +\n                Math.round(data.source.x1) +\n                ',' +\n                Math.round(data.source.y0 + data.source.sourceLinks.reduce((prev, curr) => prev + curr.width, 0)) +\n                ')'\n            )\n        })\n}\n\nconst addChartAxisLines = (svg: D3Selector, height: number, nodes: PathNodeData[], maxLayer: number): void => {\n    if (maxLayer > 5) {\n        const arr = [...Array(maxLayer)]\n        const minWidthApart = nodes[1].x0 - nodes[0].x0\n        arr.forEach((_, i) => {\n            svg.append('line')\n                .style('stroke', 'var(--color-border-primary)')\n                .attr('stroke-width', 2)\n                .attr('x1', minWidthApart * (i + 1) - 20)\n                .attr('y1', 0)\n                .attr('x2', minWidthApart * (i + 1) - 20)\n                .attr('y2', height)\n        })\n    }\n}\n\nexport function renderPaths(\n    canvasRef: RefObject<HTMLDivElement>,\n    canvasWidth: number,\n    canvasHeight: number,\n    paths: Paths,\n    pathsFilter: PathsFilter,\n    funnelPathsFilter: FunnelPathsFilter,\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void {\n    if (!paths || paths.nodes.length === 0) {\n        return\n    }\n\n    const maxLayer = paths.links.reduce((prev, curr) => {\n        return Math.max(prev, Number(curr.target.match(/[^_]*/)))\n    }, 0)\n\n    const minWidth = canvasWidth > FALLBACK_CANVAS_WIDTH || maxLayer < 3 ? canvasWidth : FALLBACK_CANVAS_WIDTH\n\n    const width = maxLayer > 5 && canvasWidth ? (minWidth / 5) * maxLayer : minWidth\n    const height = canvasHeight\n\n    const svg = createCanvas(canvasRef, width, height)\n    const sankey = createSankeyGenerator(width, height)\n\n    // clone the paths, as sankey mutates the data\n    const clonedPaths = structuredClone(paths)\n    const { nodes, links } = sankey(clonedPaths)\n\n    setNodeCards(nodes.map((node: PathNodeData) => ({ ...node, visible: node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT })))\n\n    appendPathNodes(svg, nodes, pathsFilter, funnelPathsFilter, setNodeCards)\n    appendDropoffs(svg)\n    appendPathLinks(svg, links, nodes, setNodeCards)\n    addChartAxisLines(svg, height, nodes, maxLayer)\n}\n","// KeaDevtools.tsx\nimport { getContext } from 'kea'\nimport type { BuiltLogic, Context as KeaContext } from 'kea'\nimport React, { useEffect, useMemo, useRef, useState } from 'react'\nimport { AutoSizer } from 'react-virtualized/dist/es/AutoSizer'\nimport { List, ListRowProps } from 'react-virtualized/dist/es/List'\n\ntype MountedMap = Record<string, BuiltLogic>\ntype SortMode = 'alpha' | 'recent'\ntype Tab = 'logics' | 'actions' | 'graph' | 'memory'\n\nfunction useDebounce<T>(value: T, delay: number): T {\n    const [debouncedValue, setDebouncedValue] = useState(value)\n\n    useEffect(() => {\n        const handler = setTimeout(() => {\n            setDebouncedValue(value)\n        }, delay)\n\n        return () => {\n            clearTimeout(handler)\n        }\n    }, [value, delay])\n\n    return debouncedValue\n}\n\ntype KeaDevtoolsProps = {\n    defaultOpen?: boolean\n    buttonSize?: number\n    offset?: number\n    zIndex?: number\n    maxActions?: number\n}\n\ntype WindowRect = { width: number; height: number; top: number; left: number }\n\nconst MIN_WINDOW_WIDTH = 480\nconst MIN_WINDOW_HEIGHT = 360\nconst MAX_STATE_DIFF_ENTRIES = 200\n\ntype StateDiffChange = 'added' | 'removed' | 'updated'\n\ntype StateDiffEntry = {\n    path: string\n    change: StateDiffChange\n    before?: unknown\n    after?: unknown\n}\n\ntype StateDiffResult = {\n    changes: StateDiffEntry[]\n    truncated: boolean\n}\n\ntype ActionLogItem = {\n    id: number\n    ts: number\n    type: string\n    payload: unknown\n    payloadSummary: string\n    payloadText: string\n    stateDiff: StateDiffEntry[]\n    stateDiffSummary: string\n    stateDiffText: string\n    stateDiffTruncated: boolean\n}\n\nfunction useStoreTick(): number {\n    const { store } = getContext() as KeaContext\n    const [tick, setTick] = useState(0)\n    useEffect(() => {\n        const unsub = store.subscribe(() => Promise.resolve().then(() => setTick((t) => (t + 1) % 1_000_000_000)))\n        return unsub\n    }, [store])\n    return tick\n}\n\nfunction clamp(value: number, min: number, max: number): number {\n    return Math.min(Math.max(value, min), max)\n}\n\nfunction compactJSON(x: unknown) {\n    try {\n        return JSON.stringify(x)\n    } catch {\n        return String(x)\n    }\n}\n\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n    return value !== null && typeof value === 'object' && !Array.isArray(value)\n}\n\nfunction appendPath(base: string, key: string): string {\n    if (!base) {\n        return key\n    }\n    if (/^\\d+$/.test(key)) {\n        return `${base}[${key}]`\n    }\n    return `${base}.${key}`\n}\n\nfunction arrayPath(base: string, index: number): string {\n    return base ? `${base}[${index}]` : `[${index}]`\n}\n\nfunction diffStates(prev: unknown, next: unknown, limit = MAX_STATE_DIFF_ENTRIES): StateDiffResult {\n    const changes: StateDiffEntry[] = []\n    let truncated = false\n\n    const addChange = (change: StateDiffEntry): void => {\n        if (changes.length >= limit) {\n            truncated = true\n            return\n        }\n        changes.push(change)\n    }\n\n    const visit = (prevValue: unknown, nextValue: unknown, path: string): void => {\n        if (changes.length >= limit) {\n            truncated = true\n            return\n        }\n\n        if (Object.is(prevValue, nextValue)) {\n            return\n        }\n\n        const prevIsArray = Array.isArray(prevValue)\n        const nextIsArray = Array.isArray(nextValue)\n\n        if (prevIsArray && nextIsArray) {\n            const maxLength = Math.max(prevValue.length, nextValue.length)\n            for (let index = 0; index < maxLength; index += 1) {\n                if (changes.length >= limit) {\n                    truncated = true\n                    return\n                }\n                const nextPath = arrayPath(path, index)\n                if (index >= prevValue.length) {\n                    addChange({ path: nextPath, change: 'added', after: nextValue[index] })\n                } else if (index >= nextValue.length) {\n                    addChange({ path: nextPath, change: 'removed', before: prevValue[index] })\n                } else {\n                    visit(prevValue[index], nextValue[index], nextPath)\n                }\n            }\n            return\n        }\n\n        if (isPlainObject(prevValue) && isPlainObject(nextValue)) {\n            const keys = new Set([...Object.keys(prevValue), ...Object.keys(nextValue)])\n            for (const key of keys) {\n                if (changes.length >= limit) {\n                    truncated = true\n                    return\n                }\n                const prevHasKey = Object.prototype.hasOwnProperty.call(prevValue, key)\n                const nextHasKey = Object.prototype.hasOwnProperty.call(nextValue, key)\n                const nextPath = appendPath(path, key)\n                if (!prevHasKey && nextHasKey) {\n                    addChange({ path: nextPath, change: 'added', after: nextValue[key] })\n                } else if (prevHasKey && !nextHasKey) {\n                    addChange({ path: nextPath, change: 'removed', before: prevValue[key] })\n                } else if (prevHasKey && nextHasKey) {\n                    visit(prevValue[key], nextValue[key], nextPath)\n                }\n            }\n            return\n        }\n\n        if (!prevIsArray && nextIsArray) {\n            addChange({ path: path || '[root]', change: 'updated', before: prevValue, after: nextValue })\n            return\n        }\n\n        if (prevIsArray && !nextIsArray) {\n            addChange({ path: path || '[root]', change: 'updated', before: prevValue, after: nextValue })\n            return\n        }\n\n        addChange({ path: path || '[root]', change: 'updated', before: prevValue, after: nextValue })\n    }\n\n    visit(prev, next, '')\n\n    return { changes, truncated }\n}\n\nfunction summarizeStateDiff({ changes, truncated }: StateDiffResult): string {\n    if (!changes.length) {\n        return 'No state changes'\n    }\n\n    const recordedCount = changes.length\n    const changeWord = recordedCount === 1 ? 'change' : 'changes'\n    const prefix = truncated ? `${recordedCount}+ ${changeWord}` : `${recordedCount} ${changeWord}`\n    const summaryEntries = changes.slice(0, 3).map((change) => {\n        const label = change.change === 'updated' ? 'changed' : change.change\n        return `${change.path} (${label})`\n    })\n\n    let summary = summaryEntries.length ? `${prefix}: ${summaryEntries.join(', ')}` : prefix\n    if (!truncated && changes.length > 3) {\n        summary += ', …'\n    }\n    if (truncated) {\n        summary += ' (truncated)'\n    }\n    return summary\n}\n\nfunction safeJSONStringify(value: unknown, space = 0): string {\n    if (typeof value === 'undefined') {\n        return 'undefined'\n    }\n    try {\n        const result = JSON.stringify(value, null, space)\n        if (typeof result === 'undefined') {\n            return 'undefined'\n        }\n        return result\n    } catch {\n        return String(value)\n    }\n}\n\n/* ---------- naming ---------- */\n\nfunction displayName(logic: BuiltLogic): string {\n    if (!logic || !logic.path || !logic.path.length) {\n        return 'Unknown logic'\n    }\n    const parts = logic.path\n    const hasKey = typeof logic.key !== 'undefined'\n\n    if (hasKey && parts.length >= 2) {\n        return parts.slice(-2).map(String).join('.')\n    }\n\n    return String(parts[parts.length - 1] || 'Unknown logic')\n}\n\n/** size metric → used for a subtle tint & node size */\nfunction logicSize(logic: BuiltLogic): number {\n    const c = Math.max(0, Object.keys((logic as any)?.connections || {}).length - 1)\n    const a = Object.keys((logic as any)?.actions || {}).length\n    const s = Object.keys((logic as any)?.selectors || {}).length\n    const v = Object.keys((logic as any)?.values || {}).length\n    return c + a + s + v\n}\n\n/* ---------- small UI atoms ---------- */\n\nfunction Section({\n    title,\n    count,\n    children,\n}: React.PropsWithChildren<{ title: string; count?: number }>): JSX.Element | null {\n    if (!children) {\n        return null\n    }\n    return (\n        <div style={{ marginTop: 10 }}>\n            <strong>\n                {title}\n                {typeof count === 'number' ? ` (${count})` : ''}\n            </strong>\n            <div>{children}</div>\n        </div>\n    )\n}\n\nconst linkChip: React.CSSProperties = {\n    border: '1px solid rgba(0,0,0,0.12)',\n    background: '#fff',\n    padding: '4px 8px',\n    borderRadius: 999,\n    cursor: 'pointer',\n    fontSize: 12,\n}\n\n/* ---------- right side: sections ---------- */\n\nfunction Connections({ logic, onOpen }: { logic: BuiltLogic; onOpen: (path: string) => void }): JSX.Element | null {\n    const keys = Object.keys((logic as any).connections || {})\n        .filter((k) => k !== (logic as any).pathString)\n        .sort((a, b) => a.localeCompare(b))\n    if (!keys.length) {\n        return null\n    }\n    return (\n        <Section title=\"Connections\" count={keys.length}>\n            <div style={{ display: 'flex', flexWrap: 'wrap', gap: 6 }}>\n                {keys.map((k) => (\n                    <button key={k} type=\"button\" onClick={() => onOpen(k)} style={linkChip}>\n                        {k}\n                    </button>\n                ))}\n            </div>\n        </Section>\n    )\n}\n\nfunction ReverseConnections({\n    logic,\n    mounted,\n    onOpen,\n}: {\n    logic: BuiltLogic\n    mounted: MountedMap\n    onOpen: (path: string) => void\n}): JSX.Element | null {\n    const me = (logic as any).pathString\n    const incoming = useMemo(() => {\n        return Object.keys(mounted)\n            .filter((k) => (mounted[k] as any)?.connections && (mounted[k] as any).connections[me] && k !== me)\n            .sort((a, b) => a.localeCompare(b))\n    }, [mounted, me])\n\n    if (!incoming.length) {\n        return null\n    }\n    return (\n        <Section title=\"Logics that depend on this logic\" count={incoming.length}>\n            <div style={{ display: 'flex', flexWrap: 'wrap', gap: 6 }}>\n                {incoming.map((k) => (\n                    <button key={k} type=\"button\" onClick={() => onOpen(k)} style={linkChip}>\n                        {k}\n                    </button>\n                ))}\n            </div>\n        </Section>\n    )\n}\n\nfunction ActionsList({ logic }: { logic: BuiltLogic }): JSX.Element | null {\n    const keys = Object.keys((logic as any).actions || {}).sort((a, b) => a.localeCompare(b))\n    if (!keys.length) {\n        return null\n    }\n\n    const run = async (name: string): Promise<void> => {\n        try {\n            const raw = window.prompt(`Args for ${name} (JSON array)`, '[]')\n            if (raw === null) {\n                return\n            }\n            const args = raw.trim() === '' ? [] : (JSON.parse(raw) as any[])\n            const fn = ((logic as any).actions as Record<string, (...a: any[]) => void>)[name]\n            fn(...args)\n        } catch (e: any) {\n            window.alert(`Failed to dispatch: ${e?.message ?? e}`)\n        }\n    }\n\n    return (\n        <Section title=\"Actions\" count={keys.length}>\n            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))', gap: 6 }}>\n                {keys.map((k) => (\n                    <button\n                        key={k}\n                        type=\"button\"\n                        onClick={() => run(k)}\n                        title=\"Click to run (will prompt for args)\"\n                        style={pill}\n                    >\n                        ▶︎ {k}\n                    </button>\n                ))}\n            </div>\n        </Section>\n    )\n}\n\nfunction Values({ logic }: { logic: BuiltLogic }): JSX.Element | null {\n    useStoreTick() // keep fresh\n    const keys = useMemo(\n        () => Object.keys((logic as any).values || {}).sort((a, b) => a.localeCompare(b)),\n        [(logic as any).values]\n    )\n    if (!keys.length) {\n        return null\n    }\n\n    return (\n        <Section title=\"Values\" count={keys.length}>\n            <div\n                style={{\n                    display: 'grid',\n                    gridTemplateColumns: 'max-content 1fr',\n                    columnGap: 12,\n                    rowGap: 6,\n                    alignItems: 'center',\n                }}\n            >\n                {keys.map((k) => (\n                    <React.Fragment key={k}>\n                        <div style={{ fontWeight: 500, whiteSpace: 'nowrap' }}>{k}</div>\n                        <textarea\n                            readOnly\n                            rows={1}\n                            value={compactJSON(((logic as any).values as Record<string, unknown>)[k])}\n                            style={{\n                                width: '100%',\n                                height: 28, // single line; user can resize\n                                fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',\n                                resize: 'vertical',\n                                border: '1px solid rgba(0,0,0,0.12)',\n                                borderRadius: 6,\n                                padding: '4px 6px',\n                            }}\n                        />\n                    </React.Fragment>\n                ))}\n            </div>\n        </Section>\n    )\n}\n\n/* ---------- Key + Props summary ---------- */\n\nfunction KeyAndProps({ logic }: { logic: BuiltLogic }): JSX.Element {\n    const keyVal = (logic as any).key\n    const propsVal = (logic as any).props\n    return (\n        <div\n            style={{\n                display: 'grid',\n                gridTemplateColumns: 'max-content 1fr',\n                columnGap: 12,\n                rowGap: 6,\n                alignItems: 'center',\n                marginBottom: 8,\n            }}\n        >\n            <div style={{ fontWeight: 600, whiteSpace: 'nowrap' }}>Key</div>\n            <textarea\n                readOnly\n                rows={1}\n                value={compactJSON(keyVal)}\n                style={{\n                    width: '100%',\n                    height: 28,\n                    fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',\n                    resize: 'vertical',\n                    border: '1px solid rgba(0,0,0,0.12)',\n                    borderRadius: 6,\n                    padding: '4px 6px',\n                    background: '#fafafa',\n                }}\n            />\n            <div style={{ fontWeight: 600, whiteSpace: 'nowrap' }}>Props</div>\n            <textarea\n                readOnly\n                rows={4}\n                value={compactJSON(propsVal)}\n                style={{\n                    width: '100%',\n                    height: 84,\n                    fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',\n                    resize: 'vertical',\n                    border: '1px solid rgba(0,0,0,0.12)',\n                    borderRadius: 6,\n                    padding: '4px 6px',\n                    background: '#fafafa',\n                }}\n            />\n        </div>\n    )\n}\n\n/* ---------- GRAPH TAB ---------- */\n\ntype Node = {\n    id: string\n    name: string\n    size: number\n    x: number\n    y: number\n    vx: number\n    vy: number\n    fixed?: boolean\n}\ntype Link = { source: string; target: string } // directed for highlights\ntype Undirected = { a: string; b: string } // for layout\n\nfunction GraphTab({\n    mounted,\n    onOpen,\n    highlightId,\n}: {\n    mounted: MountedMap\n    onOpen: (path: string) => void\n    highlightId?: string | null\n}): JSX.Element {\n    const width = 2400\n    const height = 1500\n\n    const { nodes, undirected, directed, outAdj, inAdj, avgDeg } = useMemo(() => {\n        const keys = Object.keys(mounted)\n\n        const degree: Record<string, number> = Object.fromEntries(keys.map((k) => [k, 0]))\n        const undirectedSeen = new Set<string>()\n        const undirected: Undirected[] = []\n        const directed: Link[] = []\n\n        const outAdj = new Map<string, Set<string>>(keys.map((k) => [k, new Set<string>()]))\n        const inAdj = new Map<string, Set<string>>(keys.map((k) => [k, new Set<string>()]))\n\n        for (const a of keys) {\n            for (const b of Object.keys((mounted[a] as any)?.connections || {})) {\n                if (!mounted[b] || a === b) {\n                    continue\n                }\n                directed.push({ source: a, target: b })\n                outAdj.get(a)!.add(b)\n                inAdj.get(b)!.add(a)\n                const u = a < b ? `${a}|${b}` : `${b}|${a}`\n                if (!undirectedSeen.has(u)) {\n                    undirectedSeen.add(u)\n                    undirected.push({ a, b })\n                    degree[a]++\n                    degree[b]++\n                }\n            }\n        }\n\n        const degVals = Object.values(degree)\n        const avgDeg = degVals.length ? degVals.reduce((s, d) => s + d, 0) / degVals.length : 0\n\n        const nodes: Node[] = keys.map((k, i) => {\n            const deg = degree[k] ?? 0\n            const size = Math.max(8, Math.min(34, 8 + Math.sqrt(deg) * 6))\n            const angle = (i / Math.max(1, keys.length)) * Math.PI * 2\n            const r = 340 + (i % 200) * 3\n            return {\n                id: k,\n                name: displayName(mounted[k]),\n                size,\n                x: width / 2 + Math.cos(angle) * r + (Math.random() - 0.5) * 80,\n                y: height / 2 + Math.sin(angle) * r + (Math.random() - 0.5) * 80,\n                vx: 0,\n                vy: 0,\n            }\n        })\n\n        return { nodes, undirected, directed, outAdj, inAdj, avgDeg }\n    }, [mounted])\n\n    // max spread constants\n    const SPREAD = 3\n    const LINK_DISTANCE = 180 * SPREAD + 30 * Math.log(nodes.length + 1)\n    const SPRING = 0.06\n    const CHARGE = (2600 + 300 * avgDeg) * SPREAD * SPREAD\n    const DAMPING = 0.9\n    const CENTER_PULL = 0.0015\n    const COLLISION_PAD = 12\n\n    // simulation\n    const [searchOutNeighbors, setSearchOutNeighbors] = useState<Set<string>>(new Set())\n    const [searchInNeighbors, setSearchInNeighbors] = useState<Set<string>>(new Set())\n    const [searchHighlights, setSearchHighlights] = useState<Set<string>>(new Set())\n    const [simRunning, setSimRunning] = useState(true)\n    const nodesRef = useRef<Node[]>(nodes)\n    const undirectedRef = useRef<Undirected[]>(undirected)\n    const rafRef = useRef<number | null>(null)\n\n    useEffect(() => {\n        const prev = nodesRef.current\n        nodesRef.current = nodes.map((n) => prev.find((p) => p.id === n.id) ?? { ...n })\n        undirectedRef.current = undirected\n        setSimRunning(true)\n        return () => {\n            if (rafRef.current) {\n                cancelAnimationFrame(rafRef.current)\n            }\n            rafRef.current = null\n        }\n    }, [nodes, undirected])\n\n    const [, force] = useState(0)\n    const bump = (): void => force((t) => t + 1)\n\n    useEffect(() => {\n        if (!simRunning) {\n            return\n        }\n        let last = performance.now()\n\n        const tick = (): void => {\n            const now = performance.now()\n            const dt = Math.min(0.02, (now - last) / 1000)\n            last = now\n\n            const ns = nodesRef.current\n            const ls = undirectedRef.current\n\n            for (let i = 0; i < ns.length; i++) {\n                for (let j = i + 1; j < ns.length; j++) {\n                    const a = ns[i],\n                        b = ns[j]\n                    let dx = a.x - b.x,\n                        dy = a.y - b.y\n                    let d2 = dx * dx + dy * dy\n                    if (d2 === 0) {\n                        d2 = 0.01\n                    }\n                    const dist = Math.sqrt(d2)\n\n                    const rep = (CHARGE * dt) / d2\n                    const rx = (dx / dist) * rep,\n                        ry = (dy / dist) * rep\n                    if (!a.fixed) {\n                        a.vx += rx\n                        a.vy += ry\n                    }\n                    if (!b.fixed) {\n                        b.vx -= rx\n                        b.vy -= ry\n                    }\n\n                    const minD = a.size + b.size + COLLISION_PAD\n                    if (dist < minD) {\n                        const overlap = minD - dist\n                        const nx = dx / (dist || 1),\n                            ny = dy / (dist || 1)\n                        if (!a.fixed) {\n                            a.x += (overlap / 2) * nx\n                            a.y += (overlap / 2) * ny\n                            a.vx = 0\n                            a.vy = 0\n                        }\n                        if (!b.fixed) {\n                            b.x -= (overlap / 2) * nx\n                            b.y -= (overlap / 2) * ny\n                            b.vx = 0\n                            b.vy = 0\n                        }\n                    }\n                }\n            }\n\n            for (const l of ls) {\n                const a = ns.find((n) => n.id === l.a)!,\n                    b = ns.find((n) => n.id === l.b)!\n                const dx = b.x - a.x,\n                    dy = b.y - a.y\n                const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy))\n                const diff = dist - LINK_DISTANCE\n                const f = diff * SPRING * dt\n                const fx = (dx / dist) * f,\n                    fy = (dy / dist) * f\n                if (!a.fixed) {\n                    a.vx += fx\n                    a.vy += fy\n                }\n                if (!b.fixed) {\n                    b.vx -= fx\n                    b.vy -= fy\n                }\n            }\n\n            const cx = width / 2,\n                cy = height / 2\n            let energy = 0\n            for (const n of ns) {\n                if (!n.fixed) {\n                    n.vx += (cx - n.x) * CENTER_PULL\n                    n.vy += (cy - n.y) * CENTER_PULL\n                    n.vx *= DAMPING\n                    n.vy *= DAMPING\n                    n.x += n.vx\n                    n.y += n.vy\n                }\n                energy += n.vx * n.vx + n.vy * n.vy\n            }\n\n            bump()\n            if (energy < 0.0006) {\n                rafRef.current = null\n                return\n            }\n            rafRef.current = requestAnimationFrame(tick)\n        }\n\n        rafRef.current = requestAnimationFrame(tick)\n        return () => {\n            if (rafRef.current) {\n                cancelAnimationFrame(rafRef.current)\n            }\n        }\n    }, [simRunning, LINK_DISTANCE, CHARGE])\n\n    // pan/zoom + drag (anchor zoom + no-jump drag + sticky hover)\n    const [k, setK] = useState(1)\n    const [tx, setTx] = useState(0)\n    const [ty, setTy] = useState(0)\n    const svgRef = useRef<SVGSVGElement | null>(null)\n    const draggingId = useRef<string | null>(null)\n    const dragOffset = useRef<{ dx: number; dy: number } | null>(null)\n    const lastPan = useRef<{ x: number; y: number } | null>(null)\n\n    const toWorld = (clientX: number, clientY: number): { x: number; y: number } => {\n        const { left, top } = svgRef.current!.getBoundingClientRect()\n        return { x: (clientX - left - tx) / k, y: (clientY - top - ty) / k }\n    }\n\n    const onWheel = (e: React.WheelEvent): void => {\n        e.preventDefault()\n        const { x: mx, y: my } = toWorld(e.clientX, e.clientY)\n        const mult = Math.exp(-e.deltaY * 0.001)\n        setK((prevK) => {\n            const unclamped = prevK * mult\n            const nextK = Math.min(4, Math.max(0.25, unclamped))\n            const r = nextK / prevK\n            setTx((prevTx) => (prevTx - mx) * r + mx)\n            setTy((prevTy) => (prevTy - my) * r + my)\n            return nextK\n        })\n    }\n\n    const onMouseDownSVG = (e: React.MouseEvent): void => {\n        if (draggingId.current) {\n            return\n        }\n        lastPan.current = { x: e.clientX, y: e.clientY }\n    }\n    const onMouseMoveSVG = (e: React.MouseEvent): void => {\n        if (!lastPan.current || draggingId.current) {\n            return\n        }\n        const dx = e.clientX - lastPan.current.x,\n            dy = e.clientY - lastPan.current.y\n        lastPan.current = { x: e.clientX, y: e.clientY }\n        setTx((t) => t + dx)\n        setTy((t) => t + dy)\n    }\n    const onMouseUpSVG = (): void => {\n        lastPan.current = null\n    }\n\n    const startDragNode =\n        (id: string) =>\n        (e: React.MouseEvent): void => {\n            e.preventDefault()\n            e.stopPropagation()\n            draggingId.current = id\n            lastPan.current = null\n            const node = nodesRef.current.find((n) => n.id === id)!\n            node.fixed = true\n            const { x, y } = toWorld(e.clientX, e.clientY)\n            dragOffset.current = { dx: x - node.x, dy: y - node.y }\n            setHoveredId(id) // keep active while dragging\n        }\n\n    const onMouseMove = (e: React.MouseEvent): void => {\n        if (!draggingId.current) {\n            return\n        }\n        const node = nodesRef.current.find((n) => n.id === draggingId.current)!\n        const { x, y } = toWorld(e.clientX, e.clientY)\n        const off = dragOffset.current || { dx: 0, dy: 0 }\n        node.x = x - off.dx\n        node.y = y - off.dy\n        node.vx = 0\n        node.vy = 0\n        bump()\n    }\n    const onMouseUp = (): void => {\n        if (!draggingId.current) {\n            return\n        }\n        const node = nodesRef.current.find((n) => n.id === draggingId.current)!\n        node.fixed = false\n        draggingId.current = null\n        dragOffset.current = null\n        setSimRunning(true)\n    }\n\n    // hover + highlighting state\n    const [hoveredId, setHoveredId] = useState<string | null>(null)\n    const outNeighbors = hoveredId ? (outAdj.get(hoveredId) ?? new Set<string>()) : new Set<string>()\n    const inNeighbors = hoveredId ? (inAdj.get(hoveredId) ?? new Set<string>()) : new Set<string>()\n    const bothNeighbors = new Set<string>([...outNeighbors].filter((x) => inNeighbors.has(x)))\n\n    // apply external highlight (from \"Show on graph\")\n    useEffect(() => {\n        if (highlightId) {\n            setHoveredId(highlightId)\n            // Optional: nudge rendering\n            bump()\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [highlightId])\n\n    // graph search\n    const [search, setSearch] = useState('')\n    useEffect(() => {\n        const term = search.trim().toLowerCase()\n        if (!term) {\n            setSearchHighlights(new Set())\n            setSearchOutNeighbors(new Set())\n            setSearchInNeighbors(new Set())\n            return\n        }\n\n        // match only by the label shown on the graph (displayName)\n        const matches = new Set<string>()\n        for (const n of nodesRef.current) {\n            const nameL = n.name.toLowerCase()\n            if (nameL.includes(term)) {\n                matches.add(n.id)\n            }\n        }\n        setSearchHighlights(matches)\n\n        // if we're not hovering, also highlight dependencies (green/red) of all matches\n        if (!hoveredId && matches.size) {\n            const out = new Set<string>()\n            const inc = new Set<string>()\n            for (const id of matches) {\n                for (const t of outAdj.get(id) ?? new Set<string>()) {\n                    out.add(t)\n                } // match -> target (green)\n                for (const s of inAdj.get(id) ?? new Set<string>()) {\n                    inc.add(s)\n                } // source -> match (red)\n            }\n            setSearchOutNeighbors(out)\n            setSearchInNeighbors(inc)\n        } else {\n            setSearchOutNeighbors(new Set())\n            setSearchInNeighbors(new Set())\n        }\n    }, [search, hoveredId, outAdj, inAdj])\n    const fillFor = (id: string): string => {\n        if (id === hoveredId) {\n            return '#FACC15'\n        }\n        if (!hoveredId) {\n            if (searchHighlights.has(id)) {\n                return '#FACC15'\n            }\n            const out = searchOutNeighbors.has(id)\n            const inc = searchInNeighbors.has(id)\n            if (out && inc) {\n                return '#14B8A6'\n            } // both directions\n            if (out) {\n                return 'rgba(34,197,94,0.9)'\n            } // depends-on (green)\n            if (inc) {\n                return 'rgba(249,115,22,0.95)'\n            } // depended-by (red/orange)\n        }\n        if (bothNeighbors.has(id)) {\n            return '#14B8A6'\n        }\n        if (outNeighbors.has(id)) {\n            return 'rgba(34,197,94,0.9)'\n        } // outgoing neighbor\n        if (inNeighbors.has(id)) {\n            return 'rgba(249,115,22,0.95)'\n        } // incoming neighbor\n        return `rgba(99, 102, 241, 0.28)`\n    }\n    const labelWeight = (id: string): number =>\n        id === hoveredId ||\n        searchHighlights.has(id) ||\n        (!hoveredId && (searchOutNeighbors.has(id) || searchInNeighbors.has(id))) ||\n        outNeighbors.has(id) ||\n        inNeighbors.has(id)\n            ? 700\n            : 400\n\n    const labelOpacity = (id: string): number => {\n        if (hoveredId) {\n            return id === hoveredId || outNeighbors.has(id) || inNeighbors.has(id) ? 1 : 0.25\n        }\n        const isEmphasized = searchHighlights.has(id) || searchOutNeighbors.has(id) || searchInNeighbors.has(id)\n        return isEmphasized ? 1 : 0.25\n    }\n\n    return (\n        <div style={{ flex: 1, minHeight: 0, background: '#fff', borderTop: '1px solid rgba(0,0,0,0.06)' }}>\n            <div style={{ padding: 8, display: 'flex', gap: 8, alignItems: 'center' }}>\n                <button type=\"button\" onClick={() => setSimRunning((s) => !s)} style={simpleBtnStyle}>\n                    {simRunning ? 'Pause layout' : 'Resume layout'}\n                </button>\n                <button\n                    type=\"button\"\n                    onClick={() => {\n                        setK(1)\n                        setTx(0)\n                        setTy(0)\n                    }}\n                    style={simpleBtnStyle}\n                >\n                    Reset view\n                </button>\n                <input\n                    type=\"search\"\n                    placeholder=\"Search graph…\"\n                    value={search || ''}\n                    onChange={(e) => setSearch(e.target.value)}\n                    style={{ ...inputStyle, maxWidth: 300 }}\n                />\n                <div style={{ marginLeft: 'auto', color: 'rgba(0,0,0,0.55)', fontSize: 12 }}>\n                    Short names • Drag nodes • Scroll to zoom • Drag background to pan\n                </div>\n            </div>\n\n            <svg\n                ref={svgRef}\n                width=\"100%\"\n                height=\"100%\"\n                viewBox={`0 0 ${width} ${height}`}\n                style={{ display: 'block', cursor: draggingId.current ? 'grabbing' : 'grab' }}\n                onWheel={onWheel}\n                onMouseDown={onMouseDownSVG}\n                onMouseMove={(e) => {\n                    onMouseMoveSVG(e)\n                    onMouseMove(e)\n                }}\n                onMouseUp={() => {\n                    onMouseUpSVG()\n                    onMouseUp()\n                }}\n                onMouseLeave={onMouseUp}\n            >\n                {/* faster marching ants */}\n                <defs>\n                    <style>{`\n            .ants-fast { stroke-dasharray: 6 6; animation: ants 0.5s linear infinite; }\n            @keyframes ants { to { stroke-dashoffset: -24; } }\n          `}</style>\n                </defs>\n\n                <g transform={`translate(${tx},${ty}) scale(${k})`}>\n                    {/* base links */}\n                    <g stroke={hoveredId ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.15)'} strokeWidth={1}>\n                        {undirectedRef.current.map((l, i) => {\n                            const a = nodesRef.current.find((n) => n.id === l.a)!\n                            const b = nodesRef.current.find((n) => n.id === l.b)!\n                            return <line key={i} x1={a.x} y1={a.y} x2={b.x} y2={b.y} />\n                        })}\n                    </g>\n\n                    {/* outgoing from hovered — animate TOWARDS hovered (reverse endpoints) */}\n                    {hoveredId ? (\n                        <g stroke=\"rgba(34,197,94,0.95)\" strokeWidth={2} className=\"ants-fast\">\n                            {directed\n                                .filter((l) => l.source === hoveredId)\n                                .map((l, i) => {\n                                    const h = nodesRef.current.find((n) => n.id === l.source)! // hovered\n                                    const n = nodesRef.current.find((n) => n.id === l.target)! // neighbor\n                                    // x1 = neighbor, x2 = hovered -> ants travel into hovered\n                                    return <line key={`out-${i}`} x1={n.x} y1={n.y} x2={h.x} y2={h.y} />\n                                })}\n                        </g>\n                    ) : null}\n\n                    {/* incoming to hovered — animate AWAY from hovered */}\n                    {hoveredId ? (\n                        <g stroke=\"rgba(249,115,22,0.95)\" strokeWidth={2} className=\"ants-fast\">\n                            {directed\n                                .filter((l) => l.target === hoveredId)\n                                .map((l, i) => {\n                                    const h = nodesRef.current.find((n) => n.id === l.target)! // hovered\n                                    const n = nodesRef.current.find((n) => n.id === l.source)! // neighbor\n                                    // x1 = hovered, x2 = neighbor -> ants travel away from hovered\n                                    return <line key={`in-${i}`} x1={h.x} y1={h.y} x2={n.x} y2={n.y} />\n                                })}\n                        </g>\n                    ) : null}\n\n                    {/* circles */}\n                    {nodesRef.current.map((n) => (\n                        <g\n                            key={`c-${n.id}`}\n                            transform={`translate(${n.x},${n.y})`}\n                            onMouseEnter={() => setHoveredId(n.id)}\n                            onMouseLeave={() => {\n                                if (!draggingId.current) {\n                                    setHoveredId(null)\n                                }\n                            }} // keep active while dragging\n                            style={{ cursor: 'pointer' }}\n                        >\n                            <circle\n                                r={n.size}\n                                fill={fillFor(n.id)}\n                                stroke={n.id === hoveredId ? '#CA8A04' : 'rgba(0,0,0,0.25)'}\n                                onMouseDown={startDragNode(n.id)}\n                                onClick={(e) => {\n                                    e.stopPropagation()\n                                    onOpen(n.id)\n                                }}\n                            />\n                        </g>\n                    ))}\n\n                    {/* labels on top; fade non-neighbors when hovering */}\n                    <g style={{ pointerEvents: 'none' }}>\n                        {nodesRef.current.map((n) => (\n                            <text\n                                key={`t-${n.id}`}\n                                x={n.x + n.size + 8}\n                                y={n.y + 4}\n                                fontSize={12}\n                                fontWeight={labelWeight(n.id)}\n                                fill=\"rgba(0,0,0,0.92)\"\n                                opacity={labelOpacity(n.id)}\n                            >\n                                {n.name}\n                            </text>\n                        ))}\n                    </g>\n                </g>\n            </svg>\n        </div>\n    )\n}\n\n/* ---------- Memory tab helpers ---------- */\nfunction formatBytes(bytes: number): string {\n    if (!Number.isFinite(bytes) || bytes <= 0) {\n        return '0 B'\n    }\n    const units = ['B', 'KB', 'MB', 'GB', 'TB']\n    let i = 0\n    let n = bytes\n    while (n >= 1024 && i < units.length - 1) {\n        n /= 1024\n        i++\n    }\n    if (i === 0) {\n        return `${Math.trunc(n)} B`\n    } // no fractional bytes\n    const s = n.toFixed(n >= 100 ? 0 : n >= 10 ? 1 : 2).replace(/\\.0+$/, '')\n    return `${s} ${units[i]}`\n}\n\n// robust path walker for kea logic.path (array of strings/numbers)\nfunction getAtPath(root: any, path: Array<string | number> | undefined): unknown {\n    if (!root || !Array.isArray(path) || !path.length) {\n        return undefined\n    }\n    let cur = root\n    for (const seg of path) {\n        if (cur == null) {\n            return undefined\n        }\n        cur = cur[String(seg)]\n    }\n    return cur\n}\n\n// Limits to keep things safe\nconst INSPECT_MAX_DEPTH = 20\nconst INSPECT_MAX_ARRAY = 5_000\n\ntype InspectResult = { data: unknown; truncated: boolean }\n\n// try/catch wrapper to protect against throwing getters/proxies\nfunction tryGet<T>(fn: () => T): T | '[[Throw]]' {\n    try {\n        return fn()\n    } catch {\n        return '[[Throw]]'\n    }\n}\n\nfunction toInspectable(\n    value: unknown,\n    maxDepth = INSPECT_MAX_DEPTH,\n    seen = new WeakMap<object, any>(),\n    depth = 0\n): InspectResult {\n    let truncated = false\n\n    const visit = (v: any, d: number): any => {\n        // primitives\n        const t = typeof v\n        if (v === null || t === 'string' || t === 'number' || t === 'boolean') {\n            return v\n        }\n        if (t === 'bigint') {\n            return v.toString()\n        }\n        if (t === 'symbol') {\n            return v.toString()\n        }\n        if (t === 'function') {\n            return `[Function ${v.name || 'anonymous'}]`\n        }\n\n        // depth limit\n        if (d >= maxDepth) {\n            truncated = true\n            return '[MaxDepth]'\n        }\n\n        // typed arrays / buffers\n        if (v instanceof Date) {\n            return v.toISOString()\n        }\n        if (v instanceof ArrayBuffer) {\n            return { __type: 'ArrayBuffer', byteLength: v.byteLength }\n        }\n        if (ArrayBuffer.isView(v) && !(v instanceof DataView)) {\n            return { __type: v.constructor?.name || 'TypedArray', length: (v as any).length }\n        }\n\n        // cycles\n        if (typeof v === 'object' && v !== null) {\n            if (seen.has(v)) {\n                return '[Circular]'\n            }\n        }\n\n        // arrays\n        if (Array.isArray(v)) {\n            const out: any[] = []\n            seen.set(v, out)\n            const n = v.length\n            const limit = Math.min(n, INSPECT_MAX_ARRAY)\n            for (let i = 0; i < limit; i++) {\n                out.push(\n                    visit(\n                        tryGet(() => v[i]),\n                        d + 1\n                    )\n                )\n            }\n            if (n > limit) {\n                truncated = true\n                out.push(`[+${n - limit} more]`)\n            }\n            return out\n        }\n\n        // Map / Set\n        if (v instanceof Map) {\n            const out: any[] = []\n            seen.set(v, out)\n            let i = 0\n            for (const [k, val] of v.entries()) {\n                if (i++ >= INSPECT_MAX_ARRAY) {\n                    truncated = true\n                    out.push('[+more]')\n                    break\n                }\n                out.push([visit(k, d + 1), visit(val, d + 1)])\n            }\n            return { __type: 'Map', entries: out }\n        }\n        if (v instanceof Set) {\n            const out: any[] = []\n            seen.set(v, out)\n            let i = 0\n            for (const val of v.values()) {\n                if (i++ >= INSPECT_MAX_ARRAY) {\n                    truncated = true\n                    out.push('[+more]')\n                    break\n                }\n                out.push(visit(val, d + 1))\n            }\n            return { __type: 'Set', values: out }\n        }\n\n        // generic object (protect against throwing property access)\n        if (typeof v === 'object' && v !== null) {\n            const out: Record<string, any> = {}\n            seen.set(v, out)\n            // own keys only\n            const names = tryGet(() => Object.getOwnPropertyNames(v)) as any\n            const syms = tryGet(() => Object.getOwnPropertySymbols(v)) as any\n            const keys: (string | symbol)[] = []\n            if (Array.isArray(names)) {\n                keys.push(...names)\n            }\n            if (Array.isArray(syms)) {\n                keys.push(...syms)\n            }\n\n            for (const k of keys) {\n                // guard individual getter/proxy throws\n                const val = tryGet(() => (v as any)[k as any])\n                out[String(k)] = val === '[[Throw]]' ? '[Throwing Getter]' : visit(val, d + 1)\n            }\n            return out\n        }\n\n        // fallback\n        return Object.prototype.toString.call(v)\n    }\n\n    const data = visit(value, depth)\n    return { data, truncated }\n}\n\nfunction toJSONStringBestEffort(value: unknown, pretty = false): { text: string; truncated: boolean } {\n    const { data, truncated } = toInspectable(value)\n    try {\n        return { text: JSON.stringify(data, null, pretty ? 2 : 0), truncated }\n    } catch {\n        return { text: '\"[Unserializable]\"', truncated: true }\n    }\n}\n\nfunction safeStringify(x: unknown, pretty = false): string {\n    return toJSONStringBestEffort(x, pretty).text\n}\n\nfunction byteLengthUTF8(s: string): number {\n    try {\n        return new TextEncoder().encode(s).length\n    } catch {\n        let bytes = 0\n        for (let i = 0; i < s.length; i++) {\n            const c = s.charCodeAt(i)\n            bytes += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0xd800 || c >= 0xe000 ? 3 : (i++, 4)\n        }\n        return bytes\n    }\n}\n\nfunction bytesOf(value: unknown): number {\n    try {\n        const { text } = toJSONStringBestEffort(value, false)\n        return byteLengthUTF8(text)\n    } catch {\n        // absolute fallback: best-effort string length\n        try {\n            return byteLengthUTF8(String(value))\n        } catch {\n            return 0\n        }\n    }\n}\n\n// Safe tag: avoids instanceof on cross-realm/host objects/proxies\nfunction safeTag(v: unknown): string {\n    try {\n        return Object.prototype.toString.call(v) // e.g. \"[object Map]\"\n    } catch {\n        return '[object Unknown]'\n    }\n}\n\nconst isArray = (v: unknown): boolean => Array.isArray(v)\nconst isMap = (v: unknown): boolean => safeTag(v) === '[object Map]'\nconst isSet = (v: unknown): boolean => safeTag(v) === '[object Set]'\nconst isDate = (v: unknown): boolean => safeTag(v) === '[object Date]'\nconst isArrayBuffer = (v: unknown): boolean => safeTag(v) === '[object ArrayBuffer]'\nconst isDataView = (v: unknown): boolean => safeTag(v) === '[object DataView]'\n\nfunction isTypedArray(v: unknown): boolean {\n    const tag = safeTag(v)\n    return (\n        /\\[object (?:Uint|Int|Float)\\d{1,2}Array\\]/.test(tag) ||\n        tag === '[object BigInt64Array]' ||\n        tag === '[object BigUint64Array]'\n    )\n}\n\n// Hard guard for “host-like” things (DOM, React elements, Window, etc.)\nfunction isHostLike(v: any): boolean {\n    // React element (don’t traverse)\n    if (v && typeof v === 'object' && (v as any).$$typeof) {\n        return true\n    }\n    const tag = safeTag(v)\n    // DOM-ish, window-ish, error objects, etc. — treat as leaf\n    if (\n        tag === '[object Window]' ||\n        tag === '[object Document]' ||\n        tag === '[object Element]' ||\n        tag === '[object Node]' ||\n        tag === '[object HTMLDocument]' ||\n        tag === '[object ShadowRoot]' ||\n        tag === '[object Error]'\n    ) {\n        return true\n    }\n    return false\n}\n\nfunction isComposite(v: unknown): boolean {\n    if (v === null) {\n        return false\n    }\n    if (typeof v !== 'object') {\n        return false\n    }\n    if (isHostLike(v)) {\n        return false\n    }\n    return true\n}\n\ntype ChildWithSize = { key: string; value: unknown; bytes: number; canExpand: boolean }\n\nfunction getChildrenSorted(value: unknown): ChildWithSize[] {\n    const out: ChildWithSize[] = []\n    if (value == null || !isComposite(value)) {\n        return out\n    }\n\n    // Map\n    if (isMap(value)) {\n        let i = 0\n        try {\n            for (const [k, v] of (value as Map<any, any>).entries()) {\n                if (i++ >= INSPECT_MAX_ARRAY) {\n                    break\n                }\n                let kPreview = ''\n                try {\n                    const s = JSON.stringify(k)\n                    kPreview = s.length > 80 ? s.slice(0, 77) + '…' : s\n                } catch {\n                    kPreview = String(k)\n                }\n                const b = bytesOf(v)\n                out.push({ key: `→ ${kPreview}`, value: v, bytes: b, canExpand: isComposite(v) })\n            }\n        } catch {\n            /* ignore */\n        }\n        out.sort((a, b) => b.bytes - a.bytes)\n        return out\n    }\n\n    // Set\n    if (isSet(value)) {\n        let i = 0,\n            idx = 0\n        try {\n            for (const v of (value as Set<any>).values()) {\n                if (i++ >= INSPECT_MAX_ARRAY) {\n                    break\n                }\n                const b = bytesOf(v)\n                out.push({ key: String(idx++), value: v, bytes: b, canExpand: isComposite(v) })\n            }\n        } catch {\n            /* ignore */\n        }\n        out.sort((a, b) => b.bytes - a.bytes)\n        return out\n    }\n\n    // Array\n    if (isArray(value)) {\n        const arr = value as any[]\n        const n = Math.min(arr.length, INSPECT_MAX_ARRAY)\n        for (let i = 0; i < n; i++) {\n            const got = tryGet(() => arr[i])\n            const val = got === '[[Throw]]' ? '[Throwing Getter]' : got\n            const b = bytesOf(val)\n            out.push({ key: String(i), value: val, bytes: b, canExpand: isComposite(val) })\n        }\n        out.sort((a, b) => b.bytes - a.bytes)\n        if (arr.length > n) {\n            out.push({ key: `[+${arr.length - n} more]`, value: undefined, bytes: 0, canExpand: false })\n        }\n        return out\n    }\n\n    // Binary & dates: leaf-metadata only\n    if (isArrayBuffer(value)) {\n        const bl = tryGet(() => (value as ArrayBuffer).byteLength)\n        out.push({ key: 'byteLength', value: bl, bytes: bytesOf(bl), canExpand: false })\n        return out\n    }\n    if (isTypedArray(value) || isDataView(value)) {\n        const len = tryGet(() => (value as any).length)\n        out.push({ key: 'length', value: len, bytes: bytesOf(len), canExpand: false })\n        return out\n    }\n    if (isDate(value)) {\n        return out\n    } // no children\n\n    // Plain-ish object\n    const keys: (string | symbol)[] = []\n    const names = tryGet(() => Object.getOwnPropertyNames(value as object))\n    const syms = tryGet(() => Object.getOwnPropertySymbols(value as object))\n    if (Array.isArray(names)) {\n        keys.push(...names)\n    }\n    if (Array.isArray(syms)) {\n        keys.push(...syms)\n    }\n\n    for (const k of keys) {\n        const got = tryGet(() => (value as any)[k as any])\n        const val = got === '[[Throw]]' ? '[Throwing Getter]' : got\n        const b = bytesOf(val)\n        out.push({ key: String(k), value: val, bytes: b, canExpand: isComposite(val) })\n        if (out.length >= INSPECT_MAX_ARRAY) {\n            out.push({ key: '[+more]', value: undefined, bytes: 0, canExpand: false })\n            break\n        }\n    }\n\n    out.sort((a, b) => b.bytes - a.bytes)\n    return out\n}\n\nfunction RowLine({\n    depth,\n    label,\n    size,\n    canExpand,\n    isOpen,\n    onToggle,\n}: {\n    depth: number\n    label: string\n    size: number\n    canExpand: boolean\n    isOpen: boolean\n    onToggle: () => void\n}): JSX.Element {\n    return (\n        <div\n            style={{\n                display: 'grid',\n                gridTemplateColumns: '1fr max-content',\n                alignItems: 'center',\n                padding: '4px 6px',\n                borderBottom: '1px dashed rgba(0,0,0,0.05)',\n            }}\n        >\n            <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>\n                <span style={{ paddingLeft: depth * 14 }} />\n                {canExpand ? (\n                    <button\n                        type=\"button\"\n                        onClick={onToggle}\n                        style={simpleBtnStyle}\n                        title={isOpen ? 'Collapse' : 'Expand'}\n                    >\n                        {isOpen ? '▾' : '▸'}\n                    </button>\n                ) : (\n                    <span style={{ width: 32 }} />\n                )}\n                <code\n                    style={{\n                        fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',\n                        wordBreak: 'break-all',\n                    }}\n                >\n                    {label}\n                </code>\n            </div>\n            <div style={{ textAlign: 'right', fontWeight: 700 }}>{formatBytes(size)}</div>\n        </div>\n    )\n}\n\ntype TreeState = { expanded: Set<string>; toggle: (id: string) => void }\n\nfunction MemoryTree({\n    rootValue,\n    rootId,\n    state,\n    depth = 0,\n}: {\n    rootValue: unknown\n    rootId: string\n    state: TreeState\n    depth?: number\n}) {\n    try {\n        const children = getChildrenSorted(rootValue)\n        return (\n            <div>\n                {children.map(({ key, value, bytes, canExpand }) => {\n                    const id = `${rootId}.${key}`\n                    const open = canExpand && state.expanded.has(id)\n                    return (\n                        <div key={id}>\n                            <RowLine\n                                depth={depth}\n                                label={key}\n                                size={bytes}\n                                canExpand={canExpand}\n                                isOpen={!!open}\n                                onToggle={() => state.toggle(id)}\n                            />\n                            {open ? <MemoryTree rootValue={value} rootId={id} state={state} depth={depth + 1} /> : null}\n                        </div>\n                    )\n                })}\n            </div>\n        )\n    } catch (e: any) {\n        return (\n            <div style={{ padding: 6, color: 'rgba(0,0,0,0.7)' }}>\n                <code>[[Render error: {e?.message ?? String(e)}]]</code>\n            </div>\n        )\n    }\n}\n\nclass MemoryErrorBoundary extends React.Component<{ children: React.ReactNode }, { hasError: boolean; msg?: string }> {\n    constructor(props: any) {\n        super(props)\n        this.state = { hasError: false, msg: undefined }\n    }\n\n    static getDerivedStateFromError(err: any): Record<string, any> {\n        return { hasError: true, msg: err?.message ?? String(err) }\n    }\n\n    componentDidCatch(err: any): void {\n        console.warn('MemoryTree error', err)\n    }\n\n    render(): JSX.Element | null {\n        if (this.state.hasError) {\n            return (\n                <div style={{ padding: 6, color: 'rgba(0,0,0,0.7)' }}>\n                    <code>[[Tree crashed: {this.state.msg}]]</code>\n                </div>\n            )\n        }\n        return this.props.children as any\n    }\n}\n\n// ---------- Memory tab ----------\n\ntype MemoryRow = {\n    key: string\n    name: string\n    bytes: number\n    value: unknown\n}\n\nfunction MemoryTab({ store, mounted }: { store: KeaContext['store']; mounted: MountedMap }): JSX.Element {\n    const lastGood = useRef<Map<string, { text: string; bytes: number; value: unknown }>>(new Map())\n    const [rows, setRows] = useState<MemoryRow[]>([])\n    const [totalBytes, setTotalBytes] = useState(0)\n    const [expanded, setExpanded] = useState<Set<string>>(new Set())\n    const [isRefreshing, setIsRefreshing] = useState(false)\n    const [lastUpdated, setLastUpdated] = useState<number | null>(null)\n\n    // single recompute from a consistent snapshot\n    const recompute = React.useCallback(() => {\n        setIsRefreshing(true)\n\n        // snapshot once\n        const state = store.getState()\n        const keys = Object.keys(mounted)\n\n        // build rows from snapshot\n        const nextRows: MemoryRow[] = keys.map((pathString) => {\n            const logic = mounted[pathString]\n            const value = getAtPath(state, (logic as any)?.path)\n\n            // Best-effort JSON\n            const { text } = toJSONStringBestEffort(value, false)\n            const bytes = byteLengthUTF8(text)\n\n            // Heuristic: if it's an object-like value but serialized to something suspiciously tiny,\n            // keep the last good snapshot (prevents collapsing to 15 B).\n            const looksTiny = typeof value === 'object' && value !== null && bytes < 40 /* ~ \"[{}]\" scale */\n\n            const prior = lastGood.current.get(pathString)\n            if (looksTiny && prior && prior.bytes > bytes) {\n                return { key: pathString, name: displayName(logic), bytes: prior.bytes, value: prior.value }\n            }\n\n            // Update last good if this is meaningful\n            if (!looksTiny || bytes > (prior?.bytes ?? 0)) {\n                lastGood.current.set(pathString, { text, bytes, value })\n            }\n\n            return { key: pathString, name: displayName(logic), bytes, value }\n        })\n\n        nextRows.sort((a, b) => b.bytes - a.bytes)\n\n        // ✅ total is the sum of Kea slices, not a risky whole-store stringify\n        const nextTotalBytes = nextRows.reduce((acc, r) => acc + r.bytes, 0)\n\n        setRows(nextRows)\n        setTotalBytes(nextTotalBytes)\n        setLastUpdated(Date.now())\n        setIsRefreshing(false)\n    }, [store, mounted])\n\n    // run once on mount\n    useEffect(() => {\n        recompute()\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [])\n\n    // also refresh on store changes (coalesced)\n    useEffect(() => {\n        let raf: number | null = null\n        const unsub = store.subscribe(() => {\n            if (raf !== null) {\n                return\n            }\n            raf = requestAnimationFrame(() => {\n                raf = null\n                recompute()\n            })\n        })\n        return () => {\n            unsub()\n            if (raf !== null) {\n                cancelAnimationFrame(raf)\n            }\n        }\n    }, [store, recompute])\n\n    const toggle = (k: string): void =>\n        setExpanded((prev) => {\n            const next = new Set(prev)\n            next.has(k) ? next.delete(k) : next.add(k)\n            return next\n        })\n\n    const copyJSON = async (k: string): Promise<void> => {\n        const row = rows.find((r) => r.key === k)\n        try {\n            await navigator.clipboard.writeText(safeStringify(row?.value, true))\n            alert('Copied JSON to clipboard.')\n        } catch (e: any) {\n            alert(`Copy failed: ${e?.message ?? e}`)\n        }\n    }\n\n    return (\n        <div style={{ display: 'flex', flexDirection: 'column', minHeight: 0, padding: 10, gap: 8, flex: 1 }}>\n            <div\n                style={{\n                    display: 'flex',\n                    alignItems: 'center',\n                    gap: 8,\n                    background: '#fff',\n                    border: '1px solid rgba(0,0,0,0.06)',\n                    borderRadius: 12,\n                    padding: 12,\n                }}\n            >\n                <div style={{ fontWeight: 800, fontSize: 16 }}>Memory usage</div>\n                <div style={{ marginLeft: 'auto', color: 'rgba(0,0,0,0.7)' }}>\n                    Store size: <strong>{formatBytes(totalBytes)}</strong>\n                    {lastUpdated ? (\n                        <span style={{ marginLeft: 10, fontSize: 12, color: 'rgba(0,0,0,0.55)' }}>\n                            Updated {new Date(lastUpdated).toLocaleTimeString()}\n                        </span>\n                    ) : null}\n                </div>\n                <button\n                    type=\"button\"\n                    onClick={recompute}\n                    disabled={isRefreshing}\n                    style={{ ...simpleBtnStyle, minWidth: 90, display: 'inline-flex', gap: 6, alignItems: 'center' }}\n                    title=\"Recompute from current store snapshot\"\n                >\n                    {isRefreshing ? (\n                        <>\n                            <span\n                                aria-hidden\n                                style={{\n                                    width: 14,\n                                    height: 14,\n                                    borderRadius: '50%',\n                                    border: '2px solid rgba(0,0,0,0.25)',\n                                    borderTopColor: 'rgba(0,0,0,0.6)',\n                                    display: 'inline-block',\n                                    animation: 'spin 0.9s linear infinite',\n                                }}\n                            />\n                            Refreshing…\n                        </>\n                    ) : (\n                        'Refresh'\n                    )}\n                </button>\n                {/* local keyframes for spinner */}\n                <style>{`@keyframes spin { to { transform: rotate(360deg); } }`}</style>\n            </div>\n\n            <div\n                style={{\n                    flex: 1,\n                    overflow: 'auto',\n                    background: '#fff',\n                    border: '1px solid rgba(0,0,0,0.06)',\n                    borderRadius: 12,\n                }}\n            >\n                {rows.length === 0 ? (\n                    <div style={{ padding: 12, color: 'rgba(0,0,0,0.6)' }}>No mounted logics.</div>\n                ) : (\n                    <table style={{ width: '100%', borderCollapse: 'collapse', tableLayout: 'fixed' }}>\n                        <thead style={{ position: 'sticky', top: 0, background: '#fafafa', zIndex: 1 }}>\n                            <tr>\n                                <th\n                                    style={{\n                                        textAlign: 'left',\n                                        padding: '10px 12px',\n                                        borderBottom: '1px solid rgba(0,0,0,0.06)',\n                                        width: '45%',\n                                    }}\n                                >\n                                    Logic\n                                </th>\n                                <th\n                                    style={{\n                                        textAlign: 'right',\n                                        padding: '10px 12px',\n                                        borderBottom: '1px solid rgba(0,0,0,0.06)',\n                                        width: '10%',\n                                    }}\n                                >\n                                    Size\n                                </th>\n                                <th\n                                    style={{\n                                        textAlign: 'left',\n                                        padding: '10px 12px',\n                                        borderBottom: '1px solid rgba(0,0,0,0.06)',\n                                    }}\n                                >\n                                    Actions\n                                </th>\n                            </tr>\n                        </thead>\n                        <tbody>\n                            {rows.map((r) => {\n                                const isOpen = expanded.has(r.key)\n                                return (\n                                    <React.Fragment key={r.key}>\n                                        <tr style={{ borderBottom: '1px solid rgba(0,0,0,0.05)' }}>\n                                            <td style={{ padding: '10px 12px', verticalAlign: 'top' }}>\n                                                <div style={{ fontWeight: 700 }}>{r.name}</div>\n                                                <div\n                                                    style={{\n                                                        marginTop: 4,\n                                                        color: 'rgba(0,0,0,0.6)',\n                                                        fontSize: 12,\n                                                        wordBreak: 'break-all',\n                                                    }}\n                                                    title={r.key}\n                                                >\n                                                    {r.key}\n                                                </div>\n                                            </td>\n                                            <td\n                                                style={{\n                                                    padding: '10px 12px',\n                                                    verticalAlign: 'top',\n                                                    textAlign: 'right',\n                                                    fontWeight: 700,\n                                                }}\n                                            >\n                                                {formatBytes(r.bytes)}\n                                            </td>\n                                            <td style={{ padding: '10px 12px', verticalAlign: 'top' }}>\n                                                <div style={{ display: 'flex', gap: 8 }}>\n                                                    <button\n                                                        type=\"button\"\n                                                        onClick={() => toggle(r.key)}\n                                                        style={simpleBtnStyle}\n                                                        title={\n                                                            isOpen ? 'Collapse details' : 'Expand to see per-key sizes'\n                                                        }\n                                                    >\n                                                        {isOpen ? 'Collapse' : 'Expand'}\n                                                    </button>\n                                                    <button\n                                                        type=\"button\"\n                                                        onClick={() => copyJSON(r.key)}\n                                                        style={simpleBtnStyle}\n                                                        title=\"Copy JSON to clipboard\"\n                                                    >\n                                                        Copy JSON\n                                                    </button>\n                                                </div>\n                                            </td>\n                                        </tr>\n                                        {isOpen ? (\n                                            <tr>\n                                                <td colSpan={3} style={{ padding: '6px 12px 12px' }}>\n                                                    <div\n                                                        style={{\n                                                            border: '1px solid rgba(0,0,0,0.12)',\n                                                            borderRadius: 8,\n                                                            background: '#fafafa',\n                                                            overflow: 'hidden',\n                                                        }}\n                                                    >\n                                                        <div\n                                                            style={{\n                                                                display: 'grid',\n                                                                gridTemplateColumns: '1fr max-content',\n                                                                padding: '8px 10px',\n                                                                background: '#f0f1f5',\n                                                                borderBottom: '1px solid rgba(0,0,0,0.08)',\n                                                                fontWeight: 700,\n                                                            }}\n                                                        >\n                                                            <div>{r.key}</div>\n                                                            <div>{formatBytes(r.bytes)}</div>\n                                                        </div>\n\n                                                        <MemoryErrorBoundary>\n                                                            <MemoryTree\n                                                                rootValue={r.value}\n                                                                rootId={r.key}\n                                                                state={{\n                                                                    expanded,\n                                                                    toggle: (id) =>\n                                                                        setExpanded((prev) => {\n                                                                            const next = new Set(prev)\n                                                                            next.has(id)\n                                                                                ? next.delete(id)\n                                                                                : next.add(id)\n                                                                            return next\n                                                                        }),\n                                                                }}\n                                                            />\n                                                        </MemoryErrorBoundary>\n                                                    </div>\n                                                </td>\n                                            </tr>\n                                        ) : null}\n                                    </React.Fragment>\n                                )\n                            })}\n                        </tbody>\n                    </table>\n                )}\n            </div>\n        </div>\n    )\n}\n\n/* ---------- main component ---------- */\n\nexport function KeaDevtools({\n    defaultOpen = false,\n    buttonSize = 56,\n    offset = 16,\n    zIndex = 2147483000,\n    maxActions = 1000,\n}: KeaDevtoolsProps): JSX.Element {\n    const [open, setOpen] = useState(defaultOpen)\n    const [activeTab, setActiveTab] = useState<Tab>('logics')\n    const [selectedKey, setSelectedKey] = useState<string | null>(null)\n    const [sortMode, setSortMode] = useState<SortMode>('alpha')\n    const [query, setQuery] = useState('')\n    const recent = useRef<Map<string, number>>(new Map())\n    const actionId = useRef(1)\n    const [actions, setActions] = useState<ActionLogItem[]>([])\n    const [paused, setPaused] = useState(false)\n    const pausedRef = useRef(paused)\n    useEffect(() => {\n        pausedRef.current = paused\n    }, [paused])\n    const dispatchPatched = useRef(false)\n    const maxActionsRef = useRef(maxActions)\n    useEffect(() => {\n        maxActionsRef.current = maxActions\n    }, [maxActions])\n    const [windowed, setWindowed] = useState(false)\n    const [windowRect, setWindowRect] = useState<WindowRect>(() => {\n        if (typeof window !== 'undefined') {\n            const maxWidth = Math.max(MIN_WINDOW_WIDTH, window.innerWidth - offset * 2)\n            const maxHeight = Math.max(MIN_WINDOW_HEIGHT, window.innerHeight - offset * 2)\n            return {\n                width: clamp(960, MIN_WINDOW_WIDTH, maxWidth),\n                height: clamp(640, MIN_WINDOW_HEIGHT, maxHeight),\n                top: offset,\n                left: offset,\n            }\n        }\n        return { width: 960, height: 640, top: offset, left: offset }\n    })\n    const dragState = useRef<{ offsetX: number; offsetY: number } | null>(null)\n    const resizeState = useRef<{ startX: number; startY: number; width: number; height: number } | null>(null)\n\n    // highlight for graph (\"Show on graph\")\n    const [graphHighlight, setGraphHighlight] = useState<string | null>(null)\n\n    const { mount, store } = getContext() as KeaContext\n    const mounted = ((mount as any)?.mounted ?? {}) as MountedMap\n\n    useEffect(() => {\n        if (typeof window === 'undefined') {\n            return\n        }\n        const handleMove = (event: MouseEvent): void => {\n            if (!windowed) {\n                return\n            }\n            if (dragState.current) {\n                const { offsetX, offsetY } = dragState.current\n                setWindowRect((rect) => {\n                    const maxLeft = Math.max(offset, window.innerWidth - rect.width - offset)\n                    const maxTop = Math.max(offset, window.innerHeight - rect.height - offset)\n                    return {\n                        ...rect,\n                        left: clamp(event.clientX - offsetX, offset, maxLeft),\n                        top: clamp(event.clientY - offsetY, offset, maxTop),\n                    }\n                })\n            } else if (resizeState.current) {\n                const { startX, startY, width, height } = resizeState.current\n                setWindowRect((rect) => {\n                    const maxWidth = Math.max(MIN_WINDOW_WIDTH, window.innerWidth - rect.left - offset)\n                    const maxHeight = Math.max(MIN_WINDOW_HEIGHT, window.innerHeight - rect.top - offset)\n                    return {\n                        ...rect,\n                        width: clamp(width + (event.clientX - startX), MIN_WINDOW_WIDTH, maxWidth),\n                        height: clamp(height + (event.clientY - startY), MIN_WINDOW_HEIGHT, maxHeight),\n                    }\n                })\n            }\n        }\n        const handleUp = (): void => {\n            dragState.current = null\n            resizeState.current = null\n        }\n        window.addEventListener('mousemove', handleMove)\n        window.addEventListener('mouseup', handleUp)\n        return () => {\n            window.removeEventListener('mousemove', handleMove)\n            window.removeEventListener('mouseup', handleUp)\n        }\n    }, [windowed, offset])\n\n    useEffect(() => {\n        if (!windowed || typeof window === 'undefined') {\n            return\n        }\n        const clampToViewport = (): void => {\n            setWindowRect((rect) => {\n                const maxWidth = Math.max(MIN_WINDOW_WIDTH, window.innerWidth - offset * 2)\n                const maxHeight = Math.max(MIN_WINDOW_HEIGHT, window.innerHeight - offset * 2)\n                const width = clamp(rect.width, MIN_WINDOW_WIDTH, maxWidth)\n                const height = clamp(rect.height, MIN_WINDOW_HEIGHT, maxHeight)\n                const maxLeft = Math.max(offset, window.innerWidth - width - offset)\n                const maxTop = Math.max(offset, window.innerHeight - height - offset)\n                return {\n                    width,\n                    height,\n                    left: clamp(rect.left, offset, maxLeft),\n                    top: clamp(rect.top, offset, maxTop),\n                }\n            })\n        }\n        const handleResize = (): void => clampToViewport()\n        window.addEventListener('resize', handleResize)\n        clampToViewport()\n        return () => {\n            window.removeEventListener('resize', handleResize)\n        }\n    }, [windowed, offset])\n\n    useEffect(() => {\n        if (!windowed) {\n            dragState.current = null\n            resizeState.current = null\n        }\n    }, [windowed])\n\n    const onHeaderMouseDown = (event: React.MouseEvent<HTMLDivElement>): void => {\n        if (!windowed || event.button !== 0) {\n            return\n        }\n        if ((event.target as HTMLElement)?.closest('button, input, select, textarea')) {\n            return\n        }\n        event.preventDefault()\n        dragState.current = {\n            offsetX: event.clientX - windowRect.left,\n            offsetY: event.clientY - windowRect.top,\n        }\n    }\n\n    const onResizeMouseDown = (event: React.MouseEvent<HTMLDivElement>): void => {\n        if (!windowed || event.button !== 0) {\n            return\n        }\n        event.preventDefault()\n        resizeState.current = {\n            startX: event.clientX,\n            startY: event.clientY,\n            width: windowRect.width,\n            height: windowRect.height,\n        }\n    }\n\n    // collect actions\n    useEffect(() => {\n        if (dispatchPatched.current) {\n            return\n        }\n        const s: any = store as any\n        const originalDispatch = s.dispatch\n        s.__keaDevtoolsOriginalDispatch = originalDispatch\n        s.dispatch = (action: any) => {\n            if (pausedRef.current) {\n                return originalDispatch(action)\n            }\n            const beforeState = s.getState()\n            const result = originalDispatch(action)\n            const afterState = s.getState()\n            const diffResult = diffStates(beforeState, afterState, MAX_STATE_DIFF_ENTRIES)\n            const payloadValue = action?.payload\n            const payloadSummary = typeof payloadValue === 'undefined' ? '—' : safeJSONStringify(payloadValue)\n            const payloadText = typeof payloadValue === 'undefined' ? '—' : safeJSONStringify(payloadValue, 2)\n            const stateDiffSummary = summarizeStateDiff(diffResult)\n            const stateDiffText = diffResult.changes.length\n                ? safeJSONStringify(diffResult.changes, 2)\n                : 'No state changes'\n\n            const entry: ActionLogItem = {\n                id: actionId.current++,\n                ts: Date.now(),\n                type: String(action?.type ?? 'UNKNOWN'),\n                payload: payloadValue,\n                payloadSummary,\n                payloadText,\n                stateDiff: diffResult.changes,\n                stateDiffSummary,\n                stateDiffText,\n                stateDiffTruncated: diffResult.truncated,\n            }\n            setActions((prev) => {\n                const next = [entry, ...prev]\n                const limit = maxActionsRef.current\n                if (typeof limit === 'number' && next.length > limit) {\n                    next.splice(limit)\n                }\n                return next\n            })\n            return result\n        }\n        dispatchPatched.current = true\n        return () => {\n            if (s.__keaDevtoolsOriginalDispatch) {\n                s.dispatch = s.__keaDevtoolsOriginalDispatch\n            }\n            dispatchPatched.current = false\n        }\n    }, [store])\n\n    // keys + default selection\n    const allKeys = useMemo(\n        () => Object.keys(mounted).sort((a, b) => displayName(mounted[a]).localeCompare(displayName(mounted[b]))),\n        [mounted]\n    )\n\n    useEffect(() => {\n        if (!selectedKey && allKeys.length) {\n            setSelectedKey(allKeys[0])\n            recent.current.set(allKeys[0], Date.now())\n        }\n    }, [selectedKey, allKeys])\n\n    // Debounce the search query for better performance\n    const debouncedQuery = useDebounce(query, 300)\n\n    // left list: filter + sort\n    const visibleKeys = useMemo(() => {\n        const q = debouncedQuery.trim().toLowerCase()\n        const base = q\n            ? allKeys.filter((k) => {\n                  const name = displayName(mounted[k]).toLowerCase()\n                  return name.includes(q) || k.toLowerCase().includes(q)\n              })\n            : allKeys.slice()\n        if (sortMode === 'recent') {\n            base.sort((a, b) => (recent.current.get(b) ?? 0) - (recent.current.get(a) ?? 0))\n        }\n        return base\n    }, [allKeys, sortMode, debouncedQuery, mounted])\n\n    const selectedLogic = selectedKey ? mounted[selectedKey] : undefined\n\n    const header = (\n        <div\n            onMouseDown={onHeaderMouseDown}\n            style={{\n                display: 'flex',\n                alignItems: 'center',\n                gap: 8,\n                padding: '8px 10px',\n                cursor: windowed ? 'move' : 'default',\n                userSelect: dragState.current ? 'none' : undefined,\n            }}\n        >\n            <div style={{ fontWeight: 800, fontSize: 16 }}>Kea Devtools</div>\n            {activeTab === 'logics' ? (\n                <div style={{ color: 'rgba(0,0,0,0.55)' }}>{allKeys.length} mounted</div>\n            ) : activeTab === 'actions' ? (\n                <div style={{ color: 'rgba(0,0,0,0.55)' }}>{actions.length} actions</div>\n            ) : activeTab === 'graph' ? (\n                <div style={{ color: 'rgba(0,0,0,0.55)' }}>Graph of {allKeys.length} logics</div>\n            ) : activeTab === 'memory' ? (\n                <div style={{ color: 'rgba(0,0,0,0.55)' }}>Memory usage</div>\n            ) : (\n                <div style={{ color: 'rgba(0,0,0,0.55)' }}>{activeTab}</div>\n            )}\n            <div style={{ marginLeft: 'auto', display: 'flex', gap: 6 }}>\n                <button\n                    type=\"button\"\n                    onClick={() => setActiveTab('logics')}\n                    style={tabBtnStyle(activeTab === 'logics')}\n                >\n                    Logics\n                </button>\n                <button\n                    type=\"button\"\n                    onClick={() => setActiveTab('actions')}\n                    style={tabBtnStyle(activeTab === 'actions')}\n                >\n                    Actions\n                </button>\n                <button type=\"button\" onClick={() => setActiveTab('graph')} style={tabBtnStyle(activeTab === 'graph')}>\n                    Graph\n                </button>\n                <button\n                    type=\"button\"\n                    onClick={() => setActiveTab('memory')}\n                    style={tabBtnStyle(activeTab === 'memory')}\n                    title=\"Analyze store size by logic\"\n                >\n                    Memory\n                </button>\n                <button\n                    type=\"button\"\n                    onClick={() => setWindowed((value) => !value)}\n                    style={simpleBtnStyle}\n                    title={windowed ? 'Return to full-screen mode' : 'Switch to windowed mode'}\n                >\n                    {windowed ? 'Full screen' : 'Windowed'}\n                </button>\n                <button\n                    type=\"button\"\n                    onClick={() => setWindowed((value) => !value)}\n                    style={simpleBtnStyle}\n                    title={windowed ? 'Return to full-screen mode' : 'Switch to windowed mode'}\n                >\n                    {windowed ? 'Full screen' : 'Windowed'}\n                </button>\n                <button type=\"button\" onClick={() => setOpen(false)} style={simpleBtnStyle}>\n                    Close\n                </button>\n            </div>\n        </div>\n    )\n\n    const panelContent = (\n        <>\n            {header}\n\n            {activeTab === 'logics' ? (\n                <div style={{ display: 'flex', minHeight: 0, flex: 1 }}>\n                    {/* Left panel */}\n                    <div\n                        style={{\n                            width: 360,\n                            minWidth: 280,\n                            maxWidth: 480,\n                            borderRight: '1px solid rgba(0,0,0,0.08)',\n                            background: '#ffffff',\n                            display: 'flex',\n                            flexDirection: 'column',\n                        }}\n                    >\n                        <div style={{ display: 'flex', gap: 6, padding: 8 }}>\n                            <input\n                                type=\"search\"\n                                placeholder=\"Search logics…\"\n                                value={query || ''}\n                                onChange={(e) => setQuery(e.target.value)}\n                                style={inputStyle}\n                            />\n                            <select\n                                value={sortMode}\n                                onChange={(e) => setSortMode(e.target.value as SortMode)}\n                                style={inputStyle}\n                            >\n                                <option value=\"alpha\">A → Z</option>\n                                <option value=\"recent\">Recent</option>\n                            </select>\n                        </div>\n                        <div style={{ overflow: 'auto', padding: 6 }}>\n                            {visibleKeys.map((k) => {\n                                const logic = mounted[k]\n                                const active = selectedKey === k\n                                const name = displayName(logic)\n                                const size = logicSize(logic)\n                                const tint = Math.min(0.18, 0.04 + size * 0.01)\n                                return (\n                                    <button\n                                        key={k}\n                                        type=\"button\"\n                                        onClick={() => {\n                                            setSelectedKey(k)\n                                            recent.current.set(k, Date.now())\n                                        }}\n                                        title={k}\n                                        style={{\n                                            ...listItemStyle,\n                                            ...(active ? listItemActiveStyle : null),\n                                            background: active\n                                                ? `rgba(99,102,241,${tint + 0.08})`\n                                                : `rgba(99,102,241,${tint})`,\n                                        }}\n                                    >\n                                        <div style={{ fontWeight: 700, textAlign: 'left' }}>{name}</div>\n                                        <div\n                                            style={{\n                                                color: 'rgba(0,0,0,0.6)',\n                                                fontSize: 12,\n                                                textAlign: 'left',\n                                                whiteSpace: 'nowrap',\n                                                overflow: 'hidden',\n                                                textOverflow: 'ellipsis',\n                                            }}\n                                        >\n                                            {k}\n                                        </div>\n                                    </button>\n                                )\n                            })}\n                        </div>\n                    </div>\n\n                    {/* Right panel */}\n                    <div style={{ flex: 1, overflow: 'auto', padding: 12 }}>\n                        {selectedLogic ? (\n                            <div\n                                style={{\n                                    background: '#fff',\n                                    border: '1px solid rgba(0,0,0,0.06)',\n                                    borderRadius: 12,\n                                    boxShadow: '0 2px 10px rgba(0,0,0,0.08)',\n                                    padding: 12,\n                                }}\n                            >\n                                <div\n                                    style={{\n                                        display: 'flex',\n                                        alignItems: 'center',\n                                        gap: 8,\n                                        marginBottom: 6,\n                                    }}\n                                >\n                                    <div style={{ fontWeight: 800 }}>{(selectedLogic as any).pathString}</div>\n                                    <div style={{ marginLeft: 'auto' }} />\n                                    <button\n                                        type=\"button\"\n                                        onClick={() => {\n                                            setGraphHighlight((selectedLogic as any).pathString)\n                                            setActiveTab('graph')\n                                        }}\n                                        style={simpleBtnStyle}\n                                    >\n                                        Show on graph\n                                    </button>\n                                </div>\n\n                                {/* Key + Props */}\n                                <KeyAndProps logic={selectedLogic} />\n\n                                <Connections logic={selectedLogic} onOpen={(path) => setSelectedKey(path)} />\n                                <ReverseConnections\n                                    logic={selectedLogic}\n                                    mounted={mounted}\n                                    onOpen={(path) => setSelectedKey(path)}\n                                />\n                                <ActionsList logic={selectedLogic} />\n                                <Values logic={selectedLogic} />\n                            </div>\n                        ) : (\n                            <div style={{ color: 'rgba(0,0,0,0.6)' }}>Select a logic on the left.</div>\n                        )}\n                    </div>\n                </div>\n            ) : activeTab === 'actions' ? (\n                <ActionsTab\n                    actions={actions}\n                    paused={paused}\n                    onPauseToggle={() => setPaused((p) => !p)}\n                    onClear={() => setActions([])}\n                />\n            ) : activeTab === 'graph' ? (\n                <GraphTab\n                    mounted={mounted}\n                    onOpen={(path) => setSelectedKey(path)}\n                    highlightId={graphHighlight ?? undefined}\n                />\n            ) : activeTab === 'memory' ? (\n                <MemoryTab store={store} mounted={mounted} />\n            ) : (\n                <></>\n            )}\n        </>\n    )\n\n    return (\n        <>\n            {/* Floating button */}\n            <button\n                type=\"button\"\n                onClick={() => setOpen((o) => !o)}\n                aria-label=\"Open Kea Devtools\"\n                title=\"Kea Devtools\"\n                style={{\n                    position: 'fixed',\n                    left: offset,\n                    bottom: offset,\n                    width: buttonSize,\n                    height: buttonSize,\n                    borderRadius: buttonSize / 2,\n                    border: '1px solid rgba(0,0,0,0.1)',\n                    boxShadow: '0 6px 22px rgba(0,0,0,0.18)',\n                    background: '#fff',\n                    cursor: 'pointer',\n                    zIndex,\n                    fontSize: Math.max(18, Math.floor(buttonSize * 0.42)),\n                    lineHeight: 1,\n                }}\n            >\n                🦜\n            </button>\n\n            {open ? (\n                windowed ? (\n                    <div style={{ position: 'fixed', inset: 0, pointerEvents: 'none', zIndex }}>\n                        <div\n                            role=\"dialog\"\n                            aria-modal={false}\n                            style={{\n                                position: 'fixed',\n                                top: windowRect.top,\n                                left: windowRect.left,\n                                width: windowRect.width,\n                                height: windowRect.height,\n                                background: '#f7f8fa',\n                                border: '1px solid rgba(0,0,0,0.08)',\n                                borderRadius: 14,\n                                boxShadow: '0 10px 40px rgba(0,0,0,0.2)',\n                                overflow: 'hidden',\n                                display: 'flex',\n                                flexDirection: 'column',\n                                pointerEvents: 'auto',\n                                userSelect: dragState.current ? 'none' : undefined,\n                            }}\n                        >\n                            {panelContent}\n                            <div\n                                onMouseDown={onResizeMouseDown}\n                                aria-hidden={true}\n                                style={{\n                                    position: 'absolute',\n                                    right: 4,\n                                    bottom: 4,\n                                    width: 16,\n                                    height: 16,\n                                    cursor: 'nwse-resize',\n                                    borderRight: '2px solid rgba(0,0,0,0.2)',\n                                    borderBottom: '2px solid rgba(0,0,0,0.2)',\n                                }}\n                            />\n                        </div>\n                    </div>\n                ) : (\n                    <div\n                        role=\"dialog\"\n                        aria-modal\n                        style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.25)', zIndex }}\n                        onClick={() => setOpen(false)}\n                    >\n                        <div\n                            onClick={(e) => e.stopPropagation()}\n                            style={{\n                                position: 'absolute',\n                                right: offset,\n                                bottom: offset + buttonSize + 12,\n                                left: offset,\n                                top: offset,\n                                background: '#f7f8fa',\n                                border: '1px solid rgba(0,0,0,0.08)',\n                                borderRadius: 14,\n                                boxShadow: '0 10px 40px rgba(0,0,0,0.2)',\n                                overflow: 'hidden',\n                                display: 'flex',\n                                flexDirection: 'column',\n                                userSelect: dragState.current ? 'none' : undefined,\n                            }}\n                        >\n                            {panelContent}\n                        </div>\n                    </div>\n                )\n            ) : null}\n        </>\n    )\n}\n\n/* ---------- Actions tab ---------- */\n\nfunction ActionsTab({\n    actions,\n    paused,\n    onPauseToggle,\n    onClear,\n}: {\n    actions: ActionLogItem[]\n    paused: boolean\n    onPauseToggle: () => void\n    onClear: () => void\n}): JSX.Element {\n    const [q, setQ] = useState('')\n    const [expanded, setExpanded] = useState<Set<number>>(new Set())\n\n    // Debounce the search query for better performance\n    const debouncedQ = useDebounce(q, 300)\n\n    const filtered = useMemo(() => {\n        const s = debouncedQ.trim().toLowerCase()\n        if (!s) {\n            return actions\n        }\n        return actions.filter((a) => {\n            if (a.type.toLowerCase().includes(s)) {\n                return true\n            }\n            if (a.payloadSummary.toLowerCase().includes(s)) {\n                return true\n            }\n            if (a.stateDiffSummary.toLowerCase().includes(s)) {\n                return true\n            }\n            if (a.stateDiffText.toLowerCase().includes(s)) {\n                return true\n            }\n            return false\n        })\n    }, [actions, debouncedQ])\n\n    const toggleExpanded = (id: number): void => {\n        setExpanded((prev) => {\n            const next = new Set(prev)\n            if (next.has(id)) {\n                next.delete(id)\n            } else {\n                next.add(id)\n            }\n            return next\n        })\n    }\n\n    const handleExport = (): void => {\n        if (typeof window === 'undefined' || typeof document === 'undefined') {\n            return\n        }\n        let url: string | null = null\n        const link = document.createElement('a')\n        let appended = false\n        try {\n            const exportData = actions\n                .slice()\n                .reverse()\n                .map((item) => ({\n                    id: item.id,\n                    ts: item.ts,\n                    type: item.type,\n                    payload: item.payload,\n                    payloadSummary: item.payloadSummary,\n                    payloadText: item.payloadText,\n                    stateDiff: item.stateDiff,\n                    stateDiffSummary: item.stateDiffSummary,\n                    stateDiffText: item.stateDiffText,\n                    stateDiffTruncated: item.stateDiffTruncated,\n                }))\n\n            const json = JSON.stringify(exportData, null, 2)\n            if (!json) {\n                throw new Error('Failed to serialise actions')\n            }\n            const blob = new Blob([json], { type: 'application/json' })\n            url = URL.createObjectURL(blob)\n            link.href = url\n            const timestamp = new Date().toISOString().replace(/[:.]/g, '-')\n            link.download = `kea-actions-${timestamp}.json`\n            link.style.display = 'none'\n            document.body.appendChild(link)\n            appended = true\n            link.click()\n        } catch (error) {\n            // eslint-disable-next-line no-console\n            console.error('Failed to export actions', error)\n        } finally {\n            if (appended && link.parentNode) {\n                link.parentNode.removeChild(link)\n            }\n            if (url) {\n                URL.revokeObjectURL(url)\n            }\n        }\n    }\n\n    // Calculate dynamic row height based on whether payload is expanded\n    const getRowHeight = ({ index }: { index: number }): number => {\n        const action = filtered[index]\n        if (!action) {\n            return 110\n        }\n        const isOpen = expanded.has(action.id)\n        if (!isOpen) {\n            return 110\n        }\n        const payloadLines = Math.max(1, action.payloadText.split('\\n').length)\n        const diffLines = Math.max(1, action.stateDiffText.split('\\n').length)\n        const truncatedLines = action.stateDiffTruncated ? 1 : 0\n        return Math.min(110 + (payloadLines + diffLines + truncatedLines) * 18, 800)\n    }\n\n    // Row renderer for virtualized list\n    const renderRow = ({ index, key, style }: ListRowProps): JSX.Element => {\n        const action = filtered[index]\n        if (!action) {\n            return <div key={key} style={style} />\n        }\n\n        const isOpen = expanded.has(action.id)\n        const payloadContent = isOpen ? action.payloadText : action.payloadSummary\n        const stateDiffContent = isOpen ? action.stateDiffText : action.stateDiffSummary\n\n        return (\n            <div\n                key={key}\n                style={{\n                    ...style,\n                    display: 'flex',\n                    borderBottom: '1px solid rgba(0,0,0,0.05)',\n                    background: '#fff',\n                }}\n            >\n                <div\n                    style={{\n                        flex: '0 0 28%',\n                        padding: '10px 12px',\n                        borderRight: '1px solid rgba(0,0,0,0.06)',\n                        display: 'flex',\n                        flexDirection: 'column',\n                        gap: 6,\n                    }}\n                >\n                    <div>\n                        <code\n                            style={{\n                                fontWeight: 700,\n                                fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',\n                                wordBreak: 'break-word',\n                            }}\n                        >\n                            {action.type}\n                        </code>\n                    </div>\n                    <div\n                        style={{\n                            color: 'rgba(0,0,0,0.6)',\n                            fontSize: 12,\n                        }}\n                        title={new Date(action.ts).toISOString()}\n                    >\n                        {new Date(action.ts).toLocaleString()}\n                    </div>\n                </div>\n                <div\n                    style={{\n                        flex: '1 1 0',\n                        minWidth: 0,\n                        padding: '10px 12px',\n                        borderRight: '1px solid rgba(0,0,0,0.06)',\n                        display: 'flex',\n                        flexDirection: 'column',\n                        gap: 6,\n                    }}\n                >\n                    <div style={{ fontWeight: 600 }}>Payload</div>\n                    <div\n                        style={{\n                            whiteSpace: isOpen ? 'pre-wrap' : 'nowrap',\n                            overflow: isOpen ? 'auto' : 'hidden',\n                            textOverflow: isOpen ? 'clip' : 'ellipsis',\n                            wordBreak: isOpen ? 'break-word' : 'normal',\n                            fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',\n                        }}\n                    >\n                        {payloadContent}\n                    </div>\n                </div>\n                <div\n                    style={{\n                        flex: '1 1 0',\n                        minWidth: 0,\n                        padding: '10px 12px',\n                        borderRight: '1px solid rgba(0,0,0,0.06)',\n                        display: 'flex',\n                        flexDirection: 'column',\n                        gap: 6,\n                    }}\n                >\n                    <div style={{ fontWeight: 600 }}>State changes</div>\n                    <div\n                        style={{\n                            whiteSpace: isOpen ? 'pre-wrap' : 'nowrap',\n                            overflow: isOpen ? 'auto' : 'hidden',\n                            textOverflow: isOpen ? 'clip' : 'ellipsis',\n                            wordBreak: isOpen ? 'break-word' : 'normal',\n                            fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',\n                        }}\n                    >\n                        {stateDiffContent}\n                    </div>\n                    {isOpen && action.stateDiffTruncated ? (\n                        <div style={{ color: 'rgba(0,0,0,0.6)', fontSize: 12 }}>\n                            Showing first {action.stateDiff.length} changes (truncated).\n                        </div>\n                    ) : null}\n                </div>\n                <div\n                    style={{\n                        flex: '0 0 96px',\n                        padding: '10px 12px',\n                        display: 'flex',\n                        alignItems: 'flex-start',\n                        justifyContent: 'center',\n                    }}\n                >\n                    <button\n                        type=\"button\"\n                        onClick={() => toggleExpanded(action.id)}\n                        style={{ ...simpleBtnStyle, width: '100%' }}\n                        title={isOpen ? 'Collapse details' : 'Expand details'}\n                    >\n                        {isOpen ? 'Collapse' : 'Expand'}\n                    </button>\n                </div>\n            </div>\n        )\n    }\n\n    // Create a ref for the List to trigger re-render when expanded state changes\n    const listRef = useRef<List>(null)\n\n    // Force re-render of list when expanded state changes\n    useEffect(() => {\n        listRef.current?.recomputeRowHeights()\n    }, [expanded, filtered])\n\n    return (\n        <div style={{ display: 'flex', flexDirection: 'column', minHeight: 0, gap: 8, padding: 10, flex: 1 }}>\n            <div style={{ display: 'flex', gap: 6, flexWrap: 'wrap' }}>\n                <input\n                    type=\"search\"\n                    placeholder=\"Filter actions…\"\n                    value={q || ''}\n                    onChange={(e) => setQ(e.target.value)}\n                    style={inputStyle}\n                />\n                <button type=\"button\" onClick={onPauseToggle} style={simpleBtnStyle}>\n                    {paused ? 'Resume' : 'Pause'}\n                </button>\n                <button type=\"button\" onClick={onClear} style={simpleBtnStyle}>\n                    Clear\n                </button>\n                <button\n                    type=\"button\"\n                    onClick={handleExport}\n                    style={{\n                        ...exportBtnStyle,\n                        opacity: actions.length === 0 ? 0.6 : 1,\n                        cursor: actions.length === 0 ? 'not-allowed' : exportBtnStyle.cursor,\n                    }}\n                    disabled={actions.length === 0}\n                >\n                    Export JSON\n                </button>\n            </div>\n\n            <div\n                style={{\n                    flex: 1,\n                    background: '#fff',\n                    border: '1px solid rgba(0,0,0,0.06)',\n                    borderRadius: 12,\n                    position: 'relative',\n                }}\n            >\n                {/* Header */}\n                <div\n                    style={{\n                        display: 'flex',\n                        position: 'sticky',\n                        top: 0,\n                        background: '#fafafa',\n                        borderBottom: '1px solid rgba(0,0,0,0.06)',\n                        zIndex: 1,\n                    }}\n                >\n                    <div\n                        style={{\n                            flex: '0 0 28%',\n                            padding: '10px 12px',\n                            fontWeight: 700,\n                            borderRight: '1px solid rgba(0,0,0,0.06)',\n                        }}\n                    >\n                        Action • Date\n                    </div>\n                    <div\n                        style={{\n                            flex: '1 1 0',\n                            padding: '10px 12px',\n                            fontWeight: 700,\n                            borderRight: '1px solid rgba(0,0,0,0.06)',\n                        }}\n                    >\n                        Payload\n                    </div>\n                    <div\n                        style={{\n                            flex: '1 1 0',\n                            padding: '10px 12px',\n                            fontWeight: 700,\n                            borderRight: '1px solid rgba(0,0,0,0.06)',\n                        }}\n                    >\n                        State changes\n                    </div>\n                    <div\n                        style={{\n                            flex: '0 0 96px',\n                            padding: '10px 12px',\n                            fontWeight: 700,\n                            textAlign: 'center',\n                        }}\n                    >\n                        Details\n                    </div>\n                </div>\n\n                {/* Content */}\n                <div style={{ height: 'calc(100% - 41px)' }}>\n                    {filtered.length === 0 ? (\n                        <div style={{ padding: 12, color: 'rgba(0,0,0,0.6)' }}>No actions yet.</div>\n                    ) : (\n                        <AutoSizer>\n                            {({ height, width }) => (\n                                <List\n                                    ref={listRef}\n                                    width={width}\n                                    height={height}\n                                    rowCount={filtered.length}\n                                    rowHeight={getRowHeight}\n                                    rowRenderer={renderRow}\n                                    overscanRowCount={10}\n                                />\n                            )}\n                        </AutoSizer>\n                    )}\n                </div>\n            </div>\n        </div>\n    )\n}\n\n/* ---------- styles ---------- */\n\nconst inputStyle: React.CSSProperties = {\n    flex: 1,\n    border: '1px solid rgba(0,0,0,0.12)',\n    background: '#fff',\n    padding: '6px 8px',\n    borderRadius: 8,\n    outline: 'none',\n}\n\nconst simpleBtnStyle: React.CSSProperties = {\n    border: '1px solid rgba(0,0,0,0.12)',\n    background: '#fff',\n    padding: '6px 10px',\n    borderRadius: 8,\n    cursor: 'pointer',\n}\n\nconst exportBtnStyle: React.CSSProperties = {\n    ...simpleBtnStyle,\n    fontWeight: 700,\n    padding: '6px 16px',\n    background: '#eef2ff',\n    borderColor: 'rgba(99,102,241,0.4)',\n}\n\nfunction tabBtnStyle(active: boolean): React.CSSProperties {\n    return {\n        ...simpleBtnStyle,\n        fontWeight: active ? 700 : 500,\n        background: active ? '#eef2ff' : '#fff',\n        borderColor: active ? 'rgba(0,0,0,0.18)' : 'rgba(0,0,0,0.12)',\n    }\n}\n\nconst listItemStyle: React.CSSProperties = {\n    width: '100%',\n    textAlign: 'left',\n    padding: 10,\n    border: '1px solid rgba(0,0,0,0.08)',\n    borderRadius: 10,\n    boxShadow: '0 1px 6px rgba(0,0,0,0.05)',\n    marginBottom: 8,\n    cursor: 'pointer',\n    transition: 'background 120ms ease',\n}\n\nconst listItemActiveStyle: React.CSSProperties = {\n    borderColor: 'rgba(99,102,241,0.6)',\n    boxShadow: '0 2px 10px rgba(99,102,241,0.18)',\n}\n\nconst pill: React.CSSProperties = {\n    border: '1px solid rgba(0,0,0,0.12)',\n    background: '#fff',\n    padding: '6px 8px',\n    borderRadius: 999,\n    cursor: 'pointer',\n    fontSize: 12,\n}\n","import { actions, connect, kea, listeners, path, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { encodeParams, urlToAction } from 'kea-router'\nimport { router } from 'kea-router'\n\nimport api from 'lib/api'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { getRelativeNextPath } from 'lib/utils'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { urls } from 'scenes/urls'\n\nimport { SSOProvider } from '~/types'\n\nimport type { loginLogicType } from './loginLogicType'\n\nexport interface AuthenticateResponseType {\n    success: boolean\n    errorCode?: string\n    errorDetail?: string\n}\n\nexport interface PrecheckResponseType {\n    sso_enforcement?: SSOProvider | null\n    saml_available: boolean\n    status: 'pending' | 'completed'\n}\n\nexport function handleLoginRedirect(): void {\n    let nextURL = '/'\n    try {\n        const nextPath = getRelativeNextPath(router.values.searchParams['next'], location) || '/'\n\n        const url = new URL(location.origin + nextPath)\n        if (url.protocol === 'http:' || url.protocol === 'https:') {\n            // Note that the hash MUST be handled client-side because /login?next= is generated by the server-side\n            // `login_required()` decorator, and hash params never make it to the server\n            nextURL = url.pathname + url.search + encodeParams(router.values.hashParams, '#')\n        }\n    } catch {\n        // do nothing\n    }\n    // A safe way to redirect to a user input URL. Calls history.replaceState() ensuring the URLs origin does not change\n    router.actions.replace(nextURL)\n}\n\nexport interface LoginForm {\n    email: string\n    password: string\n}\n\nexport interface TwoFactorForm {\n    token: number | null\n}\n\nexport const loginLogic = kea<loginLogicType>([\n    path(['scenes', 'authentication', 'loginLogic']),\n    connect(() => ({\n        values: [preflightLogic, ['preflight'], featureFlagLogic, ['featureFlags']],\n    })),\n    actions({\n        setGeneralError: (code: string, detail: string) => ({ code, detail }),\n        clearGeneralError: true,\n    }),\n    reducers({\n        // This is separate from the login form, so that the form can be submitted even if a general error is present\n        generalError: [\n            null as { code: string; detail: string } | null,\n            {\n                setGeneralError: (_, error) => error,\n                clearGeneralError: () => null,\n            },\n        ],\n    }),\n    loaders(() => ({\n        precheckResponse: [\n            { status: 'pending' } as PrecheckResponseType,\n            {\n                precheck: async (\n                    {\n                        email,\n                    }: {\n                        email: string\n                    },\n                    breakpoint\n                ) => {\n                    if (!email) {\n                        return { status: 'pending' }\n                    }\n\n                    breakpoint()\n                    const response = await api.create<any>('api/login/precheck', { email })\n                    return { status: 'completed', ...response }\n                },\n            },\n        ],\n        resendResponse: [\n            null as { success: boolean; message: string } | null,\n            {\n                resendEmailMFA: async (_, breakpoint) => {\n                    breakpoint()\n                    try {\n                        const response = await api.create<any>('api/login/email-mfa/resend')\n                        lemonToast.success('Verification email resent')\n                        return response\n                    } catch (e) {\n                        const { code, detail } = e as Record<string, any>\n                        if (code === 'too_soon') {\n                            lemonToast.error(detail || 'Please wait before requesting another email')\n                        } else {\n                            lemonToast.error(detail || 'Failed to resend email')\n                        }\n                        return null\n                    }\n                },\n            },\n        ],\n    })),\n    selectors(() => ({\n        signupUrl: [\n            () => [router.selectors.searchParams],\n            (searchParams: Record<string, string>) => {\n                const nextParam = getRelativeNextPath(searchParams['next'], location)\n                return nextParam ? `/signup?next=${encodeURIComponent(nextParam)}` : '/signup'\n            },\n        ],\n    })),\n    forms(({ actions, values }) => ({\n        login: {\n            defaults: { email: '', password: '' } as LoginForm,\n            errors: ({ email, password }) => ({\n                email: !email ? 'Please enter your email to continue' : undefined,\n                password: !password ? 'Please enter your password to continue' : undefined,\n            }),\n            submit: async ({ email, password }, breakpoint) => {\n                breakpoint()\n                try {\n                    return await api.create<any>('api/login', { email, password })\n                } catch (e) {\n                    const { code, detail } = e as Record<string, any>\n                    if (code === '2fa_required') {\n                        router.actions.push(urls.login2FA())\n                        throw e\n                    }\n                    if (code === 'email_mfa_required') {\n                        const emailAddress = detail?.email || email\n                        actions.setGeneralError(\n                            'email_verification_sent',\n                            `For your security, we've sent a verification link to ${emailAddress}. Please check your inbox and click the link to complete\n  your login.`\n                        )\n                        throw e\n                    }\n                    let errorDetail = detail\n                    if (code === 'invalid_credentials' && values.preflight?.cloud) {\n                        errorDetail = detail + ' Make sure you have selected the right data region.'\n                    }\n                    actions.setGeneralError(code, errorDetail)\n                    throw e\n                }\n            },\n        },\n    })),\n    listeners({\n        submitLoginSuccess: () => {\n            handleLoginRedirect()\n            // Reload the page after login to ensure POSTHOG_APP_CONTEXT is set correctly.\n            window.location.reload()\n        },\n    }),\n    urlToAction(({ actions }) => ({\n        '/login': (_, { error_code, error_detail, email, message }) => {\n            if (error_code) {\n                actions.setGeneralError(error_code, error_detail)\n                router.actions.replace('/login', {})\n            }\n\n            if (message) {\n                lemonToast.info(message)\n                const { message: _, ...otherParams } = router.values.searchParams\n                router.actions.replace('/login', otherParams)\n            }\n\n            // This allows us to give a quick login link in the `generate_demo_data` command\n            if (email) {\n                actions.setLoginValue('email', email)\n                actions.precheck({ email })\n            }\n        },\n    })),\n])\n","import { actions, connect, kea, listeners, path, reducers, selectors } from 'kea'\nimport { FieldNamePath, capitalizeFirstLetter, forms } from 'kea-forms'\nimport { lazyLoaders } from 'kea-loaders'\nimport { router, urlToAction } from 'kea-router'\nimport posthog from 'posthog-js'\n\nimport { LemonDialog, Link, lemonToast } from '@posthog/lemon-ui'\n\nimport api, { getJSONOrNull } from 'lib/api'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { dayjs } from 'lib/dayjs'\nimport { LemonBannerAction } from 'lib/lemon-ui/LemonBanner/LemonBanner'\nimport { lemonBannerLogic } from 'lib/lemon-ui/LemonBanner/lemonBannerLogic'\nimport { LemonButtonPropsBase } from 'lib/lemon-ui/LemonButton'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { pluralize } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { organizationLogic } from 'scenes/organizationLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport {\n    BillingPeriod,\n    BillingPlan,\n    BillingPlanType,\n    BillingProductV2AddonType,\n    BillingProductV2Type,\n    BillingType,\n    ProductKey,\n    StartupProgramLabel,\n} from '~/types'\n\nimport { DEFAULT_ESTIMATED_MONTHLY_CREDIT_AMOUNT_USD } from './CreditCTAHero'\nimport type { billingLogicType } from './billingLogicType'\n\nexport const ALLOCATION_THRESHOLD_ALERT = 0.85 // Threshold to show warning of event usage near limit\nexport const ALLOCATION_THRESHOLD_BLOCK = 1.2 // Threshold to block usage\n\nconst BILLING_ALERT_DISMISS_PREFIX = 'scenes.billing.billingLogic.billingAlertDismissed.'\n\nexport interface BillingAlertConfig {\n    status: 'info' | 'warning' | 'error'\n    title: string\n    message?: string\n    contactSupport?: boolean\n    buttonCTA?: string\n    dismissKey?: string\n    action?: LemonBannerAction\n    pathName?: string\n    onClose?: () => void\n}\n\nexport enum BillingAPIErrorCodes {\n    OPEN_INVOICES_ERROR = 'open_invoices_error',\n    NO_ACTIVE_PAYMENT_METHOD_ERROR = 'no_active_payment_method_error',\n    COULD_NOT_PAY_INVOICES_ERROR = 'could_not_pay_invoices_error',\n}\n\nexport interface UnsubscribeError {\n    detail: string | JSX.Element\n    link: JSX.Element\n}\n\nexport interface BillingError {\n    status: 'info' | 'warning' | 'error'\n    message: string\n    action: LemonButtonPropsBase\n}\n\nexport type SwitchPlanPayload = {\n    from_product_key: string\n    from_plan_key: string\n    to_product_key: string\n    to_plan_key: string\n}\n\nconst parseBillingResponse = (data: Partial<BillingType>): BillingType => {\n    if (data.billing_period) {\n        data.billing_period = {\n            current_period_start: dayjs(data.billing_period.current_period_start),\n            current_period_end: dayjs(data.billing_period.current_period_end),\n            interval: data.billing_period.interval,\n        }\n    }\n\n    data.free_trial_until = data.free_trial_until ? dayjs(data.free_trial_until) : undefined\n    data.amount_off_expires_at = data.amount_off_expires_at ? dayjs(data.amount_off_expires_at) : undefined\n    // If expiration is in the middle of the current period, we let it expire at the end of the period\n    if (\n        data.amount_off_expires_at &&\n        data.billing_period &&\n        data.amount_off_expires_at.isBefore(data.billing_period.current_period_end) &&\n        data.amount_off_expires_at.isAfter(data.billing_period.current_period_start)\n    ) {\n        data.amount_off_expires_at = data.billing_period.current_period_end\n    }\n\n    return data as BillingType\n}\n\nconst storeBillingAlertDismissal = (\n    organizationId: string | undefined,\n    productType: string,\n    billingPeriodEnd: string | null | undefined,\n    suffix: string = ''\n): void => {\n    if (billingPeriodEnd && organizationId) {\n        try {\n            const dismissKey = `${BILLING_ALERT_DISMISS_PREFIX}${organizationId}.${productType}${suffix}`\n            localStorage.setItem(dismissKey, billingPeriodEnd)\n        } catch (error) {\n            // localStorage not available, continue without storing\n            console.warn('localStorage not available for billing alert dismissal:', error)\n        }\n    }\n}\n\nconst isBillingAlertDismissed = (\n    organizationId: string | undefined,\n    productType: string,\n    billingPeriodEnd: string | null | undefined,\n    suffix: string = ''\n): boolean => {\n    if (!billingPeriodEnd || !organizationId) {\n        return false\n    }\n\n    try {\n        const dismissKey = `${BILLING_ALERT_DISMISS_PREFIX}${organizationId}.${productType}${suffix}`\n        const dismissedData = localStorage.getItem(dismissKey)\n\n        if (dismissedData) {\n            // If the stored billing period end is different from current, remove the key and show the alert\n            if (dismissedData !== billingPeriodEnd) {\n                localStorage.removeItem(dismissKey)\n                return false\n            }\n            // Alert was dismissed for this period, don't show it\n            return true\n        }\n        return false\n    } catch (error) {\n        // localStorage not available, continue to show alert\n        console.warn('localStorage not available for billing alert dismissal:', error)\n        return false\n    }\n}\n\nexport const billingLogic = kea<billingLogicType>([\n    path(['scenes', 'billing', 'billingLogic']),\n    actions({\n        setProductSpecificAlert: (productSpecificAlert: BillingAlertConfig | null) => ({ productSpecificAlert }),\n        setScrollToProductKey: (scrollToProductKey: ProductKey | null) => ({ scrollToProductKey }),\n        setShowLicenseDirectInput: (show: boolean) => ({ show }),\n        reportBillingAlertShown: (alertConfig: BillingAlertConfig) => ({ alertConfig }),\n        reportBillingAlertActionClicked: (alertConfig: BillingAlertConfig) => ({ alertConfig }),\n        reportCreditsFormSubmitted: (creditInput: number) => ({ creditInput }),\n        reportCreditsModalShown: true,\n        reportBillingShown: true,\n        registerInstrumentationProps: true,\n        reportCreditsCTAShown: (creditOverview: any) => ({ creditOverview }),\n        setRedirectPath: (redirectPath: string) => ({ redirectPath }),\n        setIsOnboarding: (isOnboarding: boolean) => ({ isOnboarding }),\n        determineBillingAlert: true,\n        setUnsubscribeError: (error: null | UnsubscribeError) => ({ error }),\n        resetUnsubscribeError: true,\n        setBillingAlert: (billingAlert: BillingAlertConfig | null) => ({ billingAlert }),\n        showPurchaseCreditsModal: (isOpen: boolean) => ({ isOpen }),\n        toggleCreditCTAHeroDismissed: (isDismissed: boolean) => ({ isDismissed }),\n        setComputedDiscount: (discount: number) => ({ discount }),\n        setCreditBrackets: (creditBrackets: any[]) => ({ creditBrackets }),\n        scrollToProduct: (productType: string) => ({ productType }),\n        setSwitchPlanLoading: (productKey: string | null) => ({ productKey }),\n    }),\n    connect(() => ({\n        values: [\n            featureFlagLogic,\n            ['featureFlags'],\n            preflightLogic,\n            ['preflight'],\n            organizationLogic,\n            ['currentOrganization'],\n        ],\n        actions: [\n            userLogic,\n            ['loadUser'],\n            organizationLogic,\n            ['loadCurrentOrganization'],\n            eventUsageLogic,\n            ['reportProductUnsubscribed'],\n            lemonBannerLogic({ dismissKey: 'usage-limit-exceeded' }),\n            ['resetDismissKey as resetUsageLimitExceededKey'],\n            lemonBannerLogic({ dismissKey: 'usage-limit-approaching' }),\n            ['resetDismissKey as resetUsageLimitApproachingKey'],\n        ],\n    })),\n    reducers({\n        billingAlert: [\n            null as BillingAlertConfig | null,\n            {\n                setBillingAlert: (_, { billingAlert }) => billingAlert,\n            },\n        ],\n        scrollToProductKey: [\n            null as ProductKey | null,\n            {\n                setScrollToProductKey: (_, { scrollToProductKey }) => scrollToProductKey,\n            },\n        ],\n        productSpecificAlert: [\n            null as BillingAlertConfig | null,\n            {\n                setProductSpecificAlert: (_, { productSpecificAlert }) => productSpecificAlert,\n            },\n        ],\n        showLicenseDirectInput: [\n            false,\n            {\n                setShowLicenseDirectInput: (_, { show }) => show,\n            },\n        ],\n        redirectPath: [\n            '' as string,\n            {\n                setRedirectPath: (_, { redirectPath }) => redirectPath,\n            },\n        ],\n        isOnboarding: [\n            false,\n            {\n                setIsOnboarding: (_, { isOnboarding }) => isOnboarding,\n            },\n        ],\n        unsubscribeError: [\n            null as null | UnsubscribeError,\n            {\n                resetUnsubscribeError: () => null,\n                setUnsubscribeError: (_, { error }) => error,\n            },\n        ],\n        timeRemainingInSeconds: [\n            0,\n            {\n                loadBillingSuccess: (_, { billing }) => {\n                    if (!billing?.billing_period) {\n                        return 0\n                    }\n                    const currentTime = dayjs()\n                    const periodEnd = dayjs(billing.billing_period.current_period_end)\n                    return periodEnd.diff(currentTime, 'second')\n                },\n            },\n        ],\n        timeTotalInSeconds: [\n            0,\n            {\n                loadBillingSuccess: (_, { billing }) => {\n                    if (!billing?.billing_period) {\n                        return 0\n                    }\n                    const periodStart = dayjs(billing.billing_period.current_period_start)\n                    const periodEnd = dayjs(billing.billing_period.current_period_end)\n                    return periodEnd.diff(periodStart, 'second')\n                },\n            },\n        ],\n        isPurchaseCreditsModalOpen: [\n            false,\n            {\n                showPurchaseCreditsModal: (_, { isOpen }) => isOpen,\n            },\n        ],\n        isCreditCTAHeroDismissed: [\n            false,\n            { persist: true },\n            {\n                toggleCreditCTAHeroDismissed: (_, { isDismissed }) => isDismissed,\n            },\n        ],\n        computedDiscount: [\n            null as number | null,\n            {\n                setComputedDiscount: (_, { discount }) => discount,\n            },\n        ],\n        creditBrackets: [\n            [],\n            {\n                setCreditBrackets: (_, { creditBrackets }) => creditBrackets || [],\n            },\n        ],\n        switchPlanLoading: [\n            null as string | null,\n            {\n                setSwitchPlanLoading: (_, { productKey }) => productKey,\n            },\n        ],\n    }),\n    lazyLoaders(({ actions, values }) => ({\n        billing: [\n            null as BillingType | null,\n            {\n                loadBilling: async () => {\n                    // Note: this is a temporary flag to skip forecasting in the billing page\n                    // for customers running into performance issues until we have a more permanent fix\n                    // of splitting the billing and forecasting data.\n                    const skipForecasting = values.featureFlags[FEATURE_FLAGS.BILLING_SKIP_FORECASTING]\n                    const response = await api.get(\n                        'api/billing' + (skipForecasting ? '?include_forecasting=false' : '')\n                    )\n\n                    return parseBillingResponse(response)\n                },\n\n                updateBillingLimits: async (limits: { [key: string]: number | null }) => {\n                    try {\n                        const response = await api.update('api/billing', { custom_limits_usd: limits })\n                        lemonToast.success('Billing limits updated')\n                        actions.loadBilling()\n                        return parseBillingResponse(response)\n                    } catch (error: any) {\n                        lemonToast.error(\n                            'There was an error updating your billing limits. Please try again or contact support.'\n                        )\n                        throw error\n                    }\n                },\n\n                deactivateProduct: async (key: string, breakpoint) => {\n                    // clear upgrade params from URL\n                    // Note(@zach): This is not working properly. We need to look into this.\n                    const currentURL = new URL(window.location.href)\n                    currentURL.searchParams.delete('upgraded')\n                    currentURL.searchParams.delete('products')\n                    router.actions.push(currentURL.pathname + currentURL.search)\n\n                    actions.resetUnsubscribeError()\n                    try {\n                        const response = await api.getResponse('api/billing/deactivate?products=' + key)\n                        const jsonRes = await getJSONOrNull(response)\n\n                        lemonToast.success(\n                            \"You have been unsubscribed. We're sad to see you go. May the hedgehogs be ever in your favor.\"\n                        )\n                        actions.reportProductUnsubscribed(key)\n\n                        // Reload billing, user, and organization to get the updated available features\n                        actions.loadBilling()\n                        await breakpoint(2000) // Wait enough time for the organization to be updated\n                        actions.loadUser()\n                        actions.loadCurrentOrganization()\n\n                        return parseBillingResponse(jsonRes)\n                    } catch (error: any) {\n                        if (error.code) {\n                            if (error.code === BillingAPIErrorCodes.OPEN_INVOICES_ERROR) {\n                                actions.setUnsubscribeError({\n                                    detail: error.detail,\n                                    link: (\n                                        <Link to={values.billing?.stripe_portal_url} target=\"_blank\">\n                                            View invoices\n                                        </Link>\n                                    ),\n                                } as UnsubscribeError)\n                            } else if (error.code === BillingAPIErrorCodes.NO_ACTIVE_PAYMENT_METHOD_ERROR) {\n                                actions.setUnsubscribeError({\n                                    detail: error.detail,\n                                } as UnsubscribeError)\n                            } else if (error.code === BillingAPIErrorCodes.COULD_NOT_PAY_INVOICES_ERROR) {\n                                actions.setUnsubscribeError({\n                                    detail: error.detail,\n                                    link: (\n                                        <Link to={error.link || values.billing?.stripe_portal_url} target=\"_blank\">\n                                            {error.link ? 'View invoice' : 'View invoices'}\n                                        </Link>\n                                    ),\n                                } as UnsubscribeError)\n                            }\n                        } else {\n                            actions.setUnsubscribeError({\n                                detail:\n                                    typeof error.detail === 'string'\n                                        ? error.detail\n                                        : `We encountered a problem. Please try again or submit a support ticket.`,\n                            } as UnsubscribeError)\n                        }\n                        console.error(error)\n                        // This is a bit of a hack to prevent the page from re-rendering.\n                        return values.billing\n                    }\n                },\n                switchFlatrateSubscriptionPlan: async (data: SwitchPlanPayload, breakpoint) => {\n                    try {\n                        await api.create('api/billing/subscription/switch-plan', data)\n\n                        const productDisplayName = capitalizeFirstLetter(data.to_product_key)\n                        lemonToast.success(`You're now on ${productDisplayName}`)\n                        actions.setSwitchPlanLoading(null)\n\n                        // Reload billing, user, and organization to get the updated available features\n                        actions.loadBilling()\n                        await breakpoint(2000)\n                        actions.loadUser()\n                        actions.loadCurrentOrganization()\n\n                        return values.billing as BillingType\n                    } catch (error: any) {\n                        posthog.captureException(error)\n                        lemonToast.error(\n                            (error && error.detail) ||\n                                'There was an error switching your plan. Please try again or contact support.'\n                        )\n                        actions.setSwitchPlanLoading(null)\n                        // Keep the current billing state on failure\n                        return values.billing as BillingType\n                    }\n                },\n            },\n        ],\n        billingError: [\n            null as BillingError | null,\n            {\n                loadInvoices: async () => {\n                    // First check to see if there are open invoices\n                    try {\n                        const res = await api.getResponse('api/billing/get_invoices?status=open')\n                        const jsonRes = await getJSONOrNull(res)\n                        const numOpenInvoices = jsonRes['count']\n                        if (numOpenInvoices > 0) {\n                            const viewInvoicesButton = {\n                                to:\n                                    numOpenInvoices == 1 && jsonRes['link']\n                                        ? jsonRes['link']\n                                        : values.billing?.stripe_portal_url,\n                                children: `View invoice${numOpenInvoices > 1 ? 's' : ''}`,\n                                targetBlank: true,\n                            }\n                            return {\n                                status: 'warning',\n                                message: `You have ${numOpenInvoices} open invoice${\n                                    numOpenInvoices > 1 ? 's' : ''\n                                }. Please pay ${\n                                    numOpenInvoices > 1 ? 'them' : 'it'\n                                } before adding items to your subscription.`,\n                                action: viewInvoicesButton,\n                            }\n                        }\n                    } catch (error: any) {\n                        console.error(error)\n                    }\n                    return null\n                },\n            },\n        ],\n        creditOverview: [\n            {\n                eligible: false,\n                estimated_monthly_credit_amount_usd: null,\n                status: 'none',\n                invoice_url: null,\n                collection_method: null,\n                cc_last_four: null,\n                email: null,\n                credit_brackets: [],\n            },\n            {\n                loadCreditOverview: async () => {\n                    // Check if the user is subscribed\n                    if (values.billing?.has_active_subscription) {\n                        const response = await api.get('api/billing/credits/overview')\n\n                        if (!values.creditForm.creditInput) {\n                            let spend = DEFAULT_ESTIMATED_MONTHLY_CREDIT_AMOUNT_USD\n\n                            if (response.estimated_monthly_credit_amount_usd !== null) {\n                                spend = response.estimated_monthly_credit_amount_usd\n                            }\n\n                            actions.setCreditBrackets(response.credit_brackets)\n                            actions.setCreditFormValue('creditInput', Math.round(spend * 12))\n                        }\n\n                        if (response.eligible && response.status === 'none') {\n                            actions.reportCreditsCTAShown(response)\n                        }\n\n                        return response\n                    }\n                    // Return default values if not subscribed\n                    return {\n                        eligible: false,\n                        estimated_monthly_credit_amount_usd: null,\n                        status: 'none',\n                        invoice_url: null,\n                        collection_method: null,\n                        cc_last_four: null,\n                        email: null,\n                        credit_brackets: [],\n                    }\n                },\n            },\n        ],\n        products: [\n            [] as BillingProductV2Type[],\n            {\n                loadProducts: async () => {\n                    const response = await api.get('api/billing/available_products')\n                    return response\n                },\n            },\n        ],\n    })),\n    selectors({\n        upgradeLink: [(s) => [s.preflight], (): string => '/organization/billing'],\n        isUnlicensedDebug: [\n            (s) => [s.preflight, s.billing],\n            (preflight, billing): boolean => !!preflight?.is_debug && !billing?.billing_period,\n        ],\n        supportPlans: [\n            (s) => [s.billing],\n            (billing: BillingType): BillingPlanType[] => {\n                const platformAndSupportProduct = billing?.products?.find(\n                    (product) => product.type == ProductKey.PLATFORM_AND_SUPPORT\n                )\n                if (!platformAndSupportProduct?.plans) {\n                    return []\n                }\n\n                const addonPlans = platformAndSupportProduct?.addons?.map((addon) => addon.plans).flat()\n                const insertionIndex = Math.max(0, (platformAndSupportProduct?.plans?.length ?? 1) - 1)\n                const allPlans = platformAndSupportProduct?.plans?.slice(0) || []\n                allPlans.splice(insertionIndex, 0, ...addonPlans)\n                return allPlans\n            },\n        ],\n        hasSupportAddonPlan: [\n            (s) => [s.billing],\n            (billing: BillingType): boolean => {\n                return !!billing?.products\n                    ?.find((product) => product.type == ProductKey.PLATFORM_AND_SUPPORT)\n                    ?.addons.find((addon) => addon.plans.find((plan) => plan.current_plan))\n            },\n        ],\n        platformAddons: [\n            (s) => [s.billing],\n            (billing: BillingType): BillingProductV2AddonType[] => {\n                const platformProduct = billing?.products?.find(\n                    (product: BillingProductV2Type) => product.type === ProductKey.PLATFORM_AND_SUPPORT\n                )\n                return platformProduct?.addons ?? []\n            },\n        ],\n        currentPlatformAddon: [\n            (s) => [s.billing],\n            (billing: BillingType): BillingProductV2AddonType | null => {\n                const platformProduct = billing?.products?.find(\n                    (product: BillingProductV2Type) => product.type === ProductKey.PLATFORM_AND_SUPPORT\n                )\n                return platformProduct?.addons?.find((addon: BillingProductV2AddonType) => !!addon.subscribed) || null\n            },\n        ],\n        unusedPlatformAddonAmount: [\n            (s) => [s.currentPlatformAddon, s.timeRemainingInSeconds, s.timeTotalInSeconds],\n            (\n                currentPlatformAddon: BillingProductV2AddonType | null,\n                timeRemainingInSeconds: number,\n                timeTotalInSeconds: number\n            ): number => {\n                if (!currentPlatformAddon || !timeTotalInSeconds) {\n                    return 0\n                }\n                const unitAmount = parseFloat(currentPlatformAddon.current_amount_usd || '0')\n                const ratio = Math.max(0, Math.min(1, timeRemainingInSeconds / timeTotalInSeconds))\n                const amount = unitAmount * ratio\n                return Math.round(amount * 100) / 100\n            },\n        ],\n        creditDiscount: [(s) => [s.computedDiscount], (computedDiscount) => computedDiscount || 0],\n        billingPlan: [\n            (s) => [s.billing],\n            (billing: BillingType | null): BillingPlan | null => billing?.billing_plan || null,\n        ],\n        startupProgramLabelCurrent: [\n            (s) => [s.billing],\n            (billing: BillingType | null): StartupProgramLabel | null => billing?.startup_program_label || null,\n        ],\n        startupProgramLabelPrevious: [\n            (s) => [s.billing],\n            (billing: BillingType | null): StartupProgramLabel | null =>\n                billing?.startup_program_label_previous || null,\n        ],\n        isAnnualPlanCustomer: [\n            (s) => [s.billing],\n            (billing: BillingType | null): boolean => billing?.is_annual_plan_customer || false,\n        ],\n        billingPeriodUTC: [\n            (s) => [s.billing],\n            (billing: BillingType | null): BillingPeriod => ({\n                start: billing?.billing_period?.current_period_start?.utc() || null,\n                end: billing?.billing_period?.current_period_end?.utc() || null,\n                interval: billing?.billing_period?.interval || null,\n            }),\n        ],\n        showBillingSummary: [\n            (s) => [s.billing, s.isOnboarding],\n            (billing: BillingType | null, isOnboarding: boolean): boolean => {\n                return !isOnboarding && !!billing?.billing_period\n            },\n        ],\n        showCreditCTAHero: [\n            (s) => [s.creditOverview, s.featureFlags],\n            (creditOverview, featureFlags): boolean => {\n                const isEligible = creditOverview.eligible || !!featureFlags[FEATURE_FLAGS.SELF_SERVE_CREDIT_OVERRIDE]\n                return isEligible && creditOverview.status !== 'paid'\n            },\n        ],\n        showBillingHero: [\n            (s) => [s.billing, s.billingPlan, s.showCreditCTAHero],\n            (billing: BillingType | null, billingPlan: BillingPlan | null, showCreditCTAHero: boolean): boolean => {\n                const platformAndSupportProduct = billing?.products?.find(\n                    (product) => product.type === ProductKey.PLATFORM_AND_SUPPORT\n                )\n                return !!billingPlan && !!platformAndSupportProduct && !showCreditCTAHero\n            },\n        ],\n        isManagedAccount: [\n            (s) => [s.billing],\n            (billing: BillingType): boolean => {\n                return !!(billing?.account_owner?.name || billing?.account_owner?.email)\n            },\n        ],\n        accountOwner: [\n            (s) => [s.billing],\n            (billing: BillingType): { name?: string; email?: string } | null => billing?.account_owner || null,\n        ],\n        estimatedMonthlyCreditAmountUsd: [\n            (s) => [s.creditOverview],\n            (creditOverview): number | null => {\n                if (creditOverview === null) {\n                    return null\n                }\n\n                if (\n                    creditOverview.estimated_monthly_credit_amount_usd === null ||\n                    creditOverview.estimated_monthly_credit_amount_usd === undefined\n                ) {\n                    return DEFAULT_ESTIMATED_MONTHLY_CREDIT_AMOUNT_USD\n                }\n\n                return creditOverview.estimated_monthly_credit_amount_usd\n            },\n        ],\n    }),\n    forms(({ actions, values }) => ({\n        activateLicense: {\n            defaults: { license: '' } as { license: string },\n            errors: ({ license }) => ({\n                license: !license ? 'Please enter your license key' : undefined,\n            }),\n            submit: async ({ license }, breakpoint) => {\n                await breakpoint(500)\n                try {\n                    await api.update('api/billing/license', {\n                        license,\n                    })\n\n                    // Reset the URL so we don't trigger the license submission again\n                    router.actions.replace(\n                        `/${values.isOnboarding ? 'ingestion' : 'organization'}/billing?success=true`\n                    )\n                    setTimeout(() => {\n                        window.location.reload() // Permissions, projects etc will be out of date at this point, so refresh\n                    }, 100)\n                } catch (e: any) {\n                    actions.setActivateLicenseManualErrors({\n                        license: e.detail || 'License could not be activated. Please contact support.',\n                    })\n                    throw e\n                }\n            },\n        },\n        creditForm: {\n            defaults: {\n                creditInput: '',\n                collectionMethod: 'charge_automatically',\n            },\n            submit: async ({ creditInput, collectionMethod }) => {\n                await api.create('api/billing/credits/purchase', {\n                    annual_credit_amount_usd: +creditInput,\n                    collection_method: collectionMethod,\n                })\n\n                actions.showPurchaseCreditsModal(false)\n                actions.loadCreditOverview()\n                actions.reportCreditsFormSubmitted(+creditInput)\n\n                LemonDialog.open({\n                    title: 'Your credit purchase has been submitted',\n                    width: 536,\n                    content:\n                        collectionMethod === 'send_invoice' ? (\n                            <>\n                                <p className=\"mb-4\">\n                                    The invoice for your credits has been created and it will be emailed to the email on\n                                    file.\n                                </p>\n                                <p>\n                                    Once the invoice is paid we will apply the credits to your account. Until the\n                                    invoice is paid you will be charged for usage as normal.\n                                </p>\n                            </>\n                        ) : (\n                            <>\n                                <p>\n                                    Your card will be charged soon and the credits will be applied to your account.\n                                    Please make sure your{' '}\n                                    <Link to={values.billing?.stripe_portal_url} target=\"_blank\">\n                                        card on file\n                                    </Link>{' '}\n                                    is up to date. You will receive an email when the credits are applied.\n                                </p>\n                            </>\n                        ),\n                })\n            },\n            errors: ({ creditInput, collectionMethod }) => ({\n                creditInput: !creditInput\n                    ? 'Please enter the amount of credits you want to purchase'\n                    : // This value is used because 3333 - 10% = 3000\n                      +creditInput < 3333\n                      ? 'Please enter a credit amount of at least $3,333'\n                      : undefined,\n                collectionMethod: !collectionMethod ? 'Please select a collection method' : undefined,\n            }),\n        },\n    })),\n    listeners(({ actions, values }) => ({\n        reportBillingShown: () => {\n            posthog.capture('billing v2 shown')\n        },\n        reportBillingAlertShown: ({ alertConfig }) => {\n            posthog.capture('billing alert shown', {\n                ...alertConfig,\n            })\n        },\n        reportBillingAlertActionClicked: ({ alertConfig }) => {\n            posthog.capture('billing alert action clicked', {\n                ...alertConfig,\n            })\n        },\n        reportCreditsModalShown: () => {\n            posthog.capture('credits modal shown')\n        },\n        reportCreditsFormSubmitted: ({ creditInput }) => {\n            posthog.capture('credits modal credit form submitted', {\n                credit_amount_usd: creditInput,\n            })\n        },\n        reportCreditsCTAShown: ({ creditOverview }) => {\n            posthog.capture('credits cta shown', {\n                eligible: creditOverview.eligible,\n                status: creditOverview.status,\n                estimated_monthly_credit_amount_usd: creditOverview.estimated_monthly_credit_amount_usd,\n            })\n        },\n        toggleCreditCTAHeroDismissed: ({ isDismissed }) => {\n            if (isDismissed) {\n                posthog.capture('credits cta hero dismissed')\n            }\n        },\n        switchFlatrateSubscriptionPlan: async (payload) => {\n            actions.setSwitchPlanLoading(payload.to_product_key)\n        },\n        loadBillingSuccess: async (_, breakpoint) => {\n            actions.registerInstrumentationProps()\n            actions.determineBillingAlert()\n            actions.loadCreditOverview()\n\n            // If the activation is successful, we reload the user/organization to get the updated available features\n            // activation can be triggered from the billing page or onboarding\n            if (\n                (router.values.location.pathname.includes('/organization/billing') ||\n                    router.values.location.pathname.includes('/onboarding')) &&\n                (router.values.searchParams['success'] || router.values.searchParams['upgraded'])\n            ) {\n                // Wait enough time for the organization to be updated\n                await breakpoint(1000)\n                actions.loadUser()\n                actions.loadCurrentOrganization()\n                // Clear the params from the billing page so we don't trigger the activation again\n                if (router.values.location.pathname.includes('/organization/billing')) {\n                    router.actions.replace('/organization/billing')\n                }\n            }\n        },\n        determineBillingAlert: () => {\n            // If we already have a billing alert, don't show another one\n            if (values.billingAlert) {\n                return\n            }\n\n            if (values.productSpecificAlert) {\n                actions.setBillingAlert(values.productSpecificAlert)\n                return\n            }\n\n            if (!values.billing || !values.preflight?.cloud) {\n                return\n            }\n\n            const trial = values.billing.trial\n            if (trial && trial.expires_at && dayjs(trial.expires_at).isAfter(dayjs())) {\n                if (trial.type === 'autosubscribe' || trial.status !== 'active') {\n                    // Only show for standard ones (managed by sales)\n                    return\n                }\n\n                const remainingDays = dayjs(trial.expires_at).diff(dayjs(), 'days')\n                const remainingHours = dayjs(trial.expires_at).diff(dayjs(), 'hours')\n                if (remainingHours > 72) {\n                    return\n                }\n\n                const contactEmail = values.billing.account_owner?.email || 'sales@posthog.com'\n                const contactName = values.billing.account_owner?.name || 'sales'\n                actions.setBillingAlert({\n                    status: 'info',\n                    title: `Your free trial for the ${capitalizeFirstLetter(trial.target)} plan will end in ${\n                        remainingHours < 24 ? pluralize(remainingHours, 'hour') : pluralize(remainingDays, 'day')\n                    }.`,\n                    message: `If you have any questions, please reach out to ${contactName} at ${contactEmail}.`,\n                })\n                return\n            }\n\n            if (values.billing.deactivated) {\n                actions.setBillingAlert({\n                    status: 'error',\n                    title: 'Your organization has been temporarily suspended.',\n                    message: 'Please contact support to reactivate it.',\n                    contactSupport: true,\n                })\n                return\n            }\n\n            const productOverLimit = values.billing.products?.find((x: BillingProductV2Type) => {\n                return x.percentage_usage > 1 && x.usage_key\n            })\n\n            if (productOverLimit) {\n                const hideProductFlag = `billing_hide_product_${productOverLimit?.type}`\n                const isHidden = values.featureFlags[hideProductFlag] === true\n                if (isHidden) {\n                    return\n                }\n\n                // Check if this alert was dismissed for the current billing period\n                const billingPeriodEnd = values.billing.billing_period?.current_period_end?.format('YYYY-MM-DD')\n                if (isBillingAlertDismissed(values.currentOrganization?.id, productOverLimit.type, billingPeriodEnd)) {\n                    return\n                }\n\n                actions.setBillingAlert({\n                    status: 'error',\n                    title: 'Usage limit exceeded',\n                    message: `You have exceeded the usage limit for ${productOverLimit.name}. Please\n                        ${productOverLimit.subscribed ? 'increase your billing limit' : 'upgrade your plan'}\n                        or ${\n                            productOverLimit.name === 'Data warehouse'\n                                ? 'data will not be synced'\n                                : productOverLimit.name === 'Feature flags & Experiments'\n                                  ? 'feature flags will not evaluate'\n                                  : 'data loss may occur'\n                        }.`,\n                    dismissKey: 'usage-limit-exceeded',\n                    onClose: () => {\n                        // Store dismissal in localStorage\n                        const billingPeriodEnd =\n                            values.billing?.billing_period?.current_period_end?.format('YYYY-MM-DD')\n                        storeBillingAlertDismissal(\n                            values.currentOrganization?.id,\n                            productOverLimit.type,\n                            billingPeriodEnd\n                        )\n                        actions.setBillingAlert(null)\n                    },\n                })\n                return\n            }\n\n            actions.resetUsageLimitExceededKey()\n\n            const productApproachingLimit = values.billing.products?.find(\n                (x) => x.percentage_usage > ALLOCATION_THRESHOLD_ALERT\n            )\n\n            if (productApproachingLimit) {\n                const hideProductFlag = `billing_hide_product_${productApproachingLimit?.type}`\n                const isHidden = values.featureFlags[hideProductFlag] === true\n                if (isHidden) {\n                    return\n                }\n\n                // Check if this alert was dismissed for the current billing period\n                const billingPeriodEnd = values.billing?.billing_period?.current_period_end?.format('YYYY-MM-DD')\n                if (\n                    isBillingAlertDismissed(\n                        values.currentOrganization?.id,\n                        productApproachingLimit.type,\n                        billingPeriodEnd,\n                        '-approaching'\n                    )\n                ) {\n                    return\n                }\n\n                actions.setBillingAlert({\n                    status: 'info',\n                    title: 'You will soon hit your usage limit',\n                    message: `You have currently used ${parseFloat(\n                        (productApproachingLimit.percentage_usage * 100).toFixed(2)\n                    )}% of your ${\n                        productApproachingLimit.usage_key && productApproachingLimit.usage_key.toLowerCase()\n                    } allocation.`,\n                    dismissKey: 'usage-limit-approaching',\n                    onClose: () => {\n                        // Store dismissal in localStorage\n                        const billingPeriodEnd =\n                            values.billing?.billing_period?.current_period_end?.format('YYYY-MM-DD')\n                        storeBillingAlertDismissal(\n                            values.currentOrganization?.id,\n                            productApproachingLimit.type,\n                            billingPeriodEnd,\n                            '-approaching'\n                        )\n                        actions.setBillingAlert(null)\n                    },\n                })\n                return\n            }\n\n            actions.resetUsageLimitApproachingKey()\n        },\n        setCreditFormValue: ({ name, value }) => {\n            if (name === 'creditInput' || (name as FieldNamePath)?.[0] === 'creditInput') {\n                const spend = +value\n\n                for (const bracket of values.creditBrackets) {\n                    if (\n                        spend >= bracket.annual_credit_from_inclusive &&\n                        spend < (bracket.annual_credit_to_exclusive || Infinity)\n                    ) {\n                        actions.setComputedDiscount(bracket.discount)\n                        return\n                    }\n                }\n\n                actions.setComputedDiscount(0)\n            }\n        },\n        registerInstrumentationProps: async (_, breakpoint) => {\n            await breakpoint(100)\n            if (posthog && values.billing) {\n                const payload: { [key: string]: any } = {\n                    has_billing_plan: !!values.billing.has_active_subscription,\n                    free_trial_until: values.billing.free_trial_until?.toISOString(),\n                    customer_deactivated: values.billing.deactivated,\n                    current_total_amount_usd: values.billing.current_total_amount_usd,\n                }\n                if (values.billing.custom_limits_usd) {\n                    for (const product of Object.keys(values.billing.custom_limits_usd)) {\n                        payload[`custom_limits_usd.${product}`] = values.billing.custom_limits_usd[product]\n                    }\n                }\n                if (values.billing.products) {\n                    for (const product of values.billing.products) {\n                        const type = product.type.toLowerCase()\n                        payload[`percentage_usage.${type}`] = product.percentage_usage\n                        payload[`current_amount_usd.${type}`] = product.current_amount_usd\n                        payload[`unit_amount_usd.${type}`] = product.unit_amount_usd\n                        payload[`usage_limit.${type}`] = product.usage_limit\n                        payload[`current_usage.${type}`] = product.current_usage\n                        payload[`projected_usage.${type}`] = product.projected_usage\n                        payload[`free_allocation.${type}`] = product.free_allocation\n                    }\n                }\n                if (values.billing.billing_period) {\n                    payload['billing_period_start'] = values.billing.billing_period.current_period_start\n                    payload['billing_period_end'] = values.billing.billing_period.current_period_end\n                }\n                posthog.register(payload)\n            }\n        },\n        showPurchaseCreditsModal: ({ isOpen }) => {\n            if (isOpen) {\n                actions.reportCreditsModalShown()\n            }\n        },\n        scrollToProduct: ({ productType }) => {\n            let element = document.querySelector(`[data-attr=\"billing-product-addon-${productType}\"]`)\n            if (element == null) {\n                element = document.querySelector(`[data-attr=\"billing-product-${productType}\"]`)\n            }\n            element?.scrollIntoView({\n                behavior: 'smooth',\n                block: 'center',\n            })\n        },\n    })),\n    urlToAction(({ actions, values }) => ({\n        // IMPORTANT: This needs to be above the \"*\" so it takes precedence\n        '/*/billing': (_params, _search, hash) => {\n            if (hash.license) {\n                actions.setShowLicenseDirectInput(true)\n                actions.setActivateLicenseValues({ license: hash.license })\n                actions.submitActivateLicense()\n            }\n            if (_search.products) {\n                const products = _search.products.split(',')\n                actions.setScrollToProductKey(products[0])\n            }\n            if (_search.billing_error) {\n                actions.setBillingAlert({\n                    status: 'error',\n                    title: 'Error',\n                    message: _search.billing_error,\n                    contactSupport: true,\n                })\n            }\n\n            const redirectPath = window.location.pathname.includes('/onboarding')\n                ? window.location.pathname + window.location.search\n                : ''\n            if (values.redirectPath !== redirectPath) {\n                actions.setRedirectPath(redirectPath)\n            }\n            const isOnboarding = window.location.pathname.includes('/onboarding')\n            if (values.isOnboarding !== isOnboarding) {\n                actions.setIsOnboarding(isOnboarding)\n            }\n        },\n        '*': () => {\n            const redirectPath = window.location.pathname.includes('/onboarding')\n                ? window.location.pathname + window.location.search\n                : ''\n            if (values.redirectPath !== redirectPath) {\n                actions.setRedirectPath(redirectPath)\n            }\n            const isOnboarding = window.location.pathname.includes('/onboarding')\n            if (values.isOnboarding !== isOnboarding) {\n                actions.setIsOnboarding(isOnboarding)\n            }\n        },\n    })),\n])\n","import { actions, connect, isBreakpoint, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { router, urlToAction } from 'kea-router'\n\nimport api from 'lib/api'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { dayjs } from 'lib/dayjs'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { hasFormErrors, toParams } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { ProductIntentContext } from 'lib/utils/product-intents'\nimport { addProjectIdIfMissing } from 'lib/utils/router-utils'\nimport { billingLogic } from 'scenes/billing/billingLogic'\nimport {\n    indexToVariantKeyFeatureFlagPayloads,\n    featureFlagLogic as sceneFeatureFlagLogic,\n    validateFeatureFlagKey,\n    variantKeyToIndexFeatureFlagPayloads,\n} from 'scenes/feature-flags/featureFlagLogic'\nimport { featureFlagsLogic } from 'scenes/feature-flags/featureFlagsLogic'\nimport { funnelDataLogic } from 'scenes/funnels/funnelDataLogic'\nimport { insightDataLogic } from 'scenes/insights/insightDataLogic'\nimport { projectLogic } from 'scenes/projectLogic'\nimport { Scene } from 'scenes/sceneTypes'\nimport { sceneConfigurations } from 'scenes/scenes'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { trendsDataLogic } from 'scenes/trends/trendsDataLogic'\nimport { urls } from 'scenes/urls'\n\nimport { ActivationTask, activationLogic } from '~/layout/navigation-3000/sidepanel/panels/activation/activationLogic'\nimport { SIDE_PANEL_CONTEXT_KEY, SidePanelSceneContext } from '~/layout/navigation-3000/sidepanel/types'\nimport { refreshTreeItem } from '~/layout/panel-layout/ProjectTree/projectTreeLogic'\nimport { cohortsModel } from '~/models/cohortsModel'\nimport { groupsModel } from '~/models/groupsModel'\nimport { QUERY_TIMEOUT_ERROR_MESSAGE, performQuery } from '~/queries/query'\nimport {\n    AnyEntityNode,\n    CachedExperimentFunnelsQueryResponse,\n    CachedExperimentQueryResponse,\n    CachedExperimentTrendsQueryResponse,\n    CachedLegacyExperimentQueryResponse,\n    CachedNewExperimentQueryResponse,\n    ExperimentExposureCriteria,\n    ExperimentExposureQueryResponse,\n    ExperimentFunnelsQuery,\n    ExperimentMetric,\n    ExperimentMetricType,\n    ExperimentTrendsQuery,\n    FunnelsQuery,\n    InsightVizNode,\n    NodeKind,\n    TrendsQuery,\n} from '~/queries/schema/schema-general'\nimport { setLatestVersionsOnQuery } from '~/queries/utils'\nimport {\n    AccessControlLevel,\n    ActivityScope,\n    Breadcrumb,\n    BreakdownAttributionType,\n    BreakdownType,\n    CohortType,\n    CountPerActorMathType,\n    DashboardType,\n    Experiment,\n    ExperimentStatsMethod,\n    FeatureFlagType,\n    FunnelExperimentVariant,\n    InsightType,\n    MultivariateFlagVariant,\n    ProductKey,\n    ProjectTreeRef,\n    PropertyMathType,\n    TrendExperimentVariant,\n} from '~/types'\n\nimport { getDefaultMetricTitle } from './MetricsView/shared/utils'\nimport { SharedMetric } from './SharedMetrics/sharedMetricLogic'\nimport { sharedMetricsLogic } from './SharedMetrics/sharedMetricsLogic'\nimport { EXPERIMENT_MIN_EXPOSURES_FOR_RESULTS, MetricInsightId } from './constants'\nimport type { experimentLogicType } from './experimentLogicType'\nimport { experimentsLogic } from './experimentsLogic'\nimport { holdoutsLogic } from './holdoutsLogic'\nimport {\n    conversionRateForVariant,\n    expectedRunningTime,\n    getSignificanceDetails,\n    minimumSampleSizePerVariant,\n    recommendedExposureForCountData,\n} from './legacyExperimentCalculations'\nimport { addExposureToMetric, compose, getInsight, getQuery } from './metricQueryUtils'\nimport { modalsLogic } from './modalsLogic'\nimport {\n    featureFlagEligibleForExperiment,\n    initializeMetricOrdering,\n    isLegacyExperiment,\n    percentageDistribution,\n    transformFiltersForWinningVariant,\n} from './utils'\n\nconst NEW_EXPERIMENT: Experiment = {\n    id: 'new',\n    name: '',\n    type: 'product',\n    feature_flag_key: '',\n    filters: {},\n    metrics: [],\n    metrics_secondary: [],\n    primary_metrics_ordered_uuids: null,\n    secondary_metrics_ordered_uuids: null,\n    saved_metrics_ids: [],\n    saved_metrics: [],\n    parameters: {\n        feature_flag_variants: [\n            { key: 'control', rollout_percentage: 50 },\n            { key: 'test', rollout_percentage: 50 },\n        ],\n    },\n    secondary_metrics: [],\n    created_at: null,\n    created_by: null,\n    updated_at: null,\n    holdout_id: null,\n    exposure_criteria: {\n        filterTestAccounts: true,\n    },\n    user_access_level: AccessControlLevel.Editor,\n}\n\nexport const DEFAULT_MDE = 30\n\nexport const FORM_MODES = {\n    create: 'create',\n    duplicate: 'duplicate',\n    update: 'update',\n} as const\n\n/**\n * get the values of formModes as a union type\n * we don't really need formModes unless we need to do FORM_MODES[num]\n * this could be just an union type\n */\nexport type FormModes = (typeof FORM_MODES)[keyof typeof FORM_MODES]\n\nexport interface ExperimentLogicProps {\n    experimentId?: Experiment['id']\n    formMode?: FormModes\n}\n\ninterface MetricLoadingConfig {\n    metrics: any[]\n    experimentId: Experiment['id']\n    refresh?: boolean\n    onSetLegacyResults: (\n        results: (\n            | CachedLegacyExperimentQueryResponse\n            | CachedExperimentTrendsQueryResponse\n            | CachedExperimentFunnelsQueryResponse\n            | null\n        )[]\n    ) => void\n    onSetResults: (results: CachedNewExperimentQueryResponse[]) => void\n    onSetErrors: (errors: any[]) => void\n    onTimeout: (experimentId: Experiment['id'], metric: any) => void\n}\n\nconst loadMetrics = async ({\n    metrics,\n    experimentId,\n    refresh,\n    onSetLegacyResults,\n    onSetResults,\n    onSetErrors,\n    onTimeout,\n}: MetricLoadingConfig): Promise<void[]> => {\n    const legacyResults: (\n        | CachedLegacyExperimentQueryResponse\n        | CachedExperimentTrendsQueryResponse\n        | CachedExperimentFunnelsQueryResponse\n        | null\n    )[] = []\n\n    const results: CachedNewExperimentQueryResponse[] = []\n    const currentErrors = new Array(metrics.length).fill(null)\n\n    return await Promise.all(\n        metrics.map(async (metric, index) => {\n            try {\n                let queryWithExperimentId\n                if (metric.kind === NodeKind.ExperimentMetric) {\n                    queryWithExperimentId = {\n                        kind: NodeKind.ExperimentQuery,\n                        metric: metric,\n                        experiment_id: experimentId,\n                    }\n                } else {\n                    queryWithExperimentId = {\n                        ...metric,\n                        experiment_id: experimentId,\n                    }\n                }\n                const response = await performQuery(\n                    setLatestVersionsOnQuery(queryWithExperimentId),\n                    undefined,\n                    refresh ? 'force_async' : 'async'\n                )\n\n                // Convert ExperimentQuery responses to typed responses\n                if (\n                    metric.kind === NodeKind.ExperimentMetric ||\n                    queryWithExperimentId.kind === NodeKind.ExperimentQuery\n                ) {\n                    const typedResponse = convertToTypedExperimentResponse(response as CachedExperimentQueryResponse)\n                    if (typedResponse) {\n                        if (isLegacyExperimentResponse(typedResponse)) {\n                            legacyResults[index] = {\n                                ...typedResponse,\n                                fakeInsightId: Math.random().toString(36).substring(2, 15),\n                            } as CachedLegacyExperimentQueryResponse & { fakeInsightId: string }\n                        } else if (isNewExperimentResponse(typedResponse)) {\n                            results[index] = typedResponse\n                        }\n                    }\n                } else {\n                    // For trends/funnels queries, keep original response\n                    legacyResults[index] = {\n                        ...response,\n                        fakeInsightId: Math.random().toString(36).substring(2, 15),\n                    } as (CachedExperimentTrendsQueryResponse | CachedExperimentFunnelsQueryResponse) & {\n                        fakeInsightId: string\n                    }\n                }\n                onSetLegacyResults([...legacyResults])\n                onSetResults([...results])\n            } catch (error: any) {\n                const errorDetailMatch = error.detail?.match(/\\{.*\\}/)\n                const errorDetail = errorDetailMatch ? JSON.parse(errorDetailMatch[0]) : error.detail || error.message\n\n                currentErrors[index] = {\n                    detail: errorDetail,\n                    statusCode: error.status,\n                    hasDiagnostics: !!errorDetailMatch,\n                }\n                onSetErrors(currentErrors)\n\n                if (errorDetail === QUERY_TIMEOUT_ERROR_MESSAGE) {\n                    onTimeout(experimentId, metric)\n                }\n\n                legacyResults[index] = null\n                onSetLegacyResults([...legacyResults])\n                onSetResults([...results])\n            }\n        })\n    )\n}\n\n// Type guards to distinguish between legacy and new experiment responses\nexport function isLegacyExperimentResponse(\n    response: CachedExperimentQueryResponse\n): response is CachedLegacyExperimentQueryResponse {\n    return 'variants' in response && response.variants !== null\n}\n\nexport function isNewExperimentResponse(\n    response: CachedExperimentQueryResponse\n): response is CachedNewExperimentQueryResponse {\n    return 'baseline' in response && response.baseline !== null\n}\n\n// Union type for strongly typed experiment responses\nexport type TypedExperimentResponse = CachedLegacyExperimentQueryResponse | CachedNewExperimentQueryResponse\n\n// Utility function to convert generic response to typed response\nfunction convertToTypedExperimentResponse(response: CachedExperimentQueryResponse): TypedExperimentResponse | null {\n    if (isLegacyExperimentResponse(response)) {\n        return response\n    }\n\n    if (isNewExperimentResponse(response)) {\n        return response\n    }\n\n    // If response doesn't match either pattern, return null\n    return null\n}\n\nexport const experimentLogic = kea<experimentLogicType>([\n    props({} as ExperimentLogicProps),\n    key((props) => props.experimentId || 'new'),\n    path((key) => ['scenes', 'experiment', 'experimentLogic', key]),\n    connect(() => ({\n        values: [\n            projectLogic,\n            ['currentProjectId'],\n            groupsModel,\n            ['aggregationLabel', 'groupTypes', 'showGroupsOptions'],\n            featureFlagLogic,\n            ['featureFlags'],\n            holdoutsLogic,\n            ['holdouts'],\n            billingLogic,\n            ['billing'],\n            // Hook the insight state to get the results for the sample size estimation\n            funnelDataLogic({ dashboardItemId: MetricInsightId.Funnels }),\n            ['results as funnelResults', 'conversionMetrics'],\n            trendsDataLogic({ dashboardItemId: MetricInsightId.Trends }),\n            ['results as trendResults'],\n            // Hook into the loading state of the metric insight\n            insightDataLogic({ dashboardItemId: MetricInsightId.Trends }),\n            ['insightDataLoading as trendMetricInsightLoading'],\n            insightDataLogic({ dashboardItemId: MetricInsightId.Funnels }),\n            ['insightDataLoading as funnelMetricInsightLoading'],\n            sharedMetricsLogic,\n            ['sharedMetrics'],\n        ],\n        actions: [\n            experimentsLogic,\n            ['updateExperiments', 'addToExperiments'],\n            eventUsageLogic,\n            [\n                'reportExperimentCreated',\n                'reportExperimentViewed',\n                'reportExperimentLaunched',\n                'reportExperimentCompleted',\n                'reportExperimentArchived',\n                'reportExperimentReset',\n                'reportExperimentExposureCohortCreated',\n                'reportExperimentVariantShipped',\n                'reportExperimentVariantScreenshotUploaded',\n                'reportExperimentResultsLoadingTimeout',\n                'reportExperimentReleaseConditionsViewed',\n                'reportExperimentHoldoutAssigned',\n                'reportExperimentSharedMetricAssigned',\n                'reportExperimentDashboardCreated',\n                'reportExperimentMetricTimeout',\n                'reportExperimentTimeseriesViewed',\n                'reportExperimentTimeseriesRecalculated',\n            ],\n            teamLogic,\n            ['addProductIntent'],\n            featureFlagsLogic,\n            ['updateFlag'],\n            modalsLogic,\n            [\n                'openPrimaryMetricModal',\n                'closePrimaryMetricModal',\n                'openSecondaryMetricModal',\n                'closeSecondaryMetricModal',\n                'openPrimarySharedMetricModal',\n                'openSecondarySharedMetricModal',\n                'openStopExperimentModal',\n                'closeStopExperimentModal',\n                'closeShipVariantModal',\n                'openReleaseConditionsModal',\n            ],\n        ],\n    })),\n    actions({\n        setExperimentMissing: true,\n        setExperiment: (experiment: Partial<Experiment>) => ({ experiment }),\n        createExperiment: (draft?: boolean, folder?: string | null) => ({ draft, folder }),\n        setCreateExperimentLoading: (loading: boolean) => ({ loading }),\n        setExperimentType: (type?: string) => ({ type }),\n        addVariant: true,\n        removeVariant: (idx: number) => ({ idx }),\n        setEditExperiment: (editing: boolean) => ({ editing }),\n        setExposureAndSampleSize: (exposure: number, sampleSize: number) => ({ exposure, sampleSize }),\n        refreshExperimentResults: (forceRefresh?: boolean) => ({ forceRefresh }),\n        updateExperimentMetrics: true,\n        updateExperimentCollectionGoal: true,\n        updateExposureCriteria: true,\n        changeExperimentStartDate: (startDate: string) => ({ startDate }),\n        changeExperimentEndDate: (endDate: string) => ({ endDate }),\n        launchExperiment: true,\n        endExperiment: true,\n        archiveExperiment: true,\n        resetRunningExperiment: true,\n        updateExperimentVariantImages: (variantPreviewMediaIds: Record<string, string[]>) => ({\n            variantPreviewMediaIds,\n        }),\n        setExposureCriteria: (exposureCriteria: ExperimentExposureCriteria) => ({ exposureCriteria }),\n        createExperimentDashboard: true,\n        setIsCreatingExperimentDashboard: (isCreating: boolean) => ({ isCreating }),\n        setUnmodifiedExperiment: (experiment: Experiment) => ({ experiment }),\n        restoreUnmodifiedExperiment: true,\n        setValidExistingFeatureFlag: (featureFlag: FeatureFlagType | null) => ({ featureFlag }),\n        setFeatureFlagValidationError: (error: string) => ({ error }),\n        validateFeatureFlag: (featureFlagKey: string) => ({ featureFlagKey }),\n        // METRICS\n        setMetric: ({\n            uuid,\n            name,\n            metric,\n            isSecondary = false,\n        }: {\n            uuid: string\n            name?: string\n            metric: ExperimentMetric\n            isSecondary?: boolean\n        }) => ({ uuid, name, metric, isSecondary }),\n        setTrendsMetric: ({\n            uuid,\n            name,\n            series,\n            filterTestAccounts,\n            isSecondary = false,\n        }: {\n            uuid: string\n            name?: string\n            series?: AnyEntityNode[]\n            filterTestAccounts?: boolean\n            isSecondary?: boolean\n        }) => ({ uuid, name, series, filterTestAccounts, isSecondary }),\n        setTrendsExposureMetric: ({\n            uuid,\n            name,\n            series,\n            filterTestAccounts,\n            isSecondary = false,\n        }: {\n            uuid: string\n            name?: string\n            series?: AnyEntityNode[]\n            filterTestAccounts?: boolean\n            isSecondary?: boolean\n        }) => ({ uuid, name, series, filterTestAccounts, isSecondary }),\n        setFunnelsMetric: ({\n            uuid,\n            name,\n            series,\n            filterTestAccounts,\n            breakdownAttributionType,\n            breakdownAttributionValue,\n            funnelWindowInterval,\n            funnelWindowIntervalUnit,\n            aggregation_group_type_index,\n            funnelAggregateByHogQL,\n            isSecondary,\n        }: {\n            uuid: string\n            name?: string\n            series?: AnyEntityNode[]\n            filterTestAccounts?: boolean\n            breakdownAttributionType?: BreakdownAttributionType\n            breakdownAttributionValue?: number\n            funnelWindowInterval?: number\n            funnelWindowIntervalUnit?: string\n            aggregation_group_type_index?: number\n            funnelAggregateByHogQL?: string\n            isSecondary?: boolean\n        }) => ({\n            uuid,\n            name,\n            series,\n            filterTestAccounts,\n            breakdownAttributionType,\n            breakdownAttributionValue,\n            funnelWindowInterval,\n            funnelWindowIntervalUnit,\n            aggregation_group_type_index,\n            funnelAggregateByHogQL,\n            isSecondary,\n        }),\n        addSharedMetricsToExperiment: (\n            sharedMetricIds: SharedMetric['id'][],\n            metadata: { type: 'primary' | 'secondary' }\n        ) => ({\n            sharedMetricIds,\n            metadata,\n        }),\n        removeSharedMetricFromExperiment: (sharedMetricId: SharedMetric['id']) => ({ sharedMetricId }),\n        duplicateMetric: ({ uuid, isSecondary, newUuid }: { uuid: string; isSecondary: boolean; newUuid: string }) => ({\n            uuid,\n            isSecondary,\n            newUuid,\n        }),\n        // METRICS RESULTS\n        setLegacyPrimaryMetricsResults: (\n            results: (\n                | CachedLegacyExperimentQueryResponse\n                | CachedExperimentTrendsQueryResponse\n                | CachedExperimentFunnelsQueryResponse\n                | null\n            )[]\n        ) => ({ results }),\n        setPrimaryMetricsResults: (results: CachedNewExperimentQueryResponse[]) => ({ results }),\n        setPrimaryMetricsResultsLoading: (loading: boolean) => ({ loading }),\n        loadPrimaryMetricsResults: (refresh?: boolean) => ({ refresh }),\n        setPrimaryMetricsResultsErrors: (errors: any[]) => ({ errors }),\n        setSecondaryMetricsResults: (results: CachedNewExperimentQueryResponse[]) => ({ results }),\n        loadSecondaryMetricsResults: (refresh?: boolean) => ({ refresh }),\n        setSecondaryMetricsResultsErrors: (errors: any[]) => ({ errors }),\n        setSecondaryMetricsResultsLoading: (loading: boolean) => ({ loading }),\n        setLegacySecondaryMetricsResults: (\n            results: (\n                | CachedLegacyExperimentQueryResponse\n                | CachedExperimentTrendsQueryResponse\n                | CachedExperimentFunnelsQueryResponse\n                | null\n            )[]\n        ) => ({ results }),\n        updateDistribution: (featureFlag: FeatureFlagType) => ({ featureFlag }),\n    }),\n    reducers({\n        experiment: [\n            { ...NEW_EXPERIMENT } as Experiment,\n            {\n                setExperiment: (state, { experiment }) => {\n                    return { ...state, ...experiment }\n                },\n                addVariant: (state) => {\n                    if (state?.parameters?.feature_flag_variants) {\n                        const newRolloutPercentages = percentageDistribution(\n                            state.parameters.feature_flag_variants.length + 1\n                        )\n                        const updatedRolloutPercentageVariants = state.parameters.feature_flag_variants.map(\n                            (variant: MultivariateFlagVariant, i: number) => ({\n                                ...variant,\n                                rollout_percentage: newRolloutPercentages[i],\n                            })\n                        )\n                        return {\n                            ...state,\n                            parameters: {\n                                ...state.parameters,\n                                feature_flag_variants: [\n                                    ...updatedRolloutPercentageVariants,\n                                    {\n                                        key: `test-${state.parameters.feature_flag_variants.length}`,\n                                        rollout_percentage: newRolloutPercentages[newRolloutPercentages.length - 1],\n                                    },\n                                ],\n                            },\n                        }\n                    }\n                    return state\n                },\n                removeVariant: (state, { idx }) => {\n                    if (!state) {\n                        return { ...NEW_EXPERIMENT }\n                    }\n                    const variants = [...(state.parameters?.feature_flag_variants || [])]\n                    variants.splice(idx, 1)\n                    const newRolloutPercentages = percentageDistribution(\n                        (state?.parameters?.feature_flag_variants || []).length - 1\n                    )\n                    const updatedVariants = variants.map((variant: MultivariateFlagVariant, i: number) => ({\n                        ...variant,\n                        rollout_percentage: newRolloutPercentages[i],\n                    }))\n\n                    return {\n                        ...state,\n                        parameters: {\n                            ...state.parameters,\n                            feature_flag_variants: updatedVariants,\n                        },\n                    }\n                },\n                setExposureCriteria: (\n                    state,\n                    { exposureCriteria }: { exposureCriteria: ExperimentExposureCriteria }\n                ) => {\n                    return {\n                        ...state,\n                        exposure_criteria: { ...state.exposure_criteria, ...exposureCriteria },\n                    }\n                },\n                setMetric: (state, { uuid, metric, isSecondary }) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n\n                    const targetIndex = metrics.findIndex((m) => m.uuid === uuid)\n                    if (targetIndex !== -1) {\n                        metrics[targetIndex] = metric\n                    }\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n                setTrendsMetric: (state, { uuid, name, series, filterTestAccounts, isSecondary }) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n                    const targetIndex = metrics.findIndex((m) => m.uuid === uuid)\n\n                    if (targetIndex === -1) {\n                        return state\n                    }\n\n                    const metric = metrics[targetIndex]\n\n                    metrics[targetIndex] = {\n                        ...metric,\n                        ...(name !== undefined && { name }),\n                        count_query: {\n                            ...(metric as ExperimentTrendsQuery).count_query,\n                            ...(series && { series }),\n                            ...(filterTestAccounts !== undefined && { filterTestAccounts }),\n                        },\n                    } as ExperimentTrendsQuery\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n                setTrendsExposureMetric: (state, { uuid, name, series, filterTestAccounts, isSecondary }) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n                    const targetIndex = metrics.findIndex((m) => m.uuid === uuid)\n\n                    if (targetIndex === -1) {\n                        return state\n                    }\n\n                    const metric = metrics[targetIndex]\n\n                    metrics[targetIndex] = {\n                        ...metric,\n                        ...(name !== undefined && { name }),\n                        exposure_query: {\n                            ...(metric as ExperimentTrendsQuery).exposure_query,\n                            ...(series && { series }),\n                            ...(filterTestAccounts !== undefined && { filterTestAccounts }),\n                        },\n                    } as ExperimentTrendsQuery\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n                setFunnelsMetric: (\n                    state,\n                    {\n                        uuid,\n                        name,\n                        series,\n                        filterTestAccounts,\n                        breakdownAttributionType,\n                        breakdownAttributionValue,\n                        funnelWindowInterval,\n                        funnelWindowIntervalUnit,\n                        aggregation_group_type_index,\n                        funnelAggregateByHogQL,\n                        isSecondary,\n                    }\n                ) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n                    const targetIndex = metrics.findIndex((m) => m.uuid === uuid)\n\n                    if (targetIndex === -1) {\n                        return state\n                    }\n\n                    const metric = metrics[targetIndex]\n\n                    metrics[targetIndex] = {\n                        ...metric,\n                        ...(name !== undefined && { name }),\n                        funnels_query: {\n                            ...(metric as ExperimentFunnelsQuery).funnels_query,\n                            ...(series && { series }),\n                            ...(filterTestAccounts !== undefined && { filterTestAccounts }),\n                            ...(aggregation_group_type_index !== undefined && { aggregation_group_type_index }),\n                            funnelsFilter: {\n                                ...(metric as ExperimentFunnelsQuery).funnels_query.funnelsFilter,\n                                ...(breakdownAttributionType && { breakdownAttributionType }),\n                                ...(breakdownAttributionValue !== undefined && { breakdownAttributionValue }),\n                                ...(funnelWindowInterval !== undefined && { funnelWindowInterval }),\n                                ...(funnelWindowIntervalUnit && { funnelWindowIntervalUnit }),\n                                ...(funnelAggregateByHogQL !== undefined && { funnelAggregateByHogQL }),\n                            },\n                        },\n                    } as ExperimentFunnelsQuery\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n                duplicateMetric: (state, { uuid, isSecondary, newUuid }) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n\n                    const originalIndex = metrics.findIndex((m) => m.uuid === uuid)\n\n                    if (originalIndex === -1) {\n                        return state\n                    }\n\n                    const originalMetric = metrics[originalIndex]\n\n                    const name = originalMetric.name\n                        ? `${originalMetric.name} (copy)`\n                        : originalMetric.kind === NodeKind.ExperimentMetric\n                          ? `${getDefaultMetricTitle(originalMetric)} (copy)`\n                          : undefined\n\n                    const newMetric = { ...originalMetric, uuid: newUuid, name }\n                    metrics.splice(originalIndex + 1, 0, newMetric)\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n            },\n        ],\n        experimentMissing: [\n            false,\n            {\n                setExperimentMissing: () => true,\n            },\n        ],\n        unmodifiedExperiment: [\n            null as Experiment | null,\n            {\n                setUnmodifiedExperiment: (_, { experiment }) => experiment,\n            },\n        ],\n        // PRIMARY METRICS\n        legacyPrimaryMetricsResults: [\n            [] as (\n                | CachedLegacyExperimentQueryResponse\n                | CachedExperimentTrendsQueryResponse\n                | CachedExperimentFunnelsQueryResponse\n                | null\n            )[],\n            {\n                setLegacyPrimaryMetricsResults: (_, { results }) => results,\n            },\n        ],\n        primaryMetricsResults: [\n            [] as CachedNewExperimentQueryResponse[],\n            {\n                setPrimaryMetricsResults: (_, { results }) => results,\n                loadPrimaryMetricsResults: () => [],\n                loadExperiment: () => [],\n            },\n        ],\n        primaryMetricsResultsLoading: [\n            false,\n            {\n                setPrimaryMetricsResultsLoading: (_, { loading }) => loading,\n            },\n        ],\n        primaryMetricsResultsErrors: [\n            [] as any[],\n            {\n                setPrimaryMetricsResultsErrors: (_, { errors }) => errors,\n                loadPrimaryMetricsResults: () => [],\n                loadExperiment: () => [],\n            },\n        ],\n        // SECONDARY METRICS\n        legacySecondaryMetricsResults: [\n            [] as (\n                | CachedLegacyExperimentQueryResponse\n                | CachedExperimentTrendsQueryResponse\n                | CachedExperimentFunnelsQueryResponse\n                | null\n            )[],\n            {\n                setLegacySecondaryMetricsResults: (_, { results }) => results,\n            },\n        ],\n        secondaryMetricsResults: [\n            [] as CachedNewExperimentQueryResponse[],\n            {\n                setSecondaryMetricsResults: (_, { results }) => results,\n                loadSecondaryMetricsResults: () => [],\n                loadExperiment: () => [],\n            },\n        ],\n        secondaryMetricsResultsLoading: [\n            false,\n            {\n                setSecondaryMetricsResultsLoading: (_, { loading }) => loading,\n            },\n        ],\n        secondaryMetricsResultsErrors: [\n            [] as any[],\n            {\n                setSecondaryMetricsResultsErrors: (_, { errors }) => errors,\n                loadSecondaryMetricsResults: () => [],\n                loadExperiment: () => [],\n            },\n        ],\n        editingPrimaryMetricUuid: [\n            null as string | null,\n            {\n                openPrimaryMetricModal: (_, { uuid }) => uuid,\n                closePrimaryMetricModal: () => null,\n                updateExperimentMetrics: () => null,\n                setEditingPrimaryMetricUuid: (_, { uuid }) => uuid,\n            },\n        ],\n        editingSecondaryMetricUuid: [\n            null as string | null,\n            {\n                openSecondaryMetricModal: (_, { uuid }) => uuid,\n                closeSecondaryMetricModal: () => null,\n                updateExperimentMetrics: () => null,\n            },\n        ],\n        editingSharedMetricId: [\n            null as SharedMetric['id'] | null,\n            {\n                openPrimarySharedMetricModal: (_, { sharedMetricId }) => sharedMetricId,\n                openSecondarySharedMetricModal: (_, { sharedMetricId }) => sharedMetricId,\n                updateExperimentMetrics: () => null,\n            },\n        ],\n        isCreatingExperimentDashboard: [\n            false,\n            {\n                setIsCreatingExperimentDashboard: (_, { isCreating }) => isCreating,\n            },\n        ],\n        validExistingFeatureFlag: [\n            null as FeatureFlagType | null,\n            {\n                setValidExistingFeatureFlag: (_, { featureFlag }) => featureFlag,\n            },\n        ],\n        featureFlagValidationError: [\n            null as string | null,\n            {\n                setFeatureFlagValidationError: (_, { error }) => error,\n            },\n        ],\n        createExperimentLoading: [\n            false,\n            {\n                setCreateExperimentLoading: (_, { loading }) => loading,\n            },\n        ],\n    }),\n    listeners(({ values, actions, props }) => ({\n        createExperiment: async ({ draft, folder }) => {\n            actions.setCreateExperimentLoading(true)\n            const { recommendedRunningTime, recommendedSampleSize, minimumDetectableEffect } = values\n\n            actions.touchExperimentField('name')\n            actions.touchExperimentField('feature_flag_key')\n            values.experiment.parameters.feature_flag_variants.forEach((_, i) =>\n                actions.touchExperimentField(`parameters.feature_flag_variants.${i}.key`)\n            )\n\n            if (hasFormErrors(values.experimentErrors)) {\n                actions.setCreateExperimentLoading(false)\n                return\n            }\n\n            // Minimum Detectable Effect is calculated based on a loaded insight\n            // Terminate if the insight did not manage to load in time\n            if (!minimumDetectableEffect) {\n                eventUsageLogic.actions.reportExperimentInsightLoadFailed()\n                actions.setCreateExperimentLoading(false)\n                return lemonToast.error(\n                    'Failed to load insight. Experiment cannot be saved without this value. Try changing the experiment goal.'\n                )\n            }\n\n            let response: Experiment | null = null\n            const isUpdate = props.formMode === 'update'\n            try {\n                if (isUpdate) {\n                    response = await api.update(\n                        `api/projects/${values.currentProjectId}/experiments/${values.experimentId}`,\n                        {\n                            ...values.experiment,\n                            parameters: {\n                                ...values.experiment?.parameters,\n                                recommended_running_time: recommendedRunningTime,\n                                recommended_sample_size: recommendedSampleSize,\n                                minimum_detectable_effect: minimumDetectableEffect,\n                            },\n                            ...(!draft && { start_date: dayjs() }),\n                            // backwards compatibility: Remove any global properties set on the experiment.\n                            // These were used to change feature flag targeting, but this is controlled directly\n                            // on the feature flag now.\n                            filters: {\n                                events: [],\n                                actions: [],\n                                ...values.experiment.filters,\n                                properties: [],\n                            },\n                        }\n                    )\n\n                    if (response?.id) {\n                        actions.updateExperiments(response)\n                        actions.setEditExperiment(false)\n                        actions.loadExperimentSuccess(response)\n                        return\n                    }\n                } else {\n                    // Make experiment eligible for timeseries\n                    const statsConfig = {\n                        ...values.experiment?.stats_config,\n                        ...(values.featureFlags[FEATURE_FLAGS.EXPERIMENT_TIMESERIES] && { timeseries: true }),\n                        ...(values.featureFlags[FEATURE_FLAGS.EXPERIMENTS_USE_NEW_QUERY_BUILDER] && {\n                            use_new_query_builder: true,\n                        }),\n                    }\n\n                    response = await api.create(`api/projects/${values.currentProjectId}/experiments`, {\n                        ...values.experiment,\n                        parameters:\n                            /**\n                             * only if we are creating a new experiment we need to reset\n                             * the recommended running time. If we are duplicating we want to\n                             * preserve this values.\n                             */\n                            props.formMode === FORM_MODES.create\n                                ? {\n                                      ...values.experiment?.parameters,\n                                      recommended_running_time: recommendedRunningTime,\n                                      recommended_sample_size: recommendedSampleSize,\n                                      minimum_detectable_effect: minimumDetectableEffect,\n                                  }\n                                : values.experiment?.parameters,\n                        ...(!draft && { start_date: dayjs() }),\n                        ...(typeof folder === 'string' ? { _create_in_folder: folder } : {}),\n                        stats_config: statsConfig,\n                    })\n\n                    if (response) {\n                        actions.reportExperimentCreated(response)\n                        actions.addProductIntent({\n                            product_type: ProductKey.EXPERIMENTS,\n                            intent_context: ProductIntentContext.EXPERIMENT_CREATED,\n                        })\n                        if (response.feature_flag?.id) {\n                            refreshTreeItem('feature_flag', String(response.feature_flag.id))\n                        }\n                    }\n                }\n            } catch (error: any) {\n                lemonToast.error(error.detail || 'Failed to create experiment')\n                actions.setCreateExperimentLoading(false)\n                return\n            }\n\n            if (response?.id) {\n                const experimentId = response.id\n                refreshTreeItem('experiment', String(experimentId))\n                router.actions.push(urls.experiment(experimentId))\n                actions.addToExperiments(response)\n                lemonToast.success(`Experiment ${isUpdate ? 'updated' : 'created'}`, {\n                    button: {\n                        label: 'View it',\n                        action: () => {\n                            router.actions.push(urls.experiment(experimentId))\n                        },\n                    },\n                })\n            }\n            actions.setCreateExperimentLoading(false)\n        },\n        setExperimentType: async ({ type }) => {\n            actions.setExperiment({ type: type })\n        },\n        loadExperimentSuccess: async ({ experiment }) => {\n            const duration = experiment?.start_date ? dayjs().diff(experiment.start_date, 'second') : null\n            experiment && actions.reportExperimentViewed(experiment, duration)\n\n            if (experiment?.start_date) {\n                actions.refreshExperimentResults()\n            }\n        },\n        launchExperiment: async () => {\n            const startDate = dayjs()\n            actions.updateExperiment({ start_date: startDate.toISOString() })\n            values.experiment && eventUsageLogic.actions.reportExperimentLaunched(values.experiment, startDate)\n            activationLogic.findMounted()?.actions.markTaskAsCompleted(ActivationTask.LaunchExperiment)\n        },\n        changeExperimentStartDate: async ({ startDate }) => {\n            actions.updateExperiment({ start_date: startDate })\n            values.experiment && eventUsageLogic.actions.reportExperimentStartDateChange(values.experiment, startDate)\n        },\n        changeExperimentEndDate: async ({ endDate }) => {\n            actions.updateExperiment({ end_date: endDate })\n            values.experiment && eventUsageLogic.actions.reportExperimentEndDateChange(values.experiment, endDate)\n        },\n        endExperiment: async () => {\n            const endDate = dayjs()\n            actions.updateExperiment({\n                end_date: endDate.toISOString(),\n                conclusion: values.experiment.conclusion,\n                conclusion_comment: values.experiment.conclusion_comment,\n            })\n            const duration = endDate.diff(values.experiment?.start_date, 'second')\n            values.experiment &&\n                actions.reportExperimentCompleted(\n                    values.experiment,\n                    endDate,\n                    duration,\n                    values.experiment.metrics?.[0]?.uuid\n                        ? values.isPrimaryMetricSignificant(values.experiment.metrics[0].uuid)\n                        : false\n                )\n            actions.closeStopExperimentModal()\n        },\n        archiveExperiment: async () => {\n            actions.updateExperiment({ archived: true })\n            values.experiment && actions.reportExperimentArchived(values.experiment)\n        },\n        refreshExperimentResults: async ({ forceRefresh }) => {\n            actions.loadPrimaryMetricsResults(forceRefresh)\n            actions.loadSecondaryMetricsResults(forceRefresh)\n            actions.loadExposures(forceRefresh)\n        },\n        updateExperimentMetrics: async () => {\n            actions.updateExperiment({\n                metrics: values.experiment.metrics,\n                metrics_secondary: values.experiment.metrics_secondary,\n                primary_metrics_ordered_uuids: values.experiment.primary_metrics_ordered_uuids,\n                secondary_metrics_ordered_uuids: values.experiment.secondary_metrics_ordered_uuids,\n            })\n        },\n        updateExperimentCollectionGoal: async () => {\n            const { recommendedRunningTime, recommendedSampleSize, minimumDetectableEffect } = values\n\n            actions.updateExperiment({\n                parameters: {\n                    ...values.experiment?.parameters,\n                    recommended_running_time: recommendedRunningTime,\n                    recommended_sample_size: recommendedSampleSize,\n                    minimum_detectable_effect: minimumDetectableEffect || 0,\n                },\n            })\n        },\n        updateExposureCriteria: async () => {\n            actions.updateExperiment({\n                exposure_criteria: {\n                    ...values.experiment.exposure_criteria,\n                },\n            })\n            actions.refreshExperimentResults(true)\n        },\n        resetRunningExperiment: async () => {\n            actions.updateExperiment({\n                start_date: null,\n                end_date: null,\n                archived: false,\n                conclusion: null,\n                conclusion_comment: null,\n            })\n            values.experiment && actions.reportExperimentReset(values.experiment)\n            actions.setLegacyPrimaryMetricsResults([])\n            actions.setLegacySecondaryMetricsResults([])\n        },\n        updateExperimentSuccess: async ({ experiment, payload }) => {\n            actions.updateExperiments(experiment)\n            if (experiment.start_date) {\n                const forceRefresh = payload?.start_date !== undefined || payload?.end_date !== undefined\n                actions.refreshExperimentResults(forceRefresh)\n            }\n        },\n        createExposureCohortSuccess: ({ exposureCohort }) => {\n            if (exposureCohort && exposureCohort.id !== 'new') {\n                cohortsModel.actions.cohortCreated(exposureCohort)\n                actions.reportExperimentExposureCohortCreated(values.experiment, exposureCohort)\n                actions.setExperiment({ exposure_cohort: exposureCohort.id })\n                lemonToast.success('Exposure cohort created successfully', {\n                    button: {\n                        label: 'View cohort',\n                        action: () => router.actions.push(urls.cohort(exposureCohort.id)),\n                    },\n                })\n            }\n        },\n        shipVariantSuccess: ({ payload }) => {\n            lemonToast.success('The selected variant has been shipped')\n            actions.closeShipVariantModal()\n            if (payload.shouldStopExperiment && !values.isExperimentStopped) {\n                actions.endExperiment()\n            }\n            actions.reportExperimentVariantShipped(values.experiment)\n\n            actions.openStopExperimentModal()\n        },\n        shipVariantFailure: ({ error }) => {\n            lemonToast.error(error)\n            actions.closeShipVariantModal()\n        },\n        updateExperimentVariantImages: async ({ variantPreviewMediaIds }) => {\n            try {\n                const updatedParameters = {\n                    ...values.experiment.parameters,\n                    variant_screenshot_media_ids: variantPreviewMediaIds,\n                }\n                await api.update(`api/projects/${values.currentProjectId}/experiments/${values.experimentId}`, {\n                    parameters: updatedParameters,\n                })\n                actions.setExperiment({\n                    parameters: updatedParameters,\n                })\n            } catch {\n                lemonToast.error('Failed to update experiment variant images')\n            }\n        },\n        updateDistribution: async ({ featureFlag }) => {\n            const { created_at, id, ...flag } = featureFlag\n\n            const preparedFlag = indexToVariantKeyFeatureFlagPayloads(flag)\n\n            const savedFlag = await api.update(\n                `api/projects/${values.currentProjectId}/feature_flags/${id}`,\n                preparedFlag\n            )\n\n            const updatedFlag = variantKeyToIndexFeatureFlagPayloads(savedFlag)\n            actions.updateFlag(updatedFlag)\n\n            actions.updateExperiment({\n                holdout_id: values.experiment.holdout_id,\n            })\n        },\n        addSharedMetricsToExperiment: async ({ sharedMetricIds, metadata }) => {\n            const existingMetricsIds = values.experiment.saved_metrics.map((sharedMetric) => ({\n                id: sharedMetric.saved_metric,\n                metadata: sharedMetric.metadata,\n            }))\n\n            const newMetricsIds = sharedMetricIds.map((id: SharedMetric['id']) => ({ id, metadata }))\n            newMetricsIds.forEach((metricId) => {\n                const metric = values.sharedMetrics.find((m: SharedMetric) => m.id === metricId.id)\n                if (metric) {\n                    actions.reportExperimentSharedMetricAssigned(values.experimentId, metric)\n                }\n            })\n            const combinedMetricsIds = [...existingMetricsIds, ...newMetricsIds]\n\n            await api.update(`api/projects/${values.currentProjectId}/experiments/${values.experimentId}`, {\n                saved_metrics_ids: combinedMetricsIds,\n                primary_metrics_ordered_uuids: values.experiment.primary_metrics_ordered_uuids,\n                secondary_metrics_ordered_uuids: values.experiment.secondary_metrics_ordered_uuids,\n            })\n\n            actions.loadExperiment()\n        },\n        removeSharedMetricFromExperiment: async ({ sharedMetricId }) => {\n            const sharedMetricsIds = values.experiment.saved_metrics\n                .filter((sharedMetric) => sharedMetric.saved_metric !== sharedMetricId)\n                .map((sharedMetric) => ({\n                    id: sharedMetric.saved_metric,\n                    metadata: sharedMetric.metadata,\n                }))\n            await api.update(`api/projects/${values.currentProjectId}/experiments/${values.experimentId}`, {\n                saved_metrics_ids: sharedMetricsIds,\n                primary_metrics_ordered_uuids: values.experiment.primary_metrics_ordered_uuids,\n                secondary_metrics_ordered_uuids: values.experiment.secondary_metrics_ordered_uuids,\n            })\n\n            actions.loadExperiment()\n        },\n        createExperimentDashboard: async () => {\n            actions.setIsCreatingExperimentDashboard(true)\n\n            /**\n             * create a query builder to transform the experiment metric into a query\n             * that can be used to create an insight\n             */\n            const queryBuilder = compose<\n                ExperimentMetric,\n                ExperimentMetric,\n                FunnelsQuery | TrendsQuery | undefined,\n                InsightVizNode | undefined\n            >(\n                addExposureToMetric({\n                    kind: NodeKind.EventsNode,\n                    event: '$pageview',\n                    custom_name: 'Placeholder for experiment exposure',\n                    properties: [],\n                }),\n                getQuery(),\n                getInsight()\n            )\n\n            try {\n                /**\n                 * get the experiment url for the dashboard description\n                 */\n                const experimentUrl =\n                    window.location.origin + addProjectIdIfMissing(urls.experiment(values.experimentId))\n\n                /**\n                 * create a new dashboard\n                 */\n                const dashboard: DashboardType = await api.create(\n                    `api/environments/${teamLogic.values.currentTeamId}/dashboards/`,\n                    {\n                        name: 'Experiment: ' + values.experiment.name,\n                        description: `Dashboard for [${experimentUrl}](${experimentUrl})`,\n                        filters: {\n                            date_from: values.experiment.start_date,\n                            date_to: values.experiment.end_date,\n                            properties: [],\n                            breakdown_filter: {\n                                breakdown: '$feature/' + values.experiment.feature_flag_key,\n                                breakdown_type: 'event' as BreakdownType,\n                            },\n                        },\n                    } as Partial<DashboardType>\n                )\n\n                /**\n                 * create a new insight for each metric, either primary or secondary\n                 * reverse the order of the metric because adding an insight to the dashboard\n                 * places it at the beginning of the list\n                 */\n                for (const type of ['secondary', 'primary']) {\n                    const singleMetrics =\n                        type === 'secondary' ? values.experiment.metrics_secondary : values.experiment.metrics\n                    const sharedMetrics = values.experiment?.saved_metrics.filter(\n                        (sharedMetric) => sharedMetric.metadata.type === type\n                    )\n                    const metrics = [\n                        ...singleMetrics,\n                        ...sharedMetrics.map((m) => ({ name: m.name, ...m.query })),\n                    ].reverse()\n\n                    for (const query of metrics) {\n                        const insightQuery = queryBuilder(query)\n\n                        await api.create(`api/projects/${projectLogic.values.currentProjectId}/insights`, {\n                            name: query.name || undefined,\n                            query: insightQuery,\n                            dashboards: [dashboard.id],\n                        })\n                    }\n                }\n\n                actions.reportExperimentDashboardCreated(values.experiment, dashboard.id)\n\n                const dashboardUrl = window.location.origin + addProjectIdIfMissing(urls.dashboard(dashboard.id))\n                actions.updateExperiment({\n                    description:\n                        (values.experiment.description ? values.experiment.description + `\\n\\n` : '') +\n                        `Dashboard: [${dashboardUrl}](${dashboardUrl})`,\n                })\n\n                lemonToast.success('Dashboard created successfully', {\n                    button: {\n                        label: 'View dashboard',\n                        action: () => router.actions.push(`/dashboard/${dashboard.id}`),\n                    },\n                })\n            } catch (error: any) {\n                if (!isBreakpoint(error)) {\n                    const message = error.code && error.detail ? `${error.code}: ${error.detail}` : error\n                    lemonToast.error(`Could not create dashboard: ${message}`)\n                }\n            }\n            actions.setIsCreatingExperimentDashboard(false)\n        },\n        restoreUnmodifiedExperiment: () => {\n            if (values.unmodifiedExperiment) {\n                actions.setExperiment(structuredClone(values.unmodifiedExperiment))\n            }\n        },\n        validateFeatureFlag: async ({ featureFlagKey }: { featureFlagKey: string }, breakpoint) => {\n            await breakpoint(200)\n            const response = await api.get(\n                `api/projects/${values.currentProjectId}/feature_flags/?${toParams({ search: featureFlagKey })}`\n            )\n            const existingErrors = {\n                // :KLUDGE: If there is no name error, we don't want to trigger the 'required' error early\n                name: undefined,\n                ...values.experimentErrors,\n            }\n            if (response.results.length > 0) {\n                const matchingFlag = response.results.find((flag: FeatureFlagType) => flag.key === featureFlagKey)\n                if (matchingFlag) {\n                    let isValid\n                    try {\n                        isValid = featureFlagEligibleForExperiment(matchingFlag)\n                    } catch {\n                        isValid = false\n                    }\n                    actions.setValidExistingFeatureFlag(isValid ? matchingFlag : null)\n                    actions.setFeatureFlagValidationError(\n                        isValid ? '' : 'Existing feature flag is not eligible for experiments.'\n                    )\n                    actions.setExperimentManualErrors({\n                        ...existingErrors,\n                        feature_flag_key: values.featureFlagValidationError || undefined,\n                    })\n                    return\n                }\n            }\n\n            actions.setValidExistingFeatureFlag(null)\n            actions.setFeatureFlagValidationError(validateFeatureFlagKey(featureFlagKey) || '')\n            actions.setExperimentManualErrors({\n                ...existingErrors,\n                feature_flag_key: values.featureFlagValidationError || undefined,\n            })\n        },\n        touchExperimentField: ({ key }) => {\n            // :KLUDGE: Persist the existing feature_flag_key validation when the field is blurred.\n            if (key === 'feature_flag_key') {\n                actions.setExperimentManualErrors({\n                    feature_flag_key: values.featureFlagValidationError || undefined,\n                })\n            }\n        },\n        loadPrimaryMetricsResults: async ({ refresh }: { refresh?: boolean }) => {\n            actions.setPrimaryMetricsResultsLoading(true)\n            actions.setLegacyPrimaryMetricsResults([])\n            actions.setPrimaryMetricsResults([])\n\n            let metrics = values.experiment?.metrics\n            const sharedMetrics = values.experiment?.saved_metrics\n                .filter((sharedMetric) => sharedMetric.metadata.type === 'primary')\n                .map((sharedMetric) => sharedMetric.query)\n            if (sharedMetrics) {\n                metrics = [...metrics, ...sharedMetrics]\n            }\n\n            await loadMetrics({\n                metrics,\n                experimentId: values.experimentId,\n                refresh,\n                onSetLegacyResults: actions.setLegacyPrimaryMetricsResults,\n                onSetResults: actions.setPrimaryMetricsResults,\n                onSetErrors: actions.setPrimaryMetricsResultsErrors,\n                onTimeout: actions.reportExperimentMetricTimeout,\n            })\n\n            actions.setPrimaryMetricsResultsLoading(false)\n        },\n        loadSecondaryMetricsResults: async ({ refresh }: { refresh?: boolean }) => {\n            actions.setSecondaryMetricsResultsLoading(true)\n            actions.setLegacySecondaryMetricsResults([])\n            actions.setSecondaryMetricsResults([])\n\n            let secondaryMetrics = values.experiment?.metrics_secondary\n            const sharedMetrics = values.experiment?.saved_metrics\n                .filter((sharedMetric) => sharedMetric.metadata.type === 'secondary')\n                .map((sharedMetric) => sharedMetric.query)\n            if (sharedMetrics) {\n                secondaryMetrics = [...secondaryMetrics, ...sharedMetrics]\n            }\n\n            await loadMetrics({\n                metrics: secondaryMetrics,\n                experimentId: values.experimentId,\n                refresh,\n                onSetLegacyResults: actions.setLegacySecondaryMetricsResults,\n                onSetResults: actions.setSecondaryMetricsResults,\n                onSetErrors: actions.setSecondaryMetricsResultsErrors,\n                onTimeout: actions.reportExperimentMetricTimeout,\n            })\n\n            actions.setSecondaryMetricsResultsLoading(false)\n        },\n        openReleaseConditionsModal: () => {\n            const numericFlagId = values.experiment.feature_flag?.id\n            if (numericFlagId) {\n                const logic = sceneFeatureFlagLogic.findMounted() || sceneFeatureFlagLogic({ id: numericFlagId })\n                if (logic) {\n                    logic.actions.loadFeatureFlag() // Access the loader through actions\n                }\n            }\n        },\n    })),\n    loaders(({ actions, props, values }) => ({\n        experiment: {\n            loadExperiment: async () => {\n                if (props.experimentId && props.experimentId !== 'new') {\n                    try {\n                        let response: Experiment = await api.get(\n                            `api/projects/${values.currentProjectId}/experiments/${props.experimentId}`\n                        )\n\n                        /**\n                         * if we are duplicating, we need to clear a lot of props to ensure that\n                         * the experiment will be in draft mode and available for launch\n                         */\n                        if (props.formMode === FORM_MODES.duplicate) {\n                            response = {\n                                ...response,\n                                name: `${response.name} (duplicate)`,\n                                parameters: {\n                                    ...response.parameters,\n                                    feature_flag_variants: NEW_EXPERIMENT.parameters.feature_flag_variants,\n                                },\n                                feature_flag: undefined,\n                                feature_flag_key: '',\n                                archived: false,\n                                start_date: undefined,\n                                end_date: undefined,\n                                conclusion: undefined,\n                                conclusion_comment: undefined,\n                                created_by: null,\n                                created_at: null,\n                                updated_at: null,\n                            }\n                        }\n\n                        const responseWithMetricsOrdering = initializeMetricOrdering(response)\n\n                        actions.setUnmodifiedExperiment(structuredClone(responseWithMetricsOrdering))\n                        return responseWithMetricsOrdering\n                    } catch (error: any) {\n                        if (error.status === 404) {\n                            actions.setExperimentMissing()\n                        } else {\n                            throw error\n                        }\n                    }\n                }\n                return NEW_EXPERIMENT\n            },\n            updateExperiment: async (update: Partial<Experiment>) => {\n                const response: Experiment = await api.update(\n                    `api/projects/${values.currentProjectId}/experiments/${values.experimentId}`,\n                    update\n                )\n                const responseWithMetricsOrdering = initializeMetricOrdering(response)\n                refreshTreeItem('experiment', String(values.experimentId))\n                actions.setUnmodifiedExperiment(structuredClone(responseWithMetricsOrdering))\n                return responseWithMetricsOrdering\n            },\n        },\n        exposureCohort: [\n            null as CohortType | null,\n            {\n                createExposureCohort: async () => {\n                    if (props.experimentId && props.experimentId !== 'new' && props.experimentId !== 'web') {\n                        return (await api.experiments.createExposureCohort(props.experimentId)).cohort\n                    }\n                    return null\n                },\n            },\n        ],\n        featureFlag: [\n            null as FeatureFlagType | null,\n            {\n                shipVariant: async ({ selectedVariantKey, shouldStopExperiment }) => {\n                    if (!values.experiment.feature_flag) {\n                        throw new Error('Experiment does not have a feature flag linked')\n                    }\n\n                    const currentFlagFilters = values.experiment.feature_flag?.filters\n                    const newFilters = transformFiltersForWinningVariant(currentFlagFilters, selectedVariantKey)\n\n                    await api.update(\n                        `api/projects/${values.currentProjectId}/feature_flags/${values.experiment.feature_flag?.id}`,\n                        { filters: newFilters }\n                    )\n\n                    return shouldStopExperiment\n                },\n            },\n        ],\n        exposures: [\n            null as any,\n            {\n                loadExposures: async (refresh: boolean = false) => {\n                    const { experiment, usesNewQueryRunner } = values\n\n                    if (!usesNewQueryRunner) {\n                        return\n                    }\n\n                    const query = setLatestVersionsOnQuery({\n                        kind: NodeKind.ExperimentExposureQuery,\n                        experiment_id: props.experimentId,\n                        experiment_name: experiment.name,\n                        exposure_criteria: experiment.exposure_criteria,\n                        feature_flag: experiment.feature_flag,\n                        start_date: experiment.start_date,\n                        end_date: experiment.end_date,\n                        holdout: experiment.holdout,\n                    })\n                    return await performQuery(query, undefined, refresh ? 'force_async' : 'async')\n                },\n            },\n        ],\n    })),\n    selectors({\n        props: [() => [(_, props) => props], (props) => props],\n        experimentId: [\n            () => [(_, props) => props.experimentId ?? 'new'],\n            (experimentId): Experiment['id'] => experimentId,\n        ],\n        formMode: [() => [(_, props) => props.formMode], (action: FormModes) => action],\n        getInsightType: [\n            () => [],\n            () =>\n                (\n                    metric: ExperimentMetric | ExperimentTrendsQuery | ExperimentFunnelsQuery | undefined\n                ): InsightType => {\n                    return metric &&\n                        ((metric.kind === NodeKind.ExperimentMetric &&\n                            metric.metric_type === ExperimentMetricType.MEAN) ||\n                            metric?.kind === NodeKind.ExperimentTrendsQuery)\n                        ? InsightType.TRENDS\n                        : InsightType.FUNNELS\n                },\n        ],\n        getExperimentMetricType: [\n            () => [],\n            () =>\n                (metric: ExperimentMetric | undefined): ExperimentMetricType => {\n                    return metric?.metric_type || ExperimentMetricType.MEAN\n                },\n        ],\n        isExperimentDraft: [\n            (s) => [s.experiment],\n            (experiment): boolean => {\n                return !experiment?.start_date && !experiment?.end_date && !experiment?.archived\n            },\n        ],\n        isExperimentRunning: [\n            (s) => [s.experiment],\n            (experiment): boolean => {\n                return !!experiment?.start_date\n            },\n        ],\n        isExperimentStopped: [\n            (s) => [s.experiment],\n            (experiment): boolean => {\n                return (\n                    !!experiment?.end_date &&\n                    dayjs().isSameOrAfter(dayjs(experiment.end_date), 'day') &&\n                    !experiment.archived\n                )\n            },\n        ],\n        breadcrumbs: [\n            (s) => [s.experiment, s.experimentId],\n            (experiment, experimentId): Breadcrumb[] => {\n                return [\n                    {\n                        key: Scene.Experiments,\n                        name: sceneConfigurations[Scene.Experiments].name || 'Experiments',\n                        path: urls.experiments(),\n                        iconType: sceneConfigurations[Scene.Experiments].iconType || 'default_icon_type',\n                    },\n                    {\n                        key: [Scene.Experiment, experimentId],\n                        name: experiment?.name || 'New Experiment',\n                        iconType: sceneConfigurations[Scene.Experiment].iconType || 'default_icon_type',\n                    },\n                ]\n            },\n        ],\n        [SIDE_PANEL_CONTEXT_KEY]: [\n            (s) => [s.experimentId],\n            (experimentId: Experiment['id']): SidePanelSceneContext | null => {\n                return experimentId && experimentId !== 'new'\n                    ? {\n                          activity_scope: ActivityScope.EXPERIMENT,\n                          activity_item_id: `${experimentId}`,\n                      }\n                    : null\n            },\n        ],\n        projectTreeRef: [\n            () => [(_, props: ExperimentLogicProps) => props.experimentId],\n            (experimentId): ProjectTreeRef => {\n                return { type: 'experiment', ref: experimentId === 'new' ? null : String(experimentId) }\n            },\n        ],\n        variants: [\n            (s) => [s.experiment],\n            (experiment): MultivariateFlagVariant[] => {\n                return experiment?.parameters?.feature_flag_variants || []\n            },\n        ],\n        experimentMathAggregationForTrends: [\n            (s) => [s.experiment],\n            (experiment) => (): PropertyMathType | CountPerActorMathType | undefined => {\n                const query = experiment?.metrics?.[0] as ExperimentTrendsQuery\n                if (!query) {\n                    return undefined\n                }\n                const entities = query.count_query?.series || []\n\n                // Find out if we're using count per actor math aggregates averages per user\n                const userMathValue = entities.filter((entity) =>\n                    Object.values(CountPerActorMathType).includes(entity?.math as CountPerActorMathType)\n                )[0]?.math\n\n                // alternatively, if we're using property math\n                // remove 'sum' property math from the list of math types\n                // since we can handle that as a regular case\n                const targetValues = Object.values(PropertyMathType).filter((value) => value !== PropertyMathType.Sum)\n\n                const propertyMathValue = entities.filter((entity) =>\n                    (targetValues as readonly PropertyMathType[]).includes(entity?.math as PropertyMathType)\n                )[0]?.math\n\n                return (userMathValue ?? propertyMathValue) as PropertyMathType | CountPerActorMathType | undefined\n            },\n        ],\n        minimumDetectableEffect: [\n            (s) => [s.experiment],\n            (newExperiment): number => {\n                return newExperiment?.parameters?.minimum_detectable_effect ?? DEFAULT_MDE\n            },\n        ],\n        isPrimaryMetricSignificant: [\n            (s) => [s.legacyPrimaryMetricsResults, s.experiment],\n            (\n                    legacyPrimaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    experiment: Experiment\n                ) =>\n                (metricUuid: string): boolean => {\n                    // Find metric index by UUID\n                    const index = experiment.metrics.findIndex((m) => m.uuid === metricUuid)\n                    if (index === -1) {\n                        return false\n                    }\n\n                    const result = legacyPrimaryMetricsResults?.[index]\n                    if (!result) {\n                        return false\n                    }\n\n                    return result.significant || false\n                },\n        ],\n        isSecondaryMetricSignificant: [\n            (s) => [s.legacySecondaryMetricsResults, s.experiment],\n            (\n                    legacySecondaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    experiment: Experiment\n                ) =>\n                (metricUuid: string): boolean => {\n                    // Find metric index by UUID\n                    const index = experiment.metrics_secondary.findIndex((m) => m.uuid === metricUuid)\n                    if (index === -1) {\n                        return false\n                    }\n\n                    const result = legacySecondaryMetricsResults?.[index]\n                    if (!result) {\n                        return false\n                    }\n\n                    return result.significant || false\n                },\n        ],\n        significanceDetails: [\n            (s) => [s.legacyPrimaryMetricsResults, s.experiment],\n            (\n                    legacyPrimaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    experiment: Experiment\n                ) =>\n                (metricUuid: string): string => {\n                    // Find metric index by UUID\n                    const index = experiment.metrics.findIndex((m) => m.uuid === metricUuid)\n                    if (index === -1) {\n                        return ''\n                    }\n\n                    const results = legacyPrimaryMetricsResults?.[index]\n                    return getSignificanceDetails(results)\n                },\n        ],\n        recommendedSampleSize: [\n            (s) => [s.conversionMetrics, s.variants, s.minimumDetectableEffect],\n            (conversionMetrics, variants, minimumDetectableEffect): number => {\n                const conversionRate = conversionMetrics.totalRate * 100\n                const sampleSizePerVariant = minimumSampleSizePerVariant(minimumDetectableEffect, conversionRate)\n                const sampleSize = sampleSizePerVariant * variants.length\n                return sampleSize\n            },\n        ],\n        recommendedRunningTime: [\n            (s) => [\n                s.experiment,\n                s.variants,\n                s.getInsightType,\n                s.firstPrimaryMetric,\n                s.funnelResults,\n                s.conversionMetrics,\n                s.trendResults,\n                s.minimumDetectableEffect,\n            ],\n            (\n                experiment,\n                variants,\n                getInsightType,\n                firstPrimaryMetric,\n                funnelResults,\n                conversionMetrics,\n                trendResults,\n                minimumDetectableEffect\n            ): number => {\n                if (getInsightType(firstPrimaryMetric) === InsightType.FUNNELS) {\n                    const currentDuration = dayjs().diff(dayjs(experiment?.start_date), 'hour')\n                    let funnelEntrants: number | undefined\n                    if (Array.isArray(funnelResults) && funnelResults[0]) {\n                        const firstFunnelEntry = funnelResults[0]\n\n                        funnelEntrants = Array.isArray(firstFunnelEntry)\n                            ? firstFunnelEntry[0].count\n                            : firstFunnelEntry.count\n                    }\n\n                    const conversionRate = conversionMetrics.totalRate * 100\n                    const sampleSizePerVariant = minimumSampleSizePerVariant(minimumDetectableEffect, conversionRate)\n                    const funnelSampleSize = sampleSizePerVariant * variants.length\n                    if (experiment?.start_date) {\n                        return expectedRunningTime(funnelEntrants || 1, funnelSampleSize || 0, currentDuration)\n                    }\n                    return expectedRunningTime(funnelEntrants || 1, funnelSampleSize || 0)\n                }\n\n                const trendCount = trendResults[0]?.count\n                const runningTime = recommendedExposureForCountData(minimumDetectableEffect, trendCount)\n                return runningTime\n            },\n        ],\n        tabularExperimentResults: [\n            (s) => [s.experiment, s.legacyPrimaryMetricsResults, s.legacySecondaryMetricsResults, s.getInsightType],\n            (\n                    experiment,\n                    legacyPrimaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    legacySecondaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    getInsightType\n                ) =>\n                (metricIdentifier: number | string = 0, isSecondary: boolean = false): any[] => {\n                    let index: number\n                    if (typeof metricIdentifier === 'string') {\n                        // Find index by UUID\n                        const metrics = isSecondary ? experiment.metrics_secondary : experiment.metrics\n                        index = metrics.findIndex((m) => m.uuid === metricIdentifier)\n                        if (index === -1) {\n                            return []\n                        }\n                    } else {\n                        index = metricIdentifier\n                    }\n\n                    const tabularResults = []\n                    const metricType = isSecondary\n                        ? getInsightType(experiment.metrics_secondary[index])\n                        : getInsightType(experiment.metrics[index])\n                    const result = isSecondary\n                        ? legacySecondaryMetricsResults[index]\n                        : legacyPrimaryMetricsResults[index]\n\n                    if (result) {\n                        for (const variantObj of result.variants) {\n                            if (metricType === InsightType.FUNNELS) {\n                                const { key, success_count, failure_count } = variantObj as FunnelExperimentVariant\n                                tabularResults.push({ key, success_count, failure_count })\n                            } else if (metricType === InsightType.TRENDS) {\n                                const { key, count, exposure, absolute_exposure } = variantObj as TrendExperimentVariant\n                                tabularResults.push({ key, count, exposure, absolute_exposure })\n                            }\n                        }\n                    }\n\n                    if (experiment.feature_flag?.filters.multivariate?.variants) {\n                        for (const { key } of experiment.feature_flag.filters.multivariate.variants) {\n                            if (tabularResults.find((variantObj) => variantObj.key === key)) {\n                                continue\n                            }\n\n                            if (metricType === InsightType.FUNNELS) {\n                                tabularResults.push({ key, success_count: null, failure_count: null })\n                            } else if (metricType === InsightType.TRENDS) {\n                                tabularResults.push({ key, count: null, exposure: null, absolute_exposure: null })\n                            }\n                        }\n                    }\n\n                    return tabularResults\n                },\n        ],\n        sortedWinProbabilities: [\n            (s) => [s.legacyPrimaryMetricsResults, s.experiment],\n            (\n                    legacyPrimaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    experiment: Experiment\n                ) =>\n                (metricIdentifier: number | string = 0) => {\n                    let index: number\n                    if (typeof metricIdentifier === 'string') {\n                        // Find index by UUID\n                        index = experiment.metrics.findIndex((m) => m.uuid === metricIdentifier)\n                        if (index === -1) {\n                            return []\n                        }\n                    } else {\n                        index = metricIdentifier\n                    }\n\n                    const result = legacyPrimaryMetricsResults?.[index]\n\n                    if (!result) {\n                        return []\n                    }\n\n                    return Object.keys(result.probability)\n                        .map((key) => ({\n                            key,\n                            winProbability: result.probability[key],\n                            conversionRate: conversionRateForVariant(result, key),\n                        }))\n                        .sort((a, b) => b.winProbability - a.winProbability)\n                },\n        ],\n        funnelResultsPersonsTotal: [\n            (s) => [s.experiment, s.legacyPrimaryMetricsResults, s.getInsightType],\n            (\n                    experiment,\n                    legacyPrimaryMetricsResults: (\n                        | CachedLegacyExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    getInsightType\n                ) =>\n                (metricIdentifier: number | string = 0): number => {\n                    let index: number\n                    if (typeof metricIdentifier === 'string') {\n                        // Find index by UUID\n                        index = experiment.metrics.findIndex((m) => m.uuid === metricIdentifier)\n                        if (index === -1) {\n                            return 0\n                        }\n                    } else {\n                        index = metricIdentifier\n                    }\n\n                    const result = legacyPrimaryMetricsResults?.[index]\n\n                    if (getInsightType(experiment.metrics[index]) !== InsightType.FUNNELS || !result) {\n                        return 0\n                    }\n\n                    let sum = 0\n                    result.insight.forEach((variantResult) => {\n                        if (variantResult[0]?.count) {\n                            sum += variantResult[0].count\n                        }\n                    })\n                    return sum\n                },\n        ],\n        actualRunningTime: [\n            (s) => [s.experiment],\n            (experiment: Experiment): number => {\n                if (!experiment.start_date) {\n                    return 0\n                }\n\n                if (experiment.end_date) {\n                    return dayjs(experiment.end_date).diff(experiment.start_date, 'day')\n                }\n\n                return dayjs().diff(experiment.start_date, 'day')\n            },\n        ],\n        isSingleVariantShipped: [\n            (s) => [s.experiment],\n            (experiment: Experiment): boolean => {\n                const filters = experiment.feature_flag?.filters\n\n                return (\n                    !!filters &&\n                    Array.isArray(filters.groups?.[0]?.properties) &&\n                    filters.groups?.[0]?.properties?.length === 0 &&\n                    filters.groups?.[0]?.rollout_percentage === 100 &&\n                    (filters.multivariate?.variants?.some(({ rollout_percentage }) => rollout_percentage === 100) ||\n                        false)\n                )\n            },\n        ],\n        hasPrimaryMetricSet: [\n            (s) => [s.primaryMetricsLengthWithSharedMetrics],\n            (primaryMetricsLengthWithSharedMetrics): boolean => {\n                return primaryMetricsLengthWithSharedMetrics > 0\n            },\n        ],\n        firstPrimaryMetric: [\n            (s) => [s.experiment],\n            (experiment: Experiment): ExperimentMetric | ExperimentTrendsQuery | ExperimentFunnelsQuery | undefined => {\n                if (experiment.metrics.length) {\n                    return experiment.metrics[0]\n                }\n                const primaryMetric = experiment.saved_metrics.find((metric) => metric.metadata.type === 'primary')\n                if (primaryMetric) {\n                    return primaryMetric.query\n                }\n            },\n        ],\n        primaryMetricsLengthWithSharedMetrics: [\n            (s) => [s.experiment],\n            (experiment: Experiment): number => {\n                return (\n                    experiment.metrics.length +\n                    experiment.saved_metrics.filter((savedMetric) => savedMetric.metadata.type === 'primary').length\n                )\n            },\n        ],\n        secondaryMetricsLengthWithSharedMetrics: [\n            (s) => [s.experiment],\n            (experiment: Experiment): number => {\n                return (\n                    experiment.metrics_secondary.length +\n                    experiment.saved_metrics.filter((savedMetric) => savedMetric.metadata.type === 'secondary').length\n                )\n            },\n        ],\n        compatibleSharedMetrics: [\n            (s) => [s.sharedMetrics, s.usesNewQueryRunner],\n            (sharedMetrics: SharedMetric[], usesNewQueryRunner: boolean): SharedMetric[] => {\n                if (!sharedMetrics) {\n                    return []\n                }\n                if (usesNewQueryRunner) {\n                    return sharedMetrics.filter((metric) => metric.query.kind === NodeKind.ExperimentMetric)\n                }\n                return sharedMetrics.filter((metric) => metric.query.kind !== NodeKind.ExperimentMetric)\n            },\n        ],\n        usesNewQueryRunner: [\n            (s) => [s.experiment],\n            (experiment: Experiment): boolean => {\n                const hasLegacyMetrics = isLegacyExperiment(experiment)\n\n                const allMetrics = [...experiment.metrics, ...experiment.metrics_secondary, ...experiment.saved_metrics]\n                const hasExperimentMetrics = allMetrics.some((query) => query.kind === NodeKind.ExperimentMetric)\n\n                if (hasExperimentMetrics) {\n                    return true\n                }\n\n                if (hasLegacyMetrics) {\n                    return false\n                }\n\n                // If the experiment has no experiment metrics, we use the new query runner\n                return true\n            },\n        ],\n        hasMinimumExposureForResults: [\n            (s) => [s.exposures, s.usesNewQueryRunner],\n            (exposures: ExperimentExposureQueryResponse, usesNewQueryRunner: boolean): boolean => {\n                // Not relevant for old metrics\n                if (!usesNewQueryRunner) {\n                    return true\n                }\n\n                if (!exposures || !exposures.total_exposures) {\n                    return false\n                }\n\n                const total_experiment_exposures = Object.values(exposures.total_exposures).reduce(\n                    (acc, curr) => acc + curr,\n                    0\n                )\n\n                if (total_experiment_exposures < EXPERIMENT_MIN_EXPOSURES_FOR_RESULTS) {\n                    return false\n                }\n\n                return true\n            },\n        ],\n        exposureCriteria: [\n            (s) => [s.experiment],\n            (experiment: Experiment): ExperimentExposureCriteria | undefined => {\n                return experiment.exposure_criteria\n            },\n        ],\n        getOrderedMetrics: [\n            (s) => [s.experiment],\n            (experiment: Experiment) =>\n                (isSecondary: boolean): ExperimentMetric[] => {\n                    if (!experiment) {\n                        return []\n                    }\n\n                    const metricType = isSecondary ? 'secondary' : 'primary'\n                    const regularMetrics = isSecondary\n                        ? ((experiment.metrics_secondary || []) as ExperimentMetric[])\n                        : ((experiment.metrics || []) as ExperimentMetric[])\n\n                    const sharedMetrics = (experiment.saved_metrics || [])\n                        .filter((sharedMetric) => sharedMetric.metadata.type === metricType)\n                        .map((sharedMetric) => ({\n                            ...sharedMetric.query,\n                            name: sharedMetric.name,\n                            sharedMetricId: sharedMetric.saved_metric,\n                            isSharedMetric: true,\n                        })) as ExperimentMetric[]\n\n                    const allMetrics = [...regularMetrics, ...sharedMetrics]\n\n                    const metricsMap = new Map()\n                    allMetrics.forEach((metric: any) => {\n                        const uuid = metric.uuid || metric.query?.uuid\n                        if (uuid) {\n                            metricsMap.set(uuid, metric)\n                        }\n                    })\n\n                    const orderedUuids = isSecondary\n                        ? experiment.secondary_metrics_ordered_uuids || []\n                        : experiment.primary_metrics_ordered_uuids || []\n\n                    return orderedUuids.map((uuid) => metricsMap.get(uuid)).filter(Boolean) as ExperimentMetric[]\n                },\n        ],\n        statsMethod: [\n            (s) => [s.experiment],\n            (experiment: Experiment): ExperimentStatsMethod => {\n                return experiment.stats_config?.method || ExperimentStatsMethod.Bayesian\n            },\n        ],\n    }),\n    forms(({ actions, values, props }) => ({\n        experiment: {\n            options: { showErrorsOnTouch: true },\n            defaults: { ...NEW_EXPERIMENT } as Experiment,\n            errors: ({ name, parameters }) => ({\n                name: !name && 'Please enter a name',\n                // feature_flag_key is handled asynchronously\n                parameters: {\n                    feature_flag_variants: parameters.feature_flag_variants?.map(({ key }) => ({\n                        key: !key.match?.(/^([A-z]|[a-z]|[0-9]|-|_)+$/)\n                            ? 'Only letters, numbers, hyphens (-) & underscores (_) are allowed.'\n                            : undefined,\n                    })),\n                },\n            }),\n            submit: () => {\n                if (\n                    values.experimentId &&\n                    ([FORM_MODES.create, FORM_MODES.duplicate] as FormModes[]).includes(props.formMode!)\n                ) {\n                    actions.createExperiment(true)\n                } else {\n                    actions.createExperiment(true, 'Unfiled/Experiments')\n                }\n            },\n        },\n    })),\n    urlToAction(({ actions, values }) => ({\n        '/experiments/:id': ({ id }, query, __, currentLocation, previousLocation) => {\n            const didPathChange = currentLocation.initial || currentLocation.pathname !== previousLocation?.pathname\n\n            actions.setEditExperiment(false)\n\n            if (id && didPathChange) {\n                const parsedId = id === 'new' ? 'new' : parseInt(id)\n                if (parsedId === 'new') {\n                    actions.resetExperiment({\n                        ...NEW_EXPERIMENT,\n                        metrics: query.metric ? [query.metric] : [],\n                        name: query.name ?? '',\n                    })\n                }\n                if (parsedId !== 'new' && parsedId === values.experimentId) {\n                    actions.loadExperiment()\n                    if (values.isExperimentRunning) {\n                        actions.loadExposures()\n                    }\n                }\n            }\n        },\n        '/experiments/:id/:formMode': ({ id }, _, __, currentLocation, previousLocation) => {\n            const didPathChange = currentLocation.initial || currentLocation.pathname !== previousLocation?.pathname\n\n            if (id && didPathChange) {\n                actions.loadExperiment()\n            }\n        },\n    })),\n])\n","import { useValues } from 'kea'\n\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { apiHostOrigin } from 'lib/utils/apiHost'\nimport { teamLogic } from 'scenes/teamLogic'\n\nimport { GroupType } from '~/types'\n\nexport const UTM_TAGS = '?utm_medium=in-product&utm_campaign=feature-flag'\nexport interface FeatureFlagSnippet {\n    flagKey: string\n    multivariant?: boolean\n    groupType?: GroupType\n    localEvaluation?: boolean\n    payload?: boolean\n    remoteConfiguration?: boolean\n    encryptedPayload?: boolean\n    samplePropertyName?: string\n    instantlyAvailableProperties?: boolean\n}\n\nconst LOCAL_EVAL_REMINDER = `Remember to set a feature flags secure API key in the SDK to enable local evaluation.\n`\n\nconst REMOTE_CONFIG_REMINDER = `Must initialize SDK with a feature flags secure API key to enable remote configuration.`\nconst ENCRYPTED_PAYLOAD_REMINDER = `Encrypted payloads are automatically decrypted on the server before being sent to the client.`\n\nexport function NodeJSSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'await client.'\n    const flagFunction = payload ? 'getFeatureFlagPayload' : multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    if (remoteConfiguration) {\n        const reminder = REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n// ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.JavaScript} wrap>\n                    {`// ${reminder}\nconst remoteConfigPayload = await client.getRemoteConfigPayload('${flagKey}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n        // add group properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        groupProperties: { ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n        // add person properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        personProperties: {'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${\n        payload\n            ? `\n    undefined,`\n            : ''\n    }\n    {\n        groups: { '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n    }\n)`\n        : localEvalAddition\n          ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${\n        payload\n            ? `\n    undefined,`\n            : ''\n    }\n    {${localEvalAddition}\n    }\n)`\n          : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n\n    const variableName = payload ? 'matchedFlagPayload' : multivariant ? 'enabledVariant' : 'isMyFlagEnabledForUser'\n\n    const conditional = multivariant ? `${variableName} === 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif (${conditional}) {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`\n\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`${\n                    localEvaluation ? '// ' + LOCAL_EVAL_REMINDER : ''\n                }const ${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function PHPSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHog::'\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n    // empty person properties\n    [],\n    // add group properties used in the flag to ensure the flag\n    // is evaluated locally, vs. going to our servers\n    [${groupType.group_type} =>  ['${propertyName}' => 'value', 'name' => 'xyz']]`\n            : `\n    // add person properties used in the flag to ensure the flag\n    // is evaluated locally, vs. going to our servers\n    ['${propertyName}' => 'value']`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',\n    // group types\n    ['${groupType.group_type}' => '<${groupType.name_singular || 'group'} ID>'],${localEvalAddition}\n)`\n        : localEvalAddition\n          ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${localEvalAddition}\n)`\n          : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = multivariant ? '$enabledVariant' : '$isMyFlagEnabledForUser'\n\n    const conditional = multivariant ? `${variableName} === 'example-variant'` : `${variableName}`\n\n    return (\n        <>\n            <CodeSnippet language={Language.PHP} wrap>\n                {`${localEvaluation ? '// ' + LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}\n\nif (${conditional}) {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function GolangSnippet({\n    flagKey,\n    groupType,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    multivariant,\n    localEvaluation,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'client.'\n\n    const flagFunction = payload ? 'GetFeatureFlagPayload' : multivariant ? 'GetFeatureFlag' : 'IsFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    if (remoteConfiguration) {\n        const reminder = REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n// ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.Go} wrap>\n                    {`// ${reminder}\nremoteConfigPayload, err := ${clientSuffix}GetRemoteConfigPayload(\"${flagKey}\")`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n    // add group properties used in the flag to ensure the flag\n    // is evaluated locally, vs. going to our servers\n    groupProperties: map[string]Properties{\"${groupType.group_type}\": posthog.NewProperties().Set(\"${propertyName}\", \"value\").Set(\"name\", \"xyz\")}`\n            : `\n    // add person properties used in the flag to ensure the flag\n    // is evaluated locally, vs. going to our servers\n    PersonProperties: posthog.NewProperties().Set(\"${propertyName}\", \"value\")`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(posthog.FeatureFlagPayload{\n        Key:        \"${flagKey}\",\n        DistinctId: \"distinct-id\",\n        Groups:     Groups{'${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>'},${localEvalAddition}\n    }\n)`\n        : `${clientSuffix}${flagFunction}(posthog.FeatureFlagPayload{\n    Key:        '${flagKey}',\n    DistinctId: \"distinct-id\",${localEvalAddition}\n})`\n    const variableName = multivariant ? 'enabledVariant, err' : 'isMyFlagEnabledForUser, err'\n\n    const conditional = multivariant ? `enabledVariant == 'example-variant'` : `isMyFlagEnabledForUser`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Go} wrap>\n                {`${localEvaluation ? '// ' + LOCAL_EVAL_REMINDER : ''}${variableName} := ${flagSnippet}\nif err != nil {\n    // Handle error (e.g. capture error and fallback to default behaviour)\n}\nif ${conditional} {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function RubySnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n    const flagFunction = payload ? 'get_feature_flag_payload' : multivariant ? 'get_feature_flag' : 'is_feature_enabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    if (remoteConfiguration) {\n        const reminder = `# ` + REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n# ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.Ruby} wrap>\n                    {`${reminder}\nremote_config_payload = posthog.get_remote_config_payload('${flagKey}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n    # add group properties used in the flag to ensure the flag\n    # is evaluated locally, vs. going to our servers\n    group_properties: { ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n    # add person properties used in the flag to ensure the flag\n    # is evaluated locally, vs. going to our servers\n    person_properties: {'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',\n    groups: { '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n)`\n        : localEvalAddition\n          ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${localEvalAddition}\n)`\n          : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = payload ? 'matched_flag_payload' : multivariant ? 'enabled_variant' : 'is_my_flag_enabled'\n\n    const conditional = multivariant ? `${variableName} == 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif ${conditional}\n    # Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\nend`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Ruby} wrap>\n                {`${localEvaluation ? '# ' + LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function PythonSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n    const flagFunction = payload ? 'get_feature_flag_payload' : multivariant ? 'get_feature_flag' : 'feature_enabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    if (remoteConfiguration) {\n        const reminder = `# ` + REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n# ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.Python} wrap>\n                    {`${reminder}\nremote_config_payload = posthog.get_remote_config_payload('${flagKey}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n    # add group properties used in the flag to ensure the flag\n    # is evaluated locally, vs. going to our servers\n    group_properties={ ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n    # add person properties used in the flag to ensure the flag\n    # is evaluated locally, vs. going to our servers\n    person_properties={'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',\n    groups={ '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n)`\n        : localEvalAddition\n          ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${localEvalAddition}\n)`\n          : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = payload ? 'matched_flag_payload' : multivariant ? 'enabled_variant' : 'is_my_flag_enabled'\n\n    const conditional = multivariant ? `${variableName} == 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif ${conditional}:\n    # Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Python} wrap>\n                {`${localEvaluation ? '# ' + LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function CSharpSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n    const flagFunction = payload\n        ? 'GetFeatureFlagAsync'\n        : multivariant\n          ? 'GetFeatureFlagAsync'\n          : 'IsFeatureEnabledAsync'\n\n    const propertyName = samplePropertyName || 'isAuthorized'\n\n    if (remoteConfiguration) {\n        const reminder = `// ` + REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n// ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.CSharp} wrap>\n                    {`${reminder}\nvar remoteConfigPayload = await posthog.GetRemoteConfigPayloadAsync(\"${flagKey}\");`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalCommentAddition = localEvaluation\n        ? groupType\n            ? `// add group properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        `\n            : `// add person properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        `\n        : ''\n\n    const localEvalCodeAddition = localEvaluation\n        ? groupType\n            ? `{ [\"${propertyName}\"] = \"value\", [\"name\"] = \"xyz\" }`\n            : `\n    personProperties: new() { [\"${propertyName}\"] = \"value\" }`\n        : ''\n\n    const flagSnippet = groupType\n        ? `await ${clientSuffix}${flagFunction}(\n    \"${flagKey}\",\n    \"user distinct id\",\n    new FeatureFlagOptions\n    {\n        ${localEvalCommentAddition}Groups = [new Group(\"${groupType.group_type}\", \"<${\n            groupType.name_singular || 'group'\n        } ID>\")${localEvalCodeAddition}]\n    }\n);`\n        : localEvalCodeAddition\n          ? `await ${clientSuffix}${flagFunction}(\n    \"${flagKey}\",\n    \"user distinct id\",${localEvalCodeAddition}\n);`\n          : `await ${clientSuffix}${flagFunction}(\"${flagKey}\", \"user distinct id\");`\n    const variableName = payload ? 'matchedFlagPayload' : multivariant ? 'enabledVariant' : 'isMyFlagEnabled'\n\n    const conditional = multivariant ? `${variableName} == 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? `\nif (matchedFlagPayload is { Payload: {} payload })\n{\n    // The payload is a JsonDocument.\n    Console.WriteLine(payload.RootElement.GetRawText());\n}`\n        : `\n\nif (${conditional}) {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}\n`\n\n    return (\n        <>\n            <CodeSnippet language={Language.CSharp} wrap>\n                {`${\n                    localEvaluation ? '// ' + LOCAL_EVAL_REMINDER : ''\n                }var ${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function JavaSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const distinctId = 'user distinct id'\n    let snippet = ''\n    if (payload) {\n        snippet = `postHog.getFeatureFlagPayload(\"${distinctId}\", \"${flagKey}\")`\n    } else if (multivariant) {\n        snippet = `Object flagValue = postHog.getFeatureFlag(\"${distinctId}\", \"${flagKey}\");\nif (\"example-variant\".equals(flagValue)) {\n    // Do something differently for this user\n}`\n    } else {\n        snippet = `if (postHog.isFeatureEnabled(\"${distinctId}\", \"${flagKey}\")) {\n    // Do something differently for this user\n}`\n    }\n\n    return (\n        <>\n            <CodeSnippet language={Language.Java} wrap>\n                {snippet}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function AndroidSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHog.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Kotlin} wrap>\n                {`${clientSuffix}getFeatureFlagPayload(\"${flagKey}\")`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == \"example-variant\"` : ''\n    return (\n        <CodeSnippet language={Language.Kotlin} wrap>\n            {`if (${clientSuffix}${flagFunction}(\"${flagKey}\")${variantSuffix}) {\n    // do something\n}\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function FlutterSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'await Posthog().'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Dart} wrap>\n                {`${clientSuffix}getFeatureFlagPayload('${flagKey}');`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n\n    return (\n        <CodeSnippet language={Language.Dart} wrap>\n            {`if (${clientSuffix}${flagFunction}('${flagKey}')${variantSuffix}) {\n  // do something\n}\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function iOSSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHogSDK.shared.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Swift} wrap>\n                {`${clientSuffix}getFeatureFlagPayload(\"${flagKey}\")`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? `as? String == \"example-variant\"` : ''\n    return (\n        <CodeSnippet language={Language.Swift} wrap>\n            {`if ${clientSuffix}${flagFunction}(\"${flagKey}\")${variantSuffix} {\n    // do something\n}`}\n        </CodeSnippet>\n    )\n}\n\nexport function ReactNativeSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.JSX} wrap>\n                {`${clientSuffix}getFeatureFlagPayload('${flagKey}')`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n    return (\n        <CodeSnippet language={Language.JSX} wrap>\n            {`// With a hook\nimport { useFeatureFlag } from 'posthog-react-native'\n\nconst MyComponent = () => {\n    const showFlaggedFeature = useFeatureFlag('${flagKey}')\n\n    if (showFlaggedFeature === undefined) {\n        // the response is undefined if the flags are being loaded\n        return null\n    }\n\n    return showFlaggedFeature ${variantSuffix} ? <Text>Testing feature 😄</Text> : <Text>Not Testing feature 😢</Text>\n}\n\n// Or calling on the method directly\n${clientSuffix}${flagFunction}('${flagKey}')\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function ReactSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const flagFunction = payload\n        ? 'useFeatureFlagPayload'\n        : multivariant\n          ? 'useFeatureFlagVariantKey'\n          : 'useFeatureFlagEnabled'\n\n    const variable = payload ? 'payload' : multivariant ? 'variant' : 'flagEnabled'\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n\n    return (\n        <CodeSnippet language={Language.JSX} wrap>\n            {`\nimport { ${flagFunction} } from 'posthog-js/react'\n\nfunction App() {\n    const ${variable} = ${flagFunction}('${flagKey}')\n\n    if (${variable}${variantSuffix}) {\n        // do something\n    }\n}`}\n        </CodeSnippet>\n    )\n}\n\nexport function APISnippet({ flagKey, groupType, remoteConfiguration }: FeatureFlagSnippet): JSX.Element {\n    const { currentTeam } = useValues(teamLogic)\n\n    const groupAddition = groupType\n        ? `,\n    \"groups\": { \"${groupType.group_type}\": \"<${groupType.name_singular || 'group'} ID>\" },`\n        : ''\n\n    if (remoteConfiguration) {\n        return (\n            <>\n                <CodeSnippet language={Language.Bash} wrap>\n                    {`curl ${apiHostOrigin()}/api/projects/${currentTeam?.id || ':projectId'}/feature_flags/${\n                        flagKey || ':featureFlagKey'\n                    }/remote_config/ \\\\\n-H 'Content-Type: application/json' \\\\\n-H 'Authorization: Bearer [personal_api_key]'`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    return (\n        <>\n            <CodeSnippet language={Language.Bash} wrap>\n                {`curl ${apiHostOrigin()}/flags/?v=2 \\\\\n-X POST -H 'Content-Type: application/json' \\\\\n-d '{\n    \"api_key\": \"${currentTeam ? currentTeam.api_token : '[project_api_key]'}\",\n    \"distinct_id\": \"[user distinct id]\"${groupAddition}\n}'\n                `}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function JSSnippet({\n    flagKey,\n    multivariant,\n    payload,\n    groupType,\n    instantlyAvailableProperties,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    if (payload) {\n        return (\n            <>\n                <CodeSnippet language={Language.JavaScript} wrap>\n                    {`posthog.getFeatureFlagPayload('${flagKey ?? ''}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const propertyOverrideSnippet = `// Your flag depends on properties that are not instantly available. If you want\n// to make them available without waiting for server delays, send these properties for flag evaluation, like so:\n// Make sure to call this before evaluating flags. More info: https://posthog.com/docs/libraries/js#overriding-server-properties \nposthog.${\n        groupType\n            ? `setGroupPropertiesForFlags({ '${groupType.group_type}': {'${propertyName}': 'value'}})`\n            : `setPersonPropertiesForFlags({'${propertyName}': 'value'})`\n    }\n\n`\n\n    const clientSuffix = 'posthog.'\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`${instantlyAvailableProperties ? '' : propertyOverrideSnippet}// Ensure flags are loaded before usage.\n// You'll only need to call this on the code for when the first time a user visits.\n${clientSuffix}onFeatureFlags(function() {\n    // feature flags should be available at this point\n    if (${clientSuffix}${flagFunction}('${flagKey ?? ''}') ${variantSuffix}) {\n        // do something\n    }\n})\n\n// Otherwise, you can just do:\nif (${clientSuffix}${flagFunction}('${flagKey ?? ''}') ${variantSuffix}) {\n    // do something\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function JSBootstrappingSnippet(): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`// Initialise the posthog library with a distinct ID and feature flags for immediate loading\n// This avoids the delay between the library loading and feature flags becoming available to use.\n\nposthog.init('{project_api_key}', {\n    api_host: '${apiHostOrigin()}'\n    bootstrap:\n    {\n        distinctID: 'your-anonymous-id',\n        featureFlags: {\n    // input the flag values here from 'posthog.getAllFlags(distinct_id)' which you can find in the server-side libraries.\n        // example:\n            // 'flag-1': true,\n            // 'variant-flag': 'control',\n            // 'other-flag': false\n        },\n    }\n})\n            `}\n        </CodeSnippet>\n    )\n}\n","import { Extension } from '@tiptap/core'\nimport { ReactRenderer } from '@tiptap/react'\nimport Suggestion from '@tiptap/suggestion'\nimport Fuse from 'fuse.js'\nimport { useValues } from 'kea'\nimport { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useState } from 'react'\n\nimport {\n    IconCursor,\n    IconFunnels,\n    IconHogQL,\n    IconLifecycle,\n    IconPeople,\n    IconRetention,\n    IconRewindPlay,\n    IconSquareRoot,\n    IconStickiness,\n    IconTrends,\n    IconUpload,\n    IconUserPaths,\n} from '@posthog/icons'\nimport { IconCode } from '@posthog/icons'\nimport { LemonButton, LemonDivider, lemonToast } from '@posthog/lemon-ui'\n\nimport { EditorCommands, EditorRange } from 'lib/components/RichContentEditor/types'\nimport { Popover } from 'lib/lemon-ui/Popover'\nimport { IconBold, IconItalic } from 'lib/lemon-ui/icons'\nimport { selectFiles } from 'lib/utils/file-utils'\n\nimport { KeyboardShortcut } from '~/layout/navigation-3000/components/KeyboardShortcut'\nimport { defaultDataTableColumns } from '~/queries/nodes/DataTable/utils'\nimport { NodeKind } from '~/queries/schema/schema-general'\nimport { BaseMathType, ChartDisplayType, FunnelVizType, PathType, RetentionPeriod } from '~/types'\n\nimport { buildNodeEmbed } from '../Nodes/NotebookNodeEmbed'\nimport { buildInsightVizQueryContent, buildNodeQueryContent } from '../Nodes/NotebookNodeQuery'\nimport { NotebookNodeType } from '../types'\nimport NotebookIconHeading from './NotebookIconHeading'\nimport { notebookLogic } from './notebookLogic'\n\ntype SlashCommandConditionalProps =\n    | {\n          mode: 'add'\n          getPos: () => number\n          range?: never\n      }\n    | {\n          mode: 'slash'\n          getPos?: never\n          range: EditorRange\n      }\n\ntype SlashCommandsProps = SlashCommandConditionalProps & {\n    query?: string\n    decorationNode?: any\n    onClose?: () => void\n}\n\ntype SlashCommandsPopoverProps = SlashCommandsProps & {\n    visible: boolean\n    children?: JSX.Element\n}\n\ntype SlashCommandsRef = {\n    onKeyDown: (event: KeyboardEvent) => boolean\n}\n\ntype SlashCommandsItem = {\n    title: string\n    search?: string\n    icon?: JSX.Element\n    command: (chain: EditorCommands, pos: number | EditorRange) => EditorCommands | Promise<EditorCommands>\n}\n\nconst TEXT_CONTROLS: SlashCommandsItem[] = [\n    {\n        title: 'h1',\n        icon: <NotebookIconHeading level={1} />,\n        command: (chain) => chain.toggleHeading({ level: 1 }),\n    },\n    {\n        title: 'h2',\n        icon: <NotebookIconHeading level={2} />,\n        command: (chain) => chain.toggleHeading({ level: 2 }),\n    },\n    {\n        title: 'h3',\n        icon: <NotebookIconHeading level={3} />,\n        command: (chain) => chain.toggleHeading({ level: 3 }),\n    },\n    {\n        title: 'bold',\n        icon: <IconBold />,\n        command: (chain) => chain.toggleBold(),\n    },\n    {\n        title: 'italic',\n        icon: <IconItalic />,\n        command: (chain) => chain.toggleItalic(),\n    },\n]\n\nconst SLASH_COMMANDS: SlashCommandsItem[] = [\n    {\n        title: 'Trend',\n        search: 'graph trend insight',\n        icon: <IconTrends color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.TrendsQuery,\n                    filterTestAccounts: false,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            event: '$pageview',\n                            name: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                    interval: 'day',\n                    trendsFilter: {\n                        display: ChartDisplayType.ActionsLineGraph,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Funnel',\n        search: 'funnel insight',\n        icon: <IconFunnels color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.FunnelsQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                        },\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                        },\n                    ],\n                    funnelsFilter: {\n                        funnelVizType: FunnelVizType.Steps,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Retention',\n        search: 'retention insight',\n        icon: <IconRetention color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.RetentionQuery,\n                    retentionFilter: {\n                        period: RetentionPeriod.Day,\n                        totalIntervals: 11,\n                        targetEntity: {\n                            id: '$pageview',\n                            name: '$pageview',\n                            type: 'events',\n                        },\n                        returningEntity: {\n                            id: '$pageview',\n                            name: '$pageview',\n                            type: 'events',\n                        },\n                        retentionType: 'retention_first_time',\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Paths',\n        search: 'user paths insight',\n        icon: <IconUserPaths color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.PathsQuery,\n                    pathsFilter: {\n                        includeEventTypes: [PathType.PageView],\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Stickiness',\n        search: 'stickiness insight',\n        icon: <IconStickiness color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.StickinessQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                    stickinessFilter: {},\n                })\n            ),\n    },\n    {\n        title: 'Lifecycle',\n        search: 'lifecycle insight',\n        icon: <IconLifecycle color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.LifecycleQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                })\n            ),\n    },\n    {\n        title: 'SQL',\n        search: 'sql',\n        icon: <IconHogQL color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.HogQLQuery,\n                        query: `select event,\n        person.properties.email,\n        properties.$browser,\n        count()\n    from events\n    where {filters} -- replaced with global date and property filters\n    and person.properties.email is not null\ngroup by event,\n        properties.$browser,\n        person.properties.email\norder by count() desc\n    limit 100`,\n                        filters: {\n                            dateRange: {\n                                date_from: '-24h',\n                            },\n                        },\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Events',\n        search: 'data explore',\n        icon: <IconCursor />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.EventsQuery,\n                        select: defaultDataTableColumns(NodeKind.EventsQuery),\n                        properties: [],\n                        after: '-24h',\n                        limit: 100,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'People',\n        search: 'persons users',\n        icon: <IconPeople />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    columns: defaultDataTableColumns(NodeKind.ActorsQuery),\n                    source: {\n                        kind: NodeKind.ActorsQuery,\n                        properties: [],\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Session recordings',\n        search: 'video replay',\n        icon: <IconRewindPlay />,\n        command: (chain, pos) => chain.insertContentAt(pos, { type: NotebookNodeType.RecordingPlaylist, attrs: {} }),\n    },\n    {\n        title: 'Image',\n        search: 'picture gif',\n        icon: <IconUpload />,\n        command: async (chain, pos) => {\n            // Trigger upload followed by insert\n            try {\n                const files = await selectFiles({ contentType: 'image/*', multiple: false })\n\n                if (files.length) {\n                    return chain.insertContentAt(pos, { type: NotebookNodeType.Image, attrs: { file: files[0] } })\n                }\n            } catch {\n                lemonToast.error('Something went wrong when trying to select a file.')\n            }\n\n            return chain\n        },\n    },\n    {\n        title: 'Embedded iframe',\n        search: 'iframe embed',\n        icon: <IconCode />,\n        command: async (chain, pos) => {\n            return chain.insertContentAt(pos, buildNodeEmbed())\n        },\n    },\n    {\n        title: 'LaTeX',\n        search: 'latex math formula equation',\n        icon: <IconSquareRoot color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(pos, {\n                type: NotebookNodeType.Latex,\n                attrs: { content: '' }, // Default empty content\n            }),\n    },\n]\n\nexport const SlashCommands = forwardRef<SlashCommandsRef, SlashCommandsProps>(function SlashCommands(\n    { mode, range, getPos, onClose, query }: SlashCommandsProps,\n    ref\n): JSX.Element | null {\n    const { editor } = useValues(notebookLogic)\n    // We start with 1 because the first item is the text controls\n    const [selectedIndex, setSelectedIndex] = useState(0)\n    const [selectedHorizontalIndex, setSelectedHorizontalIndex] = useState(0)\n\n    const allCommmands = [...TEXT_CONTROLS, ...SLASH_COMMANDS]\n\n    const fuse = useMemo(() => {\n        return new Fuse(allCommmands, {\n            keys: ['title', 'search'],\n            threshold: 0.3,\n        })\n        // oxlint-disable-next-line exhaustive-deps\n    }, [allCommmands])\n\n    const filteredCommands = useMemo(() => {\n        if (!query) {\n            return allCommmands\n        }\n        return fuse.search(query).map((result) => result.item)\n        // oxlint-disable-next-line exhaustive-deps\n    }, [query, fuse])\n\n    const filteredSlashCommands = useMemo(\n        () => filteredCommands.filter((item) => SLASH_COMMANDS.includes(item)),\n        [filteredCommands]\n    )\n\n    useEffect(() => {\n        setSelectedIndex(0)\n        setSelectedHorizontalIndex(0)\n    }, [query])\n\n    const execute = async (item: SlashCommandsItem): Promise<void> => {\n        if (editor) {\n            const selectedNode = editor.getSelectedNode()\n            const isTextNode = selectedNode === null || selectedNode.isText\n            const isTextCommand = TEXT_CONTROLS.map((c) => c.title).includes(item.title)\n\n            const position = mode === 'slash' ? range.from : getPos()\n            let chain = mode === 'slash' ? editor.deleteRange(range) : editor.chain()\n\n            if (!isTextNode && isTextCommand) {\n                chain = chain.insertContentAt(position, { type: 'paragraph' })\n            }\n\n            const partialCommand = await item.command(chain, position)\n            partialCommand.run()\n\n            onClose?.()\n        }\n    }\n\n    const onPressEnter = async (): Promise<void> => {\n        const command =\n            selectedIndex === -1 ? TEXT_CONTROLS[selectedHorizontalIndex] : filteredSlashCommands[selectedIndex]\n\n        await execute(command)\n    }\n    const onPressUp = (): void => {\n        setSelectedIndex(Math.max(selectedIndex - 1, -1))\n    }\n    const onPressDown = (): void => {\n        setSelectedIndex(Math.min(selectedIndex + 1, SLASH_COMMANDS.length - 1))\n    }\n\n    const onPressLeft = (): void => {\n        setSelectedHorizontalIndex(Math.max(selectedHorizontalIndex - 1, 0))\n    }\n    const onPressRight = (): void => {\n        setSelectedHorizontalIndex(Math.min(selectedHorizontalIndex + 1, TEXT_CONTROLS.length - 1))\n    }\n\n    const onKeyDown = useCallback(\n        (event: KeyboardEvent): boolean => {\n            const keyMappings = {\n                ArrowUp: onPressUp,\n                ArrowDown: onPressDown,\n                ArrowLeft: onPressLeft,\n                ArrowRight: onPressRight,\n                Enter: onPressEnter,\n            }\n\n            if (keyMappings[event.key]) {\n                keyMappings[event.key]()\n                return true\n            }\n\n            return false\n        },\n        // oxlint-disable-next-line exhaustive-deps\n        [selectedIndex, selectedHorizontalIndex, filteredCommands]\n    )\n\n    // Expose the keydown handler to the tiptap extension\n    useImperativeHandle(ref, () => ({ onKeyDown }), [onKeyDown])\n\n    useEffect(() => {\n        if (mode !== 'add') {\n            return\n        }\n\n        // If not opened from a slash command, we want to add our own keyboard listeners\n        const keyDownListener = (event: KeyboardEvent): void => {\n            const preventDefault = onKeyDown(event)\n            if (preventDefault) {\n                event.preventDefault()\n            }\n        }\n\n        window.addEventListener('keydown', keyDownListener, true)\n\n        return () => window.removeEventListener('keydown', keyDownListener, true)\n    }, [onKeyDown, mode])\n\n    if (!editor) {\n        return null\n    }\n\n    return (\n        <div className=\"deprecated-space-y-px\">\n            <div className=\"flex items-center gap-1\">\n                {TEXT_CONTROLS.map((item, index) => (\n                    <LemonButton\n                        key={item.title}\n                        size=\"small\"\n                        active={selectedIndex === -1 && selectedHorizontalIndex === index}\n                        onClick={() => void execute(item)}\n                        icon={item.icon}\n                    />\n                ))}\n            </div>\n\n            <LemonDivider />\n\n            {filteredSlashCommands.map((item, index) => (\n                <LemonButton\n                    key={item.title}\n                    fullWidth\n                    icon={item.icon}\n                    active={index === selectedIndex}\n                    onClick={() => void execute(item)}\n                >\n                    {item.title}\n                </LemonButton>\n            ))}\n\n            {filteredSlashCommands.length === 0 && (\n                <div className=\"text-secondary p-1\">\n                    Nothing matching <code>/{query}</code>\n                </div>\n            )}\n\n            {mode === 'add' && (\n                <>\n                    <LemonDivider className=\"my-0\" />\n                    <div className=\"text-xs text-secondary p-1\">\n                        You can trigger this menu by typing <KeyboardShortcut forwardslash />\n                    </div>\n                </>\n            )}\n        </div>\n    )\n})\n\nexport const SlashCommandsPopover = forwardRef<SlashCommandsRef, SlashCommandsPopoverProps>(\n    function SlashCommandsPopover(\n        { visible = true, decorationNode, children, onClose, ...props }: SlashCommandsPopoverProps,\n        ref\n    ): JSX.Element | null {\n        return (\n            <Popover\n                placement=\"right-start\"\n                fallbackPlacements={['left-start', 'right-end']}\n                overlay={<SlashCommands ref={ref} onClose={onClose} {...props} />}\n                referenceElement={decorationNode}\n                visible={visible}\n                onClickOutside={onClose}\n            >\n                {children}\n            </Popover>\n        )\n    }\n)\n\nexport const SlashCommandsExtension = Extension.create({\n    name: 'slash-commands',\n\n    addProseMirrorPlugins() {\n        return [\n            Suggestion({\n                editor: this.editor,\n                char: '/',\n                startOfLine: true,\n                render: () => {\n                    let renderer: ReactRenderer<SlashCommandsRef>\n\n                    return {\n                        onStart: (props) => {\n                            renderer = new ReactRenderer(SlashCommandsPopover, {\n                                props: { ...props, mode: 'slash' },\n                                editor: props.editor,\n                            })\n                        },\n\n                        onUpdate(props) {\n                            renderer.updateProps(props)\n\n                            if (!props.clientRect) {\n                                return\n                            }\n                        },\n\n                        onKeyDown(props) {\n                            if (props.event.key === 'Escape') {\n                                renderer.destroy()\n                                return true\n                            }\n                            return renderer.ref?.onKeyDown(props.event) ?? false\n                        },\n\n                        onExit() {\n                            renderer.destroy()\n                        },\n                    }\n                },\n            }),\n        ]\n    },\n})\n","import { actions, kea, key, path, props, selectors } from 'kea'\nimport { lazyLoaders } from 'kea-loaders'\nimport posthog from 'posthog-js'\n\nimport api from 'lib/api'\nimport { Scene } from 'scenes/sceneTypes'\nimport { sceneConfigurations } from 'scenes/scenes'\n\nimport { hogqlQuery } from '~/queries/query'\nimport { hogql } from '~/queries/utils'\nimport { Breadcrumb, PersonType } from '~/types'\n\nimport { getHogqlQueryStringForPersonId } from './person-utils'\nimport type { personLogicType } from './personLogicType'\n\nexport interface PersonLogicProps {\n    id: string | undefined\n    distinctId: string | undefined\n}\n\nexport interface Info {\n    sessionCount: number\n    eventCount: number\n    lastSeen: string | null\n}\n\nexport const personLogic = kea<personLogicType>([\n    props({} as PersonLogicProps),\n    key((props) => props.distinctId ?? props.id ?? 'undefined'),\n    path((key) => ['scenes', 'persons', 'personLogic', key]),\n    actions({\n        loadPerson: true,\n        loadInfo: true,\n    }),\n    selectors(() => ({\n        breadcrumbs: [\n            () => [],\n            (): Breadcrumb[] => {\n                const breadcrumbs: Breadcrumb[] = [\n                    {\n                        key: Scene.Person,\n                        name: sceneConfigurations[Scene.Person].name,\n                        iconType: sceneConfigurations[Scene.Person].iconType || 'default_icon_type',\n                    },\n                ]\n\n                return breadcrumbs\n            },\n        ],\n    })),\n    lazyLoaders(({ props }) => ({\n        person: [\n            null as PersonType | null,\n            {\n                loadPerson: async (): Promise<PersonType | null> => {\n                    if (props.distinctId != null) {\n                        const response = await api.persons.list({ distinct_id: props.distinctId })\n                        const person = response.results[0]\n                        if (person != null) {\n                            return person\n                        }\n                    }\n                    if (props.id == null) {\n                        return null\n                    }\n                    const queryResponse = await hogqlQuery(\n                        getHogqlQueryStringForPersonId(),\n                        { id: props.id },\n                        'blocking'\n                    )\n                    const row = queryResponse?.results?.[0]\n                    if (row == null) {\n                        return null\n                    }\n                    const queryPerson: PersonType = {\n                        id: row[0],\n                        uuid: row[0],\n                        distinct_ids: row[1],\n                        properties: JSON.parse(row[2] || '{}'),\n                        is_identified: !!row[3],\n                        created_at: row[4],\n                    }\n                    return queryPerson\n                },\n            },\n        ],\n        info: [\n            null as Info | null,\n            {\n                loadInfo: async (): Promise<Info | null> => {\n                    if (!props.id) {\n                        return null\n                    }\n\n                    const infoQuery = hogql`\n                    SELECT\n                        count(DISTINCT $session_id) as session_count,\n                        count(*) as event_count,\n                        max(timestamp) as last_seen\n                    FROM events\n                    WHERE person_id = ${props.id}\n                    AND timestamp >= now() - interval 30 day\n                    `\n                    try {\n                        const response = await api.queryHogQL(infoQuery)\n                        const row = response.results?.[0]\n                        if (!row) {\n                            return {\n                                sessionCount: 0,\n                                eventCount: 0,\n                                lastSeen: null,\n                            }\n                        }\n\n                        const [sessionCount, eventCount, lastSeen] = row\n                        return { sessionCount, eventCount, lastSeen }\n                    } catch (error: any) {\n                        posthog.captureException(error)\n                        return {\n                            sessionCount: 0,\n                            eventCount: 0,\n                            lastSeen: null,\n                        }\n                    }\n                },\n            },\n        ],\n    })),\n])\n","import { Node, NodeViewProps, mergeAttributes } from '@tiptap/core'\nimport { NodeViewWrapper, ReactNodeViewRenderer } from '@tiptap/react'\nimport clsx from 'clsx'\nimport { useValues } from 'kea'\nimport { useMemo } from 'react'\n\nimport { LemonButton } from '@posthog/lemon-ui'\n\nimport { dayjs } from 'lib/dayjs'\nimport { urls } from 'scenes/urls'\n\nimport { openNotebook } from '~/models/notebooksModel'\n\nimport { notebookLogic } from '../Notebook/notebookLogic'\nimport { NotebookNodeType, NotebookTarget } from '../types'\n\nexport interface NotebookNodeReplayTimestampAttrs {\n    playbackTime?: number\n    sessionRecordingId: string\n    sourceNodeId?: string\n}\n\nconst Component = (props: NodeViewProps): JSX.Element => {\n    const { shortId, findNodeLogic, findNodeLogicById } = useValues(notebookLogic)\n    const { sessionRecordingId, playbackTime = 0, sourceNodeId } = props.node.attrs as NotebookNodeReplayTimestampAttrs\n\n    const relatedNodeInNotebook = useMemo(() => {\n        const logicById = sourceNodeId ? findNodeLogicById(sourceNodeId) : null\n\n        return logicById ?? findNodeLogic(NotebookNodeType.Recording, { id: sessionRecordingId })\n        // oxlint-disable-next-line exhaustive-deps\n    }, [findNodeLogic])\n\n    const handlePlayInNotebook = (): void => {\n        // TODO: Figure out how to send this action info to the playlist OR the replay node...\n\n        relatedNodeInNotebook?.values.sendMessage('play-replay', {\n            sessionRecordingId,\n            time: playbackTime ?? 0,\n        })\n    }\n\n    return (\n        <NodeViewWrapper\n            as=\"span\"\n            className={clsx('NotebookRecordingTimestamp', props.selected && 'NotebookRecordingTimestamp--selected')}\n        >\n            <LemonButton\n                size=\"small\"\n                noPadding\n                active\n                onClick={\n                    relatedNodeInNotebook ? handlePlayInNotebook : () => openNotebook(shortId, NotebookTarget.Popover)\n                }\n                to={\n                    !relatedNodeInNotebook\n                        ? urls.replaySingle(sessionRecordingId) + `?t=${playbackTime / 1000}`\n                        : undefined\n                }\n            >\n                <span className=\"p-1\">{formatTimestamp(playbackTime)}</span>\n            </LemonButton>\n        </NodeViewWrapper>\n    )\n}\n\nexport const NotebookNodeReplayTimestamp = Node.create({\n    name: NotebookNodeType.ReplayTimestamp,\n    inline: true,\n    group: 'inline',\n    atom: true,\n\n    serializedText: (attrs: NotebookNodeReplayTimestampAttrs): string => {\n        // timestamp is not a block so `getText` does not add a separator.\n        // we need to add it manually\n        return `${attrs.playbackTime ? formatTimestamp(attrs.playbackTime) : '00:00'}:\\n`\n    },\n\n    addAttributes() {\n        return {\n            playbackTime: { default: null, keepOnSplit: false },\n            sessionRecordingId: { default: null, keepOnSplit: true, isRequired: true },\n            sourceNodeId: { default: null, keepOnSplit: true },\n        }\n    },\n\n    parseHTML() {\n        return [{ tag: NotebookNodeType.ReplayTimestamp }]\n    },\n\n    renderHTML({ HTMLAttributes }) {\n        return [NotebookNodeType.ReplayTimestamp, mergeAttributes(HTMLAttributes)]\n    },\n\n    addNodeView() {\n        return ReactNodeViewRenderer(Component)\n    },\n})\n\nexport function formatTimestamp(time: number): string {\n    return dayjs.duration(time, 'milliseconds').format('HH:mm:ss').replace(/^00:/, '').trim()\n}\n","import { Link } from '@posthog/lemon-ui'\n\nimport { DataTableNode, NodeKind } from '~/queries/schema/schema-general'\nimport { QueryContext, QueryContextColumn } from '~/queries/types'\nimport { hogql } from '~/queries/utils'\n\nconst DEFAULT_COLUMN_CONFIG: QueryContextColumn = {\n    width: '60px',\n    align: 'center',\n}\n\nconst ZENDESK_TICKETS_QUERY_COLUMNS = ['id', 'url', 'subject', 'status', 'priority', 'created_at', 'updated_at']\n\ninterface ZendeskTicketsQueryProps {\n    personId: string\n    status?: string\n    priority?: string\n    orderBy?: string\n    orderDirection?: string\n}\n\nexport const zendeskTicketsQuery = ({\n    personId,\n    status,\n    priority,\n    orderBy,\n    orderDirection,\n}: ZendeskTicketsQueryProps): DataTableNode => {\n    const conditions: string[] = ['1=1']\n    if (status && status !== 'all') {\n        conditions.push(`status = '${status}'`)\n    }\n    if (priority && priority !== 'all') {\n        conditions.push(`priority = '${priority}'`)\n    }\n\n    return {\n        kind: NodeKind.DataTableNode,\n        source: {\n            kind: NodeKind.HogQLQuery,\n            query: hogql`\n              with\n                person as (\n                    select properties.email as email\n                    from persons\n                    where id = ${personId}\n                ),\n                zendesk_user as (\n                    select u.id, u.email\n                    from zendesk_users u\n                    inner join person p on p.email = u.email\n                ),\n                tickets as (\n                    select *\n                    from zendesk_tickets\n                )\n            select tickets.id, url, subject, status, priority, created_at, updated_at\n            from tickets\n            inner join zendesk_user on zendesk_user.id = tickets.requester_id\n            where ${hogql.raw(conditions.join(' AND '))}\n            order by tickets.${hogql.identifier(orderBy || 'updated_at')} ${hogql.identifier(orderDirection || 'asc')}\n            limit 500\n            `,\n        },\n        showTimings: false,\n        showOpenEditorButton: false,\n        hiddenColumns: ['url'],\n        columns: ZENDESK_TICKETS_QUERY_COLUMNS,\n    }\n}\n\nexport const useZendeskTicketsQueryContext = (): QueryContext => {\n    return {\n        columns: {\n            id: DEFAULT_COLUMN_CONFIG,\n            status: DEFAULT_COLUMN_CONFIG,\n            priority: DEFAULT_COLUMN_CONFIG,\n            created_at: { ...DEFAULT_COLUMN_CONFIG, title: 'created' },\n            updated_at: { ...DEFAULT_COLUMN_CONFIG, title: 'updated' },\n            subject: {\n                render: ({ record, columnName }) => {\n                    const row = record as (number | string)[]\n                    const subjectIndex = ZENDESK_TICKETS_QUERY_COLUMNS.indexOf(columnName)\n                    const urlIndex = ZENDESK_TICKETS_QUERY_COLUMNS.indexOf('url')\n                    const url = (row[urlIndex] as string).replace('/api/v2', '').replace('.json', '')\n                    return (\n                        <Link to={url} target=\"_new\" className=\"truncate\">\n                            {row[subjectIndex]}\n                        </Link>\n                    )\n                },\n                width: '400px',\n            },\n        },\n        emptyStateHeading: 'There are no matching tickets for this customer',\n        emptyStateDetail: 'They have not submitted any support tickets yet',\n    }\n}\n","import './PersonDisplay.scss'\n\nimport { PERSON_DEFAULT_DISPLAY_NAME_PROPERTIES } from 'lib/constants'\nimport { ProfilePictureProps } from 'lib/lemon-ui/ProfilePicture'\nimport { midEllipsis } from 'lib/utils'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { HogQLQueryString, hogql } from '~/queries/utils'\n\nexport type PersonPropType =\n    | { properties?: Record<string, any>; distinct_ids?: string[]; distinct_id?: never; id?: never }\n    | { properties?: Record<string, any>; distinct_ids?: never; distinct_id?: string; id?: never }\n    | { properties?: Record<string, any>; distinct_ids?: string[]; distinct_id?: string; id: string }\n\nexport interface PersonDisplayProps {\n    person?: PersonPropType | null\n    withIcon?: boolean | ProfilePictureProps['size']\n    noLink?: boolean\n    noEllipsis?: boolean\n    noPopover?: boolean\n}\n\n/** Very permissive email format. */\nconst EMAIL_REGEX = /.+@.+\\..+/i\n/** Very rough UUID format. It's loose around length, because the posthog-js UUID util returns non-normative IDs. */\nconst BROWSER_ANON_ID_REGEX = /^(?:[a-fA-F0-9]+-){4}[a-fA-F0-9]+$/i\n/** Score distinct IDs for display: UUID-like (i.e. anon ID) gets 0, custom format gets 1, email-like gets 2. */\nfunction scoreDistinctId(id: string): number {\n    if (EMAIL_REGEX.test(id)) {\n        return 2\n    }\n    if (BROWSER_ANON_ID_REGEX.test(id) && id.length > 36) {\n        // posthog-js IDs have the shape of UUIDs but are longer\n        return 0\n    }\n    return 1\n}\n\nexport function asDisplay(person: PersonPropType | null | undefined, maxLength?: number): string {\n    if (!person) {\n        return 'Unknown'\n    }\n    const team = teamLogic.findMounted()?.values?.currentTeam\n\n    // Sync the logic below with the plugin server `getPersonDetails`\n    const personDisplayNameProperties = team?.person_display_name_properties ?? PERSON_DEFAULT_DISPLAY_NAME_PROPERTIES\n    const customPropertyKey = personDisplayNameProperties.find((x) => person.properties?.[x])\n    const propertyIdentifier = customPropertyKey ? person.properties?.[customPropertyKey] : undefined\n\n    const customIdentifier: string =\n        typeof propertyIdentifier !== 'string' ? JSON.stringify(propertyIdentifier) : propertyIdentifier\n\n    const display: string | undefined = (\n        customIdentifier ||\n        person.distinct_id ||\n        (person.distinct_ids\n            ? person.distinct_ids.slice().sort((a, b) => scoreDistinctId(b) - scoreDistinctId(a))[0]\n            : undefined)\n    )?.trim()\n\n    return display ? midEllipsis(display, maxLength || 40) : 'Anonymous'\n}\n\nexport const asLink = (person?: PersonPropType | null): string | undefined =>\n    person?.distinct_id\n        ? urls.personByDistinctId(person.distinct_id)\n        : person?.distinct_ids?.length\n          ? urls.personByDistinctId(person.distinct_ids[0])\n          : person?.id\n            ? urls.personByUUID(person.id)\n            : undefined\n\nexport const getHogqlQueryStringForPersonId = (): HogQLQueryString => {\n    return hogql`SELECT\n                    id,\n                    groupArray(101)(pdi2.distinct_id) as distinct_ids,\n                    properties,\n                    is_identified,\n                    created_at\n                FROM persons\n                LEFT JOIN (\n                    SELECT\n                        pdi2.distinct_id,\n                        argMax(pdi2.person_id, pdi2.version) AS person_id\n                    FROM raw_person_distinct_ids pdi2\n                    WHERE pdi2.distinct_id IN (\n                            SELECT distinct_id\n                            FROM raw_person_distinct_ids\n                            WHERE person_id = {id}\n                        )\n                    GROUP BY pdi2.distinct_id\n                    HAVING argMax(pdi2.is_deleted, pdi2.version) = 0\n                        AND argMax(pdi2.person_id, pdi2.version) = {id}\n                ) AS pdi2 ON pdi2.person_id = persons.id\n                WHERE persons.id = {id}\n                GROUP BY id, properties, is_identified, created_at`\n}\n","import useSize from '@react-hook/size'\nimport { useValues } from 'kea'\nimport { MutableRefObject, useMemo, useRef } from 'react'\n\nimport { cn } from 'lib/utils/css-classes'\n\nimport useIsHovering from '~/lib/hooks/useIsHovering'\n\nimport { sessionRecordingPlayerLogic } from '../sessionRecordingPlayerLogic'\n\ninterface ActivityPoint {\n    x: number\n    y: number\n}\n\nexport function UserActivity({ hoverRef }: { hoverRef: MutableRefObject<HTMLDivElement | null> }): JSX.Element {\n    const { activityPerSecond } = useValues(sessionRecordingPlayerLogic)\n\n    const seekBarRef = useRef<HTMLDivElement | null>(null)\n    const [width, height] = useSize(seekBarRef)\n\n    const isHovering = useIsHovering(hoverRef)\n\n    const points: ActivityPoint[] = useMemo(() => {\n        return Object.entries(activityPerSecond.smoothedPoints).map(([second, activity]) => ({\n            x: (parseInt(second, 10) / activityPerSecond.durationSeconds) * width,\n            y: height - (Math.log(activity.y + 1) / Math.log(activityPerSecond.maxY + 1)) * height,\n        }))\n    }, [activityPerSecond, width, height])\n\n    const hasPoints = points.length > 0\n\n    return (\n        <div\n            className={cn(\n                'absolute bottom-0 w-full bg-gradient-to-t from-surface-primary via-surface-primary to-transparent from-0% via-96% to-100% transition-opacity duration-300',\n                {\n                    'opacity-0': !isHovering,\n                }\n            )}\n            ref={seekBarRef}\n            // if there are no points, we don't want to take up space\n            // eslint-disable-next-line react/forbid-dom-props\n            style={{ height: hasPoints ? '3rem' : '0' }}\n        >\n            <svg width=\"100%\" height=\"100%\" preserveAspectRatio=\"none\">\n                <path\n                    d={\n                        points.length\n                            ? `\n                        M 0,${height}\n                        ${points.map((point) => `L ${point.x},${point.y}`).join(' ')}\n                        L ${width},${height}\n                        Z\n                    `\n                            : ''\n                    }\n                    fill=\"var(--color-bg-fill-highlight-200)\"\n                    stroke=\"none\"\n                />\n            </svg>\n        </div>\n    )\n}\n","import { actions, beforeUnmount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { subscriptions } from 'kea-subscriptions'\nimport posthog from 'posthog-js'\n\nimport api from 'lib/api'\nimport { Dayjs, dayjs } from 'lib/dayjs'\nimport { objectsEqual } from 'lib/utils'\nimport { chainToElements } from 'lib/utils/elements-chain'\nimport { TimeTree } from 'lib/utils/time-tree'\n\nimport { HogQLQueryString, hogql } from '~/queries/utils'\nimport { RecordingEventType } from '~/types'\n\nimport type { sessionEventsDataLogicType } from './sessionEventsDataLogicType'\nimport { SessionRecordingMetaLogicProps, sessionRecordingMetaLogic } from './sessionRecordingMetaLogic'\nimport { ViewportResolution } from './snapshot-processing/patch-meta-event'\n\nconst TWENTY_FOUR_HOURS_IN_MS = 24 * 60 * 60 * 1000 // +- before and after start and end of a recording to query for session linked events.\nconst FIVE_MINUTES_IN_MS = 5 * 60 * 1000 // +- before and after start and end of a recording to query for events related by person.\n\nexport const sessionEventsDataLogic = kea<sessionEventsDataLogicType>([\n    path((key) => ['scenes', 'session-recordings', 'sessionEventsDataLogic', key]),\n    props({} as SessionRecordingMetaLogicProps),\n    key(({ sessionRecordingId }) => sessionRecordingId || 'no-session-recording-id'),\n    connect((props: SessionRecordingMetaLogicProps) => {\n        const metaLogic = sessionRecordingMetaLogic(props)\n        return {\n            values: [metaLogic, ['sessionPlayerMetaData']],\n            actions: [metaLogic, ['loadRecordingMetaSuccess']],\n        }\n    }),\n    actions({\n        loadEvents: true,\n        loadFullEventData: (event: RecordingEventType | RecordingEventType[]) => ({ event }),\n    }),\n    reducers(() => ({})),\n    loaders(({ values, props }) => ({\n        sessionEventsData: [\n            null as null | RecordingEventType[],\n            {\n                loadEvents: async () => {\n                    const meta = values.sessionPlayerMetaData\n                    if (!meta) {\n                        return null\n                    }\n\n                    const start = meta.start_time ? dayjs(meta.start_time) : null\n                    const end = meta.end_time ? dayjs(meta.end_time) : null\n                    const person = meta.person\n\n                    if (!person || !start || !end) {\n                        return null\n                    }\n\n                    const sessionEventsQuery = hogql`\nSELECT uuid, event, timestamp, elements_chain, properties.$window_id, properties.$current_url, properties.$event_type, properties.$viewport_width, properties.$viewport_height, properties.$screen_name, distinct_id\nFROM events\nWHERE timestamp > ${start.subtract(TWENTY_FOUR_HOURS_IN_MS, 'ms')}\nAND timestamp < ${end.add(TWENTY_FOUR_HOURS_IN_MS, 'ms')}\nAND $session_id = ${props.sessionRecordingId}\nORDER BY timestamp ASC\nLIMIT 1000000`\n\n                    let relatedEventsQuery = hogql`\nSELECT uuid, event, timestamp, elements_chain, properties.$window_id, properties.$current_url, properties.$event_type, distinct_id\nFROM events\nWHERE timestamp > ${start.subtract(FIVE_MINUTES_IN_MS, 'ms')}\nAND timestamp < ${end.add(FIVE_MINUTES_IN_MS, 'ms')}\nAND (empty ($session_id) OR isNull($session_id))\nAND properties.$lib != 'web'`\n\n                    if (person?.uuid) {\n                        relatedEventsQuery = (relatedEventsQuery +\n                            hogql`\\nAND person_id = ${person.uuid}`) as HogQLQueryString\n                    }\n                    if (!person?.uuid && values.sessionPlayerMetaData?.distinct_id) {\n                        relatedEventsQuery = (relatedEventsQuery +\n                            hogql`\\nAND distinct_id = ${values.sessionPlayerMetaData.distinct_id}`) as HogQLQueryString\n                    }\n\n                    relatedEventsQuery = (relatedEventsQuery +\n                        hogql`\\nORDER BY timestamp ASC\\nLIMIT 1000000`) as HogQLQueryString\n\n                    const [sessionEvents, relatedEvents]: any[] = await Promise.all([\n                        // make one query for all events that are part of the session\n                        api.queryHogQL(sessionEventsQuery),\n                        // make a second for all events from that person,\n                        // not marked as part of the session\n                        // but in the same time range\n                        // these are probably e.g. backend events for the session\n                        // but with no session id\n                        // since posthog-js must always add session id we can also\n                        // take advantage of lib being materialized and further filter\n                        api.queryHogQL(relatedEventsQuery),\n                    ])\n\n                    return [...sessionEvents.results, ...relatedEvents.results].map(\n                        (event: any): RecordingEventType => {\n                            const currentUrl = event[5]\n                            // We use the pathname to simplify the UI - we build it here instead of fetching it to keep data usage small\n                            let pathname: string | undefined\n                            try {\n                                pathname = event[5] ? new URL(event[5]).pathname : undefined\n                            } catch {\n                                pathname = undefined\n                            }\n\n                            const viewportWidth = event.length > 7 ? event[7] : undefined\n                            const viewportHeight = event.length > 8 ? event[8] : undefined\n\n                            return {\n                                id: event[0],\n                                event: event[1],\n                                timestamp: event[2],\n                                elements: chainToElements(event[3]),\n                                properties: {\n                                    $window_id: event[4],\n                                    $current_url: currentUrl,\n                                    $event_type: event[6],\n                                    $pathname: pathname,\n                                    $viewport_width: viewportWidth,\n                                    $viewport_height: viewportHeight,\n                                    $screen_name: event.length > 9 ? event[9] : undefined,\n                                },\n                                playerTime: +dayjs(event[2]) - +start,\n                                fullyLoaded: false,\n                                distinct_id: event[event.length - 1] || values.sessionPlayerMetaData?.distinct_id,\n                            }\n                        }\n                    )\n                },\n\n                loadFullEventData: async ({ event }) => {\n                    // box so we're always dealing with a list\n                    const events = Array.isArray(event) ? event : [event]\n\n                    let existingEvents = values.sessionEventsData?.filter((x) => events.some((e) => e.id === x.id))\n\n                    const allEventsAreFullyLoaded =\n                        existingEvents?.every((e) => e.fullyLoaded) && existingEvents.length === events.length\n                    if (!existingEvents || allEventsAreFullyLoaded) {\n                        return values.sessionEventsData\n                    }\n\n                    existingEvents = existingEvents.filter((e) => !e.fullyLoaded)\n                    const timestamps = existingEvents.map((ee) => dayjs(ee.timestamp).utc().valueOf())\n                    const eventNames = Array.from(new Set(existingEvents.map((ee) => ee.event)))\n                    const eventIds = existingEvents.map((ee) => ee.id)\n                    const earliestTimestamp = timestamps.reduce((a, b) => Math.min(a, b))\n                    const latestTimestamp = timestamps.reduce((a, b) => Math.max(a, b))\n\n                    try {\n                        const query = hogql`\n                            SELECT properties, uuid\n                            FROM events\n                            -- the timestamp range here is only to avoid querying too much of the events table\n                            -- we don't really care about the absolute value,\n                            -- but we do care about whether timezones have an odd impact\n                            -- so, we extend the range by a day on each side so that timezones don't cause issues\n                            WHERE timestamp > ${dayjs(earliestTimestamp).subtract(1, 'day')}\n                            AND timestamp < ${dayjs(latestTimestamp).add(1, 'day')}\n                            AND event in ${eventNames}\n                            AND uuid in ${eventIds}`\n\n                        const response = await api.queryHogQL(query)\n                        if (response.error) {\n                            throw new Error(response.error)\n                        }\n\n                        for (const event of existingEvents) {\n                            const result = response.results.find((x: any) => {\n                                return x[1] === event.id\n                            })\n\n                            if (result) {\n                                event.properties = JSON.parse(result[0])\n                                event.fullyLoaded = true\n                            }\n                        }\n                    } catch (e) {\n                        // NOTE: This is not ideal but should happen so rarely that it is tolerable.\n                        existingEvents.forEach((e) => (e.fullyLoaded = true))\n                        posthog.captureException(e, { feature: 'session-recording-load-full-event-data' })\n                    }\n\n                    // here we map the events list because we want the result to be a new instance to trigger downstream recalculation\n                    return !values.sessionEventsData\n                        ? values.sessionEventsData\n                        : values.sessionEventsData.map((x) => {\n                              const event = existingEvents?.find((ee) => ee.id === x.id)\n                              return event\n                                  ? ({\n                                        ...x,\n                                        properties: event.properties,\n                                        fullyLoaded: event.fullyLoaded,\n                                    } as RecordingEventType)\n                                  : x\n                          })\n                },\n            },\n        ],\n    })),\n    listeners(({ actions }) => ({\n        loadRecordingMetaSuccess: () => {\n            actions.loadEvents()\n        },\n    })),\n    selectors(() => ({\n        webVitalsEvents: [\n            (s) => [s.sessionEventsData],\n            (sessionEventsData): RecordingEventType[] =>\n                (sessionEventsData || []).filter((e) => e.event === '$web_vitals'),\n        ],\n        AIEvents: [\n            (s) => [s.sessionEventsData],\n            (sessionEventsData): RecordingEventType[] =>\n                // see if event start with $ai_\n                (sessionEventsData || []).filter((e) => e.event.startsWith('$ai_')),\n        ],\n        exceptionEvents: [\n            (s) => [s.sessionEventsData],\n            (sessionEventsData): RecordingEventType[] =>\n                (sessionEventsData || []).filter((e) => e.event === '$exception'),\n        ],\n        preloadableEvents: [\n            (s) => [s.webVitalsEvents, s.AIEvents, s.exceptionEvents],\n            (webVitalsEvents, AIEvents, exceptionEvents): RecordingEventType[] => [\n                ...webVitalsEvents,\n                ...AIEvents,\n                ...exceptionEvents,\n            ],\n            { resultEqualityCheck: objectsEqual },\n        ],\n        eventViewportsItems: [\n            (s) => [s.sessionEventsData],\n            (\n                sessionEventsData\n            ): TimeTree<{\n                timestamp: Dayjs\n                payload: ViewportResolution\n            }> => {\n                const viewportEvents = new TimeTree<{\n                    timestamp: Dayjs\n                    payload: ViewportResolution\n                }>()\n                viewportEvents.add(\n                    (sessionEventsData || [])\n                        .filter((e) => e.properties.$viewport_width && e.properties.$viewport_height)\n                        .map((e) => ({\n                            timestamp: dayjs(e.timestamp),\n                            payload: {\n                                width: e.properties.$viewport_width,\n                                height: e.properties.$viewport_height,\n                                href: e.properties.$current_url,\n                            },\n                        }))\n                )\n                return viewportEvents\n            },\n            { resultEqualityCheck: objectsEqual },\n        ],\n        viewportForTimestamp: [\n            (s) => [s.eventViewportsItems],\n            (eventViewportsItems) => {\n                return (timestamp: number) => {\n                    const closestItem =\n                        eventViewportsItems.next(dayjs(timestamp)) || eventViewportsItems.previous(dayjs(timestamp))\n                    if (!closestItem) {\n                        return undefined\n                    }\n                    return closestItem.payload as ViewportResolution\n                }\n            },\n        ],\n    })),\n    subscriptions(({ actions }) => ({\n        preloadableEvents: (pe: null | RecordingEventType[]) => {\n            if (pe?.length) {\n                actions.loadFullEventData(pe)\n            }\n        },\n    })),\n    beforeUnmount(({ cache }) => {\n        cache.windowIdForTimestamp = undefined\n        cache.viewportForTimestamp = undefined\n        cache.processingCache = undefined\n    }),\n])\n","import { kea, key, path, props, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { combineUrl } from 'kea-router'\n\nimport { colonDelimitedDuration, reverseColonDelimitedDuration } from 'lib/utils'\nimport { urls } from 'scenes/urls'\n\nimport type { playerShareLogicType } from './playerShareLogicType'\n\nexport interface FormWithTime {\n    includeTime: boolean\n    time: string | null\n}\n\nfunction makePrivateLinkQueryParams(formWithTime: FormWithTime): Record<string, string | undefined> {\n    return {\n        t: formWithTime.includeTime ? `${reverseColonDelimitedDuration(formWithTime.time) || 0}` : undefined,\n    }\n}\n\nexport function makePrivateLink(id: string, formWithTime: FormWithTime): string {\n    return combineUrl(\n        urls.absolute(urls.currentProject(urls.replaySingle(id))),\n        makePrivateLinkQueryParams(formWithTime)\n    ).url\n}\n\nexport type PlayerShareLogicProps = {\n    seconds: number | null\n    id: string\n    shareType?: 'private' | 'public' | 'linear'\n}\n\nexport const playerShareLogic = kea<playerShareLogicType>([\n    path(() => ['scenes', 'session-recordings', 'player', 'playerShareLogic']),\n    props({} as PlayerShareLogicProps),\n    key((props: PlayerShareLogicProps) => `${props.id}-${props.seconds}`),\n\n    forms(({ props }) => ({\n        privateLinkForm: {\n            defaults: { includeTime: true, time: colonDelimitedDuration(props.seconds, null) } as FormWithTime,\n            errors: ({ time, includeTime }) => ({\n                time:\n                    time && includeTime && reverseColonDelimitedDuration(time || undefined) === null\n                        ? 'Set a valid time like 02:30 (minutes:seconds)'\n                        : undefined,\n            }),\n            options: {\n                // whether we show errors after touch (true) or submit (false)\n                showErrorsOnTouch: true,\n\n                // show errors even without submitting first\n                alwaysShowErrors: true,\n            },\n        },\n        linearLinkForm: {\n            defaults: {\n                includeTime: true,\n                time: colonDelimitedDuration(props.seconds, null),\n                issueTitle: '',\n                issueDescription: '',\n            } as FormWithTime & {\n                issueTitle: string\n                issueDescription: string\n            },\n            errors: ({ time, includeTime }) => ({\n                time:\n                    time && includeTime && reverseColonDelimitedDuration(time || undefined) === null\n                        ? 'Set a valid time like 02:30 (minutes:seconds)'\n                        : undefined,\n            }),\n            options: {\n                // whether we show errors after touch (true) or submit (false)\n                showErrorsOnTouch: true,\n\n                // show errors even without submitting first\n                alwaysShowErrors: true,\n            },\n        },\n    })),\n\n    selectors(({ props }) => ({\n        privateLinkUrlQueryParams: [\n            (s) => [s.privateLinkForm],\n            (privateLinkForm) => {\n                return makePrivateLinkQueryParams(privateLinkForm)\n            },\n        ],\n        privateLinkUrl: [\n            (s) => [s.privateLinkForm],\n            (privateLinkForm) => {\n                return makePrivateLink(props.id, privateLinkForm)\n            },\n        ],\n        linearQueryParams: [\n            (s) => [s.linearLinkForm],\n            (linearLinkForm) => {\n                return {\n                    title: linearLinkForm.issueTitle,\n                    description:\n                        linearLinkForm.issueDescription +\n                        `\\n\\nPostHog recording: ${makePrivateLink(props.id, linearLinkForm)}`,\n                }\n            },\n        ],\n        linearUrl: [\n            (s) => [s.linearQueryParams],\n            (linearQueryParams) => {\n                return combineUrl('https://linear.app/new', linearQueryParams).url\n            },\n        ],\n    })),\n])\n","import clsx from 'clsx'\nimport { useActions, useValues } from 'kea'\nimport React, { ReactNode, useEffect, useState } from 'react'\nimport { Transition } from 'react-transition-group'\nimport { ENTERED, ENTERING } from 'react-transition-group/Transition'\nimport useResizeObserver from 'use-resize-observer'\n\nimport {\n    IconAIText,\n    IconClock,\n    IconCollapse,\n    IconExpand,\n    IconKeyboard,\n    IconMagicWand,\n    IconPointer,\n    IconThumbsDown,\n    IconThumbsUp,\n    IconWarning,\n} from '@posthog/icons'\nimport { LemonBanner, LemonDivider, LemonTag, Link, Tooltip } from '@posthog/lemon-ui'\n\nimport { useOnMountEffect } from 'lib/hooks/useOnMountEffect'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { Spinner } from 'lib/lemon-ui/Spinner'\nimport { playerMetaLogic } from 'scenes/session-recordings/player/player-meta/playerMetaLogic'\nimport { sessionRecordingPlayerLogic } from 'scenes/session-recordings/player/sessionRecordingPlayerLogic'\nimport { urls } from 'scenes/urls'\n\nimport { playerInspectorLogic } from '../inspector/playerInspectorLogic'\nimport {\n    SegmentMeta,\n    SessionKeyAction,\n    SessionSegment,\n    SessionSegmentKeyActions,\n    SessionSegmentOutcome,\n    SessionSummaryContent,\n} from '../player-meta/types'\n\nfunction formatEventMetaInfo(event: SessionKeyAction): JSX.Element {\n    return (\n        <pre className=\"m-0 p-0 font-mono text-xs whitespace-pre\">\n            {`Event: ${event.event}\n            Event type: ${event.event_type}\n            Issues: ${\n                [\n                    event.abandonment && 'Abandonment',\n                    event.confusion && 'Confusion',\n                    event.exception && `Exception (${event.exception})`,\n                ]\n                    .filter(Boolean)\n                    .join(', ') || 'None'\n            }\n            Timestamp: ${event.timestamp}\n            Milliseconds since start: ${event.milliseconds_since_start}\n            Window ID: ${event.window_id}\n            Current URL: ${event.current_url}`}\n        </pre>\n    )\n}\n\nfunction formatMsIntoTime(ms: number): string {\n    const seconds = Math.floor(ms / 1000)\n    const hours = Math.floor(seconds / 3600)\n    const minutes = Math.floor((seconds % 3600) / 60)\n    const remainingSeconds = seconds % 60\n\n    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${remainingSeconds\n        .toString()\n        .padStart(2, '0')}`\n}\n\nconst isValidTimestamp = (ms: unknown): ms is number => typeof ms === 'number' && !isNaN(ms) && ms >= 0\nconst isValidMetaNumber = (value: unknown): value is number => typeof value === 'number' && !isNaN(value) && value >= 0\n\ninterface SegmentMetaProps {\n    meta: SegmentMeta | null | undefined\n}\n\nfunction LoadingTimer({ operation }: { operation?: string }): JSX.Element {\n    const [elapsedSeconds, setElapsedSeconds] = useState(0)\n\n    useEffect(() => {\n        if (operation !== undefined) {\n            setElapsedSeconds(0) // Reset timer only when operation changes and is provided\n        }\n    }, [operation])\n\n    // Run on mount only to avoid resetting interval\n    useOnMountEffect(() => {\n        const interval = setInterval(() => {\n            setElapsedSeconds((prev) => prev + 1)\n        }, 1000)\n\n        return () => clearInterval(interval)\n    })\n\n    return <span className=\"font-mono text-xs text-muted\">{elapsedSeconds}s</span>\n}\n\ninterface SessionSegmentCollapseProps {\n    header: ReactNode\n    content: ReactNode\n    actionsPresent?: boolean\n    className?: string\n    isFailed?: boolean\n}\n\nfunction SessionSegmentCollapse({\n    header,\n    content,\n    actionsPresent,\n    className,\n    isFailed,\n}: SessionSegmentCollapseProps): JSX.Element {\n    const [isExpanded, setIsExpanded] = useState(false)\n    const { height: contentHeight, ref: contentRef } = useResizeObserver({ box: 'border-box' })\n\n    return (\n        <div className={clsx('LemonCollapse', className)}>\n            <div className=\"LemonCollapsePanel\" aria-expanded={isExpanded}>\n                <LemonButton\n                    fullWidth\n                    className={clsx(\n                        'LemonCollapsePanel__header hover:bg-primary-alt-highlight border-l-[5px]',\n                        !actionsPresent && 'LemonCollapsePanel__header--disabled',\n                        isFailed && 'border-l-danger'\n                    )}\n                    onClick={actionsPresent ? () => setIsExpanded(!isExpanded) : undefined}\n                    icon={isExpanded ? <IconCollapse /> : <IconExpand />}\n                    size=\"medium\"\n                    disabled={!actionsPresent}\n                >\n                    {header}\n                </LemonButton>\n                <Transition in={isExpanded} timeout={200} mountOnEnter unmountOnExit>\n                    {(status) => (\n                        <div\n                            className=\"LemonCollapsePanel__body\"\n                            // eslint-disable-next-line react/forbid-dom-props\n                            style={\n                                status === ENTERING || status === ENTERED\n                                    ? {\n                                          height: contentHeight,\n                                      }\n                                    : undefined\n                            }\n                            aria-busy={status.endsWith('ing')}\n                        >\n                            <div className=\"LemonCollapsePanel__content\" ref={contentRef}>\n                                {content}\n                            </div>\n                        </div>\n                    )}\n                </Transition>\n            </div>\n        </div>\n    )\n}\n\nfunction SegmentMetaTable({ meta }: SegmentMetaProps): JSX.Element | null {\n    if (!meta) {\n        return null\n    }\n\n    return (\n        <div className=\"grid grid-cols-2 gap-2 text-xs mt-2\">\n            <div className=\"flex items-center gap-1\">\n                <IconKeyboard className={meta.key_action_count && meta.key_action_count > 0 ? 'text-success' : ''} />\n                <span className=\"text-muted\">Key actions:</span>\n                {isValidMetaNumber(meta.key_action_count) && <span>{meta.key_action_count}</span>}\n            </div>\n            <div className=\"flex items-center gap-1\">\n                <IconWarning className={meta.failure_count && meta.failure_count > 0 ? 'text-danger' : ''} />\n                <span className=\"text-muted\">Issues:</span>\n                {isValidMetaNumber(meta.failure_count) && <span>{meta.failure_count}</span>}\n            </div>\n            <div className=\"flex items-center gap-1\">\n                <IconClock />\n                <span className=\"text-muted\">Duration:</span>\n                {isValidMetaNumber(meta.duration) && isValidMetaNumber(meta.duration_percentage) && (\n                    <span>\n                        {meta.duration === 0 ? (\n                            <span className=\"text-muted\">...</span>\n                        ) : (\n                            `${formatMsIntoTime(meta.duration * 1000)} (${(\n                                (meta.duration_percentage || 0) * 100\n                            ).toFixed(2)}%)`\n                        )}\n                    </span>\n                )}\n            </div>\n            <div className=\"flex items-center gap-1\">\n                <IconPointer />\n                <span className=\"text-muted\">Events:</span>\n                {isValidMetaNumber(meta.events_count) && isValidMetaNumber(meta.events_percentage) && (\n                    <span>\n                        {meta.events_count === 0 ? (\n                            <span className=\"text-muted\">...</span>\n                        ) : (\n                            `${meta.events_count} (${((meta.events_percentage || 0) * 100).toFixed(2)}%)`\n                        )}\n                    </span>\n                )}\n            </div>\n        </div>\n    )\n}\n\ninterface SessionSegmentViewProps {\n    segment: SessionSegment\n    segmentOutcome: SessionSegmentOutcome | undefined\n    keyActions: SessionSegmentKeyActions[]\n    onSeekToTime: (time: number) => void\n}\n\nfunction getIssueTags(event: SessionKeyAction): JSX.Element[] {\n    const tags: JSX.Element[] = []\n    if (event.abandonment) {\n        tags.push(\n            <LemonTag key=\"abandonment\" size=\"small\" type=\"warning\">\n                abandoned\n            </LemonTag>\n        )\n    }\n    if (event.confusion) {\n        tags.push(\n            <LemonTag key=\"confusion\" size=\"small\" type=\"warning\">\n                confusion\n            </LemonTag>\n        )\n    }\n    if (event.exception) {\n        tags.push(\n            <LemonTag key=\"exception\" size=\"small\" type={event.exception === 'blocking' ? 'danger' : 'warning'}>\n                {event.exception}\n            </LemonTag>\n        )\n    }\n    return tags\n}\n\nfunction SessionSegmentView({\n    segment,\n    segmentOutcome,\n    keyActions,\n    onSeekToTime,\n}: SessionSegmentViewProps): JSX.Element {\n    return (\n        <div key={segment.name} className=\"mb-4\">\n            <SessionSegmentCollapse\n                className=\"cursor-pointer\"\n                actionsPresent={keyActions && keyActions.length > 0}\n                isFailed={segmentOutcome && Object.keys(segmentOutcome).length > 0 && segmentOutcome.success === false}\n                header={\n                    <div className=\"py-2\">\n                        <div className=\"flex flex-row gap-2\">\n                            <h3 className=\"mb-1\">{segment.name}</h3>\n                            {segmentOutcome && Object.keys(segmentOutcome).length > 0 ? (\n                                <div>\n                                    {segmentOutcome.success ? null : (\n                                        <LemonTag size=\"small\" type=\"default\">\n                                            failed\n                                        </LemonTag>\n                                    )}\n                                </div>\n                            ) : (\n                                <Spinner />\n                            )}\n                        </div>\n                        {segmentOutcome && (\n                            <>\n                                <p className=\"text-sm font-normal mb-0\">{segmentOutcome.summary}</p>\n                            </>\n                        )}\n                        <SegmentMetaTable\n                            meta={segment.meta && Object.keys(segment.meta).length > 0 ? segment.meta : null}\n                        />\n                    </div>\n                }\n                content={\n                    <>\n                        {keyActions && keyActions.length > 0 ? (\n                            <>\n                                {keyActions?.map((segmentKeyActions) => (\n                                    <SessionSummaryKeyActions\n                                        key={segmentKeyActions.segment_index}\n                                        keyActions={segmentKeyActions}\n                                        segmentName={segment.name}\n                                        onSeekToTime={onSeekToTime}\n                                    />\n                                ))}\n                            </>\n                        ) : (\n                            <div className=\"text-muted-alt\">\n                                Waiting for key actions... <Spinner />\n                            </div>\n                        )}\n                    </>\n                }\n            />\n        </div>\n    )\n}\n\nfunction SessionSummaryKeyActions({\n    keyActions,\n    segmentName,\n    onSeekToTime,\n}: {\n    keyActions: SessionSegmentKeyActions\n    segmentName?: string | null\n    onSeekToTime: (time: number) => void\n}): JSX.Element {\n    const timeToSeeekTo = (ms: number): number => Math.max(ms - 4000, 0)\n    return (\n        <>\n            {keyActions.events?.map((event: SessionKeyAction, eventIndex: number, events: SessionKeyAction[]) =>\n                isValidTimestamp(event.milliseconds_since_start) ? (\n                    <div\n                        key={`${segmentName}-${eventIndex}`}\n                        className={clsx(\n                            'cursor-pointer py-2 px-2 hover:bg-primary-alt-highlight',\n                            // Avoid adding a border to the last event\n                            eventIndex !== events.length - 1 && 'border-b',\n                            (event.abandonment || event.confusion || event.exception) && 'bg-danger-highlight'\n                        )}\n                        onClick={() => {\n                            // Excessive check, required for type safety\n                            if (!isValidTimestamp(event.milliseconds_since_start)) {\n                                return\n                            }\n                            onSeekToTime(timeToSeeekTo(event.milliseconds_since_start))\n                        }}\n                    >\n                        <div className=\"flex flex-row gap-2\">\n                            <span className=\"text-muted-alt shrink-0 min-w-[4rem] font-mono text-xs\">\n                                {formatMsIntoTime(event.milliseconds_since_start)}\n                                <div className=\"flex flex-row gap-2 mt-1\">\n                                    {event.current_url ? (\n                                        <Link to={event.current_url} target=\"_blank\">\n                                            <Tooltip title={event.current_url} placement=\"top\">\n                                                <span className=\"font-mono text-xs text-muted-alt\">url</span>\n                                            </Tooltip>\n                                        </Link>\n                                    ) : null}\n                                    <Tooltip title={formatEventMetaInfo(event)} placement=\"top\">\n                                        <span className=\"font-mono text-xs text-muted-alt\">meta</span>\n                                    </Tooltip>\n                                </div>\n                            </span>\n\n                            <div className=\"flex flex-col\">\n                                <div className=\"text-xs break-words\">{event.description}</div>\n                                <div className=\"flex flex-wrap gap-1 mt-2\">\n                                    {event.milliseconds_since_start === 0 && (\n                                        <LemonTag size=\"small\" type=\"default\">\n                                            before start\n                                        </LemonTag>\n                                    )}\n                                    {getIssueTags(event).map((tag, i) => (\n                                        <React.Fragment key={i}>{tag}</React.Fragment>\n                                    ))}\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                ) : null\n            )}\n        </>\n    )\n}\n\ninterface SessionSummaryLoadingStateProps {\n    finished: boolean\n    operation?: string\n    counter?: number\n    name?: string\n    outOf?: number\n}\n\nfunction SessionSummaryLoadingState({ operation, counter, name, outOf }: SessionSummaryLoadingStateProps): JSX.Element {\n    return (\n        <div className=\"mb-4 grid grid-cols-[auto_1fr] gap-x-2\">\n            <Spinner className=\"text-2xl row-span-2 self-center\" />\n            <div className=\"flex items-center justify-between\">\n                <span className=\"text-muted\">\n                    {operation}&nbsp;\n                    {counter !== undefined && (\n                        <span className=\"font-semibold\">\n                            ({counter}\n                            {outOf ? ` out of ${outOf}` : ''})\n                        </span>\n                    )}\n                    {name ? ':' : ''}\n                </span>\n                <div className=\"flex items-center gap-1 ml-auto font-mono text-xs\">\n                    <LoadingTimer operation={operation} />\n                </div>\n            </div>\n            {name ? (\n                <div className=\"font-semibold\">{name}</div>\n            ) : (\n                // Empty div to maintain two rows for spinner alignment\n                <div />\n            )}\n        </div>\n    )\n}\n\nfunction SessionSummaryRoot({ children }: { children: React.ReactNode }): JSX.Element {\n    return <div className=\"flex flex-col\">{children}</div>\n}\n\nfunction SessionSummaryTitle(): JSX.Element {\n    return (\n        <h3 className=\"text-lg font-semibold mt-2 flex items-center gap-2\">\n            <IconAIText />\n            AI Replay Research\n            <LemonTag type=\"completion\" size=\"medium\">\n                ALPHA\n            </LemonTag>\n        </h3>\n    )\n}\n\nfunction SessionSummarySubtitle({ sessionId }: { sessionId: string }): JSX.Element {\n    return (\n        <div className=\"flex align-center text-md gap-1\">\n            <p className=\"text-md \">Session ID: </p>\n            <Tooltip title=\"View recording\">\n                <Link to={urls.replaySingle(sessionId)} target=\"_new\">\n                    {sessionId}\n                </Link>\n            </Tooltip>\n        </div>\n    )\n}\n\nfunction SessionSummaryOutcomeBanner({ sessionSummary }: { sessionSummary: SessionSummaryContent }): JSX.Element {\n    return (\n        <LemonBanner type={sessionSummary?.session_outcome?.success ? 'success' : 'error'} className=\"mb-4\">\n            <div className=\"text-sm font-normal\">\n                <div>{sessionSummary?.session_outcome?.description}</div>\n            </div>\n        </LemonBanner>\n    )\n}\n\nfunction SessionSummarySegments({ sessionSummary }: { sessionSummary: SessionSummaryContent }): JSX.Element | null {\n    const { seekToTime } = useActions(sessionRecordingPlayerLogic)\n\n    if (!sessionSummary?.segments) {\n        return null\n    }\n\n    return (\n        <div>\n            {sessionSummary?.segments?.map((segment) => {\n                const matchingSegmentOutcome = sessionSummary?.segment_outcomes?.find(\n                    (outcome) => outcome.segment_index === segment.index\n                )\n                const matchingKeyActions = sessionSummary?.key_actions?.filter(\n                    (keyAction) => keyAction.segment_index === segment.index\n                )\n                return (\n                    <SessionSegmentView\n                        key={segment.name}\n                        segment={segment}\n                        segmentOutcome={matchingSegmentOutcome}\n                        keyActions={matchingKeyActions || []}\n                        onSeekToTime={seekToTime}\n                    />\n                )\n            })}\n        </div>\n    )\n}\n\nfunction SessionSummaryFeedback(): JSX.Element {\n    const { logicProps } = useValues(sessionRecordingPlayerLogic)\n    const { summaryHasHadFeedback } = useValues(playerMetaLogic(logicProps))\n    const { sessionSummaryFeedback } = useActions(playerMetaLogic(logicProps))\n\n    return (\n        <div className=\"text-right mb-2 mt-4\">\n            <p>Is this a good summary?</p>\n            <div className=\"flex flex-row gap-2 justify-end\">\n                <LemonButton\n                    size=\"xsmall\"\n                    type=\"primary\"\n                    icon={<IconThumbsUp />}\n                    disabledReason={summaryHasHadFeedback ? 'Thanks for your feedback!' : undefined}\n                    onClick={() => {\n                        sessionSummaryFeedback('good')\n                    }}\n                />\n                <LemonButton\n                    size=\"xsmall\"\n                    type=\"primary\"\n                    icon={<IconThumbsDown />}\n                    disabledReason={summaryHasHadFeedback ? 'Thanks for your feedback!' : undefined}\n                    onClick={() => {\n                        sessionSummaryFeedback('bad')\n                    }}\n                />\n            </div>\n        </div>\n    )\n}\n\nexport const SessionSummaryComponent = {\n    Root: SessionSummaryRoot,\n    Title: SessionSummaryTitle,\n    OutcomeBanner: SessionSummaryOutcomeBanner,\n    LoadingState: SessionSummaryLoadingState,\n    Segments: SessionSummarySegments,\n    Feedback: SessionSummaryFeedback,\n    Subtitle: SessionSummarySubtitle,\n}\n\nfunction SessionSummary(): JSX.Element {\n    const { logicProps } = useValues(sessionRecordingPlayerLogic)\n    const { sessionSummary } = useValues(playerMetaLogic(logicProps))\n\n    const getSessionSummaryLoadingState = (): SessionSummaryLoadingStateProps => {\n        if (!sessionSummary) {\n            return {\n                finished: false,\n                operation: 'Researching the session...',\n            }\n        }\n        const segments = sessionSummary.segments || []\n        const hasSegmentsWithKeyActions = segments.some((segment) =>\n            sessionSummary.key_actions?.some(\n                (keyAction) => keyAction.segment_index === segment.index && keyAction.events?.length\n            )\n        )\n        const hasSegmentsWithOutcomes = segments.some((segment) =>\n            sessionSummary.segment_outcomes?.some((outcome) => outcome.segment_index === segment.index)\n        )\n        const allSegmentsHaveSuccess = segments.every((segment) =>\n            sessionSummary.segment_outcomes?.some(\n                (outcome) =>\n                    outcome.segment_index === segment.index && outcome.success !== null && outcome.success !== undefined\n            )\n        )\n        // If all segments have a success outcome, it means the data is fully loaded and loading state can be hidden\n        if (allSegmentsHaveSuccess) {\n            return {\n                finished: true,\n            }\n        }\n        // If some segments have outcomes already, it means we stream the success and summary of each segment\n        if (hasSegmentsWithOutcomes) {\n            return {\n                finished: false,\n                operation: 'Analyzing the success of each segment',\n            }\n        }\n        // If some segments have key actions already, it means we stream the key actions for each segment\n        if (hasSegmentsWithKeyActions) {\n            // Find first segment that has no key actions\n            const nextSegmentIndex = segments.findIndex(\n                (segment) =>\n                    !sessionSummary.key_actions?.some(\n                        (keyAction) => keyAction.segment_index === segment.index && keyAction.events?.length\n                    )\n            )\n            // If we found such segment, and it's the first one, take it as current\n            // If we don't find such segment, it means we are researching the last segment\n            let currentSegmentIndex\n            if (nextSegmentIndex === 0) {\n                currentSegmentIndex = 0\n            } else if (nextSegmentIndex === -1) {\n                currentSegmentIndex = segments.length - 1\n            } else {\n                currentSegmentIndex = nextSegmentIndex - 1\n            }\n            const currentSegment = segments[currentSegmentIndex]\n            return {\n                finished: false,\n                operation: 'Researching key actions for segments',\n                counter: currentSegmentIndex,\n                name: currentSegment?.name ?? undefined,\n                outOf: segments.length,\n            }\n        }\n        // If no segments have key actions or outcomes, it means we are researching the segments for the session\n        return {\n            finished: false,\n            operation: 'Researching segments for the session...',\n            counter: segments.length || undefined,\n        }\n    }\n\n    const sessionSummaryLoadingState = getSessionSummaryLoadingState()\n\n    return (\n        <SessionSummaryComponent.Root>\n            {sessionSummary ? (\n                <>\n                    <SessionSummaryComponent.Title />\n\n                    <div className=\"mb-2\">\n                        {sessionSummaryLoadingState.finished &&\n                        sessionSummary?.session_outcome &&\n                        sessionSummary.session_outcome.success !== null &&\n                        sessionSummary.session_outcome.success !== undefined &&\n                        sessionSummary.session_outcome.description ? (\n                            <SessionSummaryComponent.OutcomeBanner sessionSummary={sessionSummary} />\n                        ) : (\n                            <div className=\"mb-4\">\n                                <SessionSummaryComponent.LoadingState\n                                    finished={sessionSummaryLoadingState.finished}\n                                    operation={sessionSummaryLoadingState.operation}\n                                    counter={sessionSummaryLoadingState.counter}\n                                    name={sessionSummaryLoadingState.name}\n                                    outOf={sessionSummaryLoadingState.outOf}\n                                />\n                            </div>\n                        )}\n                        <LemonDivider />\n                    </div>\n                    <SessionSummaryComponent.Segments sessionSummary={sessionSummary} />\n                    <SessionSummaryComponent.Feedback />\n                </>\n            ) : (\n                <div className=\"text-center text-muted-alt\">No summary available for this session</div>\n            )}\n        </SessionSummaryComponent.Root>\n    )\n}\n\nfunction LoadSessionSummaryButton(): JSX.Element {\n    const { logicProps } = useValues(sessionRecordingPlayerLogic)\n    const { sessionSummaryLoading, loading } = useValues(playerMetaLogic(logicProps))\n    const inspectorLogic = playerInspectorLogic(logicProps)\n    const { allItemsByMiniFilterKey } = useValues(inspectorLogic)\n    const { summarizeSession } = useActions(playerMetaLogic(logicProps))\n\n    // We need $autocapture events to be able to generate a summary\n    const hasEvents = [\n        'events-posthog',\n        'events-custom',\n        'events-pageview',\n        'events-autocapture',\n        'events-exceptions',\n    ].some((key) => allItemsByMiniFilterKey[key]?.length > 0)\n    const hasAutocaptureEvents = allItemsByMiniFilterKey['events-autocapture']?.length > 0\n\n    return (\n        <div className=\"space-y-2\">\n            <LemonButton\n                size=\"small\"\n                type=\"primary\"\n                icon={<IconMagicWand />}\n                fullWidth={true}\n                data-attr=\"load-session-summary\"\n                disabled={loading || !hasAutocaptureEvents}\n                disabledReason={sessionSummaryLoading ? 'Loading...' : undefined}\n                onClick={summarizeSession}\n            >\n                Use AI to summarise this session\n            </LemonButton>\n\n            {loading ? (\n                <div className=\"text-sm\">\n                    Checking on session events... <Spinner />\n                </div>\n            ) : (\n                !hasAutocaptureEvents && (\n                    <div>\n                        {hasEvents ? (\n                            <>\n                                <h4>No autocapture events found for this session</h4>\n                                <p className=\"text-sm mb-1\">\n                                    Please, ensure that Autocapture is enabled in project's settings, or try again in a\n                                    few minutes.\n                                </p>\n                            </>\n                        ) : (\n                            <>\n                                <h4>Session events are not available for summary yet</h4>\n                                <p className=\"text-sm mb-1\">Please, try again in a few minutes.</p>\n                            </>\n                        )}\n                    </div>\n                )\n            )}\n        </div>\n    )\n}\n\nexport function PlayerSidebarSessionSummary(): JSX.Element | null {\n    const { logicProps } = useValues(sessionRecordingPlayerLogic)\n    const { sessionSummary, sessionSummaryLoading } = useValues(playerMetaLogic(logicProps))\n\n    return (\n        <div className=\"rounded border bg-surface-primary px-2 py-1\">\n            {sessionSummaryLoading ? (\n                <>\n                    <div className=\"flex items-center justify-between\">\n                        <div>\n                            Researching the session... <Spinner />\n                        </div>\n                        <div className=\"flex items-center gap-1 ml-auto\">\n                            <LoadingTimer />\n                        </div>\n                    </div>\n                </>\n            ) : sessionSummary ? (\n                <SessionSummary />\n            ) : (\n                <LoadSessionSummaryButton />\n            )}\n        </div>\n    )\n}\n","import posthog from 'posthog-js'\n\nimport {\n    EventType,\n    IncrementalSource,\n    addedNodeMutation,\n    customEvent,\n    fullSnapshotEvent,\n    incrementalSnapshotEvent,\n    metaEvent,\n    mutationData,\n    removedNodeMutation,\n} from '@posthog/rrweb-types'\n\nimport { isObject } from 'lib/utils'\nimport { PLACEHOLDER_SVG_DATA_IMAGE_URL } from 'scenes/session-recordings/player/rrweb'\n\nimport {\n    fullSnapshotEvent as MobileFullSnapshotEvent,\n    MobileIncrementalSnapshotEvent,\n    metaEvent as MobileMetaEvent,\n    MobileNodeMutation,\n    MobileNodeType,\n    NodeType,\n    attributes,\n    documentNode,\n    elementNode,\n    keyboardEvent,\n    serializedNodeWithId,\n    textNode,\n    wireframe,\n    wireframeButton,\n    wireframeCheckBox,\n    wireframeDiv,\n    wireframeImage,\n    wireframeInputComponent,\n    wireframeNavigationBar,\n    wireframePlaceholder,\n    wireframeProgress,\n    wireframeRadio,\n    wireframeRadioGroup,\n    wireframeRectangle,\n    wireframeScreenshot,\n    wireframeSelect,\n    wireframeStatusBar,\n    wireframeText,\n    wireframeToggle,\n} from '../mobile.types'\nimport { makeNavigationBar, makeOpenKeyboardPlaceholder, makeStatusBar } from './screen-chrome'\nimport { ConversionContext, ConversionResult } from './types'\nimport {\n    asStyleString,\n    makeBodyStyles,\n    makeColorStyles,\n    makeDeterminateProgressStyles,\n    makeHTMLStyles,\n    makeIndeterminateProgressStyles,\n    makeMinimalStyles,\n    makePositionStyles,\n    makeStylesString,\n} from './wireframeStyle'\n\nexport const BACKGROUND = '#f3f4ef'\nconst FOREGROUND = '#35373e'\n\n/**\n * generates a sequence of ids\n * from 100 to 9,999,999\n * the transformer reserves ids in the range 0 to 9,999,999\n * we reserve a range of ids because we need nodes to have stable ids across snapshots\n * in order for incremental snapshots to work\n * some mobile elements have to be wrapped in other elements in order to be styled correctly\n * which means the web version of a mobile replay will use ids that don't exist in the mobile replay,\n * and we need to ensure they don't clash\n * -----\n * id is typed as a number in rrweb\n * and there's a few places in their code where rrweb uses a check for `id === -1` to bail out of processing\n * so, it's safest to assume that id is expected to be a positive integer\n */\nfunction* ids(): Generator<number> {\n    let i = 100\n    while (i < 9999999) {\n        yield i++\n    }\n}\n\nlet globalIdSequence = ids()\n\n// there are some fixed ids that we need to use for fixed elements or artificial mutations\nconst DOCUMENT_ID = 1\nconst HTML_DOC_TYPE_ID = 2\nconst HTML_ELEMENT_ID = 3\nconst HEAD_ID = 4\nconst BODY_ID = 5\n// the nav bar should always be the last item in the body so that it is at the top of the stack\nconst NAVIGATION_BAR_PARENT_ID = 7\nexport const NAVIGATION_BAR_ID = 8\n// the keyboard so that it is still before the nav bar\nconst KEYBOARD_PARENT_ID = 9\nexport const KEYBOARD_ID = 10\nexport const STATUS_BAR_PARENT_ID = 11\nexport const STATUS_BAR_ID = 12\n\nfunction isKeyboardEvent(x: unknown): x is keyboardEvent {\n    return isObject(x) && 'data' in x && isObject(x.data) && 'tag' in x.data && x.data.tag === 'keyboard'\n}\n\nexport function _isPositiveInteger(id: unknown): id is number {\n    return typeof id === 'number' && id > 0 && id % 1 === 0\n}\n\nfunction _isNullish(x: unknown): x is null | undefined {\n    return x === null || x === undefined\n}\n\nfunction isRemovedNodeMutation(x: addedNodeMutation | removedNodeMutation): x is removedNodeMutation {\n    return isObject(x) && 'id' in x\n}\n\nexport const makeCustomEvent = (\n    mobileCustomEvent: (customEvent | keyboardEvent) & {\n        timestamp: number\n        delay?: number\n    }\n): (customEvent | incrementalSnapshotEvent) & {\n    timestamp: number\n    delay?: number\n} => {\n    if (isKeyboardEvent(mobileCustomEvent)) {\n        // keyboard events are handled as incremental snapshots to add or remove a keyboard from the DOM\n        // TODO eventually we can pass something to makeIncrementalEvent here\n        const adds: addedNodeMutation[] = []\n        const removes = []\n        if (mobileCustomEvent.data.payload.open) {\n            const keyboardPlaceHolder = makeOpenKeyboardPlaceholder(mobileCustomEvent, {\n                timestamp: mobileCustomEvent.timestamp,\n                idSequence: globalIdSequence,\n            })\n            if (keyboardPlaceHolder) {\n                adds.push({\n                    parentId: KEYBOARD_PARENT_ID,\n                    nextId: null,\n                    node: keyboardPlaceHolder.result,\n                })\n                // mutations seem not to want a tree of nodes to add\n                // so even though `keyboardPlaceholder` is a tree with content\n                // we have to add the text content as well\n                adds.push({\n                    parentId: keyboardPlaceHolder.result.id,\n                    nextId: null,\n                    node: {\n                        type: NodeType.Text,\n                        id: globalIdSequence.next().value,\n                        textContent: 'keyboard',\n                    },\n                })\n            } else {\n                posthog.captureException(new Error('Failed to create keyboard placeholder'), { mobileCustomEvent })\n            }\n        } else {\n            removes.push({\n                parentId: KEYBOARD_PARENT_ID,\n                id: KEYBOARD_ID,\n            })\n        }\n        const mutation: mutationData = { adds, attributes: [], removes, source: IncrementalSource.Mutation, texts: [] }\n        return {\n            type: EventType.IncrementalSnapshot,\n            data: mutation,\n            timestamp: mobileCustomEvent.timestamp,\n        }\n    }\n    return mobileCustomEvent\n}\n\nexport const makeMetaEvent = (\n    mobileMetaEvent: MobileMetaEvent & {\n        timestamp: number\n    }\n): metaEvent & {\n    timestamp: number\n    delay?: number\n} => ({\n    type: EventType.Meta,\n    data: {\n        href: mobileMetaEvent.data.href || '', // the replay doesn't use the href, so we safely ignore any absence\n        // mostly we need width and height in order to size the viewport\n        width: mobileMetaEvent.data.width,\n        height: mobileMetaEvent.data.height,\n    },\n    timestamp: mobileMetaEvent.timestamp,\n})\n\nexport function makeDivElement(\n    wireframe: wireframeDiv,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const _id = _isPositiveInteger(wireframe.id) ? wireframe.id : context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: asStyleString([makeStylesString(wireframe), 'overflow:hidden', 'white-space:nowrap']),\n                'data-rrweb-id': _id,\n            },\n            id: _id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction makeTextElement(\n    wireframe: wireframeText,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (wireframe.type !== 'text') {\n        console.error('Passed incorrect wireframe type to makeTextElement')\n        return null\n    }\n\n    // because we might have to style the text, we always wrap it in a div\n    // and apply styles to that\n    const id = context.idSequence.next().value\n\n    const childNodes = [...children]\n    if (!_isNullish(wireframe.text)) {\n        childNodes.unshift({\n            type: NodeType.Text,\n            textContent: wireframe.text,\n            // since the text node is wrapped, we assign it a synthetic id\n            id,\n        })\n    }\n\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: asStyleString([makeStylesString(wireframe), 'overflow:hidden', 'white-space:normal']),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes,\n        },\n        context,\n    }\n}\n\nfunction makeWebViewElement(\n    wireframe: wireframe,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const labelledWireframe: wireframePlaceholder = { ...wireframe } as wireframePlaceholder\n    if ('url' in wireframe) {\n        labelledWireframe.label = wireframe.url\n    }\n\n    return makePlaceholderElement(labelledWireframe, children, context)\n}\n\nexport function makePlaceholderElement(\n    wireframe: wireframe,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const txt = 'label' in wireframe && wireframe.label ? wireframe.label : wireframe.type || 'PLACEHOLDER'\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe, {\n                    verticalAlign: 'center',\n                    horizontalAlign: 'center',\n                    backgroundColor: wireframe.style?.backgroundColor || BACKGROUND,\n                    color: wireframe.style?.color || FOREGROUND,\n                    backgroundImage: PLACEHOLDER_SVG_DATA_IMAGE_URL,\n                    backgroundSize: 'auto',\n                    backgroundRepeat: 'unset',\n                    ...context.styleOverride,\n                }),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: [\n                {\n                    type: NodeType.Text,\n                    // since the text node is wrapped, we assign it a synthetic id\n                    id: context.idSequence.next().value,\n                    textContent: txt,\n                },\n                ...children,\n            ],\n        },\n        context,\n    }\n}\n\nexport function dataURIOrPNG(src: string): string {\n    // replace all new lines in src\n    src = src.replace(/\\r?\\n|\\r/g, '')\n    if (!src.startsWith('data:image/')) {\n        return 'data:image/png;base64,' + src\n    }\n    return src\n}\n\nfunction makeImageElement(\n    wireframe: wireframeImage | wireframeScreenshot,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (!wireframe.base64) {\n        return makePlaceholderElement(wireframe, children, context)\n    }\n\n    const src = dataURIOrPNG(wireframe.base64)\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'img',\n            attributes: {\n                src: src,\n                width: wireframe.width,\n                height: wireframe.height,\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction inputAttributes<T extends wireframeInputComponent>(wireframe: T): attributes {\n    const attributes = {\n        style: makeStylesString(wireframe),\n        type: wireframe.inputType,\n        ...(wireframe.disabled ? { disabled: wireframe.disabled } : {}),\n        'data-rrweb-id': wireframe.id,\n    }\n\n    switch (wireframe.inputType) {\n        case 'checkbox':\n            return {\n                ...attributes,\n                style: null, // checkboxes are styled by being combined with a label\n                ...(wireframe.checked ? { checked: wireframe.checked } : {}),\n            }\n        case 'toggle':\n            return {\n                ...attributes,\n                style: null, // toggle are styled by being combined with a label\n                ...(wireframe.checked ? { checked: wireframe.checked } : {}),\n            }\n        case 'radio':\n            return {\n                ...attributes,\n                style: null, // radio buttons are styled by being combined with a label\n                ...(wireframe.checked ? { checked: wireframe.checked } : {}),\n                // radio value defaults to the string \"on\" if not specified\n                // we're not really submitting the form, so it doesn't matter 🤞\n                // radio name is used to correctly uncheck values when one is checked\n                // mobile doesn't really have it, and we will be checking based on snapshots,\n                // so we can ignore it for now\n            }\n        case 'button':\n            return {\n                ...attributes,\n            }\n        case 'text_area':\n            return {\n                ...attributes,\n                value: wireframe.value || '',\n            }\n        case 'progress':\n            return {\n                ...attributes,\n                // indeterminate when omitted\n                value: wireframe.value || null,\n                // defaults to 1 when omitted\n                max: wireframe.max || null,\n                type: null, // progress has no type attribute\n            }\n        default:\n            return {\n                ...attributes,\n                value: wireframe.value || '',\n            }\n    }\n}\n\nfunction makeButtonElement(\n    wireframe: wireframeButton,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const buttonText: textNode | null = wireframe.value\n        ? {\n              type: NodeType.Text,\n              textContent: wireframe.value,\n          }\n        : null\n\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'button',\n            attributes: inputAttributes(wireframe),\n            id: wireframe.id,\n            childNodes: buttonText ? [{ ...buttonText, id: context.idSequence.next().value }, ...children] : children,\n        },\n        context,\n    }\n}\n\nfunction makeSelectOptionElement(\n    option: string,\n    selected: boolean,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> {\n    const optionId = context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'option',\n            attributes: {\n                ...(selected ? { selected: selected } : {}),\n                'data-rrweb-id': optionId,\n            },\n            id: optionId,\n            childNodes: [\n                {\n                    type: NodeType.Text,\n                    textContent: option,\n                    id: context.idSequence.next().value,\n                },\n            ],\n        },\n        context,\n    }\n}\n\nfunction makeSelectElement(\n    wireframe: wireframeSelect,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const selectOptions: serializedNodeWithId[] = []\n    if (wireframe.options) {\n        let optionContext = context\n        for (let i = 0; i < wireframe.options.length; i++) {\n            const option = wireframe.options[i]\n            const conversion = makeSelectOptionElement(option, wireframe.value === option, optionContext)\n            selectOptions.push(conversion.result)\n            optionContext = conversion.context\n        }\n    }\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'select',\n            attributes: inputAttributes(wireframe),\n            id: wireframe.id,\n            childNodes: [...selectOptions, ...children],\n        },\n        context,\n    }\n}\n\nfunction groupRadioButtons(children: serializedNodeWithId[], radioGroupName: string): serializedNodeWithId[] {\n    return children.map((child) => {\n        if (child.type === NodeType.Element && child.tagName === 'input' && child.attributes.type === 'radio') {\n            return {\n                ...child,\n                attributes: {\n                    ...child.attributes,\n                    name: radioGroupName,\n                    'data-rrweb-id': child.id,\n                },\n            }\n        }\n        return child\n    })\n}\n\nfunction makeRadioGroupElement(\n    wireframe: wireframeRadioGroup,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const radioGroupName = 'radio_group_' + wireframe.id\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: groupRadioButtons(children, radioGroupName),\n        },\n        context,\n    }\n}\n\nfunction makeStar(title: string, path: string, context: ConversionContext): serializedNodeWithId {\n    const svgId = context.idSequence.next().value\n    const titleId = context.idSequence.next().value\n    const pathId = context.idSequence.next().value\n    return {\n        type: NodeType.Element,\n        tagName: 'svg',\n        isSVG: true,\n        attributes: {\n            style: asStyleString(['height: 100%', 'overflow-clip-margin: content-box', 'overflow:hidden']),\n            viewBox: '0 0 24 24',\n            fill: 'currentColor',\n            'data-rrweb-id': svgId,\n        },\n        id: svgId,\n        childNodes: [\n            {\n                type: NodeType.Element,\n                tagName: 'title',\n                isSVG: true,\n                attributes: {\n                    'data-rrweb-id': titleId,\n                },\n                id: titleId,\n                childNodes: [\n                    {\n                        type: NodeType.Text,\n                        textContent: title,\n                        id: context.idSequence.next().value,\n                    },\n                ],\n            },\n            {\n                type: NodeType.Element,\n                tagName: 'path',\n                isSVG: true,\n                attributes: {\n                    d: path,\n                    'data-rrweb-id': pathId,\n                },\n                id: pathId,\n                childNodes: [],\n            },\n        ],\n    }\n}\n\nfunction filledStar(context: ConversionContext): serializedNodeWithId {\n    return makeStar(\n        'filled star',\n        'M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z',\n        context\n    )\n}\n\nfunction halfStar(context: ConversionContext): serializedNodeWithId {\n    return makeStar(\n        'half-filled star',\n        'M12,15.4V6.1L13.71,10.13L18.09,10.5L14.77,13.39L15.76,17.67M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z',\n        context\n    )\n}\n\nfunction emptyStar(context: ConversionContext): serializedNodeWithId {\n    return makeStar(\n        'empty star',\n        'M12,15.39L8.24,17.66L9.23,13.38L5.91,10.5L10.29,10.13L12,6.09L13.71,10.13L18.09,10.5L14.77,13.38L15.76,17.66M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z',\n        context\n    )\n}\n\nfunction makeRatingBar(\n    wireframe: wireframeProgress,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    // max is the number of stars... and value is the number of stars to fill\n\n    // deliberate double equals, because we want to allow null and undefined\n    if (wireframe.value == null || wireframe.max == null) {\n        return makePlaceholderElement(wireframe, children, context)\n    }\n\n    const numberOfFilledStars = Math.floor(wireframe.value)\n    const numberOfHalfStars = wireframe.value - numberOfFilledStars > 0 ? 1 : 0\n    const numberOfEmptyStars = wireframe.max - numberOfFilledStars - numberOfHalfStars\n\n    const filledStars = Array(numberOfFilledStars)\n        .fill(undefined)\n        .map(() => filledStar(context))\n    const halfStars = Array(numberOfHalfStars)\n        .fill(undefined)\n        .map(() => halfStar(context))\n    const emptyStars = Array(numberOfEmptyStars)\n        .fill(undefined)\n        .map(() => emptyStar(context))\n\n    const ratingBarId = context.idSequence.next().value\n    const ratingBar = {\n        type: NodeType.Element,\n        tagName: 'div',\n        id: ratingBarId,\n        attributes: {\n            style: asStyleString([\n                makeColorStyles(wireframe),\n                'position: relative',\n                'display: flex',\n                'flex-direction: row',\n                'padding: 2px 4px',\n            ]),\n            'data-rrweb-id': ratingBarId,\n        },\n        childNodes: [...filledStars, ...halfStars, ...emptyStars],\n    } as serializedNodeWithId\n\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: [ratingBar, ...children],\n        },\n        context,\n    }\n}\n\nfunction makeProgressElement(\n    wireframe: wireframeProgress,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (wireframe.style?.bar === 'circular') {\n        // value needs to be expressed as a number between 0 and 100\n        const max = wireframe.max || 1\n        let value = wireframe.value || null\n        if (_isPositiveInteger(value) && value <= max) {\n            value = (value / max) * 100\n        } else {\n            value = null\n        }\n\n        const styleOverride = {\n            color: wireframe.style?.color || FOREGROUND,\n            backgroundColor: wireframe.style?.backgroundColor || BACKGROUND,\n        }\n\n        // if not _isPositiveInteger(value) then we render a spinner,\n        // so we need to add a style element with the spin keyframe\n        const stylingChildren: serializedNodeWithId[] = _isPositiveInteger(value)\n            ? []\n            : [\n                  {\n                      type: NodeType.Element,\n                      tagName: 'style',\n                      attributes: {\n                          type: 'text/css',\n                      },\n                      id: context.idSequence.next().value,\n                      childNodes: [\n                          {\n                              type: NodeType.Text,\n                              textContent: `@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`,\n                              id: context.idSequence.next().value,\n                          },\n                      ],\n                  },\n              ]\n\n        const wrappingDivId = context.idSequence.next().value\n        return {\n            result: {\n                type: NodeType.Element,\n                tagName: 'div',\n                attributes: {\n                    style: makeMinimalStyles(wireframe),\n                    'data-rrweb-id': wireframe.id,\n                },\n                id: wireframe.id,\n                childNodes: [\n                    {\n                        type: NodeType.Element,\n                        tagName: 'div',\n                        attributes: {\n                            // with no provided value we render a spinner\n                            style: _isPositiveInteger(value)\n                                ? makeDeterminateProgressStyles(wireframe, styleOverride)\n                                : makeIndeterminateProgressStyles(wireframe, styleOverride),\n                            'data-rrweb-id': wrappingDivId,\n                        },\n                        id: wrappingDivId,\n                        childNodes: stylingChildren,\n                    },\n                    ...children,\n                ],\n            },\n            context,\n        }\n    } else if (wireframe.style?.bar === 'rating') {\n        return makeRatingBar(wireframe, children, context)\n    }\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'progress',\n            attributes: inputAttributes(wireframe),\n            id: wireframe.id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction makeToggleParts(wireframe: wireframeToggle, context: ConversionContext): serializedNodeWithId[] {\n    const togglePosition = wireframe.checked ? 'right' : 'left'\n    const defaultColor = wireframe.checked ? '#1d4aff' : BACKGROUND\n    const sliderPartId = context.idSequence.next().value\n    const handlePartId = context.idSequence.next().value\n    return [\n        {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                'data-toggle-part': 'slider',\n                style: asStyleString([\n                    'position:absolute',\n                    'top:33%',\n                    'left:5%',\n                    'display:inline-block',\n                    'width:75%',\n                    'height:33%',\n                    'opacity: 0.2',\n                    'border-radius:7.5%',\n                    `background-color:${wireframe.style?.color || defaultColor}`,\n                ]),\n                'data-rrweb-id': sliderPartId,\n            },\n            id: sliderPartId,\n            childNodes: [],\n        },\n        {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                'data-toggle-part': 'handle',\n                style: asStyleString([\n                    'position:absolute',\n                    'top:1.5%',\n                    `${togglePosition}:5%`,\n                    'display:flex',\n                    'align-items:center',\n                    'justify-content:center',\n                    'width:40%',\n                    'height:75%',\n                    'cursor:inherit',\n                    'border-radius:50%',\n                    `background-color:${wireframe.style?.color || defaultColor}`,\n                    `border:2px solid ${wireframe.style?.borderColor || wireframe.style?.color || defaultColor}`,\n                ]),\n                'data-rrweb-id': handlePartId,\n            },\n            id: handlePartId,\n            childNodes: [],\n        },\n    ]\n}\n\nfunction makeToggleElement(\n    wireframe: wireframeToggle,\n    context: ConversionContext\n): ConversionResult<\n    elementNode & {\n        id: number\n    }\n> | null {\n    const isLabelled = 'label' in wireframe\n    const wrappingDivId = context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                // if labelled take up available space, otherwise use provided positioning\n                style: isLabelled ? asStyleString(['height:100%', 'flex:1']) : makePositionStyles(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: [\n                {\n                    type: NodeType.Element,\n                    tagName: 'div',\n                    attributes: {\n                        // relative position, fills parent\n                        style: asStyleString(['position:relative', 'width:100%', 'height:100%']),\n                        'data-rrweb-id': wrappingDivId,\n                    },\n                    id: wrappingDivId,\n                    childNodes: makeToggleParts(wireframe, context),\n                },\n            ],\n        },\n        context,\n    }\n}\n\nfunction makeLabelledInput(\n    wireframe: wireframeCheckBox | wireframeRadio | wireframeToggle,\n    theInputElement: serializedNodeWithId,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> {\n    const theLabel: serializedNodeWithId = {\n        type: NodeType.Text,\n        textContent: wireframe.label || '',\n        id: context.idSequence.next().value,\n    }\n\n    const orderedChildren = wireframe.inputType === 'toggle' ? [theLabel, theInputElement] : [theInputElement, theLabel]\n\n    const labelId = context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'label',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': labelId,\n            },\n            id: labelId,\n            childNodes: orderedChildren,\n        },\n        context,\n    }\n}\n\nfunction makeInputElement(\n    wireframe: wireframeInputComponent,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (!wireframe.inputType) {\n        return null\n    }\n\n    if (wireframe.inputType === 'button') {\n        return makeButtonElement(wireframe, children, context)\n    }\n\n    if (wireframe.inputType === 'select') {\n        return makeSelectElement(wireframe, children, context)\n    }\n\n    if (wireframe.inputType === 'progress') {\n        return makeProgressElement(wireframe, children, context)\n    }\n\n    const theInputElement: ConversionResult<serializedNodeWithId> | null =\n        wireframe.inputType === 'toggle'\n            ? makeToggleElement(wireframe, context)\n            : {\n                  result: {\n                      type: NodeType.Element,\n                      tagName: 'input',\n                      attributes: inputAttributes(wireframe),\n                      id: wireframe.id,\n                      childNodes: children,\n                  },\n                  context,\n              }\n\n    if (!theInputElement) {\n        return null\n    }\n\n    if ('label' in wireframe) {\n        return makeLabelledInput(wireframe, theInputElement.result, theInputElement.context)\n    }\n    // when labelled no styles are needed, when un-labelled as here - we add the styling in.\n    ;(theInputElement.result as elementNode).attributes.style = makeStylesString(wireframe)\n    return theInputElement\n}\n\nfunction makeRectangleElement(\n    wireframe: wireframeRectangle,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction chooseConverter<T extends wireframe>(\n    wireframe: T\n): (\n    wireframe: T,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n) => ConversionResult<serializedNodeWithId> | null {\n    // in theory type is always present\n    // but since this is coming over the wire we can't really be sure,\n    // and so we default to div\n    const converterType: MobileNodeType = wireframe.type || 'div'\n    const converterMapping: Record<\n        MobileNodeType,\n        (wireframe: T, children: serializedNodeWithId[]) => ConversionResult<serializedNodeWithId> | null\n    > = {\n        // KLUDGE: TS can't tell that the wireframe type of each function is safe based on the converter type\n        text: makeTextElement as any,\n        image: makeImageElement as any,\n        rectangle: makeRectangleElement as any,\n        div: makeDivElement as any,\n        input: makeInputElement as any,\n        radio_group: makeRadioGroupElement as any,\n        web_view: makeWebViewElement as any,\n        placeholder: makePlaceholderElement as any,\n        status_bar: makeStatusBar as any,\n        navigation_bar: makeNavigationBar as any,\n        screenshot: makeImageElement as any,\n    }\n    return converterMapping[converterType]\n}\n\nfunction convertWireframe(\n    wireframe: wireframe,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const children = convertWireframesFor(wireframe.childWireframes, context)\n    const converted = chooseConverter(wireframe)?.(wireframe, children.result, children.context)\n    return converted || null\n}\n\nfunction convertWireframesFor(\n    wireframes: wireframe[] | undefined,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId[]> {\n    if (!wireframes) {\n        return { result: [], context }\n    }\n\n    const result: serializedNodeWithId[] = []\n    for (const wireframe of wireframes) {\n        const converted = convertWireframe(wireframe, context)\n        if (converted) {\n            result.push(converted.result)\n            context = converted.context\n        }\n    }\n    return { result, context }\n}\n\nfunction isMobileIncrementalSnapshotEvent(x: unknown): x is MobileIncrementalSnapshotEvent {\n    const isIncrementalSnapshot = isObject(x) && 'type' in x && x.type === EventType.IncrementalSnapshot\n    if (!isIncrementalSnapshot) {\n        return false\n    }\n    const hasData = isObject(x) && 'data' in x\n    const data = hasData ? x.data : null\n\n    const hasMutationSource = isObject(data) && 'source' in data && data.source === IncrementalSource.Mutation\n\n    const adds = isObject(data) && 'adds' in data && Array.isArray(data.adds) ? data.adds : null\n    const updates = isObject(data) && 'updates' in data && Array.isArray(data.updates) ? data.updates : null\n\n    const hasUpdatedWireframe = !!updates && updates.length > 0 && isObject(updates[0]) && 'wireframe' in updates[0]\n    const hasAddedWireframe = !!adds && adds.length > 0 && isObject(adds[0]) && 'wireframe' in adds[0]\n\n    return hasMutationSource && (hasAddedWireframe || hasUpdatedWireframe)\n}\n\nfunction chooseParentId(nodeType: MobileNodeType, providedParentId: number): number {\n    return nodeType === 'screenshot' ? BODY_ID : providedParentId\n}\n\nfunction makeIncrementalAdd(add: MobileNodeMutation, context: ConversionContext): addedNodeMutation[] | null {\n    const converted = convertWireframe(add.wireframe, context)\n\n    if (!converted) {\n        return null\n    }\n\n    const addition: addedNodeMutation = {\n        parentId: chooseParentId(add.wireframe.type, add.parentId),\n        nextId: null,\n        node: converted.result,\n    }\n    const adds: addedNodeMutation[] = []\n    if (addition) {\n        const flattened = flattenMutationAdds(addition)\n        flattened.forEach((x) => adds.push(x))\n        return adds\n    }\n    return null\n}\n\n/**\n * When processing an update we remove the entire item, and then add it back in.\n */\nfunction makeIncrementalRemoveForUpdate(update: MobileNodeMutation): removedNodeMutation {\n    return {\n        parentId: chooseParentId(update.wireframe.type, update.parentId),\n        id: update.wireframe.id,\n    }\n}\n\nfunction isNode(x: unknown): x is serializedNodeWithId {\n    // KLUDGE: really we should check that x.type is valid, but we're safe enough already\n    return isObject(x) && 'type' in x && 'id' in x\n}\n\nfunction isNodeWithChildren(x: unknown): x is elementNode | documentNode {\n    return isNode(x) && 'childNodes' in x && Array.isArray(x.childNodes)\n}\n\n/**\n * when creating incremental adds we have to flatten the node tree structure\n * there's no point, then keeping those child nodes in place\n */\nfunction cloneWithoutChildren(converted: addedNodeMutation): addedNodeMutation {\n    const cloned = { ...converted }\n    const clonedNode: serializedNodeWithId = { ...converted.node }\n    if (isNodeWithChildren(clonedNode)) {\n        clonedNode.childNodes = []\n    }\n    cloned.node = clonedNode\n    return cloned\n}\n\nfunction flattenMutationAdds(converted: addedNodeMutation): addedNodeMutation[] {\n    const flattened: addedNodeMutation[] = []\n\n    flattened.push(cloneWithoutChildren(converted))\n\n    const node: unknown = converted.node\n    const newParentId = converted.node.id\n    if (isNodeWithChildren(node)) {\n        node.childNodes.forEach((child) => {\n            flattened.push(\n                cloneWithoutChildren({\n                    parentId: newParentId,\n                    nextId: null,\n                    node: child,\n                })\n            )\n            if (isNodeWithChildren(child)) {\n                flattened.push(...flattenMutationAdds({ parentId: newParentId, nextId: null, node: child }))\n            }\n        })\n    }\n    return flattened\n}\n\n/**\n * each update wireframe carries the entire tree because we don't want to diff on the client\n * that means that we might create multiple mutations for the same node\n * we only want to add it once, so we dedupe the mutations\n * the app guarantees that for a given ID that is present more than once in a single snapshot\n * every instance of that ID is identical\n * it might change in the next snapshot but for a single incremental snapshot there is one\n * and only one version of any given ID\n */\nfunction dedupeMutations<T extends addedNodeMutation | removedNodeMutation>(mutations: T[]): T[] {\n    // KLUDGE: it's slightly yucky to stringify everything but since synthetic nodes\n    // introduce a new id, we can't just compare the id\n    const seen = new Set<string>()\n\n    // in case later mutations are the ones we want to keep, we reverse the array\n    // this does help with the deduping, so, it's likely that the view for a single ID\n    // is not consistent over a snapshot, but it's cheap to reverse so :YOLO:\n    return mutations\n        .reverse()\n        .filter((mutation: addedNodeMutation | removedNodeMutation) => {\n            let toCompare: string\n            if (isRemovedNodeMutation(mutation)) {\n                toCompare = JSON.stringify(mutation)\n            } else {\n                // if this is a synthetic addition, then we need to ignore the id,\n                // since duplicates won't have duplicate ids\n                toCompare = JSON.stringify({\n                    ...mutation.node,\n                    id: 0,\n                })\n            }\n\n            if (seen.has(toCompare)) {\n                return false\n            }\n            seen.add(toCompare)\n            return true\n        })\n        .reverse()\n}\n\n/**\n * We want to ensure that any events don't use id = 0.\n * They must always represent a valid ID from the dom, so we swap in the body id when the id = 0.\n *\n * For \"removes\", we don't need to do anything, the id of the element to be removed remains valid. We won't try and remove other elements that we added during transformation in order to show that element.\n *\n * \"adds\" are converted from wireframes to nodes and converted to `incrementalSnapshotEvent.adds`\n *\n * \"updates\" are converted to a remove and an add.\n *\n */\nexport const makeIncrementalEvent = (\n    mobileEvent: (MobileIncrementalSnapshotEvent | incrementalSnapshotEvent) & {\n        timestamp: number\n        delay?: number\n    }\n): incrementalSnapshotEvent & {\n    timestamp: number\n    delay?: number\n} => {\n    const converted = mobileEvent as unknown as incrementalSnapshotEvent & {\n        timestamp: number\n        delay?: number\n    }\n    if ('id' in converted.data && converted.data.id === 0) {\n        converted.data.id = BODY_ID\n    }\n\n    if (isMobileIncrementalSnapshotEvent(mobileEvent)) {\n        const adds: addedNodeMutation[] = []\n        const removes: removedNodeMutation[] = mobileEvent.data.removes || []\n        if ('adds' in mobileEvent.data && Array.isArray(mobileEvent.data.adds)) {\n            const addsContext = {\n                timestamp: mobileEvent.timestamp,\n                idSequence: globalIdSequence,\n            }\n\n            mobileEvent.data.adds.forEach((add) => {\n                makeIncrementalAdd(add, addsContext)?.forEach((x) => adds.push(x))\n            })\n        }\n        if ('updates' in mobileEvent.data && Array.isArray(mobileEvent.data.updates)) {\n            const updatesContext = {\n                timestamp: mobileEvent.timestamp,\n                idSequence: globalIdSequence,\n            }\n            const updateAdditions: addedNodeMutation[] = []\n            mobileEvent.data.updates.forEach((update) => {\n                const removal = makeIncrementalRemoveForUpdate(update)\n                if (removal) {\n                    removes.push(removal)\n                }\n                makeIncrementalAdd(update, updatesContext)?.forEach((x) => updateAdditions.push(x))\n            })\n            dedupeMutations(updateAdditions).forEach((x) => adds.push(x))\n        }\n\n        converted.data = {\n            source: IncrementalSource.Mutation,\n            attributes: [],\n            texts: [],\n            adds: dedupeMutations(adds),\n            // TODO: this assumes that removes are processed before adds 🤞\n            removes: dedupeMutations(removes),\n        }\n    }\n\n    return converted\n}\n\nfunction makeKeyboardParent(): serializedNodeWithId {\n    return {\n        type: NodeType.Element,\n        tagName: 'div',\n        attributes: {\n            'data-render-reason': 'a fixed placeholder to contain the keyboard in the correct stacking position',\n            'data-rrweb-id': KEYBOARD_PARENT_ID,\n        },\n        id: KEYBOARD_PARENT_ID,\n        childNodes: [],\n    }\n}\n\nfunction makeStatusBarNode(\n    statusBar: wireframeStatusBar | undefined,\n    context: ConversionContext\n): serializedNodeWithId {\n    const childNodes = statusBar ? convertWireframesFor([statusBar], context).result : []\n    return {\n        type: NodeType.Element,\n        tagName: 'div',\n        attributes: {\n            'data-rrweb-id': STATUS_BAR_PARENT_ID,\n        },\n        id: STATUS_BAR_PARENT_ID,\n        childNodes,\n    }\n}\n\nfunction makeNavBarNode(\n    navigationBar: wireframeNavigationBar | undefined,\n    context: ConversionContext\n): serializedNodeWithId {\n    const childNodes = navigationBar ? convertWireframesFor([navigationBar], context).result : []\n    return {\n        type: NodeType.Element,\n        tagName: 'div',\n        attributes: {\n            'data-rrweb-id': NAVIGATION_BAR_PARENT_ID,\n        },\n        id: NAVIGATION_BAR_PARENT_ID,\n        childNodes,\n    }\n}\n\nfunction stripBarsFromWireframe(wireframe: wireframe): {\n    wireframe: wireframe | undefined\n    statusBar: wireframeStatusBar | undefined\n    navBar: wireframeNavigationBar | undefined\n} {\n    if (wireframe.type === 'status_bar') {\n        return { wireframe: undefined, statusBar: wireframe, navBar: undefined }\n    } else if (wireframe.type === 'navigation_bar') {\n        return { wireframe: undefined, statusBar: undefined, navBar: wireframe }\n    }\n    let statusBar: wireframeStatusBar | undefined\n    let navBar: wireframeNavigationBar | undefined\n    const wireframeToReturn: wireframe | undefined = { ...wireframe }\n    wireframeToReturn.childWireframes = []\n    for (const child of wireframe.childWireframes || []) {\n        const {\n            wireframe: childWireframe,\n            statusBar: childStatusBar,\n            navBar: childNavBar,\n        } = stripBarsFromWireframe(child)\n        statusBar = statusBar || childStatusBar\n        navBar = navBar || childNavBar\n        if (childWireframe) {\n            wireframeToReturn.childWireframes.push(childWireframe)\n        }\n    }\n    return { wireframe: wireframeToReturn, statusBar, navBar }\n}\n\n/**\n * We want to be able to place the status bar and navigation bar in the correct stacking order.\n * So, we lift them out of the tree, and return them separately.\n */\nexport function stripBarsFromWireframes(wireframes: wireframe[]): {\n    statusBar: wireframeStatusBar | undefined\n    navigationBar: wireframeNavigationBar | undefined\n    appNodes: wireframe[]\n} {\n    let statusBar: wireframeStatusBar | undefined\n    let navigationBar: wireframeNavigationBar | undefined\n    const copiedNodes: wireframe[] = []\n\n    wireframes.forEach((w) => {\n        const matches = stripBarsFromWireframe(w)\n        if (matches.statusBar) {\n            statusBar = matches.statusBar\n        }\n        if (matches.navBar) {\n            navigationBar = matches.navBar\n        }\n        if (matches.wireframe) {\n            copiedNodes.push(matches.wireframe)\n        }\n    })\n    return { statusBar, navigationBar, appNodes: copiedNodes }\n}\n\nexport const makeFullEvent = (\n    mobileEvent: MobileFullSnapshotEvent & {\n        timestamp: number\n        delay?: number\n    }\n): fullSnapshotEvent & {\n    timestamp: number\n    delay?: number\n} => {\n    // we can restart the id sequence on each full snapshot\n    globalIdSequence = ids()\n\n    if (!(isObject(mobileEvent.data) && 'wireframes' in mobileEvent.data)) {\n        return mobileEvent as unknown as fullSnapshotEvent & {\n            timestamp: number\n            delay?: number\n        }\n    }\n\n    const conversionContext = {\n        timestamp: mobileEvent.timestamp,\n        idSequence: globalIdSequence,\n    }\n\n    const { statusBar, navigationBar, appNodes } = stripBarsFromWireframes(mobileEvent.data.wireframes)\n\n    const nodeGroups = {\n        appNodes: convertWireframesFor(appNodes, conversionContext).result || [],\n        statusBarNode: makeStatusBarNode(statusBar, conversionContext),\n        navBarNode: makeNavBarNode(navigationBar, conversionContext),\n    }\n\n    return {\n        type: EventType.FullSnapshot,\n        timestamp: mobileEvent.timestamp,\n        data: {\n            node: {\n                type: NodeType.Document,\n                childNodes: [\n                    {\n                        type: NodeType.DocumentType,\n                        name: 'html',\n                        publicId: '',\n                        systemId: '',\n                        id: HTML_DOC_TYPE_ID,\n                    },\n                    {\n                        type: NodeType.Element,\n                        tagName: 'html',\n                        attributes: { style: makeHTMLStyles(), 'data-rrweb-id': HTML_ELEMENT_ID },\n                        id: HTML_ELEMENT_ID,\n                        childNodes: [\n                            {\n                                type: NodeType.Element,\n                                tagName: 'head',\n                                attributes: { 'data-rrweb-id': HEAD_ID },\n                                id: HEAD_ID,\n                                childNodes: [makeCSSReset(conversionContext)],\n                            },\n                            {\n                                type: NodeType.Element,\n                                tagName: 'body',\n                                attributes: { style: makeBodyStyles(), 'data-rrweb-id': BODY_ID },\n                                id: BODY_ID,\n                                childNodes: [\n                                    // in the order they should stack if they ever clash\n                                    // lower is higher in the stacking context\n                                    ...nodeGroups.appNodes,\n                                    makeKeyboardParent(),\n                                    nodeGroups.navBarNode,\n                                    nodeGroups.statusBarNode,\n                                ],\n                            },\n                        ],\n                    },\n                ],\n                id: DOCUMENT_ID,\n            },\n            initialOffset: {\n                top: 0,\n                left: 0,\n            },\n        },\n    }\n}\n\nfunction makeCSSReset(context: ConversionContext): serializedNodeWithId {\n    // we need to normalize CSS so browsers don't do unexpected things\n    return {\n        type: NodeType.Element,\n        tagName: 'style',\n        attributes: {\n            type: 'text/css',\n        },\n        id: context.idSequence.next().value,\n        childNodes: [\n            {\n                type: NodeType.Text,\n                textContent: `\n                    body {\n                      margin: unset;\n                    }\n                    input, button, select, textarea {\n                        font: inherit;\n                        margin: 0;\n                        padding: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        padding-block: 0 !important;\n                    }\n                    .input:focus {\n                        outline: none;\n                    }\n                    img {\n                      border-style: none;\n                    }\n                `,\n                id: context.idSequence.next().value,\n            },\n        ],\n    }\n}\n","import { actions, connect, kea, listeners, path, reducers } from 'kea'\nimport { loaders } from 'kea-loaders'\n\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { sessionRecordingEventUsageLogic } from 'scenes/session-recordings/sessionRecordingEventUsageLogic'\n\nimport { hogql } from '~/queries/utils'\nimport { CORE_FILTER_DEFINITIONS_BY_GROUP } from '~/taxonomy/taxonomy'\nimport { SessionRecordingPropertiesType, SessionRecordingType } from '~/types'\n\nimport type { sessionRecordingsListPropertiesLogicType } from './sessionRecordingsListPropertiesLogicType'\n\n// This logic is used to fetch properties for a list of recordings\n// It is used in a global way as the cached values can be re-used\nexport const sessionRecordingsListPropertiesLogic = kea<sessionRecordingsListPropertiesLogicType>([\n    path(() => ['scenes', 'session-recordings', 'playlist', 'sessionRecordingsListPropertiesLogic']),\n    connect(() => ({\n        actions: [sessionRecordingEventUsageLogic, ['reportRecordingsListPropertiesFetched']],\n    })),\n\n    actions({\n        loadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n        maybeLoadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n    }),\n\n    loaders(({ actions }) => ({\n        recordingProperties: [\n            [] as SessionRecordingPropertiesType[],\n            {\n                loadPropertiesForSessions: async ({ sessions }, breakpoint) => {\n                    await breakpoint(100)\n\n                    const startTime = performance.now()\n                    const sessionIds = sessions.map((x) => x.id)\n\n                    const oldestTimestamp = sessions.map((x) => x.start_time).sort()[0]\n                    const newestTimestamp = sessions.map((x) => x.end_time).sort()[sessions.length - 1]\n\n                    const query = hogql`\n                        SELECT \n                            $session_id as session_id, \n                            any(properties.$geoip_country_code) as $geoip_country_code, \n                            any(properties.$browser) as $browser, \n                            any(properties.$device_type) as $device_type, \n                            any(properties.$os) as $os, \n                            any(properties.$os_name) as $os_name,\n                            any(session.$entry_referring_domain) as $entry_referring_domain,\n                            any(properties.$geoip_subdivision_1_name) as $geoip_subdivision_1_name,\n                            any(properties.$geoip_city_name) as $geoip_city_name,\n                            any(session.$entry_current_url) as $entry_current_url\n                        FROM events\n                        WHERE event IN ${Object.keys(CORE_FILTER_DEFINITIONS_BY_GROUP['events'])}\n                        AND session_id IN ${sessionIds}\n                        -- the timestamp range here is only to avoid querying too much of the events table\n                        -- we don't really care about the absolute value, \n                        -- but we do care about whether timezones have an odd impact\n                        -- so, we extend the range by a day on each side so that timezones don't cause issues\n                        AND timestamp >= ${dayjs(oldestTimestamp).subtract(1, 'day')}\n                        AND timestamp <= ${dayjs(newestTimestamp).add(1, 'day')}\n                        GROUP BY session_id`\n\n                    const response = await api.queryHogQL(query)\n                    const loadTimeMs = performance.now() - startTime\n\n                    actions.reportRecordingsListPropertiesFetched(loadTimeMs)\n\n                    breakpoint()\n                    return (response.results || []).map((x: any): SessionRecordingPropertiesType => {\n                        return {\n                            id: x[0],\n                            properties: {\n                                $geoip_country_code: x[1],\n                                $browser: x[2],\n                                $device_type: x[3],\n                                $os: x[4],\n                                $os_name: x[5],\n                                $entry_referring_domain: x[6],\n                                $geoip_subdivision_1_name: x[7],\n                                $geoip_city_name: x[8],\n                                $entry_current_url: x[9],\n                            },\n                        }\n                    })\n                },\n            },\n        ],\n    })),\n\n    listeners(({ actions, values }) => ({\n        maybeLoadPropertiesForSessions: ({ sessions }) => {\n            const newSessions = sessions.filter((session) => !values.recordingPropertiesById[session.id])\n\n            if (newSessions.length > 0) {\n                actions.loadPropertiesForSessions(newSessions)\n            }\n        },\n    })),\n\n    reducers({\n        recordingPropertiesById: [\n            {} as Record<string, SessionRecordingPropertiesType['properties']>,\n            {\n                loadPropertiesForSessionsSuccess: (\n                    state,\n                    { recordingProperties }\n                ): Record<string, SessionRecordingPropertiesType['properties']> => {\n                    const newState = { ...state }\n                    recordingProperties.forEach((properties) => {\n                        if (properties.properties) {\n                            newState[properties.id] = properties.properties\n                        }\n                    })\n\n                    return newState\n                },\n            },\n        ],\n    }),\n])\n","import { actions, connect, kea, listeners, path, reducers, selectors, sharedListeners } from 'kea'\nimport { forms } from 'kea-forms'\nimport { actionToUrl, router, urlToAction } from 'kea-router'\nimport { subscriptions } from 'kea-subscriptions'\n\nimport { teamLogic } from 'scenes/teamLogic'\n\nimport { SessionReplayUrlTriggerConfig, TeamPublicType, TeamType } from '~/types'\n\nimport type { replayTriggersLogicType } from './replayTriggersLogicType'\n\nexport type ReplayPlatform = 'web' | 'mobile'\n\nconst NEW_URL_TRIGGER = { url: '', matching: 'regex' }\n\nexport function isStringWithLength(x: unknown): x is string {\n    return typeof x === 'string' && x.trim() !== ''\n}\n\nfunction ensureAnchored(url: string): string {\n    url = url.startsWith('^') ? url.substring(1) : url\n    url = url.endsWith('$') ? url.substring(0, url.length - 1) : url\n    return `^${url}$`\n}\n\nexport const replayTriggersLogic = kea<replayTriggersLogicType>([\n    path(['scenes', 'settings', 'project', 'replayTriggersLogic']),\n    actions({\n        setUrlTriggerConfig: (urlTriggerConfig: SessionReplayUrlTriggerConfig[]) => ({ urlTriggerConfig }),\n        addUrlTrigger: (urlTriggerConfig: SessionReplayUrlTriggerConfig) => ({ urlTriggerConfig }),\n        removeUrlTrigger: (index: number) => ({ index }),\n        updateUrlTrigger: (index: number, urlTriggerConfig: SessionReplayUrlTriggerConfig) => ({\n            index,\n            urlTriggerConfig,\n        }),\n        setEditUrlTriggerIndex: (originalIndex: number | null) => ({ originalIndex }),\n        newUrlTrigger: true,\n        cancelProposingUrlTrigger: true,\n\n        setUrlBlocklistConfig: (urlBlocklistConfig: SessionReplayUrlTriggerConfig[]) => ({ urlBlocklistConfig }),\n        addUrlBlocklist: (urlBlocklistConfig: SessionReplayUrlTriggerConfig) => ({ urlBlocklistConfig }),\n        removeUrlBlocklist: (index: number) => ({ index }),\n        updateUrlBlocklist: (index: number, urlBlocklistConfig: SessionReplayUrlTriggerConfig) => ({\n            index,\n            urlBlocklistConfig,\n        }),\n        setEditUrlBlocklistIndex: (originalIndex: number | null) => ({ originalIndex }),\n        newUrlBlocklist: true,\n        cancelProposingUrlBlocklist: true,\n        setEventTriggerConfig: (eventTriggerConfig: string[]) => ({ eventTriggerConfig }),\n        updateEventTriggerConfig: (eventTriggerConfig: string[]) => ({ eventTriggerConfig }),\n        selectPlatform: (platform: ReplayPlatform) => ({ platform }),\n        setCheckUrlTrigger: (url: string) => ({ url }),\n        setCheckUrlBlocklist: (url: string) => ({ url }),\n        validateUrlInput: (url: string, type: 'trigger' | 'blocklist') => ({ url, type }),\n    }),\n    connect(() => ({ values: [teamLogic, ['currentTeam']], actions: [teamLogic, ['updateCurrentTeam']] })),\n    reducers({\n        urlTriggerConfig: [\n            null as SessionReplayUrlTriggerConfig[] | null,\n            {\n                setUrlTriggerConfig: (_, { urlTriggerConfig }) => urlTriggerConfig,\n                addUrlTrigger: (state, { urlTriggerConfig }) => [...(state ?? []), urlTriggerConfig],\n                updateUrlTrigger: (state, { index, urlTriggerConfig: newUrlTriggerConfig }) =>\n                    (state ?? []).map((triggerConfig, i) => (i === index ? newUrlTriggerConfig : triggerConfig)),\n                removeUrlTrigger: (state, { index }) => {\n                    return (state ?? []).filter((_, i) => i !== index)\n                },\n            },\n        ],\n        editUrlTriggerIndex: [\n            null as number | null,\n            {\n                setEditUrlTriggerIndex: (_, { originalIndex }) => originalIndex,\n                removeUrlTrigger: (editUrlTriggerIndex, { index }) =>\n                    editUrlTriggerIndex && index < editUrlTriggerIndex\n                        ? editUrlTriggerIndex - 1\n                        : index === editUrlTriggerIndex\n                          ? null\n                          : editUrlTriggerIndex,\n                newUrlTrigger: () => -1,\n                updateUrlTrigger: () => null,\n                addUrlTrigger: () => null,\n                cancelProposingUrlTrigger: () => null,\n            },\n        ],\n        urlBlocklistConfig: [\n            null as SessionReplayUrlTriggerConfig[] | null,\n            {\n                setUrlBlocklistConfig: (_, { urlBlocklistConfig }) => urlBlocklistConfig,\n                addUrlBlocklist: (state, { urlBlocklistConfig }) => [...(state ?? []), urlBlocklistConfig],\n                updateUrlBlocklist: (state, { index, urlBlocklistConfig: newUrlBlocklistConfig }) =>\n                    (state ?? []).map((blocklistConfig, i) => (i === index ? newUrlBlocklistConfig : blocklistConfig)),\n                removeUrlBlocklist: (state, { index }) => {\n                    return (state ?? []).filter((_, i) => i !== index)\n                },\n            },\n        ],\n        editUrlBlocklistIndex: [\n            null as number | null,\n            {\n                setEditUrlBlocklistIndex: (_, { originalIndex }) => originalIndex,\n                removeUrlBlocklist: (editUrlBlocklistIndex, { index }) =>\n                    editUrlBlocklistIndex && index < editUrlBlocklistIndex\n                        ? editUrlBlocklistIndex - 1\n                        : index === editUrlBlocklistIndex\n                          ? null\n                          : editUrlBlocklistIndex,\n                newUrlBlocklist: () => -1,\n                updateUrlBlocklist: () => null,\n                addUrlBlocklist: () => null,\n            },\n        ],\n        eventTriggerConfig: [\n            null as string[] | null,\n            {\n                // we have seen some instances where a user manages to get a null into the array.\n                // we guard against this by filtering out nulls, and empty strings\n                // since we only want valid strings, empty arrays or null-ish, as the value here\n                setEventTriggerConfig: (_, { eventTriggerConfig }) =>\n                    eventTriggerConfig?.filter(isStringWithLength) ?? null,\n                updateEventTriggerConfig: (_, { eventTriggerConfig }) =>\n                    eventTriggerConfig?.filter(isStringWithLength) ?? null,\n            },\n        ],\n        selectedPlatform: [\n            'web' as ReplayPlatform,\n            {\n                selectPlatform: (_, { platform }) => platform,\n            },\n        ],\n        checkUrlTrigger: [\n            '' as string,\n            {\n                setCheckUrlTrigger: (_, { url }) => url,\n            },\n        ],\n        checkUrlBlocklist: [\n            '' as string,\n            {\n                setCheckUrlBlocklist: (_, { url }) => url,\n            },\n        ],\n        urlTriggerInputValidationWarning: [\n            null as string | null,\n            {\n                validateUrlInput: (_, { url, type }) => {\n                    if (type !== 'trigger') {\n                        return _\n                    }\n                    // Check if it ends with a TLD\n                    if (/\\.[a-z]{2,}\\/?$/i.test(url)) {\n                        const sanitizedUrl = url.endsWith('/') ? url.slice(0, -1) : url\n                        return `If you want to match all paths of a domain, you should write \" ${sanitizedUrl}(/.*)? \". This would match: \n                        ${sanitizedUrl}, ${sanitizedUrl}/, ${sanitizedUrl}/page, etc. Don't forget to include https:// at the beginning of the url.`\n                    }\n                    return null\n                },\n            },\n        ],\n        urlBlocklistInputValidationWarning: [\n            null as string | null,\n            {\n                validateUrlInput: (_, { url, type }) => {\n                    if (type !== 'blocklist') {\n                        return _\n                    }\n                    // Check if it ends with a TLD\n                    if (/\\.[a-z]{2,}\\/?$/i.test(url)) {\n                        const sanitizedUrl = url.endsWith('/') ? url.slice(0, -1) : url\n                        return `If you want to match all paths of a domain, you should write \" ${sanitizedUrl}(/.*)? \". This would match: \n                        ${sanitizedUrl}, ${sanitizedUrl}/, ${sanitizedUrl}/page, etc. Don't forget to include https:// at the beginning of the url.`\n                    }\n                    return null\n                },\n            },\n        ],\n    }),\n    selectors({\n        remoteUrlTriggerConfig: [\n            (s) => [s.currentTeam],\n            (currentTeam) => currentTeam?.session_recording_url_trigger_config,\n        ],\n        isAddUrlTriggerConfigFormVisible: [\n            (s) => [s.editUrlTriggerIndex],\n            (editUrlTriggerIndex) => editUrlTriggerIndex === -1,\n        ],\n        urlTriggerToEdit: [\n            (s) => [s.urlTriggerConfig, s.editUrlTriggerIndex],\n            (urlTriggerConfig, editUrlTriggerIndex) => {\n                if (\n                    editUrlTriggerIndex === null ||\n                    editUrlTriggerIndex === -1 ||\n                    !urlTriggerConfig?.[editUrlTriggerIndex]\n                ) {\n                    return NEW_URL_TRIGGER\n                }\n                return urlTriggerConfig[editUrlTriggerIndex]\n            },\n        ],\n\n        remoteUrlBlocklistConfig: [\n            (s) => [s.currentTeam],\n            (currentTeam) => currentTeam?.session_recording_url_blocklist_config,\n        ],\n        isAddUrlBlocklistConfigFormVisible: [\n            (s) => [s.editUrlBlocklistIndex],\n            (editUrlBlocklistIndex) => editUrlBlocklistIndex === -1,\n        ],\n        urlBlocklistToEdit: [\n            (s) => [s.urlBlocklistConfig, s.editUrlBlocklistIndex],\n            (urlBlocklistConfig, editUrlBlocklistIndex) => {\n                if (\n                    editUrlBlocklistIndex === null ||\n                    editUrlBlocklistIndex === -1 ||\n                    !urlBlocklistConfig?.[editUrlBlocklistIndex]\n                ) {\n                    return NEW_URL_TRIGGER\n                }\n                return urlBlocklistConfig[editUrlBlocklistIndex]\n            },\n        ],\n\n        checkUrlTriggerResults: [\n            (s) => [s.checkUrlTrigger, s.urlTriggerConfig],\n            (checkUrl, urlTriggerConfig): { [key: number]: boolean } => {\n                if (!checkUrl.trim() || !urlTriggerConfig) {\n                    return {}\n                }\n\n                const results: { [key: number]: boolean } = {}\n                urlTriggerConfig.forEach((trigger, index) => {\n                    try {\n                        const regex = new RegExp(trigger.url)\n                        results[index] = regex.test(checkUrl)\n                    } catch {\n                        results[index] = false\n                    }\n                })\n                return results\n            },\n        ],\n\n        checkUrlBlocklistResults: [\n            (s) => [s.checkUrlBlocklist, s.urlBlocklistConfig],\n            (checkUrl, urlBlocklistConfig): { [key: number]: boolean } => {\n                if (!checkUrl.trim() || !urlBlocklistConfig) {\n                    return {}\n                }\n\n                const results: { [key: number]: boolean } = {}\n                urlBlocklistConfig.forEach((trigger, index) => {\n                    try {\n                        const regex = new RegExp(trigger.url)\n                        results[index] = regex.test(checkUrl)\n                    } catch {\n                        results[index] = false\n                    }\n                })\n                return results\n            },\n        ],\n    }),\n    subscriptions(({ actions }) => ({\n        currentTeam: (currentTeam: TeamPublicType | TeamType | null) => {\n            actions.setUrlTriggerConfig(currentTeam?.session_recording_url_trigger_config ?? [])\n            actions.setUrlBlocklistConfig(currentTeam?.session_recording_url_blocklist_config ?? [])\n            actions.setEventTriggerConfig(\n                (currentTeam?.session_recording_event_trigger_config ?? []).filter(isStringWithLength)\n            )\n        },\n    })),\n    forms(({ values, actions }) => ({\n        proposedUrlTrigger: {\n            defaults: { url: '', matching: 'regex' } as SessionReplayUrlTriggerConfig,\n            errors: ({ url }) => ({\n                url: !url\n                    ? 'Must have a URL'\n                    : (() => {\n                          try {\n                              new RegExp(url)\n                              return undefined\n                          } catch {\n                              return 'Invalid regex pattern'\n                          }\n                      })(),\n            }),\n            submit: async ({ url, matching }) => {\n                if (values.editUrlTriggerIndex !== null && values.editUrlTriggerIndex >= 0) {\n                    actions.updateUrlTrigger(values.editUrlTriggerIndex, { url: ensureAnchored(url), matching })\n                } else {\n                    actions.addUrlTrigger({ url: ensureAnchored(url), matching })\n                }\n            },\n        },\n        proposedUrlBlocklist: {\n            defaults: { url: '', matching: 'regex' } as SessionReplayUrlTriggerConfig,\n            errors: ({ url }) => ({\n                url: !url ? 'Must have a URL' : undefined,\n            }),\n            submit: async ({ url, matching }) => {\n                if (values.editUrlBlocklistIndex !== null && values.editUrlBlocklistIndex >= 0) {\n                    actions.updateUrlBlocklist(values.editUrlBlocklistIndex, { url: ensureAnchored(url), matching })\n                } else {\n                    actions.addUrlBlocklist({ url: ensureAnchored(url), matching })\n                }\n            },\n        },\n    })),\n    sharedListeners(({ values }) => ({\n        saveUrlTriggers: async () => {\n            await teamLogic.asyncActions.updateCurrentTeam({\n                session_recording_url_trigger_config: values.urlTriggerConfig ?? [],\n            })\n        },\n        saveUrlBlocklists: async () => {\n            await teamLogic.asyncActions.updateCurrentTeam({\n                session_recording_url_blocklist_config: values.urlBlocklistConfig ?? [],\n            })\n        },\n    })),\n    listeners(({ sharedListeners, actions, values }) => ({\n        setEditUrlTriggerIndex: () => {\n            actions.setProposedUrlTriggerValue('url', values.urlTriggerToEdit.url)\n            actions.setProposedUrlTriggerValue('matching', values.urlTriggerToEdit.matching)\n        },\n        addUrlTrigger: sharedListeners.saveUrlTriggers,\n        removeUrlTrigger: sharedListeners.saveUrlTriggers,\n        updateUrlTrigger: sharedListeners.saveUrlTriggers,\n        submitProposedUrlTriggerSuccess: () => {\n            actions.setEditUrlTriggerIndex(null)\n            actions.resetProposedUrlTrigger()\n        },\n        setProposedUrlTriggerValue: ({ name, value }) => {\n            const fieldName = Array.isArray(name) ? name[0] : name\n            if (fieldName === 'url') {\n                actions.validateUrlInput(value || '', 'trigger')\n            }\n        },\n\n        setEditUrlBlocklistIndex: () => {\n            actions.setProposedUrlBlocklistValue('url', values.urlBlocklistToEdit.url)\n            actions.setProposedUrlBlocklistValue('matching', values.urlBlocklistToEdit.matching)\n        },\n        addUrlBlocklist: sharedListeners.saveUrlBlocklists,\n        removeUrlBlocklist: sharedListeners.saveUrlBlocklists,\n        updateUrlBlocklist: sharedListeners.saveUrlBlocklists,\n        submitProposedUrlBlocklistSuccess: () => {\n            actions.setEditUrlBlocklistIndex(null)\n            actions.resetProposedUrlBlocklist()\n        },\n        setProposedUrlBlocklistValue: ({ name, value }) => {\n            const fieldName = Array.isArray(name) ? name[0] : name\n            if (fieldName === 'url') {\n                actions.validateUrlInput(value || '', 'blocklist')\n            }\n        },\n        updateEventTriggerConfig: async ({ eventTriggerConfig }) => {\n            actions.setEventTriggerConfig(eventTriggerConfig)\n            // ok to stringify here... this will always be a small array\n            if (\n                JSON.stringify(eventTriggerConfig) !==\n                JSON.stringify(values.currentTeam?.session_recording_event_trigger_config)\n            ) {\n                await teamLogic.asyncActions.updateCurrentTeam({\n                    session_recording_event_trigger_config: eventTriggerConfig,\n                })\n            }\n        },\n    })),\n    actionToUrl(() => ({\n        selectPlatform: ({ platform }) => {\n            return [\n                router.values.location.pathname,\n                router.values.searchParams,\n                { ...router.values.hashParams, selectedPlatform: platform },\n            ]\n        },\n    })),\n    urlToAction(({ actions, values }) => ({\n        ['*/replay/settings']: (_, __, hashParams) => {\n            const platformFromHash = hashParams.selectedPlatform as ReplayPlatform | undefined\n            if (platformFromHash && platformFromHash !== values.selectedPlatform) {\n                actions.selectPlatform(platformFromHash)\n            }\n        },\n    })),\n])\n","import clsx from 'clsx'\nimport { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\n\nimport { IconEllipsis, IconInfo } from '@posthog/icons'\nimport {\n    LemonBanner,\n    LemonButton,\n    LemonDialog,\n    LemonInput,\n    LemonMenu,\n    LemonTable,\n    LemonTableColumns,\n    LemonTabs,\n    Spinner,\n    Tooltip,\n} from '@posthog/lemon-ui'\n\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { PayGateMini } from 'lib/components/PayGateMini/PayGateMini'\nimport { payGateMiniLogic } from 'lib/components/PayGateMini/payGateMiniLogic'\nimport { RestrictionScope, useRestrictedArea } from 'lib/components/RestrictedArea'\nimport { OrganizationMembershipLevel } from 'lib/constants'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonMarkdown } from 'lib/lemon-ui/LemonMarkdown'\n\nimport { AvailableFeature } from '~/types'\n\nimport { ProxyRecord, proxyLogic } from './proxyLogic'\n\nconst statusText = {\n    valid: 'live',\n    timed_out: 'timed out',\n}\n\nexport function ManagedReverseProxy(): JSX.Element {\n    const { formState, proxyRecords, proxyRecordsLoading } = useValues(proxyLogic)\n    const { showForm, deleteRecord } = useActions(proxyLogic)\n\n    const restrictionReason = useRestrictedArea({\n        minimumAccessLevel: OrganizationMembershipLevel.Admin,\n        scope: RestrictionScope.Organization,\n    })\n\n    const { featureAvailableOnOrg } = useValues(payGateMiniLogic({ feature: AvailableFeature.MANAGED_REVERSE_PROXY }))\n\n    const maxRecordsReached = proxyRecords.length >= (featureAvailableOnOrg?.limit || 0)\n\n    const recordsWithMessages = proxyRecords.filter((record) => !!record.message)\n\n    const columns: LemonTableColumns<ProxyRecord> = [\n        {\n            title: 'Domain',\n            dataIndex: 'domain',\n        },\n        {\n            title: 'Status',\n            dataIndex: 'status',\n            render: function RenderStatus(status) {\n                if (!status) {\n                    return <span>Unknown</span>\n                }\n\n                return (\n                    <div\n                        className={clsx(\n                            'deprecated-space-x-1',\n                            status === 'valid'\n                                ? 'text-success'\n                                : status == 'erroring'\n                                  ? 'text-danger'\n                                  : 'text-warning-dark'\n                        )}\n                    >\n                        {status === 'issuing' && <Spinner />}\n                        <span className=\"capitalize\">{statusText[status] || status}</span>\n                        {status === 'waiting' && (\n                            <Tooltip title=\"Waiting for DNS records to be created\">\n                                <IconInfo className=\"cursor-pointer\" />\n                            </Tooltip>\n                        )}\n                        {status === 'timed_out' && (\n                            <Tooltip title=\"Timed out waiting for DNS records to be created. Please delete the record and try again\">\n                                <IconInfo className=\"cursor-pointer\" />\n                            </Tooltip>\n                        )}\n                    </div>\n                )\n            },\n        },\n        {\n            title: <span className=\"h-5\" />,\n            width: 20,\n            className: 'flex justify-center',\n            render: function Render(_, { id, status }) {\n                return (\n                    status != 'deleting' &&\n                    !restrictionReason && (\n                        <LemonMenu\n                            items={[\n                                {\n                                    label: 'Delete',\n                                    status: 'danger',\n                                    onClick: () => {\n                                        LemonDialog.open({\n                                            title: 'Delete managed proxy',\n                                            width: '20rem',\n                                            content:\n                                                'Are you sure you want to delete this managed proxy? This cannot be undone and if it is in use then events sent to the domain will not be processed.',\n                                            primaryButton: {\n                                                status: 'danger',\n                                                onClick: () => deleteRecord(id),\n                                                children: 'Delete',\n                                            },\n                                            secondaryButton: {\n                                                children: 'Cancel',\n                                            },\n                                        })\n                                    },\n                                },\n                            ]}\n                        >\n                            <LemonButton size=\"small\" icon={<IconEllipsis className=\"text-secondary\" />} />\n                        </LemonMenu>\n                    )\n                )\n            },\n        },\n    ]\n\n    return (\n        <PayGateMini feature={AvailableFeature.MANAGED_REVERSE_PROXY}>\n            <div className=\"deprecated-space-y-2\">\n                {recordsWithMessages.map((r) => (\n                    <LemonBanner type=\"warning\" key={r.id}>\n                        <LemonMarkdown>{`**${r.domain}**\\n ${r.message}`}</LemonMarkdown>\n                    </LemonBanner>\n                ))}\n                <LemonTable\n                    loading={proxyRecords.length === 0 && proxyRecordsLoading}\n                    columns={columns}\n                    dataSource={proxyRecords}\n                    expandable={{\n                        expandedRowRender: (record) => <ExpandedRow record={record} />,\n                    }}\n                />\n                {formState === 'collapsed' ? (\n                    maxRecordsReached ? (\n                        <LemonBanner type=\"info\">\n                            There is a maximum of {featureAvailableOnOrg?.limit || 0} records allowed per organization.\n                        </LemonBanner>\n                    ) : (\n                        <div className=\"flex\">\n                            <LemonButton onClick={showForm} type=\"primary\" disabledReason={restrictionReason}>\n                                Add managed proxy\n                            </LemonButton>\n                        </div>\n                    )\n                ) : (\n                    <CreateRecordForm />\n                )}\n            </div>\n        </PayGateMini>\n    )\n}\n\nconst ExpandedRow = ({ record }: { record: ProxyRecord }): JSX.Element => {\n    return (\n        <div className=\"pb-4 pr-4\">\n            <LemonTabs\n                size=\"small\"\n                activeKey=\"cname\"\n                tabs={[\n                    {\n                        label: 'CNAME',\n                        key: 'cname',\n                        content: (\n                            <CodeSnippet key={record.id} language={Language.HTTP}>\n                                {record.target_cname}\n                            </CodeSnippet>\n                        ),\n                    },\n                ]}\n            />\n        </div>\n    )\n}\n\nfunction CreateRecordForm(): JSX.Element {\n    const { formState, proxyRecordsLoading, proxyRecords } = useValues(proxyLogic)\n    const { collapseForm } = useActions(proxyLogic)\n\n    const waitingRecords = proxyRecords.filter((r) => r.status === 'waiting')\n\n    return (\n        <div className=\"bg-surface-primary rounded border px-5 py-4 deprecated-space-y-2\">\n            {formState == 'active' ? (\n                <Form\n                    logic={proxyLogic}\n                    formKey=\"createRecord\"\n                    enableFormOnSubmit\n                    className=\"w-full deprecated-space-y-2\"\n                >\n                    <LemonField name=\"domain\">\n                        <LemonInput\n                            autoFocus\n                            placeholder=\"Enter a domain (e.g. ph.mydomain.com)\"\n                            data-attr=\"domain-input\"\n                        />\n                    </LemonField>\n                    <div className=\"flex justify-end gap-2\">\n                        <LemonButton\n                            type=\"secondary\"\n                            onClick={collapseForm}\n                            disabledReason={proxyRecordsLoading ? 'Saving' : undefined}\n                        >\n                            Cancel\n                        </LemonButton>\n                        <LemonButton\n                            htmlType=\"submit\"\n                            type=\"primary\"\n                            data-attr=\"domain-save\"\n                            loading={proxyRecordsLoading}\n                        >\n                            Add\n                        </LemonButton>\n                    </div>\n                </Form>\n            ) : (\n                <>\n                    <div className=\"text-xl font-semibold leading-tight\">Almost there</div>\n                    <div>\n                        You need to set the following <b>CNAME</b> records in your DNS provider:\n                    </div>\n                    {waitingRecords.map((r) => (\n                        <div key={r.id} className=\"deprecated-space-y-1\">\n                            <span className=\"font-semibold\">{r.domain}</span>\n                            <CodeSnippet key={r.id} language={Language.HTTP}>\n                                {r.target_cname}\n                            </CodeSnippet>\n                        </div>\n                    ))}\n                    <div className=\"flex justify-end\">\n                        <LemonButton onClick={collapseForm} type=\"primary\">\n                            Done\n                        </LemonButton>\n                    </div>\n                </>\n            )}\n        </div>\n    )\n}\n","import { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\n\nimport { Link } from '@posthog/lemon-ui'\n\nimport { CopyToClipboardInline } from 'lib/components/CopyToClipboard'\nimport { LemonBanner } from 'lib/lemon-ui/LemonBanner'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonInput } from 'lib/lemon-ui/LemonInput/LemonInput'\nimport { LemonModal } from 'lib/lemon-ui/LemonModal'\nimport { LemonTextArea } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\n\nimport { verifiedDomainsLogic } from './verifiedDomainsLogic'\n\nexport function ConfigureSAMLModal(): JSX.Element {\n    const { configureSAMLModalId, isSamlConfigSubmitting, samlConfig } = useValues(verifiedDomainsLogic)\n    const { setConfigureSAMLModalId } = useActions(verifiedDomainsLogic)\n    const { preflight } = useValues(preflightLogic)\n    const siteUrl = preflight?.site_url ?? window.location.origin\n\n    const samlReady = samlConfig.saml_acs_url && samlConfig.saml_entity_id && samlConfig.saml_x509_cert\n\n    const handleClose = (): void => {\n        setConfigureSAMLModalId(null)\n        // clean()\n    }\n\n    return (\n        <LemonModal onClose={handleClose} isOpen={!!configureSAMLModalId} title=\"\" simple>\n            <Form logic={verifiedDomainsLogic} formKey=\"samlConfig\" enableFormOnSubmit className=\"LemonModal__layout \">\n                <LemonModal.Header>\n                    <h3>Configure SAML authentication and provisioning</h3>\n                </LemonModal.Header>\n                <LemonModal.Content className=\"deprecated-space-y-2\">\n                    <p>\n                        <Link to=\"https://posthog.com/docs/data/sso#setting-up-saml\" target=\"_blank\" targetBlankIcon>\n                            Read the docs\n                        </Link>\n                    </p>\n                    <LemonField label=\"ACS Consumer URL\" name=\"_ACSConsumerUrl\">\n                        <CopyToClipboardInline>{`${siteUrl}/complete/saml/`}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField label=\"RelayState\" name=\"_RelayState\">\n                        <CopyToClipboardInline>{configureSAMLModalId || 'unknown'}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField label=\"Audience / Entity ID\" name=\"_Audience\">\n                        <CopyToClipboardInline>{siteUrl}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField name=\"saml_acs_url\" label=\"SAML ACS URL\">\n                        <LemonInput className=\"ph-ignore-input\" placeholder=\"Your IdP's ACS or single sign-on URL.\" />\n                    </LemonField>\n                    <LemonField name=\"saml_entity_id\" label=\"SAML Entity ID\">\n                        <LemonInput className=\"ph-ignore-input\" placeholder=\"Entity ID provided by your IdP.\" />\n                    </LemonField>\n                    <LemonField name=\"saml_x509_cert\" label=\"SAML X.509 Certificate\">\n                        <LemonTextArea\n                            className=\"ph-ignore-input\"\n                            minRows={10}\n                            placeholder={`Enter the public certificate of your IdP. Keep all line breaks.\\n-----BEGIN CERTIFICATE-----\\nMIICVjCCAb+gAwIBAgIBADANBgkqhkiG9w0BAQ0FADBIMQswCQYDVQQGEwJ1czEL\\n-----END CERTIFICATE-----`}\n                        />\n                    </LemonField>\n                    {!samlReady && (\n                        <LemonBanner type=\"info\">\n                            SAML will not be enabled unless you enter all attributes above. However you can still\n                            settings as draft.\n                        </LemonBanner>\n                    )}\n                </LemonModal.Content>\n                <LemonModal.Footer>\n                    <LemonButton loading={isSamlConfigSubmitting} type=\"primary\" htmlType=\"submit\">\n                        Save settings\n                    </LemonButton>\n                </LemonModal.Footer>\n            </Form>\n        </LemonModal>\n    )\n}\n","import { useValues } from 'kea'\nimport { router } from 'kea-router'\nimport { SurveyQuestionType } from 'posthog-js'\n\nimport { LemonButton, LemonDivider, LemonModal } from '@posthog/lemon-ui'\n\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { IconOpenInNew } from 'lib/lemon-ui/icons'\nimport { surveyLogic } from 'scenes/surveys/surveyLogic'\nimport { urls } from 'scenes/urls'\n\nimport { Survey, SurveyEventName, SurveyEventProperties, SurveyQuestion } from '~/types'\n\nimport { buildPartialResponsesFilter, createAnswerFilterHogQLExpression } from './utils'\n\ninterface SurveySQLHelperProps {\n    isOpen: boolean\n    onClose: () => void\n}\n\nexport function SurveySQLHelper({ isOpen, onClose }: SurveySQLHelperProps): JSX.Element {\n    const { survey, answerFilters } = useValues(surveyLogic)\n\n    const filterConditions = createAnswerFilterHogQLExpression(answerFilters, survey as Survey)\n\n    const generateSingleQuestionQuery = (question: SurveyQuestion, index: number): string => {\n        return `SELECT\n    distinct_id,\n    getSurveyResponse(${index}, '${question.id}'${\n        question.type === SurveyQuestionType.MultipleChoice ? ', true' : ''\n    }) AS \"${question.question}\",\n    timestamp\nFROM\n    events\nWHERE\n    event = '${SurveyEventName.SENT}'\n    AND properties.${SurveyEventProperties.SURVEY_ID} = '${survey.id}'\n    ${buildPartialResponsesFilter(survey as Survey)}\n    ${filterConditions ? filterConditions : ''}\nORDER BY\n    timestamp DESC\nLIMIT\n    100`\n    }\n\n    const generateFullSurveyQuery = (): string => {\n        const questionSelects = survey.questions\n            .map((question: SurveyQuestion, index: number) => {\n                return `    getSurveyResponse(${index}, '${question.id}'${\n                    question.type === SurveyQuestionType.MultipleChoice ? ', true' : ''\n                }) AS \"${question.question}\"`\n            })\n            .join(',\\n')\n\n        return `SELECT\n    distinct_id,\n${questionSelects},\n    timestamp\nFROM\n    events\nWHERE\n    event = '${SurveyEventName.SENT}'\n    AND properties.${SurveyEventProperties.SURVEY_ID} = '${survey.id}'\n    ${buildPartialResponsesFilter(survey as Survey)}\n    ${filterConditions ? filterConditions : ''}\nORDER BY\n    timestamp DESC\nLIMIT\n    100`\n    }\n\n    // Function to open query in a new insight\n    const openInInsight = (query: string): void => {\n        router.actions.push(urls.sqlEditor(query))\n    }\n\n    return (\n        <LemonModal\n            isOpen={isOpen}\n            onClose={onClose}\n            title=\"SQL Query Helper\"\n            description={\n                <div className=\"flex flex-col gap-1 text-sm text-muted\">\n                    <p>\n                        <b>Important:</b> Since March 7, 2025, survey responses are stored using question IDs\n                        ([UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)) instead of indexes. The\n                        queries below handle both formats using the <code>coalesce</code> function.\n                    </p>\n                    <p>\n                        <b>Note:</b> These queries only include response filters set on the table. Additional property\n                        filters like cohorts, user properties, etc. are not included.\n                    </p>\n                </div>\n            }\n            width={800}\n        >\n            <div className=\"flex flex-col gap-2\">\n                <div className=\"flex flex-col gap-1\">\n                    <h4>Full Survey Query</h4>\n                    <p className=\"text-sm text-muted\">Returns all questions for this survey.</p>\n                    <CodeSnippet\n                        language={Language.SQL}\n                        compact\n                        actions={\n                            <LemonButton\n                                icon={<IconOpenInNew />}\n                                size=\"small\"\n                                onClick={() => openInInsight(generateFullSurveyQuery())}\n                                tooltip=\"Open as new insight\"\n                                noPadding\n                            />\n                        }\n                    >\n                        {generateFullSurveyQuery()}\n                    </CodeSnippet>\n                </div>\n\n                <LemonDivider />\n\n                <div className=\"flex flex-col gap-2\">\n                    <h4>Individual Question Queries</h4>\n                    <p className=\"text-sm text-muted\">Returns responses for individual questions.</p>\n\n                    <div className=\"flex flex-col gap-1\">\n                        {survey.questions.map((question: SurveyQuestion, index: number) => (\n                            <div key={question.id || index} className=\"flex flex-col gap-2\">\n                                <h5>{question.question}</h5>\n                                <CodeSnippet\n                                    language={Language.SQL}\n                                    compact\n                                    actions={\n                                        <LemonButton\n                                            icon={<IconOpenInNew />}\n                                            size=\"small\"\n                                            onClick={() => openInInsight(generateSingleQuestionQuery(question, index))}\n                                            tooltip=\"Open as new insight\"\n                                            noPadding\n                                        />\n                                    }\n                                >\n                                    {generateSingleQuestionQuery(question, index)}\n                                </CodeSnippet>\n                            </div>\n                        ))}\n                    </div>\n                </div>\n            </div>\n        </LemonModal>\n    )\n}\n","import { actions, afterMount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl, router, urlToAction } from 'kea-router'\nimport posthog from 'posthog-js'\n\nimport { lemonToast } from '@posthog/lemon-ui'\n\nimport api from 'lib/api'\nimport { FEATURE_FLAGS, PERSON_DEFAULT_DISPLAY_NAME_PROPERTIES } from 'lib/constants'\nimport { dayjs } from 'lib/dayjs'\nimport { FeatureFlagsSet, featureFlagLogic as enabledFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { allOperatorsMapping, debounce, hasFormErrors, isObject, objectClean, pluralize } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { ProductIntentContext } from 'lib/utils/product-intents'\nimport { Scene } from 'scenes/sceneTypes'\nimport {\n    branchingConfigToDropdownValue,\n    canQuestionHaveResponseBasedBranching,\n    createBranchingConfig,\n    getDefaultBranchingType,\n} from 'scenes/surveys/components/question-branching/utils'\nimport { getDemoDataForSurvey } from 'scenes/surveys/utils/demoDataGenerator'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { ActivationTask, activationLogic } from '~/layout/navigation-3000/sidepanel/panels/activation/activationLogic'\nimport { SIDE_PANEL_CONTEXT_KEY, SidePanelSceneContext } from '~/layout/navigation-3000/sidepanel/types'\nimport { refreshTreeItem } from '~/layout/panel-layout/ProjectTree/projectTreeLogic'\nimport { propertyDefinitionsModel } from '~/models/propertyDefinitionsModel'\nimport { MAX_SELECT_RETURNED_ROWS } from '~/queries/nodes/DataTable/DataTableExport'\nimport { CompareFilter, DataTableNode, InsightVizNode, NodeKind } from '~/queries/schema/schema-general'\nimport { SurveyAnalysisQuestionGroup, SurveyAnalysisResponseItem } from '~/queries/schema/schema-surveys'\nimport { HogQLQueryString } from '~/queries/utils'\nimport {\n    ActivityScope,\n    AnyPropertyFilter,\n    BaseMathType,\n    Breadcrumb,\n    ChoiceQuestionProcessedResponses,\n    ChoiceQuestionResponseData,\n    ConsolidatedSurveyResults,\n    EventPropertyFilter,\n    FeatureFlagFilters,\n    IntervalType,\n    MultipleSurveyQuestion,\n    OpenQuestionProcessedResponses,\n    OpenQuestionResponseData,\n    ProductKey,\n    ProjectTreeRef,\n    PropertyFilterType,\n    PropertyOperator,\n    QuestionProcessedResponses,\n    RatingSurveyQuestion,\n    ResponsesByQuestion,\n    Survey,\n    SurveyEventName,\n    SurveyEventProperties,\n    SurveyEventStats,\n    SurveyMatchType,\n    SurveyQuestion,\n    SurveyQuestionBase,\n    SurveyQuestionBranchingType,\n    SurveyQuestionType,\n    SurveyRates,\n    SurveyRawResults,\n    SurveyResponseRow,\n    SurveySchedule,\n    SurveyStats,\n} from '~/types'\n\nimport {\n    NEW_SURVEY,\n    NewSurvey,\n    SURVEY_CREATED_SOURCE,\n    SURVEY_RATING_SCALE,\n    defaultSurveyAppearance,\n    defaultSurveyFieldValues,\n} from './constants'\nimport type { surveyLogicType } from './surveyLogicType'\nimport { surveysLogic } from './surveysLogic'\nimport {\n    DATE_FORMAT,\n    buildPartialResponsesFilter,\n    buildSurveyTimestampFilter,\n    calculateSurveyRates,\n    createAnswerFilterHogQLExpression,\n    getResponseFieldWithId,\n    getSurveyEndDateForQuery,\n    getSurveyResponse,\n    getSurveyStartDateForQuery,\n    isSurveyRunning,\n    sanitizeSurvey,\n    sanitizeSurveyAppearance,\n    validateSurveyAppearance,\n} from './utils'\n\nexport type SurveyBaseStatTuple = [string, number, number, string | null, string | null] // [event_name, total_count, unique_persons, first_seen, last_seen]\nexport type SurveyBaseStatsResult = SurveyBaseStatTuple[] | null\nexport type DismissedAndSentCountResult = number | null\n\nconst DEFAULT_OPERATORS: Record<SurveyQuestionType, { label: string; value: PropertyOperator }> = {\n    [SurveyQuestionType.Open]: {\n        label: allOperatorsMapping[PropertyOperator.IContains],\n        value: PropertyOperator.IContains,\n    },\n    [SurveyQuestionType.Rating]: {\n        label: allOperatorsMapping[PropertyOperator.Exact],\n        value: PropertyOperator.Exact,\n    },\n    [SurveyQuestionType.SingleChoice]: {\n        label: allOperatorsMapping[PropertyOperator.Exact],\n        value: PropertyOperator.Exact,\n    },\n    [SurveyQuestionType.MultipleChoice]: {\n        label: allOperatorsMapping[PropertyOperator.IContains],\n        value: PropertyOperator.IContains,\n    },\n    [SurveyQuestionType.Link]: {\n        label: allOperatorsMapping[PropertyOperator.Exact],\n        value: PropertyOperator.Exact,\n    },\n}\n\nexport type SurveyDemoData = ReturnType<typeof getDemoDataForSurvey>\n\nexport enum SurveyEditSection {\n    Steps = 'steps',\n    Widget = 'widget',\n    Presentation = 'presentation',\n    Appearance = 'appearance',\n    Customization = 'customization',\n    DisplayConditions = 'DisplayConditions',\n    Scheduling = 'scheduling',\n    CompletionConditions = 'CompletionConditions',\n}\nexport interface SurveyLogicProps {\n    /** Either a UUID or 'new'. */\n    id: string\n}\n\nexport interface SurveyMetricsQueries {\n    surveysShown: DataTableNode\n    surveysDismissed: DataTableNode\n}\n\nexport interface SurveyRatingResults {\n    [key: number]: {\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveyRecurringNPSResults {\n    [key: number]: {\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveySingleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveyMultipleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n    }\n}\n\nexport interface SurveyOpenTextResults {\n    [key: number]: {\n        events: { distinct_id: string; properties: Record<string, any>; personProperties: Record<string, any> }[]\n    }\n}\n\nexport interface QuestionResultsReady {\n    [key: string]: boolean\n}\n\nexport type DataCollectionType = 'until_stopped' | 'until_limit' | 'until_adaptive_limit'\n\nexport interface SurveyDateRange {\n    date_from: string | null\n    date_to: string | null\n}\n\nfunction duplicateExistingSurvey(survey: Survey | NewSurvey): Partial<Survey> {\n    return {\n        ...survey,\n        questions: survey.questions.map((question) => ({\n            ...question,\n            id: undefined,\n        })),\n        id: NEW_SURVEY.id,\n        name: `${survey.name} (duplicated at ${dayjs().format('YYYY-MM-DD HH:mm:ss')})`,\n        archived: false,\n        start_date: null,\n        end_date: null,\n        targeting_flag_filters: survey.targeting_flag?.filters ?? NEW_SURVEY.targeting_flag_filters,\n        linked_flag_id: survey.linked_flag?.id ?? NEW_SURVEY.linked_flag_id,\n    }\n}\n\nfunction isEmptyOrUndefined(value: any): boolean {\n    return value === null || value === undefined || value === ''\n}\n\nfunction isQuestionOpenChoice(question: SurveyQuestion, choiceIndex: number): boolean {\n    if (question.type !== SurveyQuestionType.SingleChoice && question.type !== SurveyQuestionType.MultipleChoice) {\n        return false\n    }\n    return !!(choiceIndex === question.choices.length - 1 && question?.hasOpenChoice)\n}\n\n// Helper to extract person data from a survey response row\nfunction extractPersonData(row: SurveyResponseRow): {\n    distinctId: string\n    personProperties?: Record<string, any>\n    timestamp: string\n} {\n    const distinctId = row.at(-2) as string\n    const timestamp = row.at(-1) as string\n    // now, we're querying for all PERSON_DEFAULT_DISPLAY_NAME_PROPERTIES, starting from the third last value, so build our person properties object\n    // from those values. We use them to have a display name for the person\n    const personProperties: Record<string, any> = {}\n    const personDisplayProperties = PERSON_DEFAULT_DISPLAY_NAME_PROPERTIES\n    let hasAnyProperties = false\n    for (let i = 0; i < personDisplayProperties.length; i++) {\n        const value = row.at(-3 - i) as string\n        if (value && value !== null && value !== '') {\n            personProperties[personDisplayProperties[i]] = value\n            hasAnyProperties = true\n        }\n    }\n    return { distinctId, personProperties: hasAnyProperties ? personProperties : undefined, timestamp }\n}\n\n// Helper to count a choice and store person data for latest occurrence\nfunction countChoice(\n    choice: string,\n    counts: { [key: string]: number },\n    latestResponsePersonData: { [key: string]: ReturnType<typeof extractPersonData> },\n    personData: ReturnType<typeof extractPersonData>\n): void {\n    if (isEmptyOrUndefined(choice)) {\n        return\n    }\n\n    counts[choice] = (counts[choice] || 0) + 1\n\n    // Always store the latest person data - this gives us the most recent respondent\n    // for each choice to display in the UI (e.g., \"Sarah was the last to pick this option\")\n    latestResponsePersonData[choice] = personData\n}\n\n// Shared utility for processing choice-based questions\nfunction processChoiceQuestion(\n    question: MultipleSurveyQuestion,\n    questionIndex: number,\n    results: SurveyRawResults,\n    questionType: SurveyQuestionType.SingleChoice | SurveyQuestionType.MultipleChoice\n): ChoiceQuestionProcessedResponses {\n    const counts: { [key: string]: number } = {}\n    // Store person data for the most recent person who selected each choice - used in UI to show\n    // \"who last picked this option\" with avatar/name when hovering over choice visualizations\n    const latestResponsePersonData: { [key: string]: ReturnType<typeof extractPersonData> } = {}\n    let total = 0\n\n    // Zero-fill predefined choices (excluding open choice)\n    question.choices?.forEach((choice: string, choiceIndex: number) => {\n        if (!isQuestionOpenChoice(question, choiceIndex)) {\n            counts[choice] = 0\n        }\n    })\n\n    // Process each response\n    results?.forEach((row: SurveyResponseRow) => {\n        const rawValue = row[questionIndex]\n        if (rawValue === null || rawValue === undefined) {\n            return\n        }\n\n        const personData = extractPersonData(row)\n\n        if (questionType === SurveyQuestionType.SingleChoice) {\n            const value = rawValue as string\n            if (!isEmptyOrUndefined(value)) {\n                countChoice(value, counts, latestResponsePersonData, personData)\n                total += 1\n            }\n        } else {\n            // Multiple choice\n            const choices = rawValue as string[]\n\n            if (choices.length > 0) {\n                total += 1\n                choices.forEach((choice) => {\n                    const cleaned = choice.replace(/^['\"]+|['\"]+$/g, '')\n                    countChoice(cleaned, counts, latestResponsePersonData, personData)\n                })\n            }\n        }\n    })\n\n    const data = Object.entries(counts)\n        .map(([label, value]) => {\n            const baseData = {\n                label,\n                value,\n                isPredefined: question.choices?.includes(label) ?? false,\n            }\n\n            // Attach the latest person's data who selected this choice (for UI display)\n            if (latestResponsePersonData[label]) {\n                return {\n                    ...baseData,\n                    distinctId: latestResponsePersonData[label].distinctId,\n                    personProperties: latestResponsePersonData[label].personProperties,\n                    timestamp: latestResponsePersonData[label].timestamp,\n                }\n            }\n\n            return baseData\n        })\n        .sort((a, b) => b.value - a.value)\n\n    return {\n        type: questionType,\n        data,\n        totalResponses: total,\n    }\n}\n\nfunction processRatingQuestion(\n    question: RatingSurveyQuestion,\n    questionIndex: number,\n    results: SurveyRawResults\n): ChoiceQuestionProcessedResponses {\n    const scaleSize = question.scale === SURVEY_RATING_SCALE.NPS_10_POINT ? 11 : question.scale\n    const counts = new Array(scaleSize).fill(0)\n    let total = 0\n\n    results?.forEach((row: SurveyResponseRow) => {\n        const value = row[questionIndex] as string\n        if (!isEmptyOrUndefined(value)) {\n            const parsedValue = parseInt(value, 10)\n            if (!isNaN(parsedValue)) {\n                let arrayIndex: number\n                let isValid = false\n\n                if (question.scale === SURVEY_RATING_SCALE.NPS_10_POINT) {\n                    // NPS scale: 0-10 (11 values)\n                    isValid = parsedValue >= 0 && parsedValue <= 10\n                    arrayIndex = parsedValue\n                } else {\n                    // Regular rating scales: 1-N (N values, but we use 0-based indexing)\n                    // For a 5-point scale, accept ratings 1-5 and map them to indices 0-4\n                    isValid = parsedValue >= 1 && parsedValue <= question.scale\n                    arrayIndex = parsedValue - 1 // Convert 1-based to 0-based\n                }\n\n                if (isValid) {\n                    counts[arrayIndex] += 1\n                    total += 1\n                }\n            }\n        }\n    })\n\n    const data = counts.map((count, index) => {\n        // For display labels:\n        // - NPS (scale 10): show 0-10\n        // - Regular scales: show 1-N (convert from 0-based index)\n        const label = question.scale === SURVEY_RATING_SCALE.NPS_10_POINT ? index.toString() : (index + 1).toString()\n\n        return {\n            label,\n            value: count,\n            isPredefined: true,\n        }\n    })\n\n    return {\n        type: SurveyQuestionType.Rating,\n        data,\n        totalResponses: total,\n    }\n}\n\nfunction processOpenQuestion(questionIndex: number, results: SurveyRawResults): OpenQuestionProcessedResponses {\n    const data: { distinctId: string; response: string; personProperties?: Record<string, any>; timestamp?: string }[] =\n        []\n    let totalResponses = 0\n\n    results?.forEach((row: SurveyResponseRow) => {\n        const value = row[questionIndex] as string\n        if (isEmptyOrUndefined(value)) {\n            return\n        }\n\n        const personData = extractPersonData(row)\n        const response = {\n            distinctId: personData.distinctId,\n            response: value,\n            personProperties: personData.personProperties,\n            timestamp: personData.timestamp,\n        }\n\n        totalResponses += 1\n        data.push(response)\n    })\n\n    return {\n        type: SurveyQuestionType.Open,\n        data,\n        totalResponses,\n    }\n}\n\nexport function processResultsForSurveyQuestions(\n    questions: SurveyQuestion[],\n    results: SurveyRawResults\n): ResponsesByQuestion {\n    const responsesByQuestion: ResponsesByQuestion = {}\n\n    questions.forEach((question, index) => {\n        // Skip questions without IDs or Link questions\n        if (!question.id || question.type === SurveyQuestionType.Link) {\n            return\n        }\n\n        let processedData: QuestionProcessedResponses\n\n        switch (question.type) {\n            case SurveyQuestionType.SingleChoice:\n            case SurveyQuestionType.MultipleChoice:\n                processedData = processChoiceQuestion(question, index, results, question.type)\n                break\n            case SurveyQuestionType.Rating:\n                processedData = processRatingQuestion(question, index, results)\n                break\n            case SurveyQuestionType.Open:\n                processedData = processOpenQuestion(index, results)\n                break\n            default:\n                // Skip unknown question types\n                return\n        }\n\n        responsesByQuestion[question.id] = processedData\n    })\n\n    return responsesByQuestion\n}\n\nexport const surveyLogic = kea<surveyLogicType>([\n    props({} as SurveyLogicProps),\n    key(({ id }) => id),\n    path((key) => ['scenes', 'surveys', 'surveyLogic', key]),\n    connect(() => ({\n        actions: [\n            surveysLogic,\n            ['loadSurveys'],\n            eventUsageLogic,\n            [\n                'reportSurveyCreated',\n                'reportSurveyEdited',\n                'reportSurveyArchived',\n                'reportSurveyViewed',\n                'reportSurveyCycleDetected',\n            ],\n            teamLogic,\n            ['addProductIntent'],\n        ],\n        values: [\n            enabledFlagLogic,\n            ['featureFlags as enabledFlags'],\n            surveysLogic,\n            ['data'],\n            userLogic,\n            ['user'],\n            teamLogic,\n            ['currentTeam'],\n            propertyDefinitionsModel,\n            ['propertyDefinitionsByType'],\n        ],\n    })),\n    actions({\n        setSurveyMissing: true,\n        editingSurvey: (editing: boolean) => ({ editing }),\n        setDefaultForQuestionType: (idx: number, surveyQuestion: SurveyQuestion, type: SurveyQuestionType) => ({\n            idx,\n            surveyQuestion,\n            type,\n        }),\n        setQuestionBranchingType: (questionIndex, type, specificQuestionIndex) => ({\n            questionIndex,\n            type,\n            specificQuestionIndex,\n        }),\n        setMultipleSurveyQuestion: (\n            questionIndex: number,\n            question: MultipleSurveyQuestion,\n            type: SurveyQuestionType.MultipleChoice | SurveyQuestionType.SingleChoice\n        ) => ({\n            questionIndex,\n            question,\n            type,\n        }),\n        setResponseBasedBranchingForQuestion: (questionIndex, responseValue, nextStep, specificQuestionIndex) => ({\n            questionIndex,\n            responseValue,\n            nextStep,\n            specificQuestionIndex,\n        }),\n        setDataCollectionType: (dataCollectionType: DataCollectionType) => ({\n            dataCollectionType,\n        }),\n        resetBranchingForQuestion: (questionIndex) => ({ questionIndex }),\n        deleteBranchingLogic: true,\n        archiveSurvey: true,\n        setWritingHTMLDescription: (writingHTML: boolean) => ({ writingHTML }),\n        setSurveyTemplateValues: (template: Partial<NewSurvey>) => ({ template }),\n        setSelectedPageIndex: (idx: number | null) => ({ idx }),\n        setSelectedSection: (section: SurveyEditSection | null) => ({ section }),\n        resetTargeting: true,\n        resetSurveyAdaptiveSampling: true,\n        resetSurveyResponseLimits: true,\n        setFlagPropertyErrors: (errors: any) => ({ errors }),\n        setPropertyFilters: (propertyFilters: AnyPropertyFilter[]) => ({ propertyFilters }),\n        setAnswerFilters: (filters: EventPropertyFilter[], reloadResults: boolean = true) => ({\n            filters,\n            reloadResults,\n        }),\n        setDateRange: (dateRange: SurveyDateRange, reloadResults: boolean = true) => ({ dateRange, reloadResults }),\n        setInterval: (interval: IntervalType) => ({ interval }),\n        setCompareFilter: (compareFilter: CompareFilter) => ({ compareFilter }),\n        setFilterSurveyStatsByDistinctId: (filterByDistinctId: boolean) => ({ filterByDistinctId }),\n        setBaseStatsResults: (results: SurveyBaseStatsResult) => ({ results }),\n        setDismissedAndSentCount: (count: DismissedAndSentCountResult) => ({ count }),\n        setIsDuplicateToProjectModalOpen: (isOpen: boolean) => ({ isOpen }),\n    }),\n    loaders(({ props, actions, values }) => ({\n        responseSummary: {\n            summarize: async ({ questionIndex, questionId }: { questionIndex?: number; questionId?: string }) => {\n                return api.surveys.summarize_responses(props.id, questionIndex, questionId)\n            },\n        },\n        survey: {\n            loadSurvey: async () => {\n                if (props.id && props.id !== 'new') {\n                    try {\n                        const survey = await api.surveys.get(props.id)\n                        const currentFilters = values.answerFilters\n                        actions.reportSurveyViewed(survey)\n                        // Initialize answer filters for all questions - first for index-based, then for id-based\n                        actions.setAnswerFilters(\n                            survey.questions.map((question) => {\n                                const { indexBasedKey, idBasedKey } = getResponseFieldWithId(0, question.id)\n                                const currentFilterForQuestion = currentFilters.find(\n                                    (filter) => filter.key === idBasedKey\n                                )\n                                return {\n                                    key: idBasedKey || indexBasedKey,\n                                    operator:\n                                        currentFilterForQuestion?.operator ?? DEFAULT_OPERATORS[question.type].value,\n                                    type: PropertyFilterType.Event as const,\n                                    value: currentFilterForQuestion?.value ?? [],\n                                }\n                            }),\n                            false\n                        )\n\n                        if (!values.dateRange) {\n                            actions.setDateRange(\n                                {\n                                    date_from: getSurveyStartDateForQuery(survey),\n                                    date_to: getSurveyEndDateForQuery(survey),\n                                },\n                                false\n                            )\n                        }\n                        actions.addProductIntent({\n                            product_type: ProductKey.SURVEYS,\n                            intent_context: ProductIntentContext.SURVEY_VIEWED,\n                            metadata: {\n                                survey_id: survey.id,\n                            },\n                        })\n                        return survey\n                    } catch (error: any) {\n                        if (error.status === 404) {\n                            actions.setSurveyMissing()\n                            return { ...NEW_SURVEY }\n                        }\n                        throw error\n                    }\n                }\n                if (props.id === 'new' && router.values.hashParams.fromTemplate) {\n                    const templatedSurvey = values.survey\n                    templatedSurvey.appearance = {\n                        ...defaultSurveyAppearance,\n                        ...teamLogic.values.currentTeam?.survey_config?.appearance,\n                        ...templatedSurvey.appearance,\n                    }\n                    return templatedSurvey\n                }\n\n                const newSurvey = NEW_SURVEY\n                newSurvey.appearance = {\n                    ...defaultSurveyAppearance,\n                    ...teamLogic.values.currentTeam?.survey_config?.appearance,\n                    ...newSurvey.appearance,\n                }\n\n                return newSurvey\n            },\n            createSurvey: async (surveyPayload: Partial<Survey>) => {\n                const response = await api.surveys.create(surveyPayload)\n                actions.addProductIntent({\n                    product_type: ProductKey.SURVEYS,\n                    intent_context: ProductIntentContext.SURVEY_CREATED,\n                    metadata: {\n                        survey_id: response.id,\n                        source: SURVEY_CREATED_SOURCE.SURVEY_FORM,\n                    },\n                })\n                return response\n            },\n            updateSurvey: async (surveyPayload: Partial<Survey> & { intentContext?: ProductIntentContext }) => {\n                const response = await api.surveys.update(props.id, surveyPayload)\n                if (surveyPayload.intentContext) {\n                    actions.addProductIntent({\n                        product_type: ProductKey.SURVEYS,\n                        intent_context: surveyPayload.intentContext,\n                        metadata: {\n                            survey_id: values.survey.id,\n                        },\n                    })\n                }\n                refreshTreeItem('survey', props.id)\n                return response\n            },\n            launchSurvey: async () => {\n                const startDate = dayjs()\n                const response = await api.surveys.update(props.id, { start_date: startDate.toISOString() })\n                actions.addProductIntent({\n                    product_type: ProductKey.SURVEYS,\n                    intent_context: ProductIntentContext.SURVEY_LAUNCHED,\n                    metadata: {\n                        survey_id: response.id,\n                    },\n                })\n                return response\n            },\n            stopSurvey: async () => {\n                const response = await api.surveys.update(props.id, { end_date: dayjs().toISOString() })\n                actions.addProductIntent({\n                    product_type: ProductKey.SURVEYS,\n                    intent_context: ProductIntentContext.SURVEY_COMPLETED,\n                    metadata: {\n                        survey_id: response.id,\n                    },\n                })\n                return response\n            },\n            resumeSurvey: async () => {\n                const response = await api.surveys.update(props.id, { end_date: null })\n                actions.addProductIntent({\n                    product_type: ProductKey.SURVEYS,\n                    intent_context: ProductIntentContext.SURVEY_RESUMED,\n                    metadata: {\n                        survey_id: response.id,\n                    },\n                })\n                return response\n            },\n        },\n        duplicatedSurvey: {\n            duplicateSurvey: async () => {\n                const { survey } = values\n                const payload = duplicateExistingSurvey(survey)\n                try {\n                    const createdSurvey = await api.surveys.create(sanitizeSurvey(payload))\n\n                    lemonToast.success('Survey duplicated.', {\n                        toastId: `survey-duplicated-${createdSurvey.id}`,\n                        button: {\n                            label: 'View Survey',\n                            action: () => {\n                                router.actions.push(urls.survey(createdSurvey.id))\n                            },\n                        },\n                    })\n\n                    actions.setIsDuplicateToProjectModalOpen(false)\n                    actions.reportSurveyCreated(createdSurvey, true)\n                    actions.addProductIntent({\n                        product_type: ProductKey.SURVEYS,\n                        intent_context: ProductIntentContext.SURVEY_DUPLICATED,\n                        metadata: {\n                            survey_id: createdSurvey.id,\n                        },\n                    })\n                    return survey\n                } catch (error) {\n                    posthog.captureException(error, {\n                        action: 'duplicate-survey',\n                        survey: payload,\n                    })\n                    lemonToast.error('Error while duplicating survey. Please try again.')\n                    return null\n                }\n            },\n        },\n        duplicatedToProjectSurvey: {\n            duplicateToProject: async ({ sourceSurvey, targetTeamIds }) => {\n                const response = await api.surveys.duplicateToProjects(sourceSurvey.id, targetTeamIds)\n\n                lemonToast.success(`Survey duplicated to ${pluralize(response.count, 'project')}.`, {\n                    toastId: `survey-bulk-duplicated-${sourceSurvey.id}`,\n                })\n\n                actions.addProductIntent({\n                    product_type: ProductKey.SURVEYS,\n                    intent_context: ProductIntentContext.SURVEY_BULK_DUPLICATED,\n                    metadata: {\n                        survey_id: sourceSurvey.id,\n                        target_team_ids: targetTeamIds,\n                        bulk_operation: true,\n                    },\n                })\n\n                actions.setIsDuplicateToProjectModalOpen(false)\n                return sourceSurvey\n            },\n        },\n        surveyBaseStats: {\n            loadSurveyBaseStats: async (): Promise<SurveyBaseStatsResult> => {\n                if (props.id === NEW_SURVEY.id || !values.survey?.start_date) {\n                    return null\n                }\n                // if we have answer filters, we need to apply them to the query for the 'survey sent' event only\n                const answerFilterCondition = values.answerFilterHogQLExpression\n                    ? values.answerFilterHogQLExpression.slice(4)\n                    : '1=1' // Use '1=1' for SQL TRUE\n\n                const query = `\n                    -- QUERYING BASE STATS\n                    SELECT\n                        event as event_name,\n                        count() as total_count,\n                        count(DISTINCT person_id) as unique_persons,\n                        if(count() > 0, min(timestamp), null) as first_seen,\n                        if(count() > 0, max(timestamp), null) as last_seen\n                    FROM events\n                    WHERE team_id = ${teamLogic.values.currentTeamId}\n                        AND event IN ('${SurveyEventName.SHOWN}', '${SurveyEventName.DISMISSED}', '${SurveyEventName.SENT}')\n                        AND properties.${SurveyEventProperties.SURVEY_ID} = '${props.id}'\n                        ${values.timestampFilter}\n                        AND {filters} -- Apply property filters here to the main query\n                        -- Main condition for handling partial responses and answer filters:\n                        AND (\n                            event != '${SurveyEventName.DISMISSED}'\n                            OR\n                            COALESCE(JSONExtractBool(properties, '${SurveyEventProperties.SURVEY_PARTIALLY_COMPLETED}'), False) = False\n                        )\n                        AND (\n                            -- Include non-'sent' events directly\n                            event != '${SurveyEventName.SENT}'\n                            OR\n                            -- Include 'sent' events only if they meet the outer query's answer filter AND are in the unique list (old or latest partial/complete)\n                            (\n                                (${answerFilterCondition}) -- Apply answer filters ONLY to 'sent' events in the outer query\n                                -- Check if the event's UUID is in the list generated by the subquery\n                                ${values.partialResponsesFilter}\n                            )\n                        )\n                    GROUP BY event` as HogQLQueryString\n\n                const response = await api.queryHogQL(query, {\n                    queryParams: {\n                        filters: {\n                            properties: values.propertyFilters,\n                        },\n                    },\n                })\n                actions.setBaseStatsResults(response.results as SurveyBaseStatsResult)\n                const numberOfSurveySentEvents = response.results?.find(\n                    (result) => result[0] === SurveyEventName.SENT\n                )?.[1]\n                actions.loadConsolidatedSurveyResults(numberOfSurveySentEvents)\n                return response.results as SurveyBaseStatsResult\n            },\n        },\n        surveyDismissedAndSentCount: {\n            loadSurveyDismissedAndSentCount: async (): Promise<DismissedAndSentCountResult> => {\n                if (props.id === NEW_SURVEY.id || !values.survey?.start_date) {\n                    return null\n                }\n                // if we have answer filters, we need to apply them to the query for the 'survey sent' event only\n                const answerFilterCondition =\n                    values.answerFilterHogQLExpression === ''\n                        ? '1=1' // Use '1=1' for SQL TRUE\n                        : values.answerFilterHogQLExpression.substring(4)\n\n                const query = `\n                    -- QUERYING DISMISSED AND SENT COUNT\n                    SELECT count()\n                    FROM (\n                        SELECT person_id\n                        FROM events\n                        WHERE team_id = ${teamLogic.values.currentTeamId}\n                            AND event IN ('${SurveyEventName.DISMISSED}', '${SurveyEventName.SENT}')\n                            AND properties.${SurveyEventProperties.SURVEY_ID} = '${props.id}'\n                            ${values.timestampFilter}\n                            AND (\n                            event != '${SurveyEventName.DISMISSED}'\n                            OR\n                            COALESCE(JSONExtractBool(properties, '${SurveyEventProperties.SURVEY_PARTIALLY_COMPLETED}'), False) = False\n                            )\n                            AND {filters} -- Apply property filters here to reduce initial events\n                        GROUP BY person_id\n                        HAVING sum(if(event = '${SurveyEventName.DISMISSED}', 1, 0)) > 0 -- Has at least one dismissed event (matching property filters)\n                            AND sum(if(event = '${SurveyEventName.SENT}' AND (${answerFilterCondition}), 1, 0)) > 0 -- Has at least one sent event matching BOTH property and answer filters\n                    ) AS PersonsWithBothEvents` as HogQLQueryString\n\n                const response = await api.queryHogQL(query, {\n                    queryParams: {\n                        filters: {\n                            properties: values.propertyFilters, // Property filters applied in WHERE\n                        },\n                    },\n                })\n                const count = response.results?.[0]?.[0] ?? 0\n                actions.setDismissedAndSentCount(count)\n                return count as DismissedAndSentCountResult\n            },\n        },\n        consolidatedSurveyResults: {\n            loadConsolidatedSurveyResults: async (\n                limit = MAX_SELECT_RETURNED_ROWS\n            ): Promise<ConsolidatedSurveyResults> => {\n                if (props.id === NEW_SURVEY.id || !values.survey?.start_date) {\n                    return { responsesByQuestion: {} }\n                }\n\n                // Build an array of all questions with their types\n                const questionFields = values.survey.questions.map((question, index) => {\n                    return `${getSurveyResponse(question, index)} AS q${index}_response`\n                })\n\n                // Also get distinct_id, person properties, and timestamp for open text questions\n                const query = `\n                    -- QUERYING ALL SURVEY RESPONSES IN ONE GO\n                    SELECT\n                        ${questionFields.join(',\\n')},\n                        ${PERSON_DEFAULT_DISPLAY_NAME_PROPERTIES.map((property) => `person.properties.${property}`).join(',\\n')},\n                        events.distinct_id,\n                        events.timestamp\n                    FROM events\n                    WHERE event = '${SurveyEventName.SENT}'\n                        AND properties.${SurveyEventProperties.SURVEY_ID} = '${props.id}'\n                        ${values.timestampFilter}\n                        ${values.answerFilterHogQLExpression}\n                        ${values.partialResponsesFilter}\n                        AND {filters}\n                    ORDER BY events.timestamp DESC\n                    LIMIT ${limit}` as HogQLQueryString\n\n                const responseJSON = await api.queryHogQL(query, {\n                    queryParams: {\n                        filters: {\n                            properties: values.propertyFilters,\n                        },\n                    },\n                })\n                const { results } = responseJSON\n\n                // Process the results into a format that can be used by each question type\n                const responsesByQuestion = processResultsForSurveyQuestions(values.survey.questions, results)\n\n                return { responsesByQuestion }\n            },\n        },\n    })),\n    listeners(({ actions, values }) => {\n        const reloadAllSurveyResults = debounce((): void => {\n            // Load survey stats data\n            actions.loadSurveyBaseStats()\n            actions.loadSurveyDismissedAndSentCount()\n        }, 1000)\n\n        return {\n            createSurveySuccess: ({ survey }) => {\n                lemonToast.success(<>Survey {survey.name} created</>)\n                actions.loadSurveys()\n                router.actions.replace(urls.survey(survey.id))\n                actions.reportSurveyCreated(survey)\n            },\n            updateSurveySuccess: ({ survey }) => {\n                lemonToast.success(<>Survey {survey.name} updated</>)\n                actions.editingSurvey(false)\n                actions.reportSurveyEdited(survey)\n                actions.loadSurveys()\n            },\n            duplicateSurveySuccess: () => {\n                actions.loadSurveys()\n            },\n            duplicatedToProjectSurveySuccess: () => {\n                actions.loadSurveys()\n            },\n            launchSurveySuccess: ({ survey }) => {\n                lemonToast.success(<>Survey {survey.name} launched</>)\n                actions.loadSurveys()\n            },\n            stopSurveySuccess: () => {\n                actions.loadSurveys()\n            },\n            resumeSurveySuccess: () => {\n                actions.loadSurveys()\n            },\n            archiveSurvey: () => {\n                actions.updateSurvey({ archived: true })\n                actions.addProductIntent({\n                    product_type: ProductKey.SURVEYS,\n                    intent_context: ProductIntentContext.SURVEY_ARCHIVED,\n                    metadata: {\n                        survey_id: values.survey.id,\n                    },\n                })\n            },\n            loadSurveySuccess: () => {\n                // Trigger stats loading after survey loads\n                if (values.survey.id !== NEW_SURVEY.id && values.survey.start_date) {\n                    actions.loadSurveyBaseStats()\n                    actions.loadSurveyDismissedAndSentCount()\n                }\n\n                if (values.survey.start_date) {\n                    activationLogic.findMounted()?.actions.markTaskAsCompleted(ActivationTask.LaunchSurvey)\n                }\n            },\n            resetSurveyResponseLimits: () => {\n                actions.setSurveyValue('responses_limit', null)\n            },\n            resetSurveyAdaptiveSampling: () => {\n                actions.setSurveyValues({\n                    response_sampling_interval: null,\n                    response_sampling_interval_type: null,\n                    response_sampling_limit: null,\n                    response_sampling_start_date: null,\n                    response_sampling_daily_limits: null,\n                })\n            },\n            resetTargeting: () => {\n                actions.setSurveyValue('linked_flag_id', NEW_SURVEY.linked_flag_id)\n                actions.setSurveyValue('targeting_flag_filters', NEW_SURVEY.targeting_flag_filters)\n                actions.setSurveyValue('linked_flag', NEW_SURVEY.linked_flag)\n                actions.setSurveyValue('targeting_flag', NEW_SURVEY.targeting_flag)\n                actions.setSurveyValue('conditions', NEW_SURVEY.conditions)\n                actions.setSurveyValue('remove_targeting_flag', true)\n                actions.setSurveyValue('responses_limit', NEW_SURVEY.responses_limit)\n                actions.setSurveyValues({\n                    iteration_count: NEW_SURVEY.iteration_count,\n                    iteration_frequency_days: NEW_SURVEY.iteration_frequency_days,\n                })\n                actions.setFlagPropertyErrors(null)\n            },\n            submitSurveyFailure: async () => {\n                // When errors occur, scroll to the error, but wait for errors to be set in the DOM first\n                if (hasFormErrors(values.flagPropertyErrors) || values.urlMatchTypeValidationError) {\n                    actions.setSelectedSection(SurveyEditSection.DisplayConditions)\n                } else if (hasFormErrors(values.survey.appearance)) {\n                    actions.setSelectedSection(SurveyEditSection.Customization)\n                } else {\n                    actions.setSelectedSection(SurveyEditSection.Steps)\n                }\n                setTimeout(\n                    () =>\n                        document\n                            .querySelector(`.Field--error`)\n                            ?.scrollIntoView({ block: 'center', behavior: 'smooth' }),\n                    5\n                )\n            },\n            setPropertyFilters: () => {\n                reloadAllSurveyResults()\n            },\n            setAnswerFilters: ({ reloadResults }) => {\n                if (reloadResults) {\n                    reloadAllSurveyResults()\n                }\n            },\n            setDateRange: ({ reloadResults }) => {\n                if (reloadResults) {\n                    reloadAllSurveyResults()\n                }\n            },\n        }\n    }),\n    reducers({\n        filterSurveyStatsByDistinctId: [\n            true,\n            { persist: true },\n            {\n                setFilterSurveyStatsByDistinctId: (_, { filterByDistinctId }) => filterByDistinctId,\n            },\n        ],\n        isEditingSurvey: [\n            false,\n            {\n                editingSurvey: (_, { editing }) => editing,\n            },\n        ],\n        isDuplicateToProjectModalOpen: [\n            false,\n            {\n                setIsDuplicateToProjectModalOpen: (_, { isOpen }) => isOpen,\n            },\n        ],\n        surveyMissing: [\n            false,\n            {\n                setSurveyMissing: () => true,\n            },\n        ],\n        dataCollectionType: [\n            'until_stopped' as DataCollectionType,\n            {\n                setDataCollectionType: (_, { dataCollectionType }) => dataCollectionType,\n            },\n        ],\n        propertyFilters: [\n            [] as AnyPropertyFilter[],\n            { persist: true },\n            {\n                setPropertyFilters: (_, { propertyFilters }) => propertyFilters,\n            },\n        ],\n        survey: [\n            { ...NEW_SURVEY } as NewSurvey | Survey,\n            {\n                setDefaultForQuestionType: (state, { idx, type, surveyQuestion }) => {\n                    const question =\n                        defaultSurveyFieldValues[surveyQuestion.type].questions[0].question !== surveyQuestion.question\n                            ? surveyQuestion.question\n                            : defaultSurveyFieldValues[type].questions[0].question\n                    const description =\n                        defaultSurveyFieldValues[surveyQuestion.type].questions[0].description !==\n                        surveyQuestion.description\n                            ? surveyQuestion.description\n                            : defaultSurveyFieldValues[type].questions[0].description\n                    const thankYouMessageHeader =\n                        defaultSurveyFieldValues[surveyQuestion.type].appearance.thankYouMessageHeader !==\n                        state.appearance?.thankYouMessageHeader\n                            ? state.appearance?.thankYouMessageHeader\n                            : defaultSurveyFieldValues[type].appearance.thankYouMessageHeader\n                    const newQuestions = [...state.questions]\n\n                    const q = {\n                        ...surveyQuestion,\n                    }\n                    if (q.type === SurveyQuestionType.MultipleChoice || q.type === SurveyQuestionType.SingleChoice) {\n                        delete q.hasOpenChoice\n                    }\n                    newQuestions[idx] = {\n                        ...q,\n                        ...(defaultSurveyFieldValues[type].questions[0] as SurveyQuestionBase),\n                        question,\n                        description,\n                    }\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                        appearance: {\n                            ...state.appearance,\n                            ...defaultSurveyFieldValues[type].appearance,\n                            thankYouMessageHeader,\n                        },\n                    }\n                },\n                setSurveyTemplateValues: (_, { template }) => {\n                    const newTemplateSurvey = { ...NEW_SURVEY, ...template }\n                    return newTemplateSurvey\n                },\n                setQuestionBranchingType: (state, { questionIndex, type, specificQuestionIndex }) => {\n                    const newQuestions = [...state.questions]\n                    const question = newQuestions[questionIndex]\n\n                    // Validate response-based branching is only used with compatible question types\n                    if (\n                        type === SurveyQuestionBranchingType.ResponseBased &&\n                        !canQuestionHaveResponseBasedBranching(question)\n                    ) {\n                        question.branching = undefined\n                        lemonToast.error(\n                            <>\n                                Response-based branching is not supported for {question.type} questions. Removing\n                                branching logic from this question.\n                            </>\n                        )\n                    } else {\n                        // Use centralized branching config creation\n                        question.branching = createBranchingConfig(type, specificQuestionIndex)\n                    }\n\n                    newQuestions[questionIndex] = question\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n                setResponseBasedBranchingForQuestion: (\n                    state,\n                    { questionIndex, responseValue, nextStep, specificQuestionIndex }\n                ) => {\n                    const newQuestions = [...state.questions]\n                    const question = newQuestions[questionIndex]\n\n                    // Use centralized validation for response-based branching compatibility\n                    if (!canQuestionHaveResponseBasedBranching(question)) {\n                        throw new Error(\n                            `Survey question type must be ${SurveyQuestionType.Rating} or ${SurveyQuestionType.SingleChoice} for response-based branching`\n                        )\n                    }\n\n                    if (question.branching?.type !== SurveyQuestionBranchingType.ResponseBased) {\n                        throw new Error(\n                            `Survey question branching type must be ${SurveyQuestionBranchingType.ResponseBased}`\n                        )\n                    }\n\n                    if ('responseValues' in question.branching) {\n                        if (nextStep === SurveyQuestionBranchingType.NextQuestion) {\n                            // Remove the response mapping to default to next question\n                            delete question.branching.responseValues[responseValue]\n                        } else if (nextStep === SurveyQuestionBranchingType.End) {\n                            // Map response to end survey\n                            question.branching.responseValues[responseValue] = SurveyQuestionBranchingType.End\n                        } else if (nextStep === SurveyQuestionBranchingType.SpecificQuestion) {\n                            // Map response to specific question index\n                            question.branching.responseValues[responseValue] = specificQuestionIndex\n                        }\n                    }\n\n                    newQuestions[questionIndex] = question\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n                resetBranchingForQuestion: (state, { questionIndex }) => {\n                    const newQuestions = [...state.questions]\n                    const question = newQuestions[questionIndex]\n                    delete question.branching\n\n                    newQuestions[questionIndex] = question\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n                deleteBranchingLogic: (state) => {\n                    const newQuestions = [...state.questions]\n                    newQuestions.forEach((question) => {\n                        delete question.branching\n                    })\n\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n                setMultipleSurveyQuestion: (state, { questionIndex, question, type }) => {\n                    const newQuestions = [...state.questions]\n                    const newQuestion: MultipleSurveyQuestion = {\n                        ...question,\n                        type,\n                    }\n                    newQuestions[questionIndex] = newQuestion\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n            },\n        ],\n        selectedPageIndex: [\n            0 as number | null,\n            {\n                setSelectedPageIndex: (_, { idx }) => idx,\n            },\n        ],\n        selectedSection: [\n            SurveyEditSection.Steps as SurveyEditSection | null,\n            {\n                setSelectedSection: (_, { section }) => section,\n            },\n        ],\n        writingHTMLDescription: [\n            false,\n            {\n                setWritingHTMLDescription: (_, { writingHTML }) => writingHTML,\n            },\n        ],\n        flagPropertyErrors: [\n            null as any,\n            {\n                setFlagPropertyErrors: (_, { errors }) => errors,\n            },\n        ],\n        answerFilters: [\n            [] as EventPropertyFilter[],\n            { persist: true },\n            {\n                setAnswerFilters: (_, { filters }) => filters,\n            },\n        ],\n        dateRange: [\n            null as SurveyDateRange | null,\n            { persist: true },\n            {\n                setDateRange: (_, { dateRange }) => dateRange,\n            },\n        ],\n        interval: [\n            null as IntervalType | null,\n            {\n                setInterval: (_, { interval }) => interval,\n            },\n        ],\n        compareFilter: [\n            { compare: true } as CompareFilter,\n            {\n                setCompareFilter: (_, { compareFilter }) => compareFilter,\n            },\n        ],\n        surveyBaseStatsInternal: [\n            null as SurveyBaseStatsResult,\n            {\n                setBaseStatsResults: (_, { results }) => results,\n                loadSurveySuccess: () => null,\n                resetSurvey: () => null,\n            },\n        ],\n        surveyDismissedAndSentCountInternal: [\n            null as DismissedAndSentCountResult,\n            {\n                setDismissedAndSentCount: (_, { count }) => count,\n                loadSurveySuccess: () => null,\n                resetSurvey: () => null,\n            },\n        ],\n    }),\n    selectors({\n        timestampFilter: [\n            (s) => [s.survey, s.dateRange],\n            (survey: Survey, dateRange: SurveyDateRange): string => {\n                return buildSurveyTimestampFilter(survey, dateRange)\n            },\n        ],\n        partialResponsesFilter: [\n            (s) => [s.survey],\n            (survey: Survey): string => {\n                if (survey.enable_partial_responses) {\n                    return buildPartialResponsesFilter(survey)\n                }\n                /**\n                 * Return only complete responses. For pre-partial responses, we didn't have the survey_completed property.\n                 * So we return all responses that don't have it.\n                 * For posthog-js > 1.240, we use the $survey_completed property.\n                 */\n                return `AND (\n                            NOT JSONHas(properties, '${SurveyEventProperties.SURVEY_COMPLETED}')\n                            OR JSONExtractBool(properties, '${SurveyEventProperties.SURVEY_COMPLETED}') = true\n                        )`\n            },\n        ],\n        isSurveyAnalysisMaxToolEnabled: [\n            (s) => [s.enabledFlags],\n            (enabledFlags: FeatureFlagsSet): boolean => {\n                return !!enabledFlags[FEATURE_FLAGS.SURVEY_ANALYSIS_MAX_TOOL]\n            },\n        ],\n        isExternalSurveyFFEnabled: [\n            (s) => [s.enabledFlags],\n            (enabledFlags: FeatureFlagsSet): boolean => {\n                return !!enabledFlags[FEATURE_FLAGS.EXTERNAL_SURVEYS]\n            },\n        ],\n        isAdaptiveLimitFFEnabled: [\n            (s) => [s.enabledFlags],\n            (enabledFlags: FeatureFlagsSet): boolean => {\n                return !!enabledFlags[FEATURE_FLAGS.SURVEYS_ADAPTIVE_LIMITS]\n            },\n        ],\n        isAnyResultsLoading: [\n            (s) => [s.surveyBaseStatsLoading, s.surveyDismissedAndSentCountLoading, s.consolidatedSurveyResultsLoading],\n            (\n                surveyBaseStatsLoading: boolean,\n                surveyDismissedAndSentCountLoading: boolean,\n                consolidatedSurveyResultsLoading: boolean\n            ) => {\n                return consolidatedSurveyResultsLoading || surveyBaseStatsLoading || surveyDismissedAndSentCountLoading\n            },\n        ],\n        defaultAnswerFilters: [\n            (s) => [s.survey],\n            (survey: Survey): EventPropertyFilter[] => {\n                return survey.questions.map((question) => {\n                    const { indexBasedKey, idBasedKey } = getResponseFieldWithId(0, question.id)\n                    return {\n                        key: idBasedKey || indexBasedKey,\n                        operator: DEFAULT_OPERATORS[question.type].value,\n                        type: PropertyFilterType.Event as const,\n                        value: [],\n                    }\n                })\n            },\n        ],\n        isSurveyRunning: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return isSurveyRunning(survey)\n            },\n        ],\n        surveyUsesLimit: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(survey.responses_limit && survey.responses_limit > 0)\n            },\n        ],\n        surveyUsesAdaptiveLimit: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(\n                    survey.response_sampling_interval &&\n                    survey.response_sampling_interval > 0 &&\n                    survey.response_sampling_interval_type !== '' &&\n                    survey.response_sampling_limit &&\n                    survey.response_sampling_limit > 0\n                )\n            },\n        ],\n        surveyShufflingQuestionsAvailable: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return survey.questions.length > 1\n            },\n        ],\n        showSurveyRepeatSchedule: [(s) => [s.survey], (survey: Survey) => survey.schedule === SurveySchedule.Recurring],\n        descriptionContentType: [\n            (s) => [s.survey],\n            (survey: Survey) => (questionIndex: number) => {\n                return survey.questions[questionIndex].descriptionContentType\n            },\n        ],\n        surveyRepeatedActivationAvailable: [\n            (s) => [s.survey],\n            (survey: Survey): boolean =>\n                survey.conditions?.events?.values != undefined && survey.conditions?.events?.values?.length > 0,\n        ],\n        hasTargetingSet: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                const hasLinkedFlag =\n                    !!survey.linked_flag_id || (survey.linked_flag && Object.keys(survey.linked_flag).length > 0)\n                const hasTargetingFlag =\n                    (survey.targeting_flag && Object.keys(survey.targeting_flag).length > 0) ||\n                    (survey.targeting_flag_filters && Object.keys(survey.targeting_flag_filters).length > 0)\n                const hasOtherConditions = survey.conditions && Object.keys(survey.conditions).length > 0\n                return !!hasLinkedFlag || !!hasTargetingFlag || !!hasOtherConditions\n            },\n        ],\n        breadcrumbs: [\n            (s) => [s.survey],\n            (survey: Survey): Breadcrumb[] => [\n                {\n                    key: Scene.Surveys,\n                    name: 'Surveys',\n                    path: urls.surveys(),\n                    iconType: 'survey',\n                },\n                {\n                    key: [Scene.Survey, survey?.id || 'new'],\n                    name: survey.name,\n                    iconType: 'survey',\n                },\n            ],\n        ],\n        [SIDE_PANEL_CONTEXT_KEY]: [\n            (s) => [s.survey],\n            (survey: Survey): SidePanelSceneContext | null => {\n                return survey?.id && survey.id !== 'new'\n                    ? {\n                          activity_scope: ActivityScope.SURVEY,\n                          activity_item_id: `${survey.id}`,\n                          access_control_resource: 'survey',\n                          access_control_resource_id: `${survey.id}`,\n                      }\n                    : null\n            },\n        ],\n        projectTreeRef: [\n            () => [(_, props: SurveyLogicProps) => props.id],\n            (id): ProjectTreeRef => {\n                return { type: 'survey', ref: id === 'new' ? null : String(id) }\n            },\n        ],\n        answerFilterHogQLExpression: [\n            (s) => [s.survey, s.answerFilters],\n            (survey: Survey, answerFilters: EventPropertyFilter[]): string => {\n                return createAnswerFilterHogQLExpression(answerFilters, survey)\n            },\n        ],\n        dataTableQuery: [\n            (s) => [s.survey, s.propertyFilters, s.answerFilterHogQLExpression, s.partialResponsesFilter, s.dateRange],\n            (\n                survey: Survey,\n                propertyFilters: AnyPropertyFilter[],\n                answerFilterHogQLExpression: string,\n                partialResponsesFilter: string,\n                dateRange: SurveyDateRange\n            ): DataTableNode | null => {\n                if (survey.id === 'new') {\n                    return null\n                }\n                const startDate = getSurveyStartDateForQuery(survey)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                const where = [`event == '${SurveyEventName.SENT}'`, partialResponsesFilter.replace(/^AND\\s+/, '')]\n\n                if (answerFilterHogQLExpression !== '') {\n                    // skip the 'AND ' prefix\n                    where.push(answerFilterHogQLExpression.substring(4))\n                }\n\n                return {\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.EventsQuery,\n                        select: [\n                            '*',\n                            ...survey.questions.map((q, i) => {\n                                if (q.type === SurveyQuestionType.MultipleChoice) {\n                                    return `arrayStringConcat(${getSurveyResponse(q, i)}, ', ') -- ${q.question}`\n                                }\n                                // Use the new condition that checks both formats\n                                return `${getSurveyResponse(q, i)} -- ${q.question}`\n                            }),\n                            'timestamp',\n                            'person',\n                            `coalesce(JSONExtractString(properties, '$lib_version')) -- Library Version`,\n                            `coalesce(JSONExtractString(properties, '$lib')) -- Library`,\n                            `coalesce(JSONExtractString(properties, '$current_url')) -- URL`,\n                        ],\n                        orderBy: ['timestamp DESC'],\n                        where,\n                        after: dateRange?.date_from || startDate,\n                        before: dateRange?.date_to || endDate,\n                        properties: [\n                            {\n                                type: PropertyFilterType.Event,\n                                key: SurveyEventProperties.SURVEY_ID,\n                                operator: PropertyOperator.Exact,\n                                value: survey.id,\n                            },\n                            ...propertyFilters,\n                        ],\n                    },\n                    propertiesViaUrl: true,\n                    showExport: true,\n                    showReload: true,\n                    showEventFilter: false,\n                    showPropertyFilter: false,\n                    showTimings: false,\n                }\n            },\n        ],\n        targetingFlagFilters: [\n            (s) => [s.survey],\n            (survey): FeatureFlagFilters | undefined => {\n                if (survey.targeting_flag_filters) {\n                    return {\n                        ...survey.targeting_flag_filters,\n                        groups: survey.targeting_flag_filters.groups,\n                        multivariate: null,\n                        payloads: {},\n                        super_groups: undefined,\n                    }\n                }\n                return survey.targeting_flag?.filters || undefined\n            },\n        ],\n        urlMatchTypeValidationError: [\n            (s) => [s.survey],\n            (survey): string | null => {\n                if (\n                    survey.conditions?.url &&\n                    [SurveyMatchType.Regex, SurveyMatchType.NotRegex].includes(\n                        survey.conditions?.urlMatchType || SurveyMatchType.Exact\n                    )\n                ) {\n                    try {\n                        new RegExp(survey.conditions.url)\n                    } catch (e: any) {\n                        return e.message\n                    }\n                }\n                return null\n            },\n        ],\n        urlSearchParams: [\n            (s) => [s.propertyFilters, s.answerFilters, s.dateRange, s.survey],\n            (\n                propertyFilters: AnyPropertyFilter[],\n                answerFilters: EventPropertyFilter[],\n                dateRange: SurveyDateRange | null,\n                survey: Survey\n            ) => {\n                const defaultDateFrom = getSurveyStartDateForQuery(survey)\n                const defaultDateTo = getSurveyEndDateForQuery(survey)\n\n                const nonEmptyAnswerFilters = answerFilters?.filter((filter) => {\n                    const value = filter.value\n                    if (Array.isArray(value)) {\n                        return value.length > 0\n                    }\n                    return value !== null && value !== undefined && value !== ''\n                })\n\n                const isDefaultDateRange =\n                    dateRange?.date_from === defaultDateFrom && dateRange?.date_to === defaultDateTo\n\n                return objectClean({\n                    ...router.values.searchParams,\n                    propertyFilters: propertyFilters?.length > 0 ? JSON.stringify(propertyFilters) : undefined,\n                    answerFilters:\n                        nonEmptyAnswerFilters?.length > 0 ? JSON.stringify(nonEmptyAnswerFilters) : undefined,\n                    date_from: !isDefaultDateRange && dateRange?.date_from ? dateRange.date_from : undefined,\n                    date_to: !isDefaultDateRange && dateRange?.date_to ? dateRange.date_to : undefined,\n                })\n            },\n        ],\n        deviceTypesMatchTypeValidationError: [\n            (s) => [s.survey],\n            (survey: Survey): string | null => {\n                if (\n                    survey.conditions?.deviceTypes &&\n                    [SurveyMatchType.Regex, SurveyMatchType.NotRegex].includes(\n                        survey.conditions?.deviceTypesMatchType || SurveyMatchType.Exact\n                    )\n                ) {\n                    try {\n                        new RegExp(survey.conditions.deviceTypes?.at(0) || '')\n                    } catch (e: any) {\n                        return e.message\n                    }\n                }\n                return null\n            },\n        ],\n        getBranchingDropdownValue: [\n            (s) => [s.survey],\n            (survey) => (questionIndex: number, question: SurveyQuestion) => {\n                if (question.branching?.type) {\n                    const { type } = question.branching\n\n                    if (type === SurveyQuestionBranchingType.SpecificQuestion) {\n                        const nextQuestionIndex = question.branching.index\n                        return branchingConfigToDropdownValue(type, nextQuestionIndex)\n                    }\n\n                    return type\n                }\n\n                // No branching specified, default to Next question / Confirmation message\n                return getDefaultBranchingType(questionIndex, survey.questions.length)\n            },\n        ],\n        getResponseBasedBranchingDropdownValue: [\n            (s) => [s.survey],\n            (survey) => (questionIndex: number, question: RatingSurveyQuestion | MultipleSurveyQuestion, response) => {\n                if (!question.branching || !('responseValues' in question.branching)) {\n                    return SurveyQuestionBranchingType.NextQuestion\n                }\n\n                // If a value is mapped onto an integer, we're redirecting to a specific question\n                if (Number.isInteger(question.branching.responseValues[response])) {\n                    const nextQuestionIndex = question.branching.responseValues[response]\n                    return `${SurveyQuestionBranchingType.SpecificQuestion}:${nextQuestionIndex}`\n                }\n\n                // If any other value is present (practically only Confirmation message), return that value\n                if (question.branching?.responseValues?.[response]) {\n                    return question.branching.responseValues[response]\n                }\n\n                // No branching specified, default to Next question / Confirmation message\n                if (questionIndex < survey.questions.length - 1) {\n                    return SurveyQuestionBranchingType.NextQuestion\n                }\n\n                return SurveyQuestionBranchingType.End\n            },\n        ],\n        hasCycle: [\n            (s) => [s.survey],\n            (survey) => {\n                const graph = new Map()\n                survey.questions.forEach((question, fromIndex: number) => {\n                    if (!graph.has(fromIndex)) {\n                        graph.set(fromIndex, new Set())\n                    }\n\n                    if (question.branching?.type === SurveyQuestionBranchingType.End) {\n                        return\n                    } else if (\n                        question.branching?.type === SurveyQuestionBranchingType.SpecificQuestion &&\n                        Number.isInteger(question.branching.index)\n                    ) {\n                        const toIndex = question.branching.index\n                        graph.get(fromIndex).add(toIndex)\n                        return\n                    } else if (\n                        question.branching?.type === SurveyQuestionBranchingType.ResponseBased &&\n                        isObject(question.branching?.responseValues)\n                    ) {\n                        for (const [_, toIndex] of Object.entries(question.branching?.responseValues)) {\n                            if (Number.isInteger(toIndex)) {\n                                graph.get(fromIndex).add(toIndex)\n                            }\n                        }\n                    }\n\n                    // No branching - still need to connect the next question\n                    if (fromIndex < survey.questions.length - 1) {\n                        const toIndex = fromIndex + 1\n                        graph.get(fromIndex).add(toIndex)\n                    }\n                })\n\n                let cycleDetected = false\n                function dfs(node: number, seen: number[]): void {\n                    if (cycleDetected) {\n                        return\n                    }\n\n                    for (const neighbor of graph.get(node) || []) {\n                        if (seen.includes(neighbor)) {\n                            cycleDetected = true\n                            return\n                        }\n                        dfs(neighbor, seen.concat(neighbor))\n                    }\n                }\n                dfs(0, [0])\n\n                return cycleDetected\n            },\n        ],\n        hasBranchingLogic: [\n            (s) => [s.survey],\n            (survey) =>\n                survey.questions.some((question) => question.branching && Object.keys(question.branching).length > 0),\n        ],\n        surveyAsInsightURL: [\n            (s) => [s.survey],\n            (survey) => {\n                const query: InsightVizNode = {\n                    kind: NodeKind.InsightVizNode,\n                    source: {\n                        kind: NodeKind.TrendsQuery,\n                        properties: [\n                            {\n                                key: SurveyEventProperties.SURVEY_ID,\n                                value: survey.id,\n                                operator: PropertyOperator.Exact,\n                                type: PropertyFilterType.Event,\n                            },\n                        ],\n                        series: [\n                            {\n                                kind: NodeKind.EventsNode,\n                                event: SurveyEventName.SENT,\n                                name: SurveyEventName.SENT,\n                                math: BaseMathType.TotalCount,\n                            },\n                            {\n                                kind: NodeKind.EventsNode,\n                                event: SurveyEventName.SHOWN,\n                                name: SurveyEventName.SHOWN,\n                                math: BaseMathType.TotalCount,\n                            },\n                            {\n                                kind: NodeKind.EventsNode,\n                                event: SurveyEventName.DISMISSED,\n                                name: SurveyEventName.DISMISSED,\n                                math: BaseMathType.TotalCount,\n                            },\n                        ],\n                    },\n                }\n\n                return urls.insightNew({ query })\n            },\n        ],\n        defaultInterval: [\n            (s) => [s.survey],\n            (survey: Survey): IntervalType => {\n                const start = dayjs(survey.created_at).utc().startOf('day').format(DATE_FORMAT)\n                const end = getSurveyEndDateForQuery(survey)\n                const diffInDays = dayjs(end).diff(dayjs(start), 'days')\n                const diffInWeeks = dayjs(end).diff(dayjs(start), 'weeks')\n\n                if (diffInDays < 2) {\n                    return 'hour'\n                }\n                if (diffInWeeks <= 4) {\n                    return 'day'\n                }\n                if (diffInWeeks <= 12) {\n                    return 'week'\n                }\n                return 'month'\n            },\n        ],\n        processedSurveyStats: [\n            (s) => [s.surveyBaseStatsInternal, s.surveyDismissedAndSentCountInternal],\n            (\n                baseStatsResults: SurveyBaseStatsResult,\n                dismissedAndSentCount: DismissedAndSentCountResult\n            ): SurveyStats | null => {\n                if (!baseStatsResults) {\n                    return null\n                }\n\n                const defaultEventStats: Omit<SurveyEventStats, 'first_seen' | 'last_seen'> = {\n                    total_count: 0,\n                    unique_persons: 0,\n                    unique_persons_only_seen: 0,\n                    total_count_only_seen: 0,\n                }\n\n                const stats: SurveyStats = {\n                    [SurveyEventName.SHOWN]: { ...defaultEventStats, first_seen: null, last_seen: null },\n                    [SurveyEventName.DISMISSED]: { ...defaultEventStats, first_seen: null, last_seen: null },\n                    [SurveyEventName.SENT]: { ...defaultEventStats, first_seen: null, last_seen: null },\n                }\n\n                // Process base results\n                baseStatsResults.forEach(([eventName, totalCount, uniquePersons, firstSeen, lastSeen]) => {\n                    const eventStats: SurveyEventStats = {\n                        total_count: totalCount,\n                        unique_persons: uniquePersons,\n                        first_seen: firstSeen ? dayjs(firstSeen).toISOString() : null,\n                        last_seen: lastSeen ? dayjs(lastSeen).toISOString() : null,\n                        unique_persons_only_seen: 0,\n                        total_count_only_seen: 0,\n                    }\n                    if (eventName === SurveyEventName.SHOWN) {\n                        stats[SurveyEventName.SHOWN] = eventStats\n                    } else if (eventName === SurveyEventName.DISMISSED) {\n                        stats[SurveyEventName.DISMISSED] = eventStats\n                    } else if (eventName === SurveyEventName.SENT) {\n                        stats[SurveyEventName.SENT] = eventStats\n                    }\n                })\n\n                // Adjust dismissed unique count\n                const adjustedDismissedUnique = Math.max(\n                    0,\n                    stats[SurveyEventName.DISMISSED].unique_persons - (dismissedAndSentCount ?? 0)\n                )\n                stats[SurveyEventName.DISMISSED].unique_persons = adjustedDismissedUnique\n\n                // Calculate derived 'only_seen' counts\n                const uniqueShown = stats[SurveyEventName.SHOWN].unique_persons\n                const uniqueDismissed = stats[SurveyEventName.DISMISSED].unique_persons\n                const uniqueSent = stats[SurveyEventName.SENT].unique_persons\n\n                const totalShown = stats[SurveyEventName.SHOWN].total_count\n                const totalDismissed = stats[SurveyEventName.DISMISSED].total_count\n                const totalSent = stats[SurveyEventName.SENT].total_count\n\n                stats[SurveyEventName.SHOWN].unique_persons_only_seen = Math.max(\n                    0,\n                    uniqueShown - uniqueDismissed - uniqueSent\n                )\n                stats[SurveyEventName.SHOWN].total_count_only_seen = Math.max(\n                    0,\n                    totalShown - totalDismissed - totalSent\n                )\n\n                return stats\n            },\n        ],\n        surveyRates: [\n            (s) => [s.processedSurveyStats],\n            (processedSurveyStats: SurveyStats | null): SurveyRates | null => {\n                return calculateSurveyRates(processedSurveyStats)\n            },\n        ],\n        surveyDemoData: [\n            (s) => [s.survey],\n            (survey: Survey | NewSurvey): SurveyDemoData => {\n                return getDemoDataForSurvey(survey)\n            },\n        ],\n        formattedOpenEndedResponses: [\n            (s) => [s.consolidatedSurveyResults, s.survey],\n            (\n                consolidatedResults: ConsolidatedSurveyResults,\n                survey: Survey | NewSurvey\n            ): SurveyAnalysisQuestionGroup[] => {\n                if (!consolidatedResults?.responsesByQuestion || !survey.questions) {\n                    return []\n                }\n\n                // Helper function to extract response info\n                const extractResponseInfo = (\n                    response: OpenQuestionResponseData | ChoiceQuestionResponseData\n                ): { timestamp: string } => ({\n                    timestamp: response.timestamp ?? '',\n                })\n\n                const responsesByQuestion: SurveyAnalysisQuestionGroup[] = []\n\n                Object.entries(consolidatedResults.responsesByQuestion).forEach(([questionId, processedData]) => {\n                    const question = survey.questions.find((q) => q.id === questionId)\n                    if (!question) {\n                        return\n                    }\n\n                    const questionResponses: SurveyAnalysisResponseItem[] = []\n\n                    if (processedData.type === SurveyQuestionType.Open) {\n                        // Pure open questions\n                        const openData = processedData as OpenQuestionProcessedResponses\n\n                        openData.data.forEach((response) => {\n                            if (response.response?.trim()) {\n                                const responseInfo = extractResponseInfo(response)\n                                questionResponses.push({\n                                    responseText: response.response.trim(),\n                                    ...responseInfo,\n                                    isOpenEnded: true,\n                                })\n                            }\n                        })\n                    } else if (\n                        processedData.type === SurveyQuestionType.SingleChoice ||\n                        processedData.type === SurveyQuestionType.MultipleChoice\n                    ) {\n                        // Choice questions with open input (isPredefined = false)\n                        const choiceData = processedData as ChoiceQuestionProcessedResponses\n\n                        choiceData.data.forEach((item) => {\n                            if (!item.isPredefined && item.label?.trim()) {\n                                const responseInfo = extractResponseInfo(item)\n                                questionResponses.push({\n                                    responseText: item.label.trim(),\n                                    ...responseInfo,\n                                    isOpenEnded: true,\n                                })\n                            }\n                        })\n                    }\n\n                    // Only add question if it has open-ended responses\n                    if (questionResponses.length > 0) {\n                        responsesByQuestion.push({\n                            questionName: question.question,\n                            questionId,\n                            responses: questionResponses,\n                        })\n                    }\n                })\n\n                return responsesByQuestion\n            },\n        ],\n    }),\n    forms(({ actions, props, values }) => ({\n        survey: {\n            defaults: { ...NEW_SURVEY } as NewSurvey | Survey,\n            errors: ({ name, questions, appearance, type }) => {\n                const sanitizedAppearance = sanitizeSurveyAppearance(appearance)\n                return {\n                    name: !name && 'Please enter a name.',\n                    questions: questions.map((question) => {\n                        const questionErrors = {\n                            question: !question.question && 'Please enter a question label.',\n                        }\n\n                        if (question.type === SurveyQuestionType.Link) {\n                            if (question.link) {\n                                if (question.link.startsWith('mailto:')) {\n                                    const emailRegex = /^mailto:[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\n                                    if (!emailRegex.test(question.link)) {\n                                        return {\n                                            ...questionErrors,\n                                            link: 'Please enter a valid mailto link (e.g., mailto:example@domain.com).',\n                                        }\n                                    }\n                                } else {\n                                    try {\n                                        const url = new URL(question.link)\n                                        if (url.protocol !== 'https:') {\n                                            return {\n                                                ...questionErrors,\n                                                link: 'Only HTTPS links are supported for security reasons.',\n                                            }\n                                        }\n                                    } catch {\n                                        return {\n                                            ...questionErrors,\n                                            link: 'Please enter a valid HTTPS URL.',\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        if (question.type === SurveyQuestionType.Rating) {\n                            return {\n                                ...questionErrors,\n                                display: !question.display && 'Please choose a display type.',\n                                scale: !question.scale && 'Please choose a scale.',\n                                lowerBoundLabel: !question.lowerBoundLabel && 'Please enter a lower bound label.',\n                                upperBoundLabel: !question.upperBoundLabel && 'Please enter an upper bound label.',\n                            }\n                        } else if (\n                            question.type === SurveyQuestionType.SingleChoice ||\n                            question.type === SurveyQuestionType.MultipleChoice\n                        ) {\n                            return {\n                                ...questionErrors,\n                                choices: question.choices.some((choice) => !choice.trim())\n                                    ? 'Please ensure all choices are non-empty.'\n                                    : undefined,\n                            }\n                        }\n\n                        return questionErrors\n                    }),\n                    // release conditions controlled using a PureField in the form\n                    targeting_flag_filters: values.flagPropertyErrors,\n                    // controlled using a PureField in the form\n                    urlMatchType: values.urlMatchTypeValidationError,\n                    appearance:\n                        sanitizedAppearance &&\n                        validateSurveyAppearance(\n                            sanitizedAppearance,\n                            questions.some((q) => q.type === SurveyQuestionType.Rating),\n                            type\n                        ),\n                }\n            },\n            submit: (surveyPayload) => {\n                if (values.hasCycle) {\n                    actions.reportSurveyCycleDetected(values.survey)\n\n                    return lemonToast.error(\n                        'Your survey contains an endless cycle. Please revisit your branching rules.'\n                    )\n                }\n                const payload = sanitizeSurvey(surveyPayload, { keepEmptyConditions: true })\n\n                // when the survey is being submitted, we should turn off editing mode\n                actions.editingSurvey(false)\n                if (props.id && props.id !== 'new') {\n                    actions.updateSurvey(payload)\n                    actions.addProductIntent({\n                        product_type: ProductKey.SURVEYS,\n                        intent_context: ProductIntentContext.SURVEY_EDITED,\n                        metadata: {\n                            survey_id: values.survey.id,\n                        },\n                    })\n                } else {\n                    actions.createSurvey({ ...payload, _create_in_folder: 'Unfiled/Surveys' })\n                }\n            },\n        },\n    })),\n    urlToAction(({ actions, props, values }) => ({\n        [urls.survey(props.id ?? 'new')]: (_, searchParams, { fromTemplate }, { method }) => {\n            // Parse filters from URL params\n            if (searchParams.propertyFilters) {\n                try {\n                    const parsedPropertyFilters = JSON.parse(searchParams.propertyFilters)\n                    if (Array.isArray(parsedPropertyFilters) && parsedPropertyFilters.length > 0) {\n                        actions.setPropertyFilters(parsedPropertyFilters)\n                    }\n                } catch (e) {\n                    console.error('Failed to parse propertyFilters from URL:', e)\n                }\n            }\n\n            if (searchParams.answerFilters) {\n                try {\n                    const parsedAnswerFilters = JSON.parse(searchParams.answerFilters)\n                    if (Array.isArray(parsedAnswerFilters) && parsedAnswerFilters.length > 0) {\n                        actions.setAnswerFilters(parsedAnswerFilters, false)\n                    }\n                } catch (e) {\n                    console.error('Failed to parse answerFilters from URL:', e)\n                }\n            }\n\n            if (searchParams.date_from || searchParams.date_to) {\n                actions.setDateRange(\n                    {\n                        date_from: searchParams.date_from || null,\n                        date_to: searchParams.date_to || null,\n                    },\n                    false\n                )\n            }\n\n            // We always set the editingSurvey to true when we create a new survey\n            if (props.id === 'new') {\n                actions.editingSurvey(true)\n            }\n            // If the URL was pushed (user clicked on a link), reset the scene's data.\n            // This avoids resetting form fields if you click back/forward.\n            if (method === 'PUSH') {\n                // When pushing to `/new` and the id matches the new survey's id, do not load the survey again\n                if (props.id === 'new' && values.survey.id === NEW_SURVEY.id && !fromTemplate) {\n                    return\n                }\n                if (props.id) {\n                    actions.loadSurvey()\n                } else {\n                    actions.resetSurvey()\n                }\n            }\n\n            if (searchParams.edit) {\n                actions.editingSurvey(true)\n            }\n        },\n    })),\n    actionToUrl(({ values }) => ({\n        setSurveyTemplateValues: () => {\n            const hashParams = router.values.hashParams\n            hashParams['fromTemplate'] = true\n\n            return [urls.survey(values.survey.id), router.values.searchParams, hashParams]\n        },\n        editingSurvey: ({ editing }) => {\n            const searchParams = router.values.searchParams\n            if (editing) {\n                searchParams['edit'] = true\n            } else {\n                delete searchParams['edit']\n            }\n\n            return [router.values.location.pathname, router.values.searchParams, router.values.hashParams]\n        },\n        setPropertyFilters: () => [\n            router.values.location.pathname,\n            values.urlSearchParams,\n            router.values.hashParams,\n            { replace: true },\n        ],\n        setAnswerFilters: () => [\n            router.values.location.pathname,\n            values.urlSearchParams,\n            router.values.hashParams,\n            { replace: true },\n        ],\n        setDateRange: () => [\n            router.values.location.pathname,\n            values.urlSearchParams,\n            router.values.hashParams,\n            { replace: true },\n        ],\n    })),\n    afterMount(({ props, actions }) => {\n        if (props.id !== 'new') {\n            actions.loadSurvey()\n        }\n        if (props.id === 'new') {\n            actions.resetSurvey()\n        }\n    }),\n])\n","import DOMPurify from 'dompurify'\nimport { DeepPartialMap, ValidationErrorType } from 'kea-forms'\nimport posthog from 'posthog-js'\n\nimport { dayjs } from 'lib/dayjs'\nimport { dateStringToDayJs } from 'lib/utils'\nimport { NewSurvey, SURVEY_CREATED_SOURCE } from 'scenes/surveys/constants'\nimport { SurveyRatingResults } from 'scenes/surveys/surveyLogic'\n\nimport {\n    EventPropertyFilter,\n    QuestionProcessedResponses,\n    Survey,\n    SurveyAppearance,\n    SurveyDisplayConditions,\n    SurveyEventName,\n    SurveyEventProperties,\n    SurveyQuestion,\n    SurveyQuestionType,\n    SurveyRates,\n    SurveyStats,\n    SurveyType,\n} from '~/types'\n\nconst sanitizeConfig = { ADD_ATTR: ['target'] }\n\nexport function sanitizeHTML(html: string): string {\n    return DOMPurify.sanitize(html, sanitizeConfig)\n}\n\nexport function sanitizeColor(color: string | undefined): string | undefined {\n    if (!color) {\n        return undefined\n    }\n\n    // test if the color is valid by adding a # to the beginning of the string\n    if (CSS.supports('color', `#${color}`)) {\n        return `#${color}`\n    }\n\n    return color\n}\n\nexport function validateCSSProperty(property: string, value: string | undefined): string | undefined {\n    if (!value) {\n        return undefined\n    }\n    const isValidCSSProperty = CSS.supports(property, value)\n    return !isValidCSSProperty ? `${value} is not a valid property for ${property}.` : undefined\n}\n\nexport function validateSurveyAppearance(\n    appearance: SurveyAppearance,\n    hasRatingQuestions: boolean,\n    surveyType: SurveyType\n): DeepPartialMap<SurveyAppearance, ValidationErrorType> {\n    return {\n        backgroundColor: validateCSSProperty('background-color', appearance.backgroundColor),\n        borderColor: validateCSSProperty('border-color', appearance.borderColor),\n        // Only validate rating button colors if there's a rating question\n        ...(hasRatingQuestions && {\n            ratingButtonActiveColor: validateCSSProperty('background-color', appearance.ratingButtonActiveColor),\n            ratingButtonColor: validateCSSProperty('background-color', appearance.ratingButtonColor),\n        }),\n        submitButtonColor: validateCSSProperty('background-color', appearance.submitButtonColor),\n        submitButtonTextColor: validateCSSProperty('color', appearance.submitButtonTextColor),\n        maxWidth: validateCSSProperty('width', appearance.maxWidth),\n        boxPadding: validateCSSProperty('padding', appearance.boxPadding),\n        boxShadow: validateCSSProperty('box-shadow', appearance.boxShadow),\n        borderRadius: validateCSSProperty('border-radius', appearance.borderRadius),\n        zIndex: validateCSSProperty('z-index', appearance.zIndex),\n        widgetSelector:\n            surveyType === SurveyType.Widget && appearance?.widgetType === 'selector' && !appearance.widgetSelector\n                ? 'Please enter a CSS selector.'\n                : undefined,\n    }\n}\n\nexport function getSurveyResponseKey(questionIndex: number): string {\n    return questionIndex === 0\n        ? SurveyEventProperties.SURVEY_RESPONSE\n        : `${SurveyEventProperties.SURVEY_RESPONSE}_${questionIndex}`\n}\n\nexport function getSurveyIdBasedResponseKey(questionId: string): string {\n    return `${SurveyEventProperties.SURVEY_RESPONSE}_${questionId}`\n}\n\n// Helper function to generate the response field keys with proper typing\nexport const getResponseFieldWithId = (\n    questionIndex: number,\n    questionId?: string\n): { indexBasedKey: string; idBasedKey: string | undefined } => {\n    return {\n        indexBasedKey: getSurveyResponseKey(questionIndex),\n        idBasedKey: questionId ? getSurveyIdBasedResponseKey(questionId) : undefined,\n    }\n}\n\nexport function sanitizeSurveyDisplayConditions(\n    displayConditions?: SurveyDisplayConditions | null,\n    surveyType?: SurveyType\n): SurveyDisplayConditions | null {\n    if (!displayConditions) {\n        return null\n    }\n\n    if (surveyType === SurveyType.ExternalSurvey) {\n        return {\n            actions: {\n                values: [],\n            },\n            events: {\n                values: [],\n            },\n            deviceTypes: undefined,\n            deviceTypesMatchType: undefined,\n            linkedFlagVariant: undefined,\n            seenSurveyWaitPeriodInDays: undefined,\n            url: undefined,\n            urlMatchType: undefined,\n        }\n    }\n\n    const trimmedUrl = displayConditions.url?.trim()\n    const trimmedSelector = displayConditions.selector?.trim()\n    const trimmedLinkedFlagVariant = displayConditions.linkedFlagVariant?.trim()\n\n    const sanitized: SurveyDisplayConditions = {\n        ...displayConditions,\n        ...(trimmedUrl && { url: trimmedUrl }),\n        ...(trimmedSelector && { selector: trimmedSelector }),\n        ...(trimmedLinkedFlagVariant && { linkedFlagVariant: trimmedLinkedFlagVariant }),\n    }\n\n    // Remove the original keys if they were empty after trimming\n    if (!trimmedUrl) {\n        delete sanitized.url\n    }\n    if (!trimmedSelector) {\n        delete sanitized.selector\n    }\n    if (!trimmedLinkedFlagVariant) {\n        delete sanitized.linkedFlagVariant\n    }\n\n    return sanitized\n}\n\nexport function sanitizeSurveyAppearance(\n    appearance?: SurveyAppearance | null,\n    isPartialResponsesEnabled = false,\n    surveyType?: SurveyType\n): SurveyAppearance | null {\n    if (!appearance) {\n        return null\n    }\n\n    return {\n        ...appearance,\n        shuffleQuestions: isPartialResponsesEnabled ? false : appearance.shuffleQuestions,\n        backgroundColor: sanitizeColor(appearance.backgroundColor),\n        borderColor: sanitizeColor(appearance.borderColor),\n        ratingButtonActiveColor: sanitizeColor(appearance.ratingButtonActiveColor),\n        ratingButtonColor: sanitizeColor(appearance.ratingButtonColor),\n        submitButtonColor: sanitizeColor(appearance.submitButtonColor),\n        submitButtonTextColor: sanitizeColor(appearance.submitButtonTextColor),\n        thankYouMessageHeader: sanitizeHTML(appearance.thankYouMessageHeader ?? ''),\n        thankYouMessageDescription: sanitizeHTML(appearance.thankYouMessageDescription ?? ''),\n        surveyPopupDelaySeconds:\n            surveyType === SurveyType.ExternalSurvey ? undefined : appearance.surveyPopupDelaySeconds,\n    }\n}\n\nexport type NPSBreakdown = {\n    total: number\n    promoters: number\n    passives: number\n    detractors: number\n    score: string\n}\n\n// NPS calculation constants\nconst NPS_SCALE_SIZE = 11 // 0-10 scale\nconst NPS_PROMOTER_MIN = 9 // 9-10 are promoters\nconst NPS_PASSIVE_MIN = 7 // 7-8 are passives. 0-6 are detractors but we don't need a variable for that.\n\ninterface NPSRawData {\n    values: number[]\n    total: number\n}\n\n/**\n * Extracts raw NPS data from processed survey data\n */\nfunction extractNPSRawData(processedData: QuestionProcessedResponses): NPSRawData | null {\n    if (\n        !processedData?.data ||\n        processedData.type !== SurveyQuestionType.Rating ||\n        !Array.isArray(processedData.data) ||\n        processedData.data.length !== NPS_SCALE_SIZE\n    ) {\n        return null\n    }\n\n    return {\n        values: processedData.data.map((item) => item.value),\n        total: processedData.totalResponses,\n    }\n}\n\n/**\n * Extracts raw NPS data from legacy survey rating results\n */\nfunction extractNPSRawDataFromLegacy(surveyRatingResults: SurveyRatingResults[number]): NPSRawData | null {\n    if (!surveyRatingResults?.data || surveyRatingResults.data.length !== NPS_SCALE_SIZE) {\n        return null\n    }\n\n    return {\n        values: surveyRatingResults.data,\n        total: surveyRatingResults.total,\n    }\n}\n\n/**\n * Core NPS calculation logic - works with raw data arrays\n */\nfunction calculateNPSFromRawData(rawData: NPSRawData): NPSBreakdown {\n    if (rawData.total === 0) {\n        return { total: 0, promoters: 0, passives: 0, detractors: 0, score: '0.0' }\n    }\n\n    const promoters = rawData.values.slice(NPS_PROMOTER_MIN, NPS_SCALE_SIZE).reduce((acc, curr) => acc + curr, 0)\n    const passives = rawData.values.slice(NPS_PASSIVE_MIN, NPS_PROMOTER_MIN).reduce((acc, curr) => acc + curr, 0)\n    const detractors = rawData.values.slice(0, NPS_PASSIVE_MIN).reduce((acc, curr) => acc + curr, 0)\n\n    const score = ((promoters - detractors) / rawData.total) * 100\n\n    return {\n        total: rawData.total,\n        promoters,\n        passives,\n        detractors,\n        score: score.toFixed(1),\n    }\n}\n\nexport function calculateNpsBreakdownFromProcessedData(processedData: QuestionProcessedResponses): NPSBreakdown | null {\n    const rawData = extractNPSRawData(processedData)\n    return rawData ? calculateNPSFromRawData(rawData) : null\n}\n\nexport function calculateNpsBreakdown(surveyRatingResults: SurveyRatingResults[number]): NPSBreakdown | null {\n    const rawData = extractNPSRawDataFromLegacy(surveyRatingResults)\n    return rawData ? calculateNPSFromRawData(rawData) : null\n}\n\n// Helper to escape special characters in SQL strings\nfunction escapeSqlString(value: string): string {\n    return value.replace(/['\\\\]/g, '\\\\$&')\n}\n\nexport function getSurveyResponse(question: SurveyQuestion, index: number): string {\n    const { indexBasedKey, idBasedKey } = getResponseFieldWithId(index, question.id)\n\n    if (question.type === SurveyQuestionType.MultipleChoice) {\n        return `if(\n        JSONHas(events.properties, '${idBasedKey}') AND length(JSONExtractArrayRaw(events.properties, '${idBasedKey}')) > 0,\n        JSONExtractArrayRaw(events.properties, '${idBasedKey}'),\n        JSONExtractArrayRaw(events.properties, '${indexBasedKey}')\n    )`\n    }\n\n    return `COALESCE(\n        NULLIF(JSONExtractString(events.properties, '${idBasedKey}'), ''),\n        NULLIF(JSONExtractString(events.properties, '${indexBasedKey}'), '')\n    )`\n}\n\n/**\n * Creates a HogQL expression for survey answer filters that handles both index-based and ID-based property keys\n * using OR logic between the alternative formats for each question.\n *\n * @param filters - The answer filters to convert to HogQL expressions\n * @param survey - The survey object (needed to access question IDs)\n * @returns A HogQL expression string that can be used in queries. If there are no filters, it returns an empty string.\n *\n * TODO: Consider leveraging the backend query builder instead of duplicating this logic in the frontend.\n * ClickHouse has powerful functions like match(), multiIf(), etc. that could be used more effectively.\n */\nexport function createAnswerFilterHogQLExpression(filters: EventPropertyFilter[], survey: Survey): string {\n    if (!filters || !filters.length) {\n        return ''\n    }\n\n    // Build the filter expression as a string\n    let filterExpression = ''\n    let hasValidFilter = false\n\n    // Process each filter\n    for (const filter of filters) {\n        // Skip filters with empty or undefined values\n        if (filter.value === undefined || filter.value === null || filter.value === '') {\n            continue\n        }\n\n        // Skip empty arrays\n        if (Array.isArray(filter.value) && filter.value.length === 0) {\n            continue\n        }\n\n        // Skip ILIKE filters with empty search patterns\n        if (\n            filter.operator === 'icontains' &&\n            (filter.value === '%' ||\n                filter.value === '%%' ||\n                (typeof filter.value === 'string' && filter.value.trim() === ''))\n        ) {\n            continue\n        }\n\n        // split the string '$survey_response_' and take the last part, as that's the question id\n        const questionId = filter.key.split(`${SurveyEventProperties.SURVEY_RESPONSE}_`).at(-1)\n        const question = survey.questions.find((question) => question.id === questionId)\n        if (!questionId || !question) {\n            continue\n        }\n\n        const questionIndex = survey.questions.findIndex((question) => question.id === questionId)\n\n        // Create the condition for this filter\n        let condition = ''\n        const escapedValue = escapeSqlString(String(filter.value))\n\n        // Handle different operators\n        switch (filter.operator) {\n            case 'exact':\n            case 'is_not':\n                if (Array.isArray(filter.value)) {\n                    const valueList = filter.value.map((v) => `'${escapeSqlString(String(v))}'`).join(', ')\n                    condition = `(${getSurveyResponse(question, questionIndex)} ${\n                        filter.operator === 'is_not' ? 'NOT IN' : 'IN'\n                    } (${valueList}))`\n                } else {\n                    condition = `(${getSurveyResponse(question, questionIndex)} ${\n                        filter.operator === 'is_not' ? '!=' : '='\n                    } '${escapedValue}')`\n                }\n                break\n            case 'icontains':\n                if (question.type !== SurveyQuestionType.MultipleChoice) {\n                    condition = `(${getSurveyResponse(question, questionIndex)} ILIKE '%${escapedValue}%')`\n                } else {\n                    condition = `(arrayExists(x -> x ilike '%${escapedValue}%', ${getSurveyResponse(question, questionIndex)}))`\n                }\n                break\n            case 'not_icontains':\n                if (question.type !== SurveyQuestionType.MultipleChoice) {\n                    condition = `(NOT ${getSurveyResponse(question, questionIndex)} ILIKE '%${escapedValue}%')`\n                } else {\n                    condition = `(NOT arrayExists(x -> x ilike '%${escapedValue}%', ${getSurveyResponse(question, questionIndex)}))`\n                }\n                break\n            case 'regex':\n                if (question.type !== SurveyQuestionType.MultipleChoice) {\n                    condition = `(match(${getSurveyResponse(question, questionIndex)}, '${escapedValue}'))`\n                } else {\n                    condition = `(arrayExists(x -> match(x, '${escapedValue}'), ${getSurveyResponse(question, questionIndex)}))`\n                }\n                break\n            case 'not_regex':\n                if (question.type !== SurveyQuestionType.MultipleChoice) {\n                    condition = `(NOT match(${getSurveyResponse(question, questionIndex)}, '${escapedValue}'))`\n                } else {\n                    condition = `(NOT arrayExists(x -> match(x, '${escapedValue}'), ${getSurveyResponse(question, questionIndex)}))`\n                }\n                break\n            // Add more operators as needed\n            default:\n                continue // Skip unsupported operators\n        }\n\n        // Add this condition to the overall expression\n        if (condition) {\n            if (hasValidFilter) {\n                filterExpression += ' AND '\n            }\n            filterExpression += condition\n            hasValidFilter = true\n        }\n    }\n\n    return hasValidFilter ? `AND ${filterExpression}` : ''\n}\n\nexport function isSurveyRunning(survey: Survey): boolean {\n    return !!(survey.start_date && !survey.end_date)\n}\n\nexport function doesSurveyHaveDisplayConditions(survey: Survey | NewSurvey): boolean {\n    const conditions = sanitizeSurveyDisplayConditions(survey.conditions)\n    if (!conditions) {\n        return false\n    }\n\n    // check string fields\n    if (conditions.url) {\n        return true\n    }\n\n    if (conditions.selector) {\n        return true\n    }\n\n    if (conditions.linkedFlagVariant) {\n        return true\n    }\n\n    // check numeric fields\n    if (conditions.seenSurveyWaitPeriodInDays !== undefined && conditions.seenSurveyWaitPeriodInDays !== null) {\n        return true\n    }\n\n    // check array fields\n    if (conditions.deviceTypes && conditions.deviceTypes.length > 0) {\n        return true\n    }\n\n    // check enum fields\n    if (conditions.urlMatchType !== undefined && conditions.urlMatchType !== null) {\n        return true\n    }\n\n    if (conditions.deviceTypesMatchType !== undefined && conditions.deviceTypesMatchType !== null) {\n        return true\n    }\n\n    // check complex object fields\n    if (conditions.actions && conditions.actions.values && conditions.actions.values.length > 0) {\n        return true\n    }\n\n    if (conditions.events && conditions.events.values && conditions.events.values.length > 0) {\n        return true\n    }\n\n    if (conditions.events?.repeatedActivation !== undefined && conditions.events.repeatedActivation !== null) {\n        return true\n    }\n\n    return false\n}\n\nexport function buildPartialResponsesFilter(survey: Survey): string {\n    if (!survey.enable_partial_responses) {\n        return `AND (\n        NOT JSONHas(properties, '${SurveyEventProperties.SURVEY_COMPLETED}')\n        OR JSONExtractBool(properties, '${SurveyEventProperties.SURVEY_COMPLETED}') = true\n    )`\n    }\n\n    return `AND uuid in (\n        SELECT\n            argMax(uuid, timestamp)\n        FROM events\n        WHERE and(\n            equals(event, '${SurveyEventName.SENT}'),\n            equals(JSONExtractString(properties, '${SurveyEventProperties.SURVEY_ID}'), '${survey.id}'),\n            greaterOrEquals(timestamp, '${getSurveyStartDateForQuery(survey)}'),\n            lessOrEquals(timestamp, '${getSurveyEndDateForQuery(survey)}')\n        )\n        GROUP BY\n            if(\n                JSONHas(properties, '${SurveyEventProperties.SURVEY_SUBMISSION_ID}'),\n                JSONExtractString(properties, '${SurveyEventProperties.SURVEY_SUBMISSION_ID}'),\n                toString(uuid)\n            )\n    ) --- Filter to ensure we only get one response per ${SurveyEventProperties.SURVEY_SUBMISSION_ID}`\n}\n\ninterface SanitizeSurveyOptions {\n    keepEmptyConditions?: boolean\n}\n\nexport function sanitizeSurvey(survey: Partial<Survey>, options?: SanitizeSurveyOptions): Partial<Survey> {\n    const sanitizedQuestions =\n        survey.questions?.map((question) => ({\n            ...question,\n            question: sanitizeHTML(question.question ?? ''),\n            description: sanitizeHTML(question.description ?? ''),\n        })) || []\n\n    const sanitizedAppearance = sanitizeSurveyAppearance(\n        survey.appearance,\n        survey.enable_partial_responses ?? false,\n        survey.type\n    )\n\n    // Remove widget-specific fields if survey type is not Widget\n    if (survey.type !== SurveyType.Widget && sanitizedAppearance) {\n        delete sanitizedAppearance.widgetType\n        delete sanitizedAppearance.widgetLabel\n        delete sanitizedAppearance.widgetColor\n    }\n\n    const conditions = sanitizeSurveyDisplayConditions(survey.conditions, survey.type)\n    const sanitized: Partial<Survey> = {\n        ...survey,\n        conditions: conditions,\n        questions: sanitizedQuestions,\n        appearance: sanitizedAppearance,\n    }\n\n    if (survey.type === SurveyType.ExternalSurvey) {\n        sanitized.remove_targeting_flag = true\n        sanitized.linked_flag_id = null\n        sanitized.targeting_flag_filters = undefined\n    }\n\n    if (options?.keepEmptyConditions !== true && (!conditions || Object.keys(conditions).length === 0)) {\n        delete sanitized.conditions\n    }\n    if (!sanitizedAppearance || Object.keys(sanitizedAppearance).length === 0) {\n        delete sanitized.appearance\n    }\n\n    return sanitized\n}\n\nexport function calculateSurveyRates(stats: SurveyStats | null): SurveyRates {\n    const defaultRates: SurveyRates = {\n        response_rate: 0.0,\n        dismissal_rate: 0.0,\n        unique_users_response_rate: 0.0,\n        unique_users_dismissal_rate: 0.0,\n    }\n\n    if (!stats) {\n        return defaultRates\n    }\n\n    const shownCount = stats[SurveyEventName.SHOWN].total_count\n    if (shownCount > 0) {\n        const sentCount = stats[SurveyEventName.SENT].total_count\n        const dismissedCount = stats[SurveyEventName.DISMISSED].total_count\n        const uniqueUsersShownCount = stats[SurveyEventName.SHOWN].unique_persons\n        const uniqueUsersSentCount = stats[SurveyEventName.SENT].unique_persons\n        const uniqueUsersDismissedCount = stats[SurveyEventName.DISMISSED].unique_persons\n\n        return {\n            response_rate: parseFloat(((sentCount / shownCount) * 100).toFixed(2)),\n            dismissal_rate: parseFloat(((dismissedCount / shownCount) * 100).toFixed(2)),\n            unique_users_response_rate: parseFloat(((uniqueUsersSentCount / uniqueUsersShownCount) * 100).toFixed(2)),\n            unique_users_dismissal_rate: parseFloat(\n                ((uniqueUsersDismissedCount / uniqueUsersShownCount) * 100).toFixed(2)\n            ),\n        }\n    }\n    return defaultRates\n}\n\nexport function captureMaxAISurveyCreationException(error?: string, source?: SURVEY_CREATED_SOURCE): void {\n    posthog.captureException(error || 'Undefined error when creating MaxAI survey', {\n        action: 'max-ai-survey-creation-failed',\n        source: source,\n    })\n}\n\nexport const DATE_FORMAT = 'YYYY-MM-DDTHH:mm:ss'\n\nexport function getSurveyStartDateForQuery(survey: Pick<Survey, 'created_at'>): string {\n    return dayjs.utc(survey.created_at).startOf('day').format(DATE_FORMAT)\n}\n\nexport function getSurveyEndDateForQuery(survey: Pick<Survey, 'end_date'>): string {\n    return survey.end_date\n        ? dayjs.utc(survey.end_date).endOf('day').format(DATE_FORMAT)\n        : dayjs.utc().endOf('day').format(DATE_FORMAT)\n}\n\nexport interface SurveyDateRange {\n    date_from: string | null\n    date_to: string | null\n}\n\nexport function buildSurveyTimestampFilter(\n    survey: Pick<Survey, 'created_at' | 'end_date'>,\n    dateRange?: SurveyDateRange | null\n): string {\n    // If no date range provided, use the survey's default date range\n    let fromDate = getSurveyStartDateForQuery(survey)\n    let toDate = getSurveyEndDateForQuery(survey)\n\n    if (!dateRange) {\n        return `AND timestamp >= '${fromDate}'\n        AND timestamp <= '${toDate}'`\n    }\n\n    // ----- Handle FROM date -----\n    if (dateRange.date_from) {\n        // Parse user-provided date and ensure it's not before survey creation\n        const userFromDate = dateStringToDayJs(dateRange.date_from)?.startOf('day')\n\n        if (userFromDate && userFromDate.isAfter(fromDate)) {\n            fromDate = userFromDate.format(DATE_FORMAT)\n        }\n    }\n\n    // ----- Handle TO date -----\n    if (dateRange.date_to) {\n        const userToDate = dateStringToDayJs(dateRange.date_to)?.endOf('day')\n\n        if (userToDate && userToDate.isBefore(toDate)) {\n            toDate = userToDate.format(DATE_FORMAT)\n        }\n    }\n\n    return `AND timestamp >= '${fromDate}'\n    AND timestamp <= '${toDate}'`\n}\n","import { BreakPointFunction, actions, afterMount, connect, kea, listeners, path, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { router } from 'kea-router'\nimport { windowValues } from 'kea-window-values'\nimport posthog from 'posthog-js'\n\nimport { IconGear } from '@posthog/icons'\nimport { LemonTag } from '@posthog/lemon-ui'\nimport { errorTrackingQuery } from '@posthog/products-error-tracking/frontend/queries'\n\nimport api from 'lib/api'\nimport { AuthorizedUrlListType, authorizedUrlListLogic } from 'lib/components/AuthorizedUrlList/authorizedUrlListLogic'\nimport { FEATURE_FLAGS, RETENTION_FIRST_OCCURRENCE_MATCHING_FILTERS } from 'lib/constants'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'\nimport { Link } from 'lib/lemon-ui/Link/Link'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { tabAwareActionToUrl } from 'lib/logic/scenes/tabAwareActionToUrl'\nimport { tabAwareUrlToAction } from 'lib/logic/scenes/tabAwareUrlToAction'\nimport {\n    UnexpectedNeverError,\n    getDefaultInterval,\n    isNotNil,\n    isValidRelativeOrAbsoluteDate,\n    objectsEqual,\n    updateDatesWithInterval,\n} from 'lib/utils'\nimport { isDefinitionStale } from 'lib/utils/definitions'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { Scene } from 'scenes/sceneTypes'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { WEB_VITALS_COLORS, WEB_VITALS_THRESHOLDS } from '~/queries/nodes/WebVitals/definitions'\nimport { hogqlQuery } from '~/queries/query'\nimport { isCompareFilter, isWebAnalyticsPropertyFilters } from '~/queries/schema-guards'\nimport {\n    ActionConversionGoal,\n    ActionsNode,\n    AnyEntityNode,\n    CompareFilter,\n    CustomEventConversionGoal,\n    DataTableNode,\n    EventsNode,\n    InsightVizNode,\n    NodeKind,\n    TrendsFilter,\n    TrendsQuery,\n    WebAnalyticsConversionGoal,\n    WebAnalyticsOrderBy,\n    WebAnalyticsOrderByDirection,\n    WebAnalyticsOrderByFields,\n    WebAnalyticsPropertyFilter,\n    WebAnalyticsPropertyFilters,\n    WebStatsBreakdown,\n    WebStatsTableQuery,\n    WebVitalsMetric,\n} from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\nimport {\n    AvailableFeature,\n    BaseMathType,\n    Breadcrumb,\n    ChartDisplayType,\n    EventDefinitionType,\n    FilterLogicalOperator,\n    InsightLogicProps,\n    InsightType,\n    IntervalType,\n    PropertyFilterBaseValue,\n    PropertyFilterType,\n    PropertyMathType,\n    PropertyOperator,\n    RecordingUniversalFilters,\n    RetentionPeriod,\n    TeamPublicType,\n    TeamType,\n    UniversalFiltersGroupValue,\n} from '~/types'\n\nimport {\n    ActiveHoursTab,\n    ConversionGoalWarning,\n    DeviceTab,\n    DeviceType,\n    GEOIP_TEMPLATE_IDS,\n    GeographyTab,\n    GraphsTab,\n    INITIAL_DATE_FROM,\n    INITIAL_DATE_TO,\n    INITIAL_INTERVAL,\n    INITIAL_WEB_ANALYTICS_FILTER,\n    PathTab,\n    ProductTab,\n    SourceTab,\n    TILES_ALLOWED_ON_PRE_AGGREGATED,\n    TabsTileTab,\n    TileId,\n    TileVisualizationOption,\n    WEB_ANALYTICS_DATA_COLLECTION_NODE_ID,\n    WEB_ANALYTICS_DEFAULT_QUERY_TAGS,\n    WebAnalyticsStatusCheck,\n    WebAnalyticsTile,\n    WebVitalsPercentile,\n    eventPropertiesToPathClean,\n    getWebAnalyticsBreakdownFilter,\n    loadPriorityMap,\n    personPropertiesToPathClean,\n    sessionPropertiesToPathClean,\n} from './common'\nimport { getDashboardItemId, getNewInsightUrlFactory } from './insightsUtils'\nimport { marketingAnalyticsTilesLogic } from './tabs/marketing-analytics/frontend/logic/marketingAnalyticsTilesLogic'\nimport type { webAnalyticsLogicType } from './webAnalyticsLogicType'\n\nconst teamId = window.POSTHOG_APP_CONTEXT?.current_team?.id\nconst persistConfig = { persist: true, prefix: `${teamId}__` }\nexport const webAnalyticsLogic = kea<webAnalyticsLogicType>([\n    path(['scenes', 'webAnalytics', 'webAnalyticsSceneLogic']),\n    connect(() => ({\n        values: [\n            featureFlagLogic,\n            ['featureFlags'],\n            teamLogic,\n            ['currentTeam', 'baseCurrency'],\n            userLogic,\n            ['hasAvailableFeature'],\n            preflightLogic,\n            ['isDev'],\n            authorizedUrlListLogic({ type: AuthorizedUrlListType.WEB_ANALYTICS, actionId: null, experimentId: null }),\n            ['authorizedUrls'],\n            marketingAnalyticsTilesLogic,\n            ['tiles as marketingTiles'],\n        ],\n    })),\n    actions({\n        setWebAnalyticsFilters: (webAnalyticsFilters: WebAnalyticsPropertyFilters) => ({ webAnalyticsFilters }),\n        togglePropertyFilter: (\n            type: PropertyFilterType.Event | PropertyFilterType.Person | PropertyFilterType.Session,\n            key: string,\n            value: string | number | null,\n            tabChange?: {\n                graphsTab?: string\n                sourceTab?: string\n                deviceTab?: string\n                pathTab?: string\n                geographyTab?: string\n                activeHoursTab?: string\n            }\n        ) => ({ type, key, value, tabChange }),\n        setGraphsTab: (tab: string) => ({ tab }),\n        setSourceTab: (tab: string) => ({ tab }),\n        setDeviceTab: (tab: string) => ({ tab }),\n        setPathTab: (tab: string) => ({ tab }),\n        setGeographyTab: (tab: string) => ({ tab }),\n        setActiveHoursTab: (tab: string) => ({ tab }),\n        setDomainFilter: (domain: string | null) => ({ domain }),\n        setDeviceTypeFilter: (deviceType: DeviceType | null) => ({ deviceType }),\n        clearTablesOrderBy: () => true,\n        setTablesOrderBy: (orderBy: WebAnalyticsOrderByFields, direction: WebAnalyticsOrderByDirection) => ({\n            orderBy,\n            direction,\n        }),\n        setDates: (dateFrom: string | null, dateTo: string | null) => ({ dateFrom, dateTo }),\n        setInterval: (interval: IntervalType) => ({ interval }),\n        setDatesAndInterval: (dateFrom: string | null, dateTo: string | null, interval: IntervalType) => ({\n            dateFrom,\n            dateTo,\n            interval,\n        }),\n        setIsPathCleaningEnabled: (isPathCleaningEnabled: boolean) => ({ isPathCleaningEnabled }),\n        setShouldFilterTestAccounts: (shouldFilterTestAccounts: boolean) => ({ shouldFilterTestAccounts }),\n        setShouldStripQueryParams: (shouldStripQueryParams: boolean) => ({ shouldStripQueryParams }),\n        setConversionGoal: (conversionGoal: WebAnalyticsConversionGoal | null) => ({ conversionGoal }),\n        openAsNewInsight: (tileId: TileId, tabId?: string) => ({ tileId, tabId }),\n        setConversionGoalWarning: (warning: ConversionGoalWarning | null) => ({ warning }),\n        setCompareFilter: (compareFilter: CompareFilter) => ({ compareFilter }),\n        setProductTab: (tab: ProductTab) => ({ tab }),\n        setWebVitalsPercentile: (percentile: WebVitalsPercentile) => ({ percentile }),\n        setWebVitalsTab: (tab: WebVitalsMetric) => ({ tab }),\n        setTileVisualization: (tileId: TileId, visualization: TileVisualizationOption) => ({ tileId, visualization }),\n        setTileVisibility: (tileId: TileId, visible: boolean) => ({ tileId, visible }),\n        resetTileVisibility: () => true,\n    }),\n    loaders(({ values }) => ({\n        // load the status check query here and pass the response into the component, so the response\n        // is accessible in this logic\n        statusCheck: {\n            __default: null as WebAnalyticsStatusCheck | null,\n            loadStatusCheck: async (): Promise<WebAnalyticsStatusCheck> => {\n                const [webVitalsResult, pageviewResult, pageleaveResult, pageleaveScroll] = await Promise.allSettled([\n                    api.eventDefinitions.list({\n                        event_type: EventDefinitionType.Event,\n                        search: '$web_vitals',\n                    }),\n                    api.eventDefinitions.list({\n                        event_type: EventDefinitionType.Event,\n                        search: '$pageview',\n                    }),\n                    api.eventDefinitions.list({\n                        event_type: EventDefinitionType.Event,\n                        search: '$pageleave',\n                    }),\n                    api.propertyDefinitions.list({\n                        event_names: ['$pageleave'],\n                        properties: ['$prev_pageview_max_content_percentage'],\n                    }),\n                ])\n\n                // no need to worry about pagination here, event names beginning with $ are reserved, and we're not\n                // going to add enough reserved event names that match this search term to cause problems\n                const webVitalsEntry =\n                    webVitalsResult.status === 'fulfilled'\n                        ? webVitalsResult.value.results.find((r) => r.name === '$web_vitals')\n                        : undefined\n\n                const pageviewEntry =\n                    pageviewResult.status === 'fulfilled'\n                        ? pageviewResult.value.results.find((r) => r.name === '$pageview')\n                        : undefined\n\n                const pageleaveEntry =\n                    pageleaveResult.status === 'fulfilled'\n                        ? pageleaveResult.value.results.find((r) => r.name === '$pageleave')\n                        : undefined\n\n                const pageleaveScrollEntry =\n                    pageleaveScroll.status === 'fulfilled'\n                        ? pageleaveScroll.value.results.find((r) => r.name === '$prev_pageview_max_content_percentage')\n                        : undefined\n\n                const isSendingWebVitals = !!webVitalsEntry && !isDefinitionStale(webVitalsEntry)\n                const isSendingPageViews = !!pageviewEntry && !isDefinitionStale(pageviewEntry)\n                const isSendingPageLeaves = !!pageleaveEntry && !isDefinitionStale(pageleaveEntry)\n                const isSendingPageLeavesScroll = !!pageleaveScrollEntry && !isDefinitionStale(pageleaveScrollEntry)\n\n                return {\n                    isSendingWebVitals,\n                    isSendingPageViews,\n                    isSendingPageLeaves,\n                    isSendingPageLeavesScroll,\n                    hasAuthorizedUrls: !!values.currentTeam?.app_urls && values.currentTeam.app_urls.length > 0,\n                }\n            },\n        },\n        shouldShowGeoIPQueries: {\n            _default: null as boolean | null,\n            loadShouldShowGeoIPQueries: async (): Promise<boolean> => {\n                // Always display on dev mode, we don't always have events and/or hogQL functions\n                // but we want the map to be there for debugging purposes\n                if (values.isDev) {\n                    return true\n                }\n\n                const [propertiesResponse, hogFunctionsResponse] = await Promise.allSettled([\n                    api.propertyDefinitions.list({\n                        event_names: ['$pageview'],\n                        properties: ['$geoip_country_code'],\n                    }),\n                    api.hogFunctions.list({ types: ['transformation'] }),\n                ])\n\n                const hasNonStaleCountryCodeDefinition =\n                    propertiesResponse.status === 'fulfilled' &&\n                    propertiesResponse.value.results.some(\n                        (property) => property.name === '$geoip_country_code' && !isDefinitionStale(property)\n                    )\n\n                if (!hasNonStaleCountryCodeDefinition) {\n                    return false\n                }\n\n                if (hogFunctionsResponse.status !== 'fulfilled') {\n                    return false\n                }\n\n                const enabledGeoIPHogFunction = hogFunctionsResponse.value.results.find((hogFunction) => {\n                    const isFromTemplate = GEOIP_TEMPLATE_IDS.includes(hogFunction.template?.id ?? '')\n                    const matchesName = hogFunction.name === 'GeoIP' // Failsafe in case someone implements their custom GeoIP function\n\n                    return (isFromTemplate || matchesName) && hogFunction.enabled\n                })\n\n                return Boolean(enabledGeoIPHogFunction)\n            },\n        },\n    })),\n    reducers({\n        rawWebAnalyticsFilters: [\n            INITIAL_WEB_ANALYTICS_FILTER,\n            persistConfig,\n            {\n                setWebAnalyticsFilters: (_, { webAnalyticsFilters }) => webAnalyticsFilters,\n                togglePropertyFilter: (oldPropertyFilters, { key, value, type }): WebAnalyticsPropertyFilters => {\n                    if (value === null) {\n                        // if there's already an isNotSet filter, remove it\n                        const isNotSetFilterExists = oldPropertyFilters.some(\n                            (f) => f.type === type || f.key === key || f.operator === PropertyOperator.IsNotSet\n                        )\n                        if (isNotSetFilterExists) {\n                            return oldPropertyFilters.filter(\n                                (f) => f.type !== type || f.key !== key || f.operator !== PropertyOperator.IsNotSet\n                            )\n                        }\n                        return [\n                            ...oldPropertyFilters,\n                            {\n                                type,\n                                key,\n                                operator: PropertyOperator.IsNotSet,\n                            },\n                        ]\n                    }\n\n                    const similarFilterExists = oldPropertyFilters.some(\n                        (f) => f.type === type && f.key === key && f.operator === PropertyOperator.Exact\n                    )\n\n                    if (similarFilterExists) {\n                        // if there's already a matching property, turn it off or merge them\n                        return oldPropertyFilters\n                            .map((f: WebAnalyticsPropertyFilter) => {\n                                if (\n                                    f.key !== key ||\n                                    f.type !== type ||\n                                    ![PropertyOperator.Exact, PropertyOperator.IsNotSet].includes(f.operator)\n                                ) {\n                                    return f\n                                }\n                                const oldValue = (Array.isArray(f.value) ? f.value : [f.value]).filter(isNotNil)\n                                let newValue: PropertyFilterBaseValue[]\n                                if (oldValue.includes(value)) {\n                                    // If there are multiple values for this filter, reduce that to just the one being clicked\n                                    if (oldValue.length > 1) {\n                                        newValue = [value]\n                                    } else {\n                                        return null\n                                    }\n                                } else {\n                                    newValue = [...oldValue, value]\n                                }\n                                return {\n                                    type: PropertyFilterType.Event,\n                                    key,\n                                    operator: PropertyOperator.Exact,\n                                    value: newValue,\n                                } as const\n                            })\n                            .filter(isNotNil)\n                    }\n\n                    // no matching property, so add one\n                    const newFilter: WebAnalyticsPropertyFilter = {\n                        type,\n                        key,\n                        value,\n                        operator: PropertyOperator.Exact,\n                    }\n\n                    return [...oldPropertyFilters, newFilter]\n                },\n                setDomainFilter: (state) => {\n                    // the domain and host filters don't interact well, so remove the host filter when the domain filter is set\n                    return state.filter((filter) => filter.key !== '$host')\n                },\n            },\n        ],\n        domainFilter: [\n            null as string | null,\n            persistConfig,\n            {\n                setDomainFilter: (_: string | null, payload: { domain: string | null }) => {\n                    const { domain } = payload\n                    return domain\n                },\n                togglePropertyFilter: (state, { key }) => {\n                    // the domain and host filters don't interact well, so remove the domain filter when the host filter is set\n                    return key === '$host' ? null : state\n                },\n                setWebAnalyticsFilters: (state, { webAnalyticsFilters }) => {\n                    // the domain and host filters don't interact well, so remove the domain filter when the host filter is set\n                    if (webAnalyticsFilters.some((f) => f.key === '$host')) {\n                        return null\n                    }\n                    return state\n                },\n            },\n        ],\n        deviceTypeFilter: [\n            null as DeviceType | null,\n            persistConfig,\n            {\n                setDeviceTypeFilter: (_: DeviceType | null, payload: unknown) => {\n                    const { deviceType } = payload as { deviceType: DeviceType | null }\n                    return deviceType\n                },\n            },\n        ],\n        _graphsTab: [\n            null as string | null,\n            persistConfig,\n            {\n                setGraphsTab: (_, { tab }) => tab,\n                togglePropertyFilter: (oldTab, { tabChange }) => tabChange?.graphsTab || oldTab,\n                setConversionGoal: (oldTab, { conversionGoal }) => {\n                    if (conversionGoal) {\n                        return GraphsTab.UNIQUE_CONVERSIONS\n                    }\n                    return oldTab\n                },\n            },\n        ],\n        _sourceTab: [\n            null as string | null,\n            persistConfig,\n            {\n                setSourceTab: (_, { tab }) => tab,\n                togglePropertyFilter: (oldTab, { tabChange }) => tabChange?.sourceTab || oldTab,\n            },\n        ],\n        _deviceTab: [\n            null as string | null,\n            persistConfig,\n            {\n                setDeviceTab: (_, { tab }) => tab,\n                togglePropertyFilter: (oldTab, { tabChange }) => tabChange?.deviceTab || oldTab,\n            },\n        ],\n        _pathTab: [\n            null as string | null,\n            persistConfig,\n            {\n                setPathTab: (_, { tab }) => tab,\n                togglePropertyFilter: (oldTab, { tabChange }) => tabChange?.pathTab || oldTab,\n            },\n        ],\n        _geographyTab: [\n            null as string | null,\n            persistConfig,\n            {\n                setGeographyTab: (_, { tab }) => tab,\n                togglePropertyFilter: (oldTab, { tabChange }) => tabChange?.geographyTab || oldTab,\n            },\n        ],\n        _activeHoursTab: [\n            null as string | null,\n            persistConfig,\n            {\n                setActiveHoursTab: (_, { tab }) => tab,\n            },\n        ],\n        _isPathCleaningEnabled: [\n            true as boolean,\n            persistConfig,\n            {\n                setIsPathCleaningEnabled: (_, { isPathCleaningEnabled }) => isPathCleaningEnabled,\n            },\n        ],\n        tablesOrderBy: [\n            null as WebAnalyticsOrderBy | null,\n            persistConfig,\n            {\n                setTablesOrderBy: (_, { orderBy, direction }) => [orderBy, direction],\n                clearTablesOrderBy: () => null,\n\n                // Reset the order by when the conversion goal changes because most of the columns are different\n                setConversionGoal: () => null,\n            },\n        ],\n        dateFilter: [\n            {\n                dateFrom: INITIAL_DATE_FROM,\n                dateTo: INITIAL_DATE_TO,\n                interval: INITIAL_INTERVAL,\n            },\n            persistConfig,\n            {\n                setDates: (_, { dateTo, dateFrom }) => {\n                    if (dateTo && !isValidRelativeOrAbsoluteDate(dateTo)) {\n                        dateTo = INITIAL_DATE_TO\n                    }\n                    if (dateFrom && !isValidRelativeOrAbsoluteDate(dateFrom)) {\n                        dateFrom = INITIAL_DATE_FROM\n                    }\n                    return {\n                        dateTo,\n                        dateFrom,\n                        interval: getDefaultInterval(dateFrom, dateTo),\n                    }\n                },\n                setInterval: ({ dateFrom: oldDateFrom, dateTo: oldDateTo }, { interval }) => {\n                    const { dateFrom, dateTo } = updateDatesWithInterval(interval, oldDateFrom, oldDateTo)\n                    return {\n                        dateTo,\n                        dateFrom,\n                        interval,\n                    }\n                },\n                setDatesAndInterval: (_, { dateTo, dateFrom, interval }) => {\n                    if (!dateFrom && !dateTo) {\n                        dateFrom = INITIAL_DATE_FROM\n                        dateTo = INITIAL_DATE_TO\n                    }\n                    if (dateTo && !isValidRelativeOrAbsoluteDate(dateTo)) {\n                        dateTo = INITIAL_DATE_TO\n                    }\n                    if (dateFrom && !isValidRelativeOrAbsoluteDate(dateFrom)) {\n                        dateFrom = INITIAL_DATE_FROM\n                    }\n                    return {\n                        dateTo,\n                        dateFrom,\n                        interval: interval || getDefaultInterval(dateFrom, dateTo),\n                    }\n                },\n            },\n        ],\n        shouldFilterTestAccounts: [\n            false as boolean,\n            persistConfig,\n            {\n                setShouldFilterTestAccounts: (_, { shouldFilterTestAccounts }) => shouldFilterTestAccounts,\n            },\n        ],\n        shouldStripQueryParams: [\n            false as boolean,\n            persistConfig,\n            {\n                setShouldStripQueryParams: (_, { shouldStripQueryParams }) => shouldStripQueryParams,\n            },\n        ],\n        conversionGoal: [\n            null as WebAnalyticsConversionGoal | null,\n            persistConfig,\n            {\n                setConversionGoal: (_, { conversionGoal }) => conversionGoal,\n            },\n        ],\n        conversionGoalWarning: [\n            null as ConversionGoalWarning | null,\n            {\n                setConversionGoalWarning: (_, { warning }) => warning,\n            },\n        ],\n        compareFilter: [\n            { compare: true } as CompareFilter,\n            persistConfig,\n            {\n                setCompareFilter: (_, { compareFilter }) => compareFilter,\n            },\n        ],\n        productTab: [\n            ProductTab.ANALYTICS as ProductTab,\n            {\n                setProductTab: (_, { tab }) => tab,\n            },\n        ],\n        webVitalsPercentile: [\n            PropertyMathType.P90 as WebVitalsPercentile,\n            persistConfig,\n            {\n                setWebVitalsPercentile: (_, { percentile }) => percentile,\n            },\n        ],\n        webVitalsTab: [\n            'INP' as WebVitalsMetric,\n            {\n                setWebVitalsTab: (_, { tab }) => tab,\n            },\n        ],\n        tileVisualizations: [\n            {} as Record<TileId, TileVisualizationOption>,\n            {\n                setTileVisualization: (state, { tileId, visualization }) => ({\n                    ...state,\n                    [tileId]: visualization,\n                }),\n            },\n        ],\n        hiddenTiles: [\n            [] as TileId[],\n            persistConfig,\n            {\n                setTileVisibility: (state, { tileId, visible }) => {\n                    if (visible) {\n                        return state.filter((id) => id !== tileId)\n                    }\n                    return state.includes(tileId) ? state : [...state, tileId]\n                },\n                resetTileVisibility: () => [],\n            },\n        ],\n    }),\n    windowValues({\n        isGreaterThanMd: (window: Window) => window.innerWidth > 768,\n    }),\n    selectors({\n        preAggregatedEnabled: [\n            (s) => [s.featureFlags, s.currentTeam],\n            (featureFlags: Record<string, boolean>, currentTeam: TeamPublicType | TeamType | null) => {\n                return (\n                    featureFlags[FEATURE_FLAGS.SETTINGS_WEB_ANALYTICS_PRE_AGGREGATED_TABLES] &&\n                    currentTeam?.modifiers?.useWebAnalyticsPreAggregatedTables\n                )\n            },\n        ],\n        breadcrumbs: [\n            () => [],\n            (): Breadcrumb[] => {\n                return [\n                    {\n                        key: Scene.WebAnalytics,\n                        name: `Web analytics`,\n                        path: urls.webAnalytics(),\n                        iconType: 'web_analytics',\n                    },\n                ]\n            },\n        ],\n        graphsTab: [(s) => [s._graphsTab], (graphsTab: string | null) => graphsTab || GraphsTab.UNIQUE_USERS],\n        sourceTab: [(s) => [s._sourceTab], (sourceTab: string | null) => sourceTab || SourceTab.CHANNEL],\n        deviceTab: [(s) => [s._deviceTab], (deviceTab: string | null) => deviceTab || DeviceTab.DEVICE_TYPE],\n        pathTab: [(s) => [s._pathTab], (pathTab: string | null) => pathTab || PathTab.PATH],\n        geographyTab: [(s) => [s._geographyTab], (geographyTab: string | null) => geographyTab || GeographyTab.MAP],\n        activeHoursTab: [\n            (s) => [s._activeHoursTab],\n            (activeHoursTab: string | null) => activeHoursTab || ActiveHoursTab.UNIQUE,\n        ],\n        isPathCleaningEnabled: [\n            (s) => [s._isPathCleaningEnabled, s.hasAvailableFeature],\n            (isPathCleaningEnabled: boolean, hasAvailableFeature) => {\n                return hasAvailableFeature(AvailableFeature.PATHS_ADVANCED) && isPathCleaningEnabled\n            },\n        ],\n        hasHostFilter: [(s) => [s.rawWebAnalyticsFilters], (filters) => filters.some((f) => f.key === '$host')],\n        webAnalyticsFilters: [\n            (s) => [s.rawWebAnalyticsFilters, s.isPathCleaningEnabled, s.domainFilter, s.deviceTypeFilter],\n            (\n                rawWebAnalyticsFilters: WebAnalyticsPropertyFilters,\n                isPathCleaningEnabled: boolean,\n                domainFilter: string | null,\n                deviceTypeFilter: DeviceType | null\n            ) => {\n                let filters = rawWebAnalyticsFilters\n\n                // Add domain filter if set\n                if (domainFilter && domainFilter !== 'all') {\n                    // Remove the leading protocol if it exists\n                    const value = domainFilter.replace(/^https?:\\/\\//, '')\n\n                    filters = [\n                        ...filters,\n                        {\n                            key: '$host',\n                            value: value,\n                            operator: PropertyOperator.Exact,\n                            type: PropertyFilterType.Event,\n                        },\n                    ]\n                }\n\n                // Add device type filter if set\n                if (deviceTypeFilter) {\n                    filters = [\n                        ...filters,\n                        {\n                            key: '$device_type',\n                            // Extra handling for device type to include mobile+tablet as a single filter\n                            value: deviceTypeFilter === 'Desktop' ? 'Desktop' : ['Mobile', 'Tablet'],\n                            operator: PropertyOperator.Exact,\n                            type: PropertyFilterType.Event,\n                        },\n                    ]\n                }\n\n                // Translate exact path filters to cleaned path filters\n                if (isPathCleaningEnabled) {\n                    filters = filters.map((filter) => {\n                        if (filter.operator !== PropertyOperator.Exact) {\n                            return filter\n                        }\n                        let propertiesToPathClean: Set<string>\n                        switch (filter.type) {\n                            case PropertyFilterType.Event:\n                                propertiesToPathClean = eventPropertiesToPathClean\n                                break\n                            case PropertyFilterType.Person:\n                                propertiesToPathClean = personPropertiesToPathClean\n                                break\n                            case PropertyFilterType.Session:\n                                propertiesToPathClean = sessionPropertiesToPathClean\n                                break\n                            default:\n                                throw new UnexpectedNeverError(filter)\n                        }\n                        if (propertiesToPathClean.has(filter.key)) {\n                            return {\n                                ...filter,\n                                operator: PropertyOperator.IsCleanedPathExact,\n                            }\n                        }\n                        return filter\n                    })\n                }\n\n                return filters\n            },\n        ],\n        tabs: [\n            (s) => [\n                s.graphsTab,\n                s.sourceTab,\n                s.deviceTab,\n                s.pathTab,\n                s.geographyTab,\n                s.activeHoursTab,\n                s.shouldShowGeoIPQueries,\n            ],\n            (graphsTab, sourceTab, deviceTab, pathTab, geographyTab, activeHoursTab, shouldShowGeoIPQueries) => ({\n                graphsTab,\n                sourceTab,\n                deviceTab,\n                pathTab,\n                geographyTab,\n                activeHoursTab,\n                shouldShowGeoIPQueries,\n            }),\n        ],\n        controls: [\n            (s) => [s.isPathCleaningEnabled, s.shouldFilterTestAccounts, s.shouldStripQueryParams],\n            (isPathCleaningEnabled, filterTestAccounts, shouldStripQueryParams) => ({\n                isPathCleaningEnabled,\n                filterTestAccounts,\n                shouldStripQueryParams,\n            }),\n        ],\n        filters: [\n            (s) => [\n                s.webAnalyticsFilters,\n                s.replayFilters,\n                s.dateFilter,\n                s.compareFilter,\n                s.webVitalsTab,\n                s.webVitalsPercentile,\n                s.tablesOrderBy,\n                s.conversionGoal,\n            ],\n            (\n                webAnalyticsFilters,\n                replayFilters,\n                dateFilter,\n                compareFilter,\n                webVitalsTab,\n                webVitalsPercentile,\n                tablesOrderBy,\n                conversionGoal\n            ) => ({\n                webAnalyticsFilters,\n                replayFilters,\n                dateFilter,\n                compareFilter,\n                webVitalsTab,\n                webVitalsPercentile,\n                tablesOrderBy,\n                conversionGoal,\n            }),\n        ],\n        replayFilters: [\n            (s) => [s.webAnalyticsFilters, s.dateFilter, s.shouldFilterTestAccounts, s.conversionGoal],\n            (\n                webAnalyticsFilters: WebAnalyticsPropertyFilters,\n                dateFilter,\n                shouldFilterTestAccounts,\n                conversionGoal\n            ): RecordingUniversalFilters => {\n                const filters: UniversalFiltersGroupValue[] = [...webAnalyticsFilters]\n                if (conversionGoal) {\n                    if ('actionId' in conversionGoal) {\n                        filters.push({\n                            id: conversionGoal.actionId,\n                            name: String(conversionGoal.actionId),\n                            type: 'actions',\n                        })\n                    } else if ('customEventName' in conversionGoal) {\n                        filters.push({\n                            id: conversionGoal.customEventName,\n                            name: conversionGoal.customEventName,\n                            type: 'events',\n                        })\n                    }\n                }\n\n                return {\n                    filter_test_accounts: shouldFilterTestAccounts,\n\n                    date_from: dateFilter.dateFrom,\n                    date_to: dateFilter.dateTo,\n                    filter_group: {\n                        type: FilterLogicalOperator.And,\n                        values: [\n                            {\n                                type: FilterLogicalOperator.And,\n                                values: filters,\n                            },\n                        ],\n                    },\n                    duration: [\n                        {\n                            type: PropertyFilterType.Recording,\n                            key: 'active_seconds',\n                            operator: PropertyOperator.GreaterThan,\n                            value: 1,\n                        },\n                    ],\n                }\n            },\n        ],\n        hasCountryFilter: [\n            (s) => [s.webAnalyticsFilters],\n            (webAnalyticsFilters: WebAnalyticsPropertyFilters) => {\n                return webAnalyticsFilters.some((filter) => filter.key === '$geoip_country_code')\n            },\n        ],\n        webVitalsMetricQuery: [\n            (s) => [\n                s.webVitalsPercentile,\n                s.webVitalsTab,\n                s.dateFilter,\n                s.webAnalyticsFilters,\n                s.shouldFilterTestAccounts,\n            ],\n            (\n                webVitalsPercentile,\n                webVitalsTab,\n                { dateFrom, dateTo, interval },\n                webAnalyticsFilters,\n                filterTestAccounts\n            ): InsightVizNode<TrendsQuery> => ({\n                kind: NodeKind.InsightVizNode,\n                source: {\n                    kind: NodeKind.TrendsQuery,\n                    dateRange: {\n                        date_from: dateFrom,\n                        date_to: dateTo,\n                    },\n                    interval,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            event: '$web_vitals',\n                            name: '$web_vitals',\n                            custom_name: webVitalsTab,\n                            math: webVitalsPercentile,\n                            math_property: `$web_vitals_${webVitalsTab}_value`,\n                        },\n                    ],\n                    trendsFilter: {\n                        display: ChartDisplayType.ActionsLineGraph,\n                        aggregationAxisFormat: webVitalsTab === 'CLS' ? 'numeric' : 'duration_ms',\n                        goalLines: [\n                            {\n                                label: 'Good',\n                                value: WEB_VITALS_THRESHOLDS[webVitalsTab].good,\n                                displayLabel: false,\n                                borderColor: WEB_VITALS_COLORS.good,\n                            },\n                            {\n                                label: 'Poor',\n                                value: WEB_VITALS_THRESHOLDS[webVitalsTab].poor,\n                                displayLabel: false,\n                                borderColor: WEB_VITALS_COLORS.needs_improvements,\n                            },\n                        ],\n                    } as TrendsFilter,\n                    filterTestAccounts,\n                    properties: webAnalyticsFilters,\n                    tags: WEB_ANALYTICS_DEFAULT_QUERY_TAGS,\n                },\n                embedded: false,\n            }),\n        ],\n        authorizedDomains: [\n            (s) => [s.authorizedUrls],\n            (authorizedUrls) => {\n                // There are a couple problems with the raw `authorizedUrls` which we need to fix here:\n                // - They are URLs, we want domains\n                // - There might be duplicates, so clean them up\n                // - There might be duplicates across http/https, so clean them up\n\n                // First create URL objects and group them by hostname+port\n                const urlsByDomain = new Map<string, URL[]>()\n\n                for (const urlStr of authorizedUrls) {\n                    try {\n                        const url = new URL(urlStr)\n                        const key = url.host // hostname + port if present\n                        if (!urlsByDomain.has(key)) {\n                            urlsByDomain.set(key, [])\n                        }\n                        urlsByDomain.get(key)!.push(url)\n                    } catch {\n                        // Silently skip URLs that can't be parsed\n                    }\n                }\n\n                // For each domain, prefer https over http\n                return Array.from(urlsByDomain.values()).map((urls) => {\n                    const preferredUrl = urls.find((url) => url.protocol === 'https:') ?? urls[0]\n                    return preferredUrl.origin\n                })\n            },\n        ],\n    }),\n    selectors(({ actions }) => ({\n        tiles: [\n            (s) => [\n                s.productTab,\n                s.tabs,\n                s.controls,\n                s.filters,\n                s.featureFlags,\n                s.isGreaterThanMd,\n                s.currentTeam,\n                s.tileVisualizations,\n                s.preAggregatedEnabled,\n                s.marketingTiles,\n                s.hiddenTiles,\n            ],\n            (\n                productTab,\n                { graphsTab, sourceTab, deviceTab, pathTab, geographyTab, shouldShowGeoIPQueries, activeHoursTab },\n                { isPathCleaningEnabled, filterTestAccounts, shouldStripQueryParams },\n                {\n                    webAnalyticsFilters,\n                    replayFilters,\n                    dateFilter: { dateFrom, dateTo, interval },\n                    conversionGoal,\n                    compareFilter,\n                    webVitalsPercentile,\n                    webVitalsTab,\n                    tablesOrderBy,\n                },\n                featureFlags,\n                isGreaterThanMd,\n                currentTeam,\n                tileVisualizations,\n                preAggregatedEnabled,\n                marketingTiles,\n                hiddenTiles\n            ): WebAnalyticsTile[] => {\n                const dateRange = { date_from: dateFrom, date_to: dateTo }\n                const sampling = { enabled: false, forceSamplingRate: { numerator: 1, denominator: 10 } }\n\n                const uniqueUserSeries: EventsNode = {\n                    event: featureFlags[FEATURE_FLAGS.WEB_ANALYTICS_FOR_MOBILE] ? '$screen' : '$pageview',\n                    kind: NodeKind.EventsNode,\n                    math: BaseMathType.UniqueUsers,\n                    name: 'Pageview',\n                    custom_name: 'Unique visitors',\n                }\n\n                const pageViewsSeries = {\n                    ...uniqueUserSeries,\n                    math: BaseMathType.TotalCount,\n                    custom_name: featureFlags[FEATURE_FLAGS.WEB_ANALYTICS_FOR_MOBILE] ? 'Screen Views' : 'Page views',\n                }\n\n                const sessionsSeries = {\n                    ...uniqueUserSeries,\n                    math: BaseMathType.UniqueSessions,\n                    custom_name: 'Sessions',\n                }\n\n                const uniqueConversionsSeries: ActionsNode | EventsNode | undefined = !conversionGoal\n                    ? undefined\n                    : 'actionId' in conversionGoal\n                      ? {\n                            kind: NodeKind.ActionsNode,\n                            id: conversionGoal.actionId,\n                            math: BaseMathType.UniqueUsers,\n                            name: 'Unique conversions',\n                            custom_name: 'Unique conversions',\n                        }\n                      : {\n                            kind: NodeKind.EventsNode,\n                            event: conversionGoal.customEventName,\n                            math: BaseMathType.UniqueUsers,\n                            name: 'Unique conversions',\n                            custom_name: 'Unique conversions',\n                        }\n                const totalConversionSeries = uniqueConversionsSeries\n                    ? {\n                          ...uniqueConversionsSeries,\n                          math: BaseMathType.TotalCount,\n                          name: 'Total conversions',\n                          custom_name: 'Total conversions',\n                      }\n                    : undefined\n\n                // the queries don't currently include revenue when the conversion goal is an action\n                const includeRevenue = !(conversionGoal && 'actionId' in conversionGoal)\n\n                const revenueEventsSeries: EventsNode[] =\n                    includeRevenue && currentTeam?.revenue_analytics_config\n                        ? (currentTeam.revenue_analytics_config.events.map((e) => ({\n                              name: e.eventName,\n                              event: e.eventName,\n                              custom_name: e.eventName,\n                              math: PropertyMathType.Sum,\n                              kind: NodeKind.EventsNode,\n                              math_property: e.revenueProperty,\n                              math_property_revenue_currency: e.revenueCurrencyProperty,\n                          })) as EventsNode[])\n                        : []\n\n                const conversionRevenueSeries =\n                    conversionGoal && 'customEventName' in conversionGoal && includeRevenue\n                        ? revenueEventsSeries.filter((e) => 'event' in e && e.event === conversionGoal.customEventName)\n                        : []\n\n                const createInsightProps = (tile: TileId, tab?: string): InsightLogicProps => {\n                    return {\n                        dashboardItemId: getDashboardItemId(tile, tab, false),\n                        loadPriority: loadPriorityMap[tile],\n                        dataNodeCollectionId: WEB_ANALYTICS_DATA_COLLECTION_NODE_ID,\n                    }\n                }\n\n                const createGraphsTrendsTab = (\n                    id: GraphsTab,\n                    title: string | JSX.Element,\n                    linkText: string | JSX.Element,\n                    series: AnyEntityNode[],\n                    trendsFilter?: Partial<TrendsFilter>,\n                    trendsQueryProperties?: Partial<TrendsQuery>\n                ): TabsTileTab => ({\n                    id,\n                    title,\n                    linkText,\n                    query: {\n                        kind: NodeKind.InsightVizNode,\n                        source: {\n                            kind: NodeKind.TrendsQuery,\n                            dateRange,\n                            interval,\n                            series: series,\n                            trendsFilter: {\n                                display: ChartDisplayType.ActionsLineGraph,\n                                ...trendsFilter,\n                            },\n                            compareFilter,\n                            filterTestAccounts,\n                            conversionGoal,\n                            properties: webAnalyticsFilters,\n                            tags: WEB_ANALYTICS_DEFAULT_QUERY_TAGS,\n                            ...trendsQueryProperties,\n                        },\n                        hidePersonsModal: true,\n                        embedded: true,\n                        hideTooltipOnScroll: true,\n                    },\n                    showIntervalSelect: true,\n                    insightProps: createInsightProps(TileId.GRAPHS, id),\n                    canOpenInsight: true,\n                })\n\n                const createTableTab = (\n                    tileId: TileId,\n                    tabId: string,\n                    title: string,\n                    linkText: string,\n                    breakdownBy: WebStatsBreakdown,\n                    source?: Partial<WebStatsTableQuery>,\n                    tab?: Partial<TabsTileTab>\n                ): TabsTileTab => {\n                    const columns = [\n                        'breakdown_value',\n                        'visitors',\n                        'views',\n                        source?.includeBounceRate ? 'bounce_rate' : null,\n                        'cross_sell',\n                    ].filter(isNotNil)\n\n                    // Check if this tile has a visualization preference\n                    const visualization =\n                        tileVisualizations[tileId as unknown as keyof typeof tileVisualizations] || undefined\n\n                    const baseTabProps = {\n                        id: tabId,\n                        title,\n                        linkText,\n                        insightProps: createInsightProps(tileId, tabId),\n                        canOpenModal: true,\n                        ...tab,\n                    }\n\n                    // In case of a graph, we need to use the breakdownFilter and a InsightsVizNode,\n                    // which will actually be handled by a WebStatsTrendTile instead of a WebStatsTableTile\n                    if (visualization === 'graph') {\n                        return {\n                            ...baseTabProps,\n                            query: {\n                                kind: NodeKind.InsightVizNode,\n                                source: {\n                                    kind: NodeKind.TrendsQuery,\n                                    dateRange,\n                                    interval,\n                                    series: [uniqueUserSeries],\n                                    trendsFilter: {\n                                        display: ChartDisplayType.ActionsLineGraph,\n                                    },\n                                    breakdownFilter: getWebAnalyticsBreakdownFilter(breakdownBy),\n                                    filterTestAccounts,\n                                    conversionGoal,\n                                    properties: webAnalyticsFilters,\n                                    tags: WEB_ANALYTICS_DEFAULT_QUERY_TAGS,\n                                },\n                                hidePersonsModal: true,\n                                embedded: true,\n                                hideTooltipOnScroll: true,\n                            },\n                            canOpenInsight: true,\n                            canOpenModal: false,\n                        }\n                    }\n\n                    return {\n                        ...baseTabProps,\n                        query: {\n                            full: true,\n                            kind: NodeKind.DataTableNode,\n                            source: {\n                                kind: NodeKind.WebStatsTableQuery,\n                                properties: webAnalyticsFilters,\n                                breakdownBy: breakdownBy,\n                                dateRange,\n                                sampling,\n                                compareFilter,\n                                limit: 10,\n                                filterTestAccounts,\n                                conversionGoal,\n                                orderBy: tablesOrderBy ?? undefined,\n                                tags: WEB_ANALYTICS_DEFAULT_QUERY_TAGS,\n                                ...source,\n                            },\n                            embedded: false,\n                            showActions: true,\n                            columns,\n                        },\n                    }\n                }\n\n                let errorTrackingQ: DataTableNode | undefined\n\n                try {\n                    errorTrackingQ = errorTrackingQuery({\n                        orderBy: 'users',\n                        dateRange: dateRange,\n                        filterTestAccounts: filterTestAccounts,\n                        filterGroup: replayFilters.filter_group,\n                        columns: ['error', 'users', 'occurrences'],\n                        limit: 4,\n                    })\n                } catch (e) {\n                    posthog.captureException(e, { dateRange, replayFilters, filterTestAccounts })\n                }\n\n                if (productTab === ProductTab.WEB_VITALS) {\n                    const createSeries = (name: WebVitalsMetric, math: PropertyMathType): AnyEntityNode => ({\n                        kind: NodeKind.EventsNode,\n                        event: '$web_vitals',\n                        name: '$web_vitals',\n                        custom_name: name,\n                        math: math,\n                        math_property: `$web_vitals_${name}_value`,\n                    })\n\n                    return [\n                        {\n                            kind: 'query',\n                            tileId: TileId.WEB_VITALS,\n                            layout: {\n                                colSpanClassName: 'md:col-span-full',\n                                orderWhenLargeClassName: 'xxl:order-0',\n                            },\n                            query: {\n                                kind: NodeKind.WebVitalsQuery,\n                                properties: webAnalyticsFilters,\n                                source: {\n                                    kind: NodeKind.TrendsQuery,\n                                    dateRange,\n                                    interval,\n                                    series: (['INP', 'LCP', 'CLS', 'FCP'] as WebVitalsMetric[]).flatMap((metric) =>\n                                        [PropertyMathType.P75, PropertyMathType.P90, PropertyMathType.P99].map((math) =>\n                                            createSeries(metric, math)\n                                        )\n                                    ),\n                                    trendsFilter: { display: ChartDisplayType.ActionsLineGraph },\n                                    compareFilter,\n                                    filterTestAccounts,\n                                    properties: webAnalyticsFilters,\n                                },\n                                tags: WEB_ANALYTICS_DEFAULT_QUERY_TAGS,\n                            },\n                            insightProps: {\n                                dashboardItemId: getDashboardItemId(TileId.WEB_VITALS, 'web-vitals-overview', false),\n                                loadPriority: loadPriorityMap[TileId.WEB_VITALS],\n                                dataNodeCollectionId: WEB_ANALYTICS_DATA_COLLECTION_NODE_ID,\n                            },\n                            showIntervalSelect: true,\n                        },\n                        {\n                            kind: 'query',\n                            tileId: TileId.WEB_VITALS_PATH_BREAKDOWN,\n                            layout: {\n                                colSpanClassName: 'md:col-span-full',\n                                orderWhenLargeClassName: 'xxl:order-0',\n                            },\n                            query: {\n                                kind: NodeKind.WebVitalsPathBreakdownQuery,\n                                dateRange,\n                                filterTestAccounts,\n                                properties: webAnalyticsFilters,\n                                percentile: webVitalsPercentile,\n                                metric: webVitalsTab,\n                                doPathCleaning: isPathCleaningEnabled,\n                                thresholds: [\n                                    WEB_VITALS_THRESHOLDS[webVitalsTab].good,\n                                    WEB_VITALS_THRESHOLDS[webVitalsTab].poor,\n                                ],\n                            },\n                            insightProps: {\n                                dashboardItemId: getDashboardItemId(\n                                    TileId.WEB_VITALS_PATH_BREAKDOWN,\n                                    'web-vitals-path-breakdown',\n                                    false\n                                ),\n                                loadPriority: loadPriorityMap[TileId.WEB_VITALS_PATH_BREAKDOWN],\n                                dataNodeCollectionId: WEB_ANALYTICS_DATA_COLLECTION_NODE_ID,\n                            },\n                        },\n                    ]\n                }\n\n                if (productTab === ProductTab.MARKETING) {\n                    return marketingTiles as unknown as WebAnalyticsTile[]\n                }\n\n                const allTiles: (WebAnalyticsTile | null)[] = [\n                    {\n                        kind: 'query',\n                        tileId: TileId.OVERVIEW,\n                        layout: {\n                            colSpanClassName: 'md:col-span-full',\n                            orderWhenLargeClassName: 'xxl:order-0',\n                        },\n                        query: {\n                            kind: NodeKind.WebOverviewQuery,\n                            properties: webAnalyticsFilters,\n                            dateRange,\n                            sampling,\n                            compareFilter,\n                            filterTestAccounts,\n                            conversionGoal,\n                            includeRevenue,\n                        },\n                        insightProps: createInsightProps(TileId.OVERVIEW),\n                    },\n                    {\n                        kind: 'tabs',\n                        tileId: TileId.GRAPHS,\n                        layout: {\n                            colSpanClassName: `md:col-span-2`,\n                            orderWhenLargeClassName: 'xxl:order-1',\n                        },\n                        activeTabId: graphsTab,\n                        setTabId: actions.setGraphsTab,\n                        tabs: (\n                            [\n                                createGraphsTrendsTab(GraphsTab.UNIQUE_USERS, 'Unique visitors', 'Visitors', [\n                                    uniqueUserSeries,\n                                ]),\n                                !conversionGoal\n                                    ? createGraphsTrendsTab(GraphsTab.PAGE_VIEWS, 'Page views', 'Views', [\n                                          pageViewsSeries,\n                                      ])\n                                    : null,\n                                !conversionGoal\n                                    ? createGraphsTrendsTab(GraphsTab.NUM_SESSION, 'Unique sessions', 'Sessions', [\n                                          sessionsSeries,\n                                      ])\n                                    : null,\n                                !conversionGoal && revenueEventsSeries?.length\n                                    ? createGraphsTrendsTab(\n                                          GraphsTab.REVENUE_EVENTS,\n                                          <span>\n                                              Revenue&nbsp;<LemonTag type=\"warning\">BETA</LemonTag>\n                                          </span>,\n                                          'Revenue',\n                                          revenueEventsSeries,\n                                          {\n                                              display:\n                                                  revenueEventsSeries.length > 1\n                                                      ? ChartDisplayType.ActionsAreaGraph\n                                                      : ChartDisplayType.ActionsLineGraph,\n                                          },\n                                          {\n                                              compareFilter: revenueEventsSeries.length > 1 ? undefined : compareFilter,\n                                          }\n                                      )\n                                    : null,\n                                conversionGoal && uniqueConversionsSeries\n                                    ? createGraphsTrendsTab(\n                                          GraphsTab.UNIQUE_CONVERSIONS,\n                                          'Unique conversions',\n                                          'Unique conversions',\n                                          [uniqueConversionsSeries]\n                                      )\n                                    : null,\n                                conversionGoal && totalConversionSeries\n                                    ? createGraphsTrendsTab(\n                                          GraphsTab.TOTAL_CONVERSIONS,\n                                          'Total conversions',\n                                          'Total conversions',\n                                          [totalConversionSeries]\n                                      )\n                                    : null,\n                                conversionGoal && uniqueUserSeries && uniqueConversionsSeries\n                                    ? createGraphsTrendsTab(\n                                          GraphsTab.CONVERSION_RATE,\n                                          'Conversion rate',\n                                          'Conversion rate',\n                                          [uniqueConversionsSeries, uniqueUserSeries],\n                                          {\n                                              formula: 'A / B',\n                                              aggregationAxisFormat: 'percentage_scaled',\n                                          }\n                                      )\n                                    : null,\n                                conversionGoal && conversionRevenueSeries.length\n                                    ? createGraphsTrendsTab(\n                                          GraphsTab.CONVERSION_REVENUE,\n                                          <span>\n                                              Conversion Revenue&nbsp;<LemonTag type=\"warning\">BETA</LemonTag>\n                                          </span>,\n                                          'Conversion Revenue',\n                                          conversionRevenueSeries\n                                      )\n                                    : null,\n                            ] as (TabsTileTab | null)[]\n                        ).filter(isNotNil),\n                    },\n                    {\n                        kind: 'tabs',\n                        tileId: TileId.PATHS,\n                        layout: {\n                            colSpanClassName: `md:col-span-2`,\n                            orderWhenLargeClassName: 'xxl:order-4',\n                        },\n                        activeTabId: pathTab,\n                        setTabId: actions.setPathTab,\n                        tabs: featureFlags[FEATURE_FLAGS.WEB_ANALYTICS_FOR_MOBILE]\n                            ? [\n                                  createTableTab(\n                                      TileId.PATHS,\n                                      PathTab.SCREEN_NAME,\n                                      'Screens',\n                                      'Screen',\n                                      WebStatsBreakdown.ScreenName,\n                                      {},\n                                      {}\n                                  ),\n                              ]\n                            : (\n                                  [\n                                      createTableTab(\n                                          TileId.PATHS,\n                                          PathTab.PATH,\n                                          'Paths',\n                                          'Path',\n                                          WebStatsBreakdown.Page,\n                                          {\n                                              includeScrollDepth: false, // TODO needs some perf work before it can be enabled\n                                              includeBounceRate: true,\n                                              doPathCleaning: isPathCleaningEnabled,\n                                          },\n                                          {\n                                              docs: {\n                                                  url: 'https://posthog.com/docs/web-analytics/dashboard#paths',\n                                                  title: 'Paths',\n                                                  description: (\n                                                      <div>\n                                                          <p>\n                                                              In this view you can validate all of the paths that were\n                                                              accessed in your application, regardless of when they were\n                                                              accessed through the lifetime of a user session.\n                                                          </p>\n                                                          {conversionGoal ? (\n                                                              <p>\n                                                                  The conversion rate is the percentage of users who\n                                                                  completed the conversion goal in this specific path.\n                                                              </p>\n                                                          ) : (\n                                                              <p>\n                                                                  The{' '}\n                                                                  <Link to=\"https://posthog.com/docs/web-analytics/dashboard#bounce-rate\">\n                                                                      bounce rate\n                                                                  </Link>{' '}\n                                                                  indicates the percentage of users who left your page\n                                                                  immediately after visiting without capturing any\n                                                                  event.\n                                                              </p>\n                                                          )}\n                                                      </div>\n                                                  ),\n                                              },\n                                          }\n                                      ),\n                                      createTableTab(\n                                          TileId.PATHS,\n                                          PathTab.INITIAL_PATH,\n                                          'Entry paths',\n                                          'Entry path',\n                                          WebStatsBreakdown.InitialPage,\n                                          {\n                                              includeBounceRate: true,\n                                              includeScrollDepth: false,\n                                              doPathCleaning: isPathCleaningEnabled,\n                                          },\n                                          {\n                                              docs: {\n                                                  url: 'https://posthog.com/docs/web-analytics/dashboard#paths',\n                                                  title: 'Entry Path',\n                                                  description: (\n                                                      <div>\n                                                          <p>\n                                                              Entry paths are the paths a user session started, i.e. the\n                                                              first path they saw when they opened your website.\n                                                          </p>\n                                                          {conversionGoal && (\n                                                              <p>\n                                                                  The conversion rate is the percentage of users who\n                                                                  completed the conversion goal after the first path in\n                                                                  their session being this path.\n                                                              </p>\n                                                          )}\n                                                      </div>\n                                                  ),\n                                              },\n                                          }\n                                      ),\n                                      createTableTab(\n                                          TileId.PATHS,\n                                          PathTab.END_PATH,\n                                          'End paths',\n                                          'End path',\n                                          WebStatsBreakdown.ExitPage,\n                                          {\n                                              includeBounceRate: false,\n                                              includeScrollDepth: false,\n                                              doPathCleaning: isPathCleaningEnabled,\n                                          },\n                                          {\n                                              docs: {\n                                                  url: 'https://posthog.com/docs/web-analytics/dashboard#paths',\n                                                  title: 'End Path',\n                                                  description: (\n                                                      <div>\n                                                          End paths are the last path a user visited before their\n                                                          session ended, i.e. the last path they saw before leaving your\n                                                          website/closing the browser/turning their computer off.\n                                                      </div>\n                                                  ),\n                                              },\n                                          }\n                                      ),\n                                      {\n                                          id: PathTab.EXIT_CLICK,\n                                          title: 'Outbound link clicks',\n                                          linkText: 'Outbound clicks',\n                                          query: {\n                                              full: true,\n                                              kind: NodeKind.DataTableNode,\n                                              source: {\n                                                  kind: NodeKind.WebExternalClicksTableQuery,\n                                                  properties: webAnalyticsFilters,\n                                                  dateRange,\n                                                  compareFilter,\n                                                  sampling,\n                                                  limit: 10,\n                                                  filterTestAccounts,\n                                                  conversionGoal,\n                                                  orderBy: tablesOrderBy ?? undefined,\n                                                  stripQueryParams: shouldStripQueryParams,\n                                              },\n                                              embedded: false,\n                                              showActions: true,\n                                              columns: ['url', 'visitors', 'clicks', 'cross_sell'],\n                                          },\n                                          insightProps: createInsightProps(TileId.PATHS, PathTab.END_PATH),\n                                          canOpenModal: true,\n                                          docs: {\n                                              title: 'Outbound Clicks',\n                                              description: (\n                                                  <div>\n                                                      You'll be able to verify when someone leaves your website by\n                                                      clicking an outbound link (to a separate domain)\n                                                  </div>\n                                              ),\n                                          },\n                                      },\n                                  ] as (TabsTileTab | undefined)[]\n                              ).filter(isNotNil),\n                    },\n                    {\n                        kind: 'tabs',\n                        tileId: TileId.SOURCES,\n                        layout: {\n                            colSpanClassName: `md:col-span-1`,\n                            orderWhenLargeClassName: 'xxl:order-2',\n                        },\n                        activeTabId: sourceTab,\n                        setTabId: actions.setSourceTab,\n                        tabs: [\n                            createTableTab(\n                                TileId.SOURCES,\n                                SourceTab.CHANNEL,\n                                'Channels',\n                                'Channel',\n                                WebStatsBreakdown.InitialChannelType,\n                                {},\n                                {\n                                    control: (\n                                        <div className=\"flex flex-row deprecated-space-x-2 font-medium\">\n                                            <span>Customize channel types</span>\n                                            <LemonButton\n                                                icon={<IconGear />}\n                                                type=\"tertiary\"\n                                                status=\"alt\"\n                                                size=\"small\"\n                                                noPadding={true}\n                                                tooltip=\"Customize channel types\"\n                                                to={urls.settings('environment-web-analytics', 'channel-type')}\n                                            />\n                                        </div>\n                                    ),\n                                    docs: {\n                                        url: 'https://posthog.com/docs/data/channel-type',\n                                        title: 'Channels',\n                                        description: (\n                                            <div>\n                                                <p>\n                                                    Channels are the different sources that bring traffic to your\n                                                    website, e.g. Paid Search, Organic Social, Direct, etc.\n                                                </p>\n                                                <p>\n                                                    You can also{' '}\n                                                    <Link\n                                                        to={urls.settings('environment-web-analytics', 'channel-type')}\n                                                    >\n                                                        create custom channel types\n                                                    </Link>\n                                                    , allowing you to further categorize your channels.\n                                                </p>\n                                                <p>\n                                                    Something unexpected? Try the{' '}\n                                                    <Link to={urls.sessionAttributionExplorer()}>\n                                                        Session attribution explorer\n                                                    </Link>\n                                                </p>\n                                            </div>\n                                        ),\n                                    },\n                                }\n                            ),\n                            createTableTab(\n                                TileId.SOURCES,\n                                SourceTab.REFERRING_DOMAIN,\n                                'Referrers',\n                                'Referring domain',\n                                WebStatsBreakdown.InitialReferringDomain,\n                                {},\n                                {\n                                    docs: {\n                                        url: 'https://posthog.com/docs/web-analytics/dashboard#referrers-channels-utms',\n                                        title: 'Referrers',\n                                        description: 'Understand where your users are coming from',\n                                    },\n                                }\n                            ),\n                            createTableTab(\n                                TileId.SOURCES,\n                                SourceTab.UTM_SOURCE,\n                                'UTM sources',\n                                'UTM source',\n                                WebStatsBreakdown.InitialUTMSource,\n                                {},\n                                {\n                                    docs: {\n                                        url: 'https://posthog.com/docs/web-analytics/dashboard#utms',\n                                        title: 'UTM source',\n                                        description: (\n                                            <>\n                                                Understand where your users are coming from - filtered down by their{' '}\n                                                <code>utm_source</code> parameter\n                                            </>\n                                        ),\n                                    },\n                                }\n                            ),\n                            createTableTab(\n                                TileId.SOURCES,\n                                SourceTab.UTM_MEDIUM,\n                                'UTM medium',\n                                'UTM medium',\n                                WebStatsBreakdown.InitialUTMMedium,\n                                {},\n                                {\n                                    docs: {\n                                        url: 'https://posthog.com/docs/web-analytics/dashboard#utms',\n                                        title: 'UTM medium',\n                                        description: (\n                                            <>\n                                                Understand where your users are coming from - filtered down by their{' '}\n                                                <code>utm_medium</code> parameter\n                                            </>\n                                        ),\n                                    },\n                                }\n                            ),\n                            createTableTab(\n                                TileId.SOURCES,\n                                SourceTab.UTM_CAMPAIGN,\n                                'UTM campaigns',\n                                'UTM campaign',\n                                WebStatsBreakdown.InitialUTMCampaign,\n                                {},\n                                {\n                                    docs: {\n                                        url: 'https://posthog.com/docs/web-analytics/dashboard#utms',\n                                        title: 'UTM campaign',\n                                        description: (\n                                            <>\n                                                Understand where your users are coming from - filtered down by their{' '}\n                                                <code>utm_campaign</code> parameter\n                                            </>\n                                        ),\n                                    },\n                                }\n                            ),\n                            createTableTab(\n                                TileId.SOURCES,\n                                SourceTab.UTM_CONTENT,\n                                'UTM content',\n                                'UTM content',\n                                WebStatsBreakdown.InitialUTMContent,\n                                {},\n                                {\n                                    docs: {\n                                        url: 'https://posthog.com/docs/web-analytics/dashboard#utms',\n                                        title: 'UTM content',\n                                        description: (\n                                            <>\n                                                Understand where your users are coming from - filtered down by their{' '}\n                                                <code>utm_content</code> parameter\n                                            </>\n                                        ),\n                                    },\n                                }\n                            ),\n                            createTableTab(\n                                TileId.SOURCES,\n                                SourceTab.UTM_TERM,\n                                'UTM terms',\n                                'UTM term',\n                                WebStatsBreakdown.InitialUTMTerm,\n                                {},\n                                {\n                                    docs: {\n                                        url: 'https://posthog.com/docs/web-analytics/dashboard#utms',\n                                        title: 'UTM term',\n                                        description: (\n                                            <>\n                                                Understand where your users are coming from - filtered down by their{' '}\n                                                <code>utm_term</code> parameter\n                                            </>\n                                        ),\n                                    },\n                                }\n                            ),\n                            createTableTab(\n                                TileId.SOURCES,\n                                SourceTab.UTM_SOURCE_MEDIUM_CAMPAIGN,\n                                'Source / Medium / Campaign',\n                                'UTM s/m/c',\n                                WebStatsBreakdown.InitialUTMSourceMediumCampaign,\n                                {},\n                                {\n                                    docs: {\n                                        url: 'https://posthog.com/docs/web-analytics/dashboard#utms',\n                                        title: 'UTM parameters',\n                                        description: (\n                                            <>\n                                                Understand where your users are coming from - filtered down by a tuple\n                                                of their <code>utm_source</code>, <code>utm_medium</code>, and{' '}\n                                                <code>utm_campaign</code> parameters\n                                            </>\n                                        ),\n                                    },\n                                }\n                            ),\n                        ],\n                    },\n                    {\n                        kind: 'tabs',\n                        tileId: TileId.DEVICES,\n                        layout: {\n                            colSpanClassName: `md:col-span-1`,\n                            orderWhenLargeClassName: 'xxl:order-3',\n                        },\n                        activeTabId: deviceTab,\n                        setTabId: actions.setDeviceTab,\n                        tabs: [\n                            createTableTab(\n                                TileId.DEVICES,\n                                DeviceTab.DEVICE_TYPE,\n                                'Device type',\n                                'Device type',\n                                WebStatsBreakdown.DeviceType\n                            ),\n                            createTableTab(\n                                TileId.DEVICES,\n                                DeviceTab.BROWSER,\n                                'Browsers',\n                                'Browser',\n                                WebStatsBreakdown.Browser\n                            ),\n                            createTableTab(TileId.DEVICES, DeviceTab.OS, 'OS', 'OS', WebStatsBreakdown.OS),\n                            createTableTab(\n                                TileId.DEVICES,\n                                DeviceTab.VIEWPORT,\n                                'Viewports',\n                                'Viewport',\n                                WebStatsBreakdown.Viewport\n                            ),\n                        ],\n                    },\n\n                    {\n                        kind: 'tabs',\n                        tileId: TileId.GEOGRAPHY,\n                        layout: {\n                            colSpanClassName: 'md:col-span-full',\n                        },\n                        activeTabId:\n                            geographyTab || (shouldShowGeoIPQueries ? GeographyTab.MAP : GeographyTab.LANGUAGES),\n                        setTabId: actions.setGeographyTab,\n                        tabs: (\n                            [\n                                shouldShowGeoIPQueries\n                                    ? {\n                                          id: GeographyTab.MAP,\n                                          title: 'World map',\n                                          linkText: 'Map',\n                                          query: {\n                                              kind: NodeKind.InsightVizNode,\n                                              source: {\n                                                  kind: NodeKind.TrendsQuery,\n                                                  breakdownFilter: {\n                                                      // use the event level country code rather than person, to work better with personless users\n                                                      breakdown: '$geoip_country_code',\n                                                      breakdown_type: 'event',\n                                                  },\n                                                  dateRange,\n                                                  series: [\n                                                      {\n                                                          event: '$pageview',\n                                                          name: 'Pageview',\n                                                          kind: NodeKind.EventsNode,\n                                                          math: BaseMathType.UniqueUsers,\n                                                      },\n                                                  ],\n                                                  trendsFilter: {\n                                                      display: ChartDisplayType.WorldMap,\n                                                  },\n                                                  conversionGoal,\n                                                  filterTestAccounts,\n                                                  properties: webAnalyticsFilters,\n                                                  tags: WEB_ANALYTICS_DEFAULT_QUERY_TAGS,\n                                              },\n                                              hidePersonsModal: true,\n                                              embedded: true,\n                                          },\n                                          insightProps: createInsightProps(TileId.GEOGRAPHY, GeographyTab.MAP),\n                                          canOpenInsight: true,\n                                      }\n                                    : null,\n                                shouldShowGeoIPQueries\n                                    ? createTableTab(\n                                          TileId.GEOGRAPHY,\n                                          GeographyTab.COUNTRIES,\n                                          'Countries',\n                                          'Countries',\n                                          WebStatsBreakdown.Country\n                                      )\n                                    : null,\n                                shouldShowGeoIPQueries\n                                    ? createTableTab(\n                                          TileId.GEOGRAPHY,\n                                          GeographyTab.REGIONS,\n                                          'Regions',\n                                          'Regions',\n                                          WebStatsBreakdown.Region\n                                      )\n                                    : null,\n                                shouldShowGeoIPQueries\n                                    ? createTableTab(\n                                          TileId.GEOGRAPHY,\n                                          GeographyTab.CITIES,\n                                          'Cities',\n                                          'Cities',\n                                          WebStatsBreakdown.City\n                                      )\n                                    : null,\n                                createTableTab(\n                                    TileId.GEOGRAPHY,\n                                    GeographyTab.LANGUAGES,\n                                    'Languages',\n                                    'Languages',\n                                    WebStatsBreakdown.Language\n                                ),\n                                createTableTab(\n                                    TileId.GEOGRAPHY,\n                                    GeographyTab.TIMEZONES,\n                                    'Timezones',\n                                    'Timezones',\n                                    WebStatsBreakdown.Timezone\n                                ),\n                            ] as (TabsTileTab | null)[]\n                        ).filter(isNotNil),\n                    },\n                    !conversionGoal\n                        ? {\n                              kind: 'query',\n                              tileId: TileId.RETENTION,\n                              title: 'Retention',\n                              layout: {\n                                  colSpanClassName: 'md:col-span-2',\n                              },\n                              query: {\n                                  kind: NodeKind.InsightVizNode,\n                                  source: {\n                                      kind: NodeKind.RetentionQuery,\n                                      properties: webAnalyticsFilters,\n                                      dateRange,\n                                      filterTestAccounts,\n                                      retentionFilter: {\n                                          retentionType: RETENTION_FIRST_OCCURRENCE_MATCHING_FILTERS,\n                                          retentionReference: 'total',\n                                          totalIntervals: isGreaterThanMd ? 8 : 5,\n                                          period: RetentionPeriod.Week,\n                                      },\n                                      tags: WEB_ANALYTICS_DEFAULT_QUERY_TAGS,\n                                  },\n                                  vizSpecificOptions: {\n                                      [InsightType.RETENTION]: {\n                                          hideLineGraph: true,\n                                          hideSizeColumn: !isGreaterThanMd,\n                                          useSmallLayout: !isGreaterThanMd,\n                                      },\n                                  },\n                                  embedded: true,\n                              },\n                              insightProps: createInsightProps(TileId.RETENTION),\n                              canOpenInsight: false,\n                              canOpenModal: true,\n                              docs: {\n                                  url: 'https://posthog.com/docs/web-analytics/dashboard#retention',\n                                  title: 'Retention',\n                                  description: (\n                                      <>\n                                          <div>\n                                              <p>\n                                                  Retention creates a cohort of unique users who performed any event for\n                                                  the first time in the last week. It then tracks the percentage of\n                                                  users who return to perform any event in the following weeks.\n                                              </p>\n                                              <p>\n                                                  You want the numbers to be the highest possible, suggesting that\n                                                  people that come to your page continue coming to your page - and\n                                                  performing an actions. Also, the further down the table the higher the\n                                                  numbers should be (or at least as high), which would indicate that\n                                                  you're either increasing or keeping your retention at the same level.\n                                              </p>\n                                          </div>\n                                      </>\n                                  ),\n                              },\n                          }\n                        : null,\n                    {\n                        kind: 'tabs',\n                        tileId: TileId.ACTIVE_HOURS,\n                        layout: {\n                            colSpanClassName: 'md:col-span-full',\n                        },\n                        activeTabId: activeHoursTab,\n                        setTabId: actions.setActiveHoursTab,\n                        tabs: [\n                            {\n                                id: ActiveHoursTab.UNIQUE,\n                                title: 'Active Hours',\n                                linkText: 'Unique users',\n                                canOpenModal: true,\n                                canOpenInsight: !!featureFlags[FEATURE_FLAGS.CALENDAR_HEATMAP_INSIGHT],\n                                query: {\n                                    kind: NodeKind.InsightVizNode,\n                                    source: {\n                                        kind: NodeKind.TrendsQuery,\n                                        series: [\n                                            {\n                                                kind: NodeKind.EventsNode,\n                                                event: '$pageview',\n                                                name: '$pageview',\n                                                math: BaseMathType.UniqueUsers,\n                                                properties: webAnalyticsFilters,\n                                            },\n                                        ],\n                                        dateRange,\n                                        conversionGoal,\n                                        tags: WEB_ANALYTICS_DEFAULT_QUERY_TAGS,\n                                        trendsFilter: {\n                                            display: ChartDisplayType.CalendarHeatmap,\n                                        },\n                                    },\n                                },\n                                docs: {\n                                    url: 'https://posthog.com/docs/web-analytics/dashboard#active-hours',\n                                    title: 'Active hours - Unique users',\n                                    description: (\n                                        <>\n                                            <div>\n                                                <p>\n                                                    Active hours displays a heatmap showing the number of unique users\n                                                    who performed any pageview event, broken down by hour of the day and\n                                                    day of the week.\n                                                </p>\n                                                <p>\n                                                    Each cell represents the number of unique users during a specific\n                                                    hour of a specific day. The \"All\" column aggregates totals for each\n                                                    day, and the bottom row aggregates totals for each hour. The\n                                                    bottom-right cell shows the grand total. The displayed time is based\n                                                    on your project's date and time settings (UTC by default,\n                                                    configurable in{' '}\n                                                    <Link to={urls.settings('project', 'date-and-time')}>\n                                                        project settings\n                                                    </Link>\n                                                    ).\n                                                </p>\n                                                <p>\n                                                    <strong>Note:</strong> Selecting a time range longer than 7 days\n                                                    will include additional occurrences of weekdays and hours,\n                                                    potentially increasing the user counts in those buckets. For best\n                                                    results, select 7 closed days or multiple of 7 closed day ranges.\n                                                </p>\n                                            </div>\n                                        </>\n                                    ),\n                                },\n                                insightProps: createInsightProps(TileId.ACTIVE_HOURS, ActiveHoursTab.UNIQUE),\n                            },\n                            {\n                                id: ActiveHoursTab.TOTAL_EVENTS,\n                                title: 'Active Hours',\n                                linkText: 'Total pageviews',\n                                canOpenModal: true,\n                                canOpenInsight: !!featureFlags[FEATURE_FLAGS.CALENDAR_HEATMAP_INSIGHT],\n                                query: {\n                                    kind: NodeKind.InsightVizNode,\n                                    source: {\n                                        kind: NodeKind.TrendsQuery,\n                                        series: [\n                                            {\n                                                kind: NodeKind.EventsNode,\n                                                event: '$pageview',\n                                                name: '$pageview',\n                                                math: BaseMathType.TotalCount,\n                                                properties: webAnalyticsFilters,\n                                            },\n                                        ],\n                                        dateRange,\n                                        conversionGoal,\n                                        trendsFilter: {\n                                            display: ChartDisplayType.CalendarHeatmap,\n                                        },\n                                        tags: WEB_ANALYTICS_DEFAULT_QUERY_TAGS,\n                                    },\n                                },\n                                docs: {\n                                    url: 'https://posthog.com/docs/web-analytics/dashboard#active-hours',\n                                    title: 'Active hours - Total pageviews',\n                                    description: (\n                                        <>\n                                            <div>\n                                                <p>\n                                                    Active hours displays a heatmap showing the total number of\n                                                    pageviews, broken down by hour of the day and day of the week.\n                                                </p>\n                                                <p>\n                                                    Each cell represents the number of total pageviews during a specific\n                                                    hour of a specific day. The \"All\" column aggregates totals for each\n                                                    day, and the bottom row aggregates totals for each hour. The\n                                                    bottom-right cell shows the grand total. The displayed time is based\n                                                    on your project's date and time settings (UTC by default,\n                                                    configurable in{' '}\n                                                    <Link to={urls.settings('project', 'date-and-time')}>\n                                                        project settings\n                                                    </Link>\n                                                    ).\n                                                </p>\n                                                <p>\n                                                    <strong>Note:</strong> Selecting a time range longer than 7 days\n                                                    will include additional occurrences of weekdays and hours,\n                                                    potentially increasing the user counts in those buckets. For best\n                                                    results, select 7 closed days or multiple of 7 closed day ranges.\n                                                </p>\n                                            </div>\n                                        </>\n                                    ),\n                                },\n                                insightProps: createInsightProps(TileId.ACTIVE_HOURS, ActiveHoursTab.TOTAL_EVENTS),\n                            },\n                        ],\n                    },\n                    // Hiding if conversionGoal is set already because values aren't representative\n                    !conversionGoal\n                        ? {\n                              kind: 'query',\n                              tileId: TileId.GOALS,\n                              title: 'Goals',\n                              layout: {\n                                  colSpanClassName: 'md:col-span-2',\n                              },\n                              query: {\n                                  full: true,\n                                  kind: NodeKind.DataTableNode,\n                                  source: {\n                                      kind: NodeKind.WebGoalsQuery,\n                                      properties: webAnalyticsFilters,\n                                      dateRange,\n                                      compareFilter,\n                                      sampling,\n                                      limit: 10,\n                                      orderBy: tablesOrderBy ?? undefined,\n                                      filterTestAccounts,\n                                      tags: WEB_ANALYTICS_DEFAULT_QUERY_TAGS,\n                                  },\n                                  embedded: true,\n                                  showActions: true,\n                                  columns: ['breakdown_value', 'visitors', 'views', 'cross_sell'],\n                              },\n                              insightProps: createInsightProps(TileId.GOALS),\n                              canOpenInsight: false,\n                              docs: {\n                                  url: 'https://posthog.com/docs/web-analytics/dashboard#goals',\n                                  title: 'Goals',\n                                  description: (\n                                      <>\n                                          <div>\n                                              <p>\n                                                  Goals shows your pinned or most recently created actions and the\n                                                  number of conversions they've had. You can set a custom event or\n                                                  action as a{' '}\n                                                  <Link to=\"https://posthog.com/docs/web-analytics/conversion-goals\">\n                                                      conversion goal\n                                                  </Link>{' '}\n                                                  at the top of the dashboard for more specific metrics.\n                                              </p>\n                                          </div>\n                                      </>\n                                  ),\n                              },\n                          }\n                        : null,\n                    !conversionGoal\n                        ? {\n                              kind: 'replay',\n                              tileId: TileId.REPLAY,\n                              layout: {\n                                  colSpanClassName: conversionGoal ? 'md:col-span-full' : 'md:col-span-1',\n                              },\n                              docs: {\n                                  url: 'https://posthog.com/docs/session-replay',\n                                  title: 'Session Replay',\n                                  description:\n                                      'Play back sessions to diagnose UI issues, improve support, and get context for nuanced user behavior.',\n                              },\n                          }\n                        : null,\n                    !conversionGoal && errorTrackingQ\n                        ? {\n                              kind: 'error_tracking',\n                              tileId: TileId.ERROR_TRACKING,\n                              layout: {\n                                  colSpanClassName: 'md:col-span-1',\n                              },\n                              query: errorTrackingQ,\n                              docs: {\n                                  url: 'https://posthog.com/docs/error-tracking',\n                                  title: 'Error Tracking',\n                                  description: (\n                                      <>\n                                          <div>\n                                              <p>\n                                                  Error tracking allows you to track, investigate, and resolve\n                                                  exceptions your customers face.\n                                              </p>\n                                              <p>\n                                                  Errors are captured as <code>$exception</code> events which means that\n                                                  you can create insights, filter recordings and trigger surveys based\n                                                  on them exactly the same way you can for any other type of event.\n                                              </p>\n                                          </div>\n                                      </>\n                                  ),\n                              },\n                          }\n                        : null,\n                    !conversionGoal && featureFlags[FEATURE_FLAGS.WEB_ANALYTICS_FRUSTRATING_PAGES_TILE]\n                        ? {\n                              kind: 'query',\n                              title: 'Frustrating Pages',\n                              tileId: TileId.FRUSTRATING_PAGES,\n                              layout: {\n                                  colSpanClassName: 'md:col-span-2',\n                              },\n                              query: {\n                                  full: true,\n                                  kind: NodeKind.DataTableNode,\n                                  source: {\n                                      kind: NodeKind.WebStatsTableQuery,\n                                      breakdownBy: WebStatsBreakdown.FrustrationMetrics,\n                                      dateRange,\n                                      filterTestAccounts,\n                                      properties: webAnalyticsFilters,\n                                      compareFilter,\n                                      limit: 10,\n                                      doPathCleaning: isPathCleaningEnabled,\n                                      tags: WEB_ANALYTICS_DEFAULT_QUERY_TAGS,\n                                  },\n                                  embedded: true,\n                                  showActions: true,\n                                  hiddenColumns: ['views'],\n                              },\n                              insightProps: createInsightProps(TileId.FRUSTRATING_PAGES, 'table'),\n                              canOpenModal: true,\n                              canOpenInsight: false,\n                              docs: {\n                                  title: 'Frustrating Pages',\n                                  description: (\n                                      <>\n                                          <div>\n                                              <p>\n                                                  See which pages are causing frustration by monitoring rage clicks,\n                                                  dead clicks, and errors.\n                                              </p>\n                                              <p>\n                                                  <ul>\n                                                      <li>\n                                                          A dead click is a click that doesn't result in any action.\n                                                          E.g. an image that looks like a button.\n                                                      </li>\n                                                      <li>\n                                                          Rageclicks are collected when a user clicks on a static\n                                                          element more than three times in a one-second window.\n                                                      </li>\n                                                      <li>\n                                                          Errors are JavaScript exceptions that occur when users\n                                                          interact with your site.\n                                                      </li>\n                                                  </ul>\n                                              </p>\n                                              <p>\n                                                  These are captured automatically and can help identify broken\n                                                  functionality, failed API calls, or other technical issues that\n                                                  frustrate users.\n                                              </p>\n                                          </div>\n                                      </>\n                                  ),\n                              },\n                          }\n                        : null,\n                ]\n                return allTiles\n                    .filter(isNotNil)\n                    .filter((tile) =>\n                        preAggregatedEnabled ? TILES_ALLOWED_ON_PRE_AGGREGATED.includes(tile.tileId) : true\n                    )\n                    .filter((tile) => !hiddenTiles.includes(tile.tileId))\n            },\n        ],\n        getNewInsightUrl: [(s) => [s.tiles], (tiles: WebAnalyticsTile[]) => getNewInsightUrlFactory(tiles)],\n    })),\n\n    // start the loaders after mounting the logic\n    afterMount(({ actions }) => {\n        actions.loadStatusCheck()\n        actions.loadShouldShowGeoIPQueries()\n    }),\n\n    tabAwareActionToUrl(({ values }) => {\n        const stateToUrl = (): string => {\n            const searchParams = { ...router.values.searchParams }\n            const urlParams = new URLSearchParams(searchParams)\n\n            const {\n                rawWebAnalyticsFilters,\n                conversionGoal,\n                dateFilter: { dateTo, dateFrom, interval },\n                _sourceTab,\n                _deviceTab,\n                _pathTab,\n                _geographyTab,\n                _graphsTab,\n                isPathCleaningEnabled,\n                shouldFilterTestAccounts,\n                compareFilter,\n                productTab,\n                webVitalsPercentile,\n                domainFilter,\n                deviceTypeFilter,\n                tileVisualizations,\n            } = values\n\n            // Make sure we're storing the raw filters only, or else we'll have issues with the domain/device type filters\n            // spreading from their individual dropdowns to the global filters list\n            if (rawWebAnalyticsFilters.length > 0) {\n                urlParams.set('filters', JSON.stringify(rawWebAnalyticsFilters))\n            }\n            if (conversionGoal) {\n                if ('actionId' in conversionGoal) {\n                    urlParams.set('conversionGoal.actionId', conversionGoal.actionId.toString())\n                } else {\n                    urlParams.set('conversionGoal.customEventName', conversionGoal.customEventName)\n                }\n            } else {\n                urlParams.delete('conversionGoal.actionId')\n                urlParams.delete('conversionGoal.customEventName')\n            }\n            if (dateFrom !== INITIAL_DATE_FROM || dateTo !== INITIAL_DATE_TO || interval !== INITIAL_INTERVAL) {\n                urlParams.set('date_from', dateFrom ?? '')\n                urlParams.set('date_to', dateTo ?? '')\n                urlParams.set('interval', interval ?? '')\n            }\n            if (_deviceTab) {\n                urlParams.set('device_tab', _deviceTab)\n            }\n            if (_sourceTab) {\n                urlParams.set('source_tab', _sourceTab)\n            }\n            if (_graphsTab) {\n                urlParams.set('graphs_tab', _graphsTab)\n            }\n            if (_pathTab) {\n                urlParams.set('path_tab', _pathTab)\n            }\n            if (_geographyTab) {\n                urlParams.set('geography_tab', _geographyTab)\n            }\n            if (isPathCleaningEnabled != null) {\n                urlParams.set('path_cleaning', isPathCleaningEnabled.toString())\n            }\n            if (shouldFilterTestAccounts != null) {\n                urlParams.set('filter_test_accounts', shouldFilterTestAccounts.toString())\n            }\n            if (compareFilter) {\n                urlParams.set('compare_filter', JSON.stringify(compareFilter))\n            } else {\n                urlParams.delete('compare_filter')\n            }\n\n            const { featureFlags } = featureFlagLogic.values\n            const pageReportsEnabled = !!featureFlags[FEATURE_FLAGS.WEB_ANALYTICS_PAGE_REPORTS]\n\n            if (productTab === ProductTab.WEB_VITALS) {\n                urlParams.set('percentile', webVitalsPercentile)\n            }\n            if (domainFilter) {\n                urlParams.set('domain', domainFilter)\n            }\n            if (deviceTypeFilter) {\n                urlParams.set('device_type', deviceTypeFilter)\n            } else {\n                urlParams.delete('device_type')\n            }\n            if (tileVisualizations) {\n                urlParams.set('tile_visualizations', JSON.stringify(tileVisualizations))\n            }\n\n            let basePath = '/web'\n            if (pageReportsEnabled && productTab === ProductTab.PAGE_REPORTS) {\n                basePath = '/web/page-reports'\n            } else if (productTab === ProductTab.WEB_VITALS) {\n                basePath = '/web/web-vitals'\n            } else if (productTab === ProductTab.MARKETING) {\n                basePath = '/web/marketing'\n            }\n            return `${basePath}${urlParams.toString() ? '?' + urlParams.toString() : ''}`\n        }\n\n        return {\n            setWebAnalyticsFilters: stateToUrl,\n            togglePropertyFilter: stateToUrl,\n            setConversionGoal: stateToUrl,\n            setDates: stateToUrl,\n            setInterval: stateToUrl,\n            setDeviceTab: stateToUrl,\n            setSourceTab: stateToUrl,\n            setGraphsTab: stateToUrl,\n            setPathTab: stateToUrl,\n            setGeographyTab: stateToUrl,\n            setActiveHoursTab: stateToUrl,\n            setCompareFilter: stateToUrl,\n            setProductTab: stateToUrl,\n            setWebVitalsPercentile: stateToUrl,\n            setIsPathCleaningEnabled: stateToUrl,\n            setDomainFilter: stateToUrl,\n            setDeviceTypeFilter: stateToUrl,\n            setTileVisualization: stateToUrl,\n        }\n    }),\n\n    tabAwareUrlToAction(({ actions, values }) => {\n        const toAction = (\n            { productTab = ProductTab.ANALYTICS }: { productTab?: ProductTab },\n            {\n                filters,\n                'conversionGoal.actionId': conversionGoalActionId,\n                'conversionGoal.customEventName': conversionGoalCustomEventName,\n                date_from,\n                date_to,\n                interval,\n                device_tab,\n                source_tab,\n                graphs_tab,\n                path_tab,\n                geography_tab,\n                active_hours_tab,\n                path_cleaning,\n                filter_test_accounts,\n                compare_filter,\n                percentile,\n                domain,\n                device_type,\n                tile_visualizations,\n            }: Record<string, any>\n        ): void => {\n            const { featureFlags } = featureFlagLogic.values\n            const pageReportsEnabled = !!featureFlags[FEATURE_FLAGS.WEB_ANALYTICS_PAGE_REPORTS]\n\n            // If trying to access page reports but the feature flag is not enabled, redirect to analytics\n            if (productTab === ProductTab.PAGE_REPORTS && !pageReportsEnabled) {\n                productTab = ProductTab.ANALYTICS\n            }\n\n            if (\n                ![ProductTab.ANALYTICS, ProductTab.WEB_VITALS, ProductTab.PAGE_REPORTS, ProductTab.MARKETING].includes(\n                    productTab\n                )\n            ) {\n                return\n            }\n\n            const parsedFilters = filters ? (isWebAnalyticsPropertyFilters(filters) ? filters : []) : undefined\n            if (parsedFilters && !objectsEqual(parsedFilters, values.webAnalyticsFilters)) {\n                actions.setWebAnalyticsFilters(parsedFilters)\n            }\n            if (\n                conversionGoalActionId &&\n                conversionGoalActionId !== (values.conversionGoal as ActionConversionGoal)?.actionId\n            ) {\n                actions.setConversionGoal({ actionId: parseInt(conversionGoalActionId, 10) })\n            } else if (\n                conversionGoalCustomEventName &&\n                conversionGoalCustomEventName !== (values.conversionGoal as CustomEventConversionGoal)?.customEventName\n            ) {\n                actions.setConversionGoal({ customEventName: conversionGoalCustomEventName })\n            }\n            if (\n                (date_from && date_from !== values.dateFilter.dateFrom) ||\n                (date_to && date_to !== values.dateFilter.dateTo) ||\n                (interval && interval !== values.dateFilter.interval)\n            ) {\n                actions.setDatesAndInterval(date_from, date_to, interval)\n            }\n            if (device_tab && device_tab !== values._deviceTab) {\n                actions.setDeviceTab(device_tab)\n            }\n            if (source_tab && source_tab !== values._sourceTab) {\n                actions.setSourceTab(source_tab)\n            }\n            if (graphs_tab && graphs_tab !== values._graphsTab) {\n                actions.setGraphsTab(graphs_tab)\n            }\n            if (path_tab && path_tab !== values._pathTab) {\n                actions.setPathTab(path_tab)\n            }\n            if (geography_tab && geography_tab !== values._geographyTab) {\n                actions.setGeographyTab(geography_tab)\n            }\n            if (active_hours_tab && active_hours_tab !== values._activeHoursTab) {\n                actions.setActiveHoursTab(active_hours_tab)\n            }\n            if (path_cleaning && path_cleaning !== values.isPathCleaningEnabled) {\n                actions.setIsPathCleaningEnabled([true, 'true', 1, '1'].includes(path_cleaning))\n            }\n            if (filter_test_accounts && filter_test_accounts !== values.shouldFilterTestAccounts) {\n                actions.setShouldFilterTestAccounts([true, 'true', 1, '1'].includes(filter_test_accounts))\n            }\n            if (\n                compare_filter &&\n                isCompareFilter(compare_filter) &&\n                !objectsEqual(compare_filter, values.compareFilter)\n            ) {\n                actions.setCompareFilter(compare_filter)\n            }\n            if (productTab && productTab !== values.productTab) {\n                actions.setProductTab(productTab)\n            }\n            if (percentile && percentile !== values.webVitalsPercentile) {\n                actions.setWebVitalsPercentile(percentile as WebVitalsPercentile)\n            }\n            if (domain && domain !== values.domainFilter) {\n                actions.setDomainFilter(domain === 'all' ? null : domain)\n            }\n            if (device_type && device_type !== values.deviceTypeFilter) {\n                actions.setDeviceTypeFilter(device_type)\n            }\n            if (tile_visualizations && !objectsEqual(tile_visualizations, values.tileVisualizations)) {\n                for (const [tileId, visualization] of Object.entries(tile_visualizations)) {\n                    actions.setTileVisualization(tileId as TileId, visualization as TileVisualizationOption)\n                }\n            }\n        }\n\n        return { '/web': toAction, '/web/:productTab': toAction, '/web/page-reports': toAction }\n    }),\n\n    listeners(({ values, actions }) => {\n        const checkGraphsTabIsCompatibleWithConversionGoal = (\n            tab: string,\n            conversionGoal: WebAnalyticsConversionGoal | null\n        ): void => {\n            if (conversionGoal) {\n                if (tab === GraphsTab.PAGE_VIEWS || tab === GraphsTab.NUM_SESSION) {\n                    actions.setGraphsTab(GraphsTab.UNIQUE_USERS)\n                }\n            } else {\n                if (\n                    tab === GraphsTab.TOTAL_CONVERSIONS ||\n                    tab === GraphsTab.CONVERSION_RATE ||\n                    tab === GraphsTab.UNIQUE_CONVERSIONS\n                ) {\n                    actions.setGraphsTab(GraphsTab.UNIQUE_USERS)\n                }\n            }\n        }\n\n        return {\n            setGraphsTab: ({ tab }) => {\n                checkGraphsTabIsCompatibleWithConversionGoal(tab, values.conversionGoal)\n            },\n            setConversionGoal: [\n                ({ conversionGoal }) => {\n                    checkGraphsTabIsCompatibleWithConversionGoal(values.graphsTab, conversionGoal)\n                },\n                ({ conversionGoal }, breakpoint) =>\n                    checkCustomEventConversionGoalHasSessionIdsHelper(\n                        conversionGoal,\n                        breakpoint,\n                        actions.setConversionGoalWarning\n                    ),\n            ],\n            [teamLogic.actionTypes.updateCurrentTeam]: async (action) => {\n                const isPreAggregatedEnabled =\n                    values.featureFlags[FEATURE_FLAGS.SETTINGS_WEB_ANALYTICS_PRE_AGGREGATED_TABLES] &&\n                    action?.modifiers?.useWebAnalyticsPreAggregatedTables\n                const hasConversionGoalPreAggFlag =\n                    values.featureFlags[FEATURE_FLAGS.WEB_ANALYTICS_CONVERSION_GOAL_PREAGG]\n\n                if (isPreAggregatedEnabled && values.conversionGoal && !hasConversionGoalPreAggFlag) {\n                    actions.setConversionGoal(null)\n                    lemonToast.info(\n                        'Your conversion goal has been cleared as the new query engine does not support it (yet!)'\n                    )\n                }\n            },\n        }\n    }),\n    afterMount(({ actions, values }) => {\n        checkCustomEventConversionGoalHasSessionIdsHelper(\n            values.conversionGoal,\n            undefined,\n            actions.setConversionGoalWarning\n        ).catch(() => {\n            // ignore, this warning is just a nice-to-have, no point showing an error to the user\n        })\n    }),\n])\n\nconst checkCustomEventConversionGoalHasSessionIdsHelper = async (\n    conversionGoal: WebAnalyticsConversionGoal | null,\n    breakpoint: BreakPointFunction | undefined,\n    setConversionGoalWarning: (warning: ConversionGoalWarning | null) => void\n): Promise<void> => {\n    if (!conversionGoal || !('customEventName' in conversionGoal) || !conversionGoal.customEventName) {\n        setConversionGoalWarning(null)\n        return\n    }\n    const { customEventName } = conversionGoal\n    // check if we have any conversion events from the last week without sessions ids\n\n    const response = await hogqlQuery(\n        hogql`select count()\n              from events\n              where timestamp >= (now() - toIntervalHour(24))\n                AND ($session_id IS NULL\n                 OR $session_id = '')\n                AND event = {event}`,\n        { event: customEventName }\n    )\n    breakpoint?.()\n    const row = response.results[0]\n    if (row[0]) {\n        setConversionGoalWarning(ConversionGoalWarning.CustomEventWithNoSessionId)\n    } else {\n        setConversionGoalWarning(null)\n    }\n}\n","import { useValues } from 'kea'\n\nimport { LemonCollapse, LemonModal, Link } from '@posthog/lemon-ui'\n\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { urls } from 'scenes/urls'\n\nimport { FeatureFlagType } from '~/types'\n\nimport EarlyAccessFeatureImage from 'public/early-access-feature-demo.png'\n\ninterface InstructionsModalProps {\n    flag: FeatureFlagType['key']\n    visible: boolean\n    onClose: () => void\n}\n\nexport function InstructionsModal({ onClose, visible, flag }: InstructionsModalProps): JSX.Element {\n    const { preflight } = useValues(preflightLogic)\n\n    const getCloudPanels = (): JSX.Element => (\n        <LemonCollapse\n            className=\"mt-2 bg-surface-primary\"\n            defaultActiveKey=\"1\"\n            panels={[\n                {\n                    key: '1',\n                    header: 'Option 1: Widget Site App',\n                    content: (\n                        <div>\n                            Give your users a{' '}\n                            <Link to={urls.hogFunctionNew('template-early-access-features')}>prebuilt widget</Link> to\n                            opt-in to features\n                            <img className=\"max-h-full max-w-full mt-2.5\" src={EarlyAccessFeatureImage} />\n                        </div>\n                    ),\n                },\n                {\n                    key: '2',\n                    header: 'Option 2: Custom implementation',\n                    content: (\n                        <div>\n                            <b>Opt user in</b>\n                            <div>\n                                <FeatureEnrollInstructions flag={flag} />\n                            </div>\n\n                            <b>Opt user out</b>\n                            <div>\n                                <FeatureUnenrollInstructions flag={flag} />\n                            </div>\n\n                            <b>Retrieve Previews</b>\n                            <div>\n                                <RetrievePreviewsInstructions />\n                            </div>\n                        </div>\n                    ),\n                },\n            ]}\n        />\n    )\n\n    const getSelfHostedPanels = (): JSX.Element => (\n        <div>\n            <b>Opt user in</b>\n            <div>\n                <FeatureEnrollInstructions flag={flag} />\n            </div>\n\n            <b>Opt user out</b>\n            <div>\n                <FeatureUnenrollInstructions flag={flag} />\n            </div>\n\n            <b>Retrieve Previews</b>\n            <div>\n                <RetrievePreviewsInstructions />\n            </div>\n        </div>\n    )\n\n    const panels: JSX.Element = preflight?.cloud ? getCloudPanels() : getSelfHostedPanels()\n\n    return (\n        <LemonModal title=\"How to implement opt-in feature flags\" isOpen={visible} onClose={onClose} width={640}>\n            <div>\n                <div className=\"mb-2\">\n                    Implement manual release condition toggles to give your users the ability choose which features they\n                    want to try\n                </div>\n                {panels}\n            </div>\n        </LemonModal>\n    )\n}\n\nfunction FeatureEnrollInstructions({ flag }: { flag: string }): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.updateEarlyAccessFeatureEnrollment(\"${flag}\", true)\n`}\n        </CodeSnippet>\n    )\n}\n\nfunction FeatureUnenrollInstructions({ flag }: { flag: string }): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.updateEarlyAccessFeatureEnrollment(\"${flag}\", false)\n`}\n        </CodeSnippet>\n    )\n}\n\nfunction RetrievePreviewsInstructions(): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.getEarlyAccessFeatures((previewItemData) => {\n    // do something with early access feature\n})\n`}\n        </CodeSnippet>\n    )\n}\n","import {\n    DataTableNode,\n    DateRange,\n    DocumentSimilarityQuery,\n    ErrorTrackingIssueCorrelationQuery,\n    ErrorTrackingQuery,\n    ErrorTrackingSimilarIssuesQuery,\n    EventsQuery,\n    InsightVizNode,\n    NodeKind,\n} from '~/queries/schema/schema-general'\nimport { HogQLQueryString, hogql, setLatestVersionsOnQuery } from '~/queries/utils'\nimport {\n    AnyPropertyFilter,\n    BaseMathType,\n    ChartDisplayType,\n    ProductKey,\n    PropertyFilterType,\n    PropertyGroupFilter,\n    PropertyOperator,\n    UniversalFiltersGroup,\n} from '~/types'\n\nimport { LIMIT_ITEMS } from './components/Breakdowns/consts'\nimport {\n    ERROR_TRACKING_DETAILS_RESOLUTION,\n    ERROR_TRACKING_LISTING_RESOLUTION,\n    SEARCHABLE_EXCEPTION_PROPERTIES,\n} from './utils'\n\nexport const errorTrackingQuery = ({\n    orderBy,\n    status,\n    dateRange,\n    assignee,\n    filterTestAccounts,\n    filterGroup,\n    searchQuery,\n    volumeResolution = ERROR_TRACKING_LISTING_RESOLUTION,\n    columns,\n    orderDirection,\n    personId,\n    limit = 50,\n}: Pick<\n    ErrorTrackingQuery,\n    | 'orderBy'\n    | 'status'\n    | 'dateRange'\n    | 'assignee'\n    | 'filterTestAccounts'\n    | 'limit'\n    | 'searchQuery'\n    | 'orderDirection'\n    | 'personId'\n> & {\n    filterGroup: UniversalFiltersGroup\n    columns: string[]\n    volumeResolution?: number\n}): DataTableNode => {\n    return {\n        kind: NodeKind.DataTableNode,\n        source: {\n            kind: NodeKind.ErrorTrackingQuery,\n            orderBy,\n            status,\n            dateRange,\n            assignee,\n            volumeResolution,\n            filterGroup: filterGroup as PropertyGroupFilter,\n            filterTestAccounts: filterTestAccounts,\n            searchQuery: searchQuery,\n            limit: limit,\n            orderDirection,\n            withAggregations: true,\n            withFirstEvent: false,\n            personId,\n            tags: {\n                productKey: ProductKey.ERROR_TRACKING,\n            },\n        },\n        showActions: false,\n        showTimings: false,\n        columns: columns,\n    }\n}\n\nexport const errorTrackingIssueQuery = ({\n    issueId,\n    dateRange,\n    filterGroup,\n    filterTestAccounts,\n    searchQuery,\n    volumeResolution = ERROR_TRACKING_DETAILS_RESOLUTION,\n    withFirstEvent = false,\n    withLastEvent = false,\n    withAggregations = false,\n}: {\n    issueId: string\n    dateRange: DateRange\n    filterGroup?: UniversalFiltersGroup\n    filterTestAccounts: boolean\n    searchQuery?: string\n    volumeResolution?: number\n    withFirstEvent?: boolean\n    withLastEvent?: boolean\n    withAggregations?: boolean\n}): ErrorTrackingQuery => {\n    return setLatestVersionsOnQuery<ErrorTrackingQuery>({\n        kind: NodeKind.ErrorTrackingQuery,\n        issueId,\n        dateRange,\n        filterGroup: filterGroup as PropertyGroupFilter,\n        orderBy: 'last_seen',\n        filterTestAccounts,\n        searchQuery,\n        volumeResolution,\n        withFirstEvent,\n        withAggregations,\n        withLastEvent,\n        tags: {\n            productKey: ProductKey.ERROR_TRACKING,\n        },\n    })\n}\n\nexport const errorTrackingIssueEventsQuery = ({\n    fingerprints,\n    filterTestAccounts,\n    filterGroup,\n    searchQuery,\n    dateRange,\n    columns,\n}: {\n    fingerprints: string[]\n    filterTestAccounts: boolean\n    filterGroup: UniversalFiltersGroup\n    searchQuery: string\n    dateRange: DateRange\n    columns: string[]\n}): EventsQuery => {\n    const group = filterGroup.values[0] as UniversalFiltersGroup\n    const properties = [...group.values] as AnyPropertyFilter[]\n\n    let where_string = `properties.$exception_fingerprint in [${fingerprints.map((f) => `'${f}'`).join(', ')}]`\n    if (searchQuery) {\n        // This is an ugly hack for the fact I don't think we support nested property filters in\n        // the eventsquery\n        where_string += ' AND ('\n        const chunks: string[] = []\n        SEARCHABLE_EXCEPTION_PROPERTIES.forEach((prop) => {\n            chunks.push(`ilike(toString(properties.${prop}), '%${searchQuery}%')`)\n        })\n        where_string += chunks.join(' OR ')\n        where_string += ')'\n    }\n\n    const where = [where_string]\n\n    const eventsQuery: EventsQuery = {\n        kind: NodeKind.EventsQuery,\n        event: '$exception',\n        select: columns,\n        where,\n        properties,\n        filterTestAccounts: filterTestAccounts,\n        after: dateRange.date_from ?? undefined,\n        before: dateRange.date_to ?? undefined,\n    }\n\n    return eventsQuery\n}\n\nexport const errorTrackingIssueCorrelationQuery = ({\n    events,\n}: {\n    events: string[]\n}): ErrorTrackingIssueCorrelationQuery => {\n    return setLatestVersionsOnQuery<ErrorTrackingIssueCorrelationQuery>({\n        kind: NodeKind.ErrorTrackingIssueCorrelationQuery,\n        events,\n        tags: { productKey: ProductKey.ERROR_TRACKING },\n    })\n}\n\nexport const errorTrackingSimilarIssuesQuery = ({\n    issueId,\n    limit,\n    maxDistance,\n}: {\n    issueId: string\n    limit: number\n    maxDistance: number\n}): ErrorTrackingSimilarIssuesQuery => {\n    return setLatestVersionsOnQuery<ErrorTrackingSimilarIssuesQuery>({\n        kind: NodeKind.ErrorTrackingSimilarIssuesQuery,\n        issueId,\n        limit,\n        maxDistance,\n        tags: { productKey: ProductKey.ERROR_TRACKING },\n    })\n}\n\nexport const errorTrackingDocumentSimilarityQuery = ({\n    documentId,\n    timestamp,\n}: {\n    documentId: string\n    timestamp: string\n}): DocumentSimilarityQuery => {\n    return setLatestVersionsOnQuery<DocumentSimilarityQuery>({\n        kind: NodeKind.DocumentSimilarityQuery,\n        origin: {\n            product: 'error_tracking',\n            document_type: 'fingerprint',\n            document_id: documentId,\n            timestamp,\n        },\n        dateRange: {},\n        order_by: 'distance',\n        order_direction: 'asc',\n        distance_func: 'cosineDistance',\n        model: 'text-embedding-3-small-1536',\n        products: ['error_tracking'],\n        document_types: ['fingerprint'],\n        renderings: [],\n        tags: { productKey: ProductKey.ERROR_TRACKING },\n    })\n}\n\nexport const errorTrackingIssueFingerprintsQuery = (\n    issue_id: string,\n    first_seen: string,\n    fingerprints: string[]\n): HogQLQueryString => {\n    return hogql`SELECT properties.$exception_fingerprint as fingerprint, count() as c, groupUniqArray(map('type', properties.$exception_types[1], 'value', properties.$exception_values[1])) as samples\n                FROM events\n                WHERE event = '$exception' and issue_id = ${issue_id} and has(${fingerprints}, properties.$exception_fingerprint) and timestamp >= toDateTime(${first_seen})\n                GROUP BY properties.$exception_fingerprint`\n}\n\nexport const errorTrackingIssueBreakdownQuery = ({\n    breakdownProperty,\n    dateRange,\n    filterTestAccounts,\n    filterGroup,\n    issueId,\n}: {\n    breakdownProperty: string\n    dateRange: DateRange\n    filterTestAccounts: boolean\n    filterGroup: UniversalFiltersGroup\n    issueId: string\n}): InsightVizNode => {\n    const group = filterGroup.values[0] as UniversalFiltersGroup\n    const properties = [...group.values] as AnyPropertyFilter[]\n\n    const query: InsightVizNode = {\n        kind: NodeKind.InsightVizNode,\n        source: {\n            kind: NodeKind.TrendsQuery,\n            trendsFilter: {\n                display: ChartDisplayType.ActionsBarValue,\n            },\n            breakdownFilter: {\n                breakdown_type: 'event',\n                breakdown: breakdownProperty,\n                breakdown_limit: LIMIT_ITEMS,\n            },\n            series: [\n                {\n                    kind: NodeKind.EventsNode,\n                    event: '$exception',\n                    math: BaseMathType.TotalCount,\n                    properties: [\n                        {\n                            key: '$exception_issue_id',\n                            type: PropertyFilterType.Event,\n                            value: issueId,\n                            operator: PropertyOperator.Exact,\n                        },\n                        ...properties,\n                    ],\n                },\n            ],\n            dateRange: dateRange,\n            filterTestAccounts,\n        },\n    }\n\n    return query\n}\n","import { actions, afterMount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { router } from 'kea-router'\n\nimport api from 'lib/api'\nimport { TaxonomicFilterGroupType } from 'lib/components/TaxonomicFilter/types'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { dayjs } from 'lib/dayjs'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { tabAwareActionToUrl } from 'lib/logic/scenes/tabAwareActionToUrl'\nimport { tabAwareUrlToAction } from 'lib/logic/scenes/tabAwareUrlToAction'\nimport { objectsEqual } from 'lib/utils'\nimport { isDefinitionStale } from 'lib/utils/definitions'\nimport { ProductIntentContext } from 'lib/utils/product-intents'\nimport { insightDataLogic } from 'scenes/insights/insightDataLogic'\nimport { sceneLogic } from 'scenes/sceneLogic'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { groupsModel } from '~/models/groupsModel'\nimport { isAnyPropertyFilters } from '~/queries/schema-guards'\nimport { DataTableNode, LLMTrace, NodeKind, TraceQuery, TrendsQuery } from '~/queries/schema/schema-general'\nimport { QueryContext } from '~/queries/types'\nimport {\n    AnyPropertyFilter,\n    BaseMathType,\n    Breadcrumb,\n    ChartDisplayType,\n    EventDefinitionType,\n    HogQLMathType,\n    InsightShortId,\n    ProductKey,\n    PropertyFilterType,\n    PropertyMathType,\n    PropertyOperator,\n} from '~/types'\n\nimport type { llmAnalyticsLogicType } from './llmAnalyticsLogicType'\n\nexport const LLM_ANALYTICS_DATA_COLLECTION_NODE_ID = 'llm-analytics-data'\n\nconst INITIAL_DASHBOARD_DATE_FROM = '-7d' as string | null\nconst INITIAL_EVENTS_DATE_FROM = '-1d' as string | null\nconst INITIAL_DATE_TO = null as string | null\n\nexport function getDefaultGenerationsColumns(showInputOutput: boolean): string[] {\n    return [\n        'uuid',\n        'properties.$ai_trace_id',\n        ...(showInputOutput ? ['properties.$ai_input[-1]', 'properties.$ai_output_choices'] : []),\n        'person',\n        \"f'{properties.$ai_model}' -- Model\",\n        \"f'{round(toFloat(properties.$ai_latency), 2)} s' -- Latency\",\n        \"f'{properties.$ai_input_tokens} → {properties.$ai_output_tokens} (∑ {toInt(properties.$ai_input_tokens) + toInt(properties.$ai_output_tokens)})' -- Token usage\",\n        \"f'${round(toFloat(properties.$ai_total_cost_usd), 6)}' -- Total cost\",\n        'timestamp',\n    ]\n}\n\nexport interface QueryTile {\n    title: string\n    description?: string\n    query: TrendsQuery\n    context?: QueryContext\n    layout?: {\n        className?: string\n    }\n}\n\nexport interface LLMAnalyticsLogicProps {\n    personId?: string\n    tabId?: string\n}\n\n/**\n * Helper function to get date range for a specific day.\n * @param day - The day string from the chart (e.g., \"2024-01-15\")\n * @returns Object with date_from and date_to formatted strings\n */\nfunction getDayDateRange(day: string): { date_from: string; date_to: string } {\n    const dayStart = dayjs(day).startOf('day')\n    return {\n        date_from: dayStart.format('YYYY-MM-DD[T]HH:mm:ss'),\n        date_to: dayStart.add(1, 'day').subtract(1, 'second').format('YYYY-MM-DD[T]HH:mm:ss'),\n    }\n}\n\nexport const llmAnalyticsLogic = kea<llmAnalyticsLogicType>([\n    path(['products', 'llm_analytics', 'frontend', 'llmAnalyticsLogic']),\n    props({} as LLMAnalyticsLogicProps),\n    key((props: LLMAnalyticsLogicProps) => props?.personId || 'llmAnalyticsScene'),\n    connect(() => ({\n        values: [sceneLogic, ['sceneKey'], groupsModel, ['groupsEnabled']],\n        actions: [teamLogic, ['addProductIntent']],\n    })),\n\n    actions({\n        setDates: (dateFrom: string | null, dateTo: string | null) => ({ dateFrom, dateTo }),\n        setDashboardDateFilter: (dateFrom: string | null, dateTo: string | null) => ({ dateFrom, dateTo }),\n        setShouldFilterTestAccounts: (shouldFilterTestAccounts: boolean) => ({ shouldFilterTestAccounts }),\n        setPropertyFilters: (propertyFilters: AnyPropertyFilter[]) => ({ propertyFilters }),\n        setGenerationsQuery: (query: DataTableNode) => ({ query }),\n        setGenerationsColumns: (columns: string[]) => ({ columns }),\n        setTracesQuery: (query: DataTableNode) => ({ query }),\n        refreshAllDashboardItems: true,\n        setRefreshStatus: (tileId: string, loading?: boolean) => ({ tileId, loading }),\n        toggleGenerationExpanded: (uuid: string, traceId: string) => ({ uuid, traceId }),\n        setLoadedTrace: (traceId: string, trace: LLMTrace) => ({ traceId, trace }),\n        clearExpandedGenerations: true,\n    }),\n\n    reducers({\n        dateFilter: [\n            {\n                dateFrom: INITIAL_EVENTS_DATE_FROM,\n                dateTo: INITIAL_DATE_TO,\n            },\n            {\n                setDates: (_, { dateFrom, dateTo }) => ({ dateFrom, dateTo }),\n            },\n        ],\n\n        dashboardDateFilter: [\n            {\n                dateFrom: INITIAL_DASHBOARD_DATE_FROM,\n                dateTo: INITIAL_DATE_TO,\n            },\n            {\n                setDates: (_, { dateFrom, dateTo }) => ({ dateFrom, dateTo }),\n            },\n        ],\n\n        shouldFilterTestAccounts: [\n            false,\n            {\n                setShouldFilterTestAccounts: (_, { shouldFilterTestAccounts }) => shouldFilterTestAccounts,\n            },\n        ],\n\n        propertyFilters: [\n            [] as AnyPropertyFilter[],\n            {\n                setPropertyFilters: (_, { propertyFilters }) => propertyFilters,\n            },\n        ],\n\n        generationsQueryOverride: [\n            null as DataTableNode | null,\n            {\n                setGenerationsQuery: (_, { query }) => query,\n            },\n        ],\n\n        generationsColumns: [\n            null as string[] | null,\n            { persist: true },\n            {\n                setGenerationsColumns: (_, { columns }) => columns,\n            },\n        ],\n\n        tracesQueryOverride: [\n            null as DataTableNode | null,\n            {\n                setTracesQuery: (_, { query }) => query,\n            },\n        ],\n\n        refreshStatus: [\n            {} as Record<string, { loading?: boolean; timer?: Date }>,\n            {\n                setRefreshStatus: (state, { tileId, loading }) => ({\n                    ...state,\n                    [tileId]: loading ? { loading: true, timer: new Date() } : state[tileId],\n                }),\n                refreshAllDashboardItems: () => ({}),\n            },\n        ],\n        newestRefreshed: [\n            null as Date | null,\n            {\n                setRefreshStatus: (state, { loading }) => (!loading ? new Date() : state),\n            },\n        ],\n\n        expandedGenerationIds: [\n            new Set<string>() as Set<string>,\n            {\n                toggleGenerationExpanded: (state, { uuid }) => {\n                    const newSet = new Set(state)\n                    if (newSet.has(uuid)) {\n                        newSet.delete(uuid)\n                    } else {\n                        newSet.add(uuid)\n                    }\n                    return newSet\n                },\n                clearExpandedGenerations: () => new Set<string>(),\n                setDates: () => new Set<string>(),\n                setPropertyFilters: () => new Set<string>(),\n                setShouldFilterTestAccounts: () => new Set<string>(),\n            },\n        ],\n\n        loadedTraces: [\n            {} as Record<string, LLMTrace>,\n            {\n                setLoadedTrace: (state, { traceId, trace }) => ({\n                    ...state,\n                    [traceId]: trace,\n                }),\n                clearExpandedGenerations: () => ({}),\n                setDates: () => ({}),\n                setPropertyFilters: () => ({}),\n                setShouldFilterTestAccounts: () => ({}),\n            },\n        ],\n    }),\n\n    loaders({\n        hasSentAiGenerationEvent: {\n            __default: undefined as boolean | undefined,\n            loadAIEventDefinition: async (): Promise<boolean> => {\n                const aiGenerationDefinition = await api.eventDefinitions.list({\n                    event_type: EventDefinitionType.Event,\n                    search: '$ai_generation',\n                })\n\n                // no need to worry about pagination here, event names beginning with $ are reserved, and we're not\n                // going to add enough reserved event names that match this search term to cause problems\n                const definition = aiGenerationDefinition.results.find((r) => r.name === '$ai_generation')\n                if (definition && !isDefinitionStale(definition)) {\n                    return true\n                }\n                return false\n            },\n        },\n    }),\n\n    listeners(({ actions, values }) => ({\n        toggleGenerationExpanded: async ({ uuid, traceId }) => {\n            // Only load if expanding and not already loaded\n            if (values.expandedGenerationIds.has(uuid) && !values.loadedTraces[traceId]) {\n                // Build TraceQuery with date range from current filters\n                const dateFrom = values.dateFilter.dateFrom || '-7d'\n                const dateTo = values.dateFilter.dateTo || undefined\n\n                const traceQuery: TraceQuery = {\n                    kind: NodeKind.TraceQuery,\n                    traceId,\n                    dateRange: {\n                        date_from: dateFrom,\n                        date_to: dateTo,\n                    },\n                }\n\n                try {\n                    const response = await api.query(traceQuery)\n                    if (response.results && response.results.length > 0) {\n                        actions.setLoadedTrace(traceId, response.results[0])\n                    }\n                } catch (error) {\n                    console.error('Failed to load trace:', error)\n                }\n            }\n        },\n    })),\n\n    selectors({\n        activeTab: [\n            (s) => [s.sceneKey],\n            (sceneKey) => {\n                if (sceneKey === 'llmAnalyticsGenerations') {\n                    return 'generations'\n                } else if (sceneKey === 'llmAnalyticsTraces') {\n                    return 'traces'\n                } else if (sceneKey === 'llmAnalyticsUsers') {\n                    return 'users'\n                } else if (sceneKey === 'llmAnalyticsPlayground') {\n                    return 'playground'\n                } else if (sceneKey === 'llmAnalyticsDatasets') {\n                    return 'datasets'\n                } else if (sceneKey === 'llmAnalyticsEvaluations') {\n                    return 'evaluations'\n                }\n                return 'dashboard'\n            },\n        ],\n\n        tiles: [\n            (s) => [s.dashboardDateFilter, s.shouldFilterTestAccounts, s.propertyFilters],\n            (dashboardDateFilter, shouldFilterTestAccounts, propertyFilters): QueryTile[] => [\n                {\n                    title: 'Traces',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                                math: HogQLMathType.HogQL,\n                                math_hogql: 'COUNT(DISTINCT properties.$ai_trace_id)',\n                            },\n                        ],\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        insightProps: {\n                            dashboardItemId: `new-traces-query`,\n                        },\n                        onDataPointClick: (series) => {\n                            if (typeof series.day === 'string') {\n                                // NOTE: This assumes the chart is day-by-day\n                                const { date_from, date_to } = getDayDateRange(series.day)\n                                router.actions.push(urls.llmAnalyticsTraces(), {\n                                    ...router.values.searchParams,\n                                    date_from,\n                                    date_to,\n                                })\n                            }\n                        },\n                    },\n                },\n                {\n                    title: 'Generative AI users',\n                    description: 'To count users, set `distinct_id` in LLM tracking.',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                                math: BaseMathType.UniqueUsers,\n                            },\n                        ],\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters.concat({\n                            type: PropertyFilterType.HogQL,\n                            key: 'distinct_id != properties.$ai_trace_id',\n                        }),\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        insightProps: {\n                            dashboardItemId: `new-generations-query`,\n                        },\n                        onDataPointClick: (series) => {\n                            if (typeof series.day === 'string') {\n                                const { date_from, date_to } = getDayDateRange(series.day)\n\n                                router.actions.push(urls.llmAnalyticsUsers(), {\n                                    ...router.values.searchParams,\n                                    date_from,\n                                    date_to,\n                                })\n                            }\n                        },\n                    },\n                },\n                {\n                    title: 'Total cost (USD)',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                math: PropertyMathType.Sum,\n                                kind: NodeKind.EventsNode,\n                                math_property: '$ai_total_cost_usd',\n                            },\n                        ],\n                        trendsFilter: {\n                            aggregationAxisPrefix: '$',\n                            decimalPlaces: 4,\n                            display: ChartDisplayType.BoldNumber,\n                        },\n                        dateRange: {\n                            date_from: dashboardDateFilter.dateFrom,\n                            date_to: dashboardDateFilter.dateTo,\n                            explicitDate: true,\n                        },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        groupTypeLabel: 'traces',\n                        onDataPointClick: () => {\n                            router.actions.push(urls.llmAnalyticsTraces(), {\n                                ...router.values.searchParams,\n                                // Use same date range as dashboard to ensure we'll see the same data after click\n                                date_from: dashboardDateFilter.dateFrom,\n                                date_to: dashboardDateFilter.dateTo,\n                            })\n                        },\n                    },\n                },\n                {\n                    title: 'Cost per user (USD)',\n                    description: \"Average cost for each generative AI user active in the data point's period.\",\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                math: PropertyMathType.Sum,\n                                kind: NodeKind.EventsNode,\n                                math_property: '$ai_total_cost_usd',\n                            },\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                                math: BaseMathType.UniqueUsers,\n                            },\n                        ],\n                        trendsFilter: {\n                            formula: 'A / B',\n                            aggregationAxisPrefix: '$',\n                            decimalPlaces: 2,\n                        },\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters.concat({\n                            type: PropertyFilterType.HogQL,\n                            key: 'distinct_id != properties.$ai_trace_id',\n                        }),\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        insightProps: {\n                            dashboardItemId: `new-cost-per-user-query`,\n                        },\n                        onDataPointClick: (series) => {\n                            if (typeof series.day === 'string') {\n                                const { date_from, date_to } = getDayDateRange(series.day)\n\n                                router.actions.push(urls.llmAnalyticsUsers(), {\n                                    ...router.values.searchParams,\n                                    date_from,\n                                    date_to,\n                                })\n                            }\n                        },\n                    },\n                },\n                {\n                    title: 'Cost by model (USD)',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                math: PropertyMathType.Sum,\n                                kind: NodeKind.EventsNode,\n                                math_property: '$ai_total_cost_usd',\n                            },\n                        ],\n                        breakdownFilter: {\n                            breakdown_type: 'event',\n                            breakdown: '$ai_model',\n                        },\n                        trendsFilter: {\n                            aggregationAxisPrefix: '$',\n                            decimalPlaces: 2,\n                            display: ChartDisplayType.ActionsBarValue,\n                            showValuesOnSeries: true,\n                        },\n                        dateRange: {\n                            date_from: dashboardDateFilter.dateFrom,\n                            date_to: dashboardDateFilter.dateTo,\n                            explicitDate: true,\n                        },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        groupTypeLabel: 'traces',\n                        onDataPointClick: ({ breakdown }) => {\n                            router.actions.push(urls.llmAnalyticsTraces(), {\n                                ...router.values.searchParams,\n                                // Use same date range as dashboard to ensure we'll see the same data after click\n                                date_from: dashboardDateFilter.dateFrom,\n                                date_to: dashboardDateFilter.dateTo,\n                                filters: [\n                                    ...(router.values.searchParams.filters || []),\n                                    {\n                                        type: PropertyFilterType.Event,\n                                        key: '$ai_model',\n                                        operator: PropertyOperator.Exact,\n                                        value: breakdown as string,\n                                    },\n                                ],\n                            })\n                        },\n                    },\n                },\n                {\n                    title: 'Generation calls',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                            },\n                        ],\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        groupTypeLabel: 'generations',\n                        insightProps: {\n                            dashboardItemId: `new-generation-calls-query`,\n                        },\n                        onDataPointClick: (series) => {\n                            if (typeof series.day === 'string') {\n                                const { date_from, date_to } = getDayDateRange(series.day)\n                                router.actions.push(urls.llmAnalyticsGenerations(), {\n                                    ...router.values.searchParams,\n                                    date_from,\n                                    date_to,\n                                })\n                            }\n                        },\n                    },\n                },\n                {\n                    title: 'AI Errors',\n                    description: 'Failed AI generation calls',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                            },\n                        ],\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters.concat({\n                            type: PropertyFilterType.Event,\n                            key: '$ai_is_error',\n                            operator: PropertyOperator.Exact,\n                            value: true,\n                        }),\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        groupTypeLabel: 'errors',\n                        insightProps: {\n                            dashboardItemId: `new-ai-errors-query`,\n                        },\n                        onDataPointClick: (series) => {\n                            if (typeof series.day === 'string') {\n                                const { date_from, date_to } = getDayDateRange(series.day)\n                                router.actions.push(urls.llmAnalyticsGenerations(), {\n                                    ...router.values.searchParams,\n                                    date_from,\n                                    date_to,\n                                    filters: [\n                                        ...(router.values.searchParams.filters || []),\n                                        {\n                                            type: PropertyFilterType.Event,\n                                            key: '$ai_is_error',\n                                            operator: PropertyOperator.Exact,\n                                            value: true,\n                                        },\n                                    ] as AnyPropertyFilter[],\n                                })\n                            }\n                        },\n                    },\n                },\n                {\n                    title: 'Generation latency by model (median)',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                math: PropertyMathType.Median,\n                                kind: NodeKind.EventsNode,\n                                math_property: '$ai_latency',\n                            },\n                        ],\n                        breakdownFilter: {\n                            breakdown: '$ai_model',\n                        },\n                        trendsFilter: {\n                            aggregationAxisPostfix: ' s',\n                            decimalPlaces: 2,\n                        },\n                        dateRange: { date_from: dashboardDateFilter.dateFrom, date_to: dashboardDateFilter.dateTo },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        groupTypeLabel: 'generations',\n                        insightProps: {\n                            dashboardItemId: `new-generation-latency-by-model-query`,\n                        },\n                        onDataPointClick: (series) => {\n                            if (typeof series.day === 'string') {\n                                const { date_from, date_to } = getDayDateRange(series.day)\n                                router.actions.push(urls.llmAnalyticsGenerations(), {\n                                    ...router.values.searchParams,\n                                    date_from,\n                                    date_to,\n                                    filters: [\n                                        ...(router.values.searchParams.filters || []),\n                                        {\n                                            type: PropertyFilterType.Event,\n                                            key: '$ai_model',\n                                            operator: PropertyOperator.Exact,\n                                            value: series.breakdown as string,\n                                        },\n                                    ] as AnyPropertyFilter[],\n                                })\n                            }\n                        },\n                    },\n                },\n                {\n                    title: 'Generations by HTTP status',\n                    query: {\n                        kind: NodeKind.TrendsQuery,\n                        series: [\n                            {\n                                event: '$ai_generation',\n                                name: '$ai_generation',\n                                kind: NodeKind.EventsNode,\n                            },\n                        ],\n                        breakdownFilter: {\n                            breakdown: '$ai_http_status',\n                        },\n                        trendsFilter: {\n                            display: ChartDisplayType.ActionsBarValue,\n                        },\n                        dateRange: {\n                            date_from: dashboardDateFilter.dateFrom,\n                            date_to: dashboardDateFilter.dateTo,\n                            explicitDate: true,\n                        },\n                        properties: propertyFilters,\n                        filterTestAccounts: shouldFilterTestAccounts,\n                    },\n                    context: {\n                        groupTypeLabel: 'generations',\n                        onDataPointClick: (series) => {\n                            router.actions.push(urls.llmAnalyticsGenerations(), {\n                                ...router.values.searchParams,\n                                // Use same date range as dashboard to ensure we'll see the same data after click\n                                date_from: dashboardDateFilter.dateFrom,\n                                date_to: dashboardDateFilter.dateTo,\n                                filters: [\n                                    ...(router.values.searchParams.filters || []),\n                                    {\n                                        type: PropertyFilterType.Event,\n                                        key: '$ai_http_status',\n                                        operator: PropertyOperator.Exact,\n                                        value: series.breakdown as string,\n                                    },\n                                ] as AnyPropertyFilter[],\n                            })\n                        },\n                    },\n                },\n            ],\n        ],\n\n        tracesQuery: [\n            (s) => [s.tracesQueryOverride, s.defaultTracesQuery],\n            (override, defQuery) => override || defQuery,\n        ],\n        defaultTracesQuery: [\n            (s) => [\n                s.dateFilter,\n                s.shouldFilterTestAccounts,\n                s.propertyFilters,\n                (_, props) => props.personId,\n                groupsModel.selectors.groupsTaxonomicTypes,\n                featureFlagLogic.selectors.featureFlags,\n            ],\n            (\n                dateFilter,\n                shouldFilterTestAccounts,\n                propertyFilters,\n                personId,\n                groupsTaxonomicTypes,\n                featureFlags\n            ): DataTableNode => ({\n                kind: NodeKind.DataTableNode,\n                source: {\n                    kind: NodeKind.TracesQuery,\n                    dateRange: {\n                        date_from: dateFilter.dateFrom || undefined,\n                        date_to: dateFilter.dateTo || undefined,\n                    },\n                    filterTestAccounts: shouldFilterTestAccounts ?? false,\n                    properties: propertyFilters,\n                    ...(personId ? { personId } : {}),\n                },\n                columns: [\n                    'id',\n                    'traceName',\n                    ...(featureFlags[FEATURE_FLAGS.LLM_OBSERVABILITY_SHOW_INPUT_OUTPUT]\n                        ? ['inputState', 'outputState']\n                        : []),\n                    'person',\n                    'totalLatency',\n                    'usage',\n                    'totalCost',\n                    'timestamp',\n                ],\n                showDateRange: true,\n                showReload: true,\n                showSearch: true,\n                showTestAccountFilters: true,\n                showExport: true,\n                showOpenEditorButton: false,\n                showColumnConfigurator: false,\n                showPropertyFilter: [\n                    TaxonomicFilterGroupType.EventProperties,\n                    TaxonomicFilterGroupType.PersonProperties,\n                    ...groupsTaxonomicTypes,\n                    TaxonomicFilterGroupType.Cohorts,\n                    TaxonomicFilterGroupType.HogQLExpression,\n                ],\n            }),\n        ],\n        generationsQuery: [\n            (s) => [s.generationsQueryOverride, s.defaultGenerationsQuery],\n            (override, defQuery) => override || defQuery,\n        ],\n        defaultGenerationsQuery: [\n            (s) => [\n                s.dateFilter,\n                s.shouldFilterTestAccounts,\n                s.propertyFilters,\n                s.generationsColumns,\n                groupsModel.selectors.groupsTaxonomicTypes,\n                featureFlagLogic.selectors.featureFlags,\n            ],\n            (\n                dateFilter,\n                shouldFilterTestAccounts,\n                propertyFilters,\n                generationsColumns,\n                groupsTaxonomicTypes,\n                featureFlags\n            ): DataTableNode => ({\n                kind: NodeKind.DataTableNode,\n                source: {\n                    kind: NodeKind.EventsQuery,\n                    select:\n                        generationsColumns ||\n                        getDefaultGenerationsColumns(!!featureFlags[FEATURE_FLAGS.LLM_OBSERVABILITY_SHOW_INPUT_OUTPUT]),\n                    orderBy: ['timestamp DESC'],\n                    after: dateFilter.dateFrom || undefined,\n                    before: dateFilter.dateTo || undefined,\n                    filterTestAccounts: shouldFilterTestAccounts,\n                    event: '$ai_generation',\n                    properties: propertyFilters,\n                },\n                showDateRange: true,\n                showReload: true,\n                showSearch: true,\n                showTestAccountFilters: true,\n                showColumnConfigurator: true,\n                showPropertyFilter: [\n                    TaxonomicFilterGroupType.EventProperties,\n                    TaxonomicFilterGroupType.PersonProperties,\n                    ...groupsTaxonomicTypes,\n                    TaxonomicFilterGroupType.Cohorts,\n                    TaxonomicFilterGroupType.HogQLExpression,\n                ],\n                showExport: true,\n                showActions: false,\n            }),\n        ],\n        usersQuery: [\n            (s) => [\n                s.dateFilter,\n                s.shouldFilterTestAccounts,\n                s.propertyFilters,\n                groupsModel.selectors.groupsTaxonomicTypes,\n            ],\n            (dateFilter, shouldFilterTestAccounts, propertyFilters, groupsTaxonomicTypes): DataTableNode => ({\n                kind: NodeKind.DataTableNode,\n                source: {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                SELECT\n                    argMax(user_tuple, timestamp) as user,\n                    countDistinctIf(ai_trace_id, notEmpty(ai_trace_id)) as traces,\n                    count() as generations,\n                    round(sum(toFloat(ai_total_cost_usd)), 4) as total_cost,\n                    min(timestamp) as first_seen,\n                    max(timestamp) as last_seen\n                FROM (\n                    SELECT\n                        distinct_id,\n                        timestamp,\n                        JSONExtractRaw(properties, '$ai_trace_id') as ai_trace_id,\n                        JSONExtractRaw(properties, '$ai_total_cost_usd') as ai_total_cost_usd,\n                        tuple(\n                            distinct_id,\n                            person.created_at,\n                            person.properties\n                        ) as user_tuple\n                    FROM events\n                    WHERE event = '$ai_generation' AND {filters}\n                )\n                GROUP BY distinct_id\n                ORDER BY total_cost DESC\n                LIMIT 50\n                    `,\n                    filters: {\n                        dateRange: {\n                            date_from: dateFilter.dateFrom || null,\n                            date_to: dateFilter.dateTo || null,\n                        },\n                        filterTestAccounts: shouldFilterTestAccounts,\n                        properties: propertyFilters,\n                    },\n                },\n                columns: ['user', 'traces', 'generations', 'total_cost', 'first_seen', 'last_seen'],\n                showDateRange: true,\n                showReload: true,\n                showSearch: true,\n                showPropertyFilter: [\n                    TaxonomicFilterGroupType.EventProperties,\n                    TaxonomicFilterGroupType.PersonProperties,\n                    ...groupsTaxonomicTypes,\n                    TaxonomicFilterGroupType.Cohorts,\n                    TaxonomicFilterGroupType.HogQLExpression,\n                ],\n                showTestAccountFilters: true,\n                showExport: true,\n                showColumnConfigurator: true,\n            }),\n        ],\n        isRefreshing: [\n            (s) => [s.refreshStatus],\n            (refreshStatus) => Object.values(refreshStatus).some((status) => status.loading),\n        ],\n        breadcrumbs: [\n            () => [],\n            (): Breadcrumb[] => {\n                return [\n                    {\n                        key: 'llm_analytics',\n                        name: 'LLM Analytics',\n                        iconType: 'llm_analytics',\n                    },\n                ]\n            },\n        ],\n    }),\n\n    tabAwareUrlToAction(({ actions, values }) => {\n        function applySearchParams({ filters, date_from, date_to, filter_test_accounts }: Record<string, any>): void {\n            const parsedFilters = isAnyPropertyFilters(filters) ? filters : []\n            if (!objectsEqual(parsedFilters, values.propertyFilters)) {\n                actions.setPropertyFilters(parsedFilters)\n            }\n\n            if (\n                (date_from || INITIAL_EVENTS_DATE_FROM) !== values.dateFilter.dateFrom ||\n                (date_to || INITIAL_DATE_TO) !== values.dateFilter.dateTo\n            ) {\n                actions.setDates(date_from || INITIAL_EVENTS_DATE_FROM, date_to || INITIAL_DATE_TO)\n            }\n\n            const filterTestAccountsValue = [true, 'true', 1, '1'].includes(filter_test_accounts)\n            if (filterTestAccountsValue !== values.shouldFilterTestAccounts) {\n                actions.setShouldFilterTestAccounts(filterTestAccountsValue)\n            }\n        }\n\n        return {\n            [urls.llmAnalyticsDashboard()]: (_, searchParams) => {\n                applySearchParams(searchParams)\n                actions.addProductIntent({\n                    product_type: ProductKey.LLM_ANALYTICS,\n                    intent_context: ProductIntentContext.LLM_ANALYTICS_VIEWED,\n                })\n            },\n            [urls.llmAnalyticsGenerations()]: (_, searchParams) => applySearchParams(searchParams),\n            [urls.llmAnalyticsTraces()]: (_, searchParams) => applySearchParams(searchParams),\n            [urls.llmAnalyticsUsers()]: (_, searchParams) => applySearchParams(searchParams),\n            [urls.llmAnalyticsPlayground()]: (_, searchParams) => applySearchParams(searchParams),\n        }\n    }),\n\n    tabAwareActionToUrl(() => ({\n        setPropertyFilters: ({ propertyFilters }) => [\n            router.values.location.pathname,\n            {\n                ...router.values.searchParams,\n                filters: propertyFilters.length > 0 ? propertyFilters : undefined,\n            },\n        ],\n        setDates: ({ dateFrom, dateTo }) => [\n            router.values.location.pathname,\n            {\n                ...router.values.searchParams,\n                date_from: dateFrom === INITIAL_EVENTS_DATE_FROM ? undefined : dateFrom || undefined,\n                date_to: dateTo || undefined,\n            },\n        ],\n        setShouldFilterTestAccounts: ({ shouldFilterTestAccounts }) => [\n            router.values.location.pathname,\n            {\n                ...router.values.searchParams,\n                filter_test_accounts: shouldFilterTestAccounts ? 'true' : undefined,\n            },\n        ],\n    })),\n\n    afterMount(({ actions }) => {\n        actions.loadAIEventDefinition()\n    }),\n\n    listeners(({ actions, values }) => ({\n        refreshAllDashboardItems: async () => {\n            // Set loading state for all tiles\n            values.tiles.forEach((_, index) => {\n                actions.setRefreshStatus(`tile-${index}`, true)\n            })\n\n            try {\n                // Refresh all tiles in parallel\n                values.tiles.map((tile, index) => {\n                    const insightProps = {\n                        dashboardItemId: tile.context?.insightProps?.dashboardItemId as InsightShortId,\n                    }\n                    const mountedInsightDataLogic = insightDataLogic.findMounted(insightProps)\n                    if (mountedInsightDataLogic) {\n                        mountedInsightDataLogic.actions.loadData('force_blocking')\n                    }\n                    actions.setRefreshStatus(`tile-${index}`, false)\n                })\n            } catch (error) {\n                console.error('Error refreshing dashboard items:', error)\n                // Clear loading states on error\n                values.tiles.forEach((_, index) => {\n                    actions.setRefreshStatus(`tile-${index}`, false)\n                })\n            }\n        },\n    })),\n])\n","import { actions, afterMount, kea, listeners, path, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { router } from 'kea-router'\n\nimport { lemonToast } from '@posthog/lemon-ui'\n\nimport api from 'lib/api'\nimport { uuid } from 'lib/utils'\nimport { isObject } from 'lib/utils'\nimport { urls } from 'scenes/urls'\n\nimport type { llmAnalyticsPlaygroundLogicType } from './llmAnalyticsPlaygroundLogicType'\nimport { normalizeRole } from './utils'\n\nexport interface ModelOption {\n    id: string\n    name: string\n    provider: string\n    description: string\n}\n\nexport interface PlaygroundResponse {\n    text: string\n    model: string\n    usage: {\n        prompt_tokens: number | null\n        completion_tokens: number | null\n        total_tokens: number | null\n    }\n}\n\nenum NormalizedMessageRole {\n    User = 'user',\n    Assistant = 'assistant',\n    System = 'system',\n}\n\nexport type MessageRole = `${NormalizedMessageRole}`\n\nexport interface Message {\n    role: MessageRole\n    content: string\n}\n\ninterface RawMessage {\n    role: string\n    content: unknown\n}\n\nenum InputMessageRole {\n    User = 'user',\n    Assistant = 'assistant',\n    AI = 'ai',\n    Model = 'model',\n    System = 'system',\n}\n\ntype ConversationRole = NormalizedMessageRole.User | NormalizedMessageRole.Assistant\n\nfunction extractConversationMessage(rawMessage: RawMessage): Message {\n    const normalizedRole = normalizeRole(rawMessage.role, NormalizedMessageRole.User)\n    const enumMap: Partial<Record<string, ConversationRole>> = {\n        [InputMessageRole.User]: NormalizedMessageRole.User,\n        [InputMessageRole.Assistant]: NormalizedMessageRole.Assistant,\n    }\n\n    const enumRole: ConversationRole | undefined = enumMap[normalizedRole]\n\n    // Default to 'user' role when we don't understand the role\n    // Better to show the message as a user message than to drop it entirely\n    const roleToUse = enumRole ?? NormalizedMessageRole.User\n\n    return {\n        role: roleToUse,\n        content: typeof rawMessage.content === 'string' ? rawMessage.content : JSON.stringify(rawMessage.content),\n    }\n}\n\nexport interface ComparisonItem {\n    id: string\n    model: string\n    systemPrompt: string\n    requestMessages: Message[]\n    response: string\n    usage?: {\n        prompt_tokens?: number | null\n        completion_tokens?: number | null\n        total_tokens?: number | null\n    }\n    ttftMs?: number | null\n    latencyMs?: number | null\n}\n\nconst DEFAULT_MODEL = 'gpt-4.1'\n\nfunction pickByPrefix(query: string, idList: string[]): string | null {\n    let best = null\n    for (const s of idList) {\n        if (query.startsWith(s)) {\n            if (best === null || s.length > best.length) {\n                best = s\n            }\n        }\n    }\n    return best\n}\n\nfunction matchClosestModel(targetModel: string, availableModels: ModelOption[]): string {\n    const ids = availableModels.map((m) => m.id)\n    if (ids.includes(targetModel)) {\n        return targetModel\n    }\n    const match = pickByPrefix(targetModel, ids)\n    if (match) {\n        return match\n    }\n    return DEFAULT_MODEL\n}\n\nexport const llmAnalyticsPlaygroundLogic = kea<llmAnalyticsPlaygroundLogicType>([\n    path(['products', 'llm_analytics', 'frontend', 'llmAnalyticsPlaygroundLogic']),\n\n    actions({\n        setModel: (model: string) => ({ model }),\n        setSystemPrompt: (systemPrompt: string) => ({ systemPrompt }),\n        setMaxTokens: (maxTokens: number | null) => ({ maxTokens }),\n        setThinking: (thinking: boolean) => ({ thinking }),\n        setReasoningLevel: (reasoningLevel: 'minimal' | 'low' | 'medium' | 'high' | null) => ({ reasoningLevel }),\n        setTools: (tools: any) => ({ tools }),\n        clearConversation: true,\n        submitPrompt: true,\n        setMessages: (messages: Message[]) => ({ messages }),\n        deleteMessage: (index: number) => ({ index }),\n        addAssistantMessageChunk: (text: string) => ({ text }),\n        addFinalizedContent: (text: string) => ({ text }),\n        addToolCallChunk: (toolCall: { id?: string; function: { name?: string; arguments?: string } }) => ({\n            toolCall,\n        }),\n        clearToolCalls: true,\n        finalizeAssistantMessage: true,\n        addMessage: (message?: Partial<Message>) => ({ message }),\n        updateMessage: (index: number, payload: Partial<Message>) => ({ index, payload }),\n        addResponseToHistory: (content: string) => ({ content }),\n        addCurrentRunToComparison: true,\n        setLastRunDetails: (details: ComparisonItem | null) => ({ details }),\n        addToComparison: (item: ComparisonItem) => ({ item }),\n        removeFromComparison: (id: string) => ({ id }),\n        clearComparison: true,\n        setupPlaygroundFromEvent: (payload: { model?: string; input?: any; tools?: any }) => ({ payload }),\n        setResponseError: (hasError: boolean) => ({ hasError }),\n        clearResponseError: true,\n    }),\n\n    reducers({\n        model: ['', { setModel: (_, { model }) => model }],\n        systemPrompt: ['You are a helpful AI assistant.', { setSystemPrompt: (_, { systemPrompt }) => systemPrompt }],\n        maxTokens: [null as number | null, { setMaxTokens: (_, { maxTokens }) => maxTokens }],\n        thinking: [false, { setThinking: (_, { thinking }) => thinking }],\n        reasoningLevel: [\n            null as 'minimal' | 'low' | 'medium' | 'high' | null,\n            { setReasoningLevel: (_, { reasoningLevel }) => reasoningLevel },\n        ],\n        tools: [null as any, { setTools: (_, { tools }) => tools }],\n        messages: [\n            [] as Message[],\n            {\n                clearConversation: () => [],\n                setMessages: (_, { messages }) => messages,\n                deleteMessage: (state, { index }) => state.filter((_, i) => i !== index),\n                addMessage: (state, { message }) => {\n                    const defaultMessage: Message = { role: 'user', content: '' }\n                    return [...state, { ...defaultMessage, ...message }]\n                },\n                updateMessage: (state, { index, payload }) => {\n                    if (index < 0 || index >= state.length) {\n                        return state\n                    }\n                    const newState = [...state]\n                    newState[index] = { ...newState[index], ...payload }\n                    return newState\n                },\n                addResponseToHistory: (state, { content }) => {\n                    if (content) {\n                        return [...state, { role: 'assistant', content }]\n                    }\n                    return state\n                },\n            },\n        ],\n        submitting: [\n            false as boolean,\n            {\n                submitPrompt: () => true,\n                addAssistantMessageChunk: () => true,\n                finalizeAssistantMessage: () => false,\n            },\n        ],\n        currentToolCalls: [\n            [] as Array<{ id: string; name: string; arguments: string }>,\n            {\n                submitPrompt: () => [],\n                clearConversation: () => [],\n                setMessages: () => [],\n                clearToolCalls: () => [],\n                addToolCallChunk: (state, { toolCall }) => {\n                    if (toolCall.id && toolCall.id !== 'null') {\n                        const existingIndex = state.findIndex((tc) => tc.id === toolCall.id)\n                        if (existingIndex >= 0) {\n                            const updated = [...state]\n                            updated[existingIndex] = {\n                                ...updated[existingIndex],\n                                name: toolCall.function?.name || updated[existingIndex].name,\n                                arguments: updated[existingIndex].arguments + (toolCall.function?.arguments || ''),\n                            }\n                            return updated\n                        }\n                        return [\n                            ...state,\n                            {\n                                id: toolCall.id,\n                                name: toolCall.function?.name || '',\n                                arguments: toolCall.function?.arguments || '',\n                            },\n                        ]\n                    }\n\n                    if (state.length === 0) {\n                        return state\n                    }\n\n                    const updated = [...state]\n                    const lastIndex = updated.length - 1\n                    updated[lastIndex] = {\n                        ...updated[lastIndex],\n                        arguments: updated[lastIndex].arguments + (toolCall.function?.arguments || ''),\n                    }\n                    return updated\n                },\n            },\n        ],\n        currentResponse: [\n            null as string | null,\n            {\n                submitPrompt: () => '',\n                addAssistantMessageChunk: (state, { text }) => (state ?? '') + text,\n                addFinalizedContent: (state, { text }) => (state ?? '') + text,\n                addResponseToHistory: () => null,\n                clearConversation: () => null,\n                setMessages: () => null,\n            },\n        ],\n        lastRunDetails: [\n            null as ComparisonItem | null,\n            {\n                submitPrompt: () => null,\n                setLastRunDetails: (_, { details }) => details,\n                addToComparison: () => null,\n                clearConversation: () => null,\n                setMessages: () => null,\n            },\n        ],\n        comparisonItems: [\n            [] as ComparisonItem[],\n            {\n                addToComparison: (state, { item }) => [...state, item],\n                removeFromComparison: (state, { id }) => state.filter((item) => item.id !== id),\n                clearComparison: () => [],\n            },\n        ],\n        responseHasError: [\n            false as boolean,\n            {\n                submitPrompt: () => false,\n                setResponseError: (_, { hasError }) => hasError,\n                clearResponseError: () => false,\n                clearConversation: () => false,\n                setMessages: () => false,\n                addResponseToHistory: () => false,\n            },\n        ],\n    }),\n    loaders(({ values }) => ({\n        modelOptions: {\n            __default: [] as ModelOption[],\n            loadModelOptions: async () => {\n                try {\n                    const response = await api.get('/api/llm_proxy/models/')\n                    if (!response) {\n                        return []\n                    }\n                    const options = response as ModelOption[]\n                    const closestMatch = matchClosestModel(values.model, options)\n                    if (values.model !== closestMatch) {\n                        llmAnalyticsPlaygroundLogic.actions.setModel(closestMatch)\n                    }\n                    return options\n                } catch (error) {\n                    console.error('Error loading model options:', error)\n                    return values.modelOptions\n                }\n            },\n        },\n    })),\n    listeners(({ actions, values }) => ({\n        finalizeAssistantMessage: () => {\n            const toolCalls = values.currentToolCalls\n            if (toolCalls.length > 0) {\n                const toolCallsText = toolCalls\n                    .map((tc) => JSON.stringify({ id: tc.id, name: tc.name, arguments: tc.arguments }, null, 2))\n                    .join('\\n\\n')\n\n                if (toolCallsText) {\n                    const separator = values.currentResponse && values.currentResponse.trim() ? '\\n\\n' : ''\n                    actions.addFinalizedContent(separator + toolCallsText)\n                }\n            }\n            actions.clearToolCalls()\n        },\n        submitPrompt: async (_, breakpoint) => {\n            const requestModel = values.model\n            const requestSystemPrompt = values.systemPrompt\n            const messagesToSend = values.messages.filter(\n                (m) => (m.role === 'user' || m.role === 'assistant' || m.role === 'system') && m.content.trim()\n            )\n\n            const requestMessages = messagesToSend\n\n            if (messagesToSend.length === 0) {\n                lemonToast.error('Please add some messages before running the prompt')\n                actions.finalizeAssistantMessage()\n                return\n            }\n\n            let responseUsage: ComparisonItem['usage'] = {}\n            let ttftMs: number | null = null\n            let latencyMs: number | null = null\n            let firstTokenTime: number | null = null\n\n            // Declare startTime outside try block\n            let startTime: number | null = null\n\n            try {\n                // Start timer for latency? Might be inaccurate due to network etc.\n                startTime = performance.now()\n\n                const requestData: any = {\n                    system: requestSystemPrompt,\n                    messages: messagesToSend.filter((m) => m.role === 'user' || m.role === 'assistant'),\n                    model: requestModel,\n                    thinking: values.thinking,\n                }\n\n                // Include tools if available\n                if (values.tools) {\n                    requestData.tools = values.tools\n                }\n\n                // Only include max_tokens if it has a value\n                if (values.maxTokens !== null && values.maxTokens > 0) {\n                    requestData.max_tokens = values.maxTokens\n                }\n\n                // Include optional reasoning level if provided\n                if (values.reasoningLevel) {\n                    requestData.reasoning_level = values.reasoningLevel\n                }\n\n                await api.stream('/api/llm_proxy/completion', {\n                    method: 'POST',\n                    data: requestData,\n                    headers: { 'Content-Type': 'application/json' },\n                    onMessage: (event) => {\n                        breakpoint()\n                        if (!event.data) {\n                            return\n                        }\n                        try {\n                            const data = JSON.parse(event.data)\n                            if (data.type === 'text') {\n                                if (firstTokenTime === null && startTime !== null) {\n                                    firstTokenTime = performance.now()\n                                    ttftMs = firstTokenTime - startTime\n                                }\n                                actions.addAssistantMessageChunk(data.text)\n                            } else if (data.type === 'tool_call') {\n                                if (firstTokenTime === null && startTime !== null) {\n                                    firstTokenTime = performance.now()\n                                    ttftMs = firstTokenTime - startTime\n                                }\n                                actions.addToolCallChunk(data)\n                            } else if (data.type === 'usage') {\n                                responseUsage = {\n                                    prompt_tokens: data.prompt_tokens ?? null,\n                                    completion_tokens: data.completion_tokens ?? null,\n                                    total_tokens: data.total_tokens ?? null,\n                                }\n                            } else if (data.error) {\n                                console.error('LLM Error:', data.error)\n                                actions.addAssistantMessageChunk(`\\n\\n**LLM Error:** ${data.error}`)\n                                actions.setResponseError(true)\n                            }\n                        } catch (e) {\n                            console.error('Error parsing stream message:', e, 'Data:', event.data)\n                            actions.addAssistantMessageChunk(`\\n\\n**Stream Error:** Could not parse response chunk.`)\n                            actions.setResponseError(true)\n                        }\n                    },\n                    onError: (err) => {\n                        console.error('Stream error:', err)\n                        actions.addAssistantMessageChunk(\n                            `\\n\\n**Stream Connection Error:** ${err.message || 'Unknown error'}`\n                        )\n                        actions.setResponseError(true)\n                        actions.finalizeAssistantMessage()\n                    },\n                })\n                actions.finalizeAssistantMessage()\n            } catch (error) {\n                console.error('Submit prompt error:', error)\n                actions.addAssistantMessageChunk(`\\n\\n**Error:** Failed to initiate prompt submission.`)\n                actions.setResponseError(true)\n                lemonToast.error('Failed to connect to LLM service. Please try again.')\n                actions.finalizeAssistantMessage()\n            } finally {\n                if (startTime) {\n                    const endTime = performance.now()\n                    latencyMs = endTime - startTime\n                }\n            }\n\n            if (values.currentResponse !== null) {\n                const runDetails: ComparisonItem = {\n                    id: uuid(),\n                    model: requestModel,\n                    systemPrompt: requestSystemPrompt,\n                    requestMessages: requestMessages,\n                    response: values.currentResponse,\n                    usage: responseUsage,\n                    ttftMs: ttftMs,\n                    latencyMs: latencyMs,\n                }\n                actions.setLastRunDetails(runDetails)\n            }\n        },\n        addCurrentRunToComparison: () => {\n            if (values.lastRunDetails) {\n                actions.addToComparison(values.lastRunDetails)\n            }\n        },\n        setupPlaygroundFromEvent: ({ payload }) => {\n            const { model, input, tools } = payload\n\n            if (model) {\n                actions.setModel(matchClosestModel(model, values.modelOptions))\n            }\n\n            // Set tools if available\n            if (tools) {\n                actions.setTools(tools)\n            }\n\n            let systemPromptContent: string | undefined = undefined\n            let conversationMessages: Message[] = []\n            let initialUserPrompt: string | undefined = undefined\n\n            if (input) {\n                try {\n                    // Case 1: Input is a standard messages array\n                    if (Array.isArray(input) && input.every((msg) => msg.role && msg.content)) {\n                        // Find and set system message\n                        const systemMessage = input.find((msg) => msg.role === 'system')\n                        if (systemMessage?.content && typeof systemMessage.content === 'string') {\n                            systemPromptContent = systemMessage.content\n                        }\n\n                        // Extract user and assistant messages for history (skip system messages as they're handled separately)\n                        conversationMessages = input\n                            .filter((msg: RawMessage) => msg.role !== 'system')\n                            .map((msg: RawMessage) => extractConversationMessage(msg))\n                    }\n                    // Case 2: Input is just a single string prompt\n                    else if (typeof input === 'string') {\n                        initialUserPrompt = input\n                    }\n                    // Case 3: Input is some other object (try to extract content)\n                    else if (isObject(input)) {\n                        if (typeof input.content === 'string') {\n                            initialUserPrompt = input.content\n                        } else if (input.content && typeof input.content !== 'string') {\n                            initialUserPrompt = JSON.stringify(input.content, null, 2)\n                        } else {\n                            initialUserPrompt = JSON.stringify(input, null, 2)\n                        }\n                    }\n                } catch (e) {\n                    console.error('Error processing input for playground:', e)\n                    initialUserPrompt = String(input)\n                    conversationMessages = []\n                }\n            }\n\n            // Set state in playground logic\n            if (systemPromptContent) {\n                actions.setSystemPrompt(systemPromptContent)\n            } else {\n                // Reset to default if no system prompt found in the input\n                actions.setSystemPrompt('You are a helpful AI assistant.')\n            }\n\n            // If the input was just a string, add it as the first user message\n            if (initialUserPrompt) {\n                // Prepend it so it appears first in the playground\n                conversationMessages.unshift({ role: 'user', content: initialUserPrompt })\n            }\n\n            actions.setMessages(conversationMessages) // Set the extracted history (potentially including the initial prompt)\n\n            // Navigate to the playground\n            router.actions.push(urls.llmAnalyticsPlayground())\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadModelOptions()\n    }),\n    selectors({}),\n])\n","import api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\n\nimport { LLMTrace, LLMTraceEvent } from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\n\nimport type { EvaluationRun } from './evaluations/types'\nimport type { SpanAggregation } from './llmAnalyticsTraceDataLogic'\nimport {\n    AnthropicInputMessage,\n    AnthropicTextMessage,\n    AnthropicThinkingMessage,\n    AnthropicToolCallMessage,\n    AnthropicToolResultMessage,\n    CompatMessage,\n    CompatToolCall,\n    LiteLLMChoice,\n    LiteLLMResponse,\n    OpenAICompletionMessage,\n    OpenAIToolCall,\n    VercelSDKImageMessage,\n    VercelSDKInputImageMessage,\n    VercelSDKInputTextMessage,\n    VercelSDKTextMessage,\n} from './types'\n\nfunction formatUsage(inputTokens: number, outputTokens?: number | null): string | null {\n    return `${inputTokens} → ${outputTokens || 0} (∑ ${inputTokens + (outputTokens || 0)})`\n}\n\nexport function formatLLMUsage(\n    trace_or_event_or_aggregation: LLMTrace | LLMTraceEvent | SpanAggregation\n): string | null {\n    // Handle SpanAggregation\n    if (\n        'totalCost' in trace_or_event_or_aggregation &&\n        'totalLatency' in trace_or_event_or_aggregation &&\n        'hasGenerationChildren' in trace_or_event_or_aggregation\n    ) {\n        const aggregation = trace_or_event_or_aggregation as SpanAggregation\n        return formatUsage(aggregation.inputTokens || 0, aggregation.outputTokens)\n    }\n\n    // Handle LLMTraceEvent\n    if ('properties' in trace_or_event_or_aggregation) {\n        const event = trace_or_event_or_aggregation as LLMTraceEvent\n        if (typeof event.properties.$ai_input_tokens === 'number') {\n            return formatUsage(event.properties.$ai_input_tokens, event.properties.$ai_output_tokens)\n        }\n    }\n\n    // Handle LLMTrace\n    const trace = trace_or_event_or_aggregation as LLMTrace\n    if (typeof trace.inputTokens === 'number') {\n        return formatUsage(trace.inputTokens, trace.outputTokens)\n    }\n\n    return null\n}\n\nexport const LATENCY_MINUTES_DISPLAY_THRESHOLD_SECONDS = 90\n\nexport function formatLLMLatency(latency: number, showMinutes?: boolean): string {\n    const roundedLatency = Math.round(latency * 100) / 100\n    if (showMinutes && latency > LATENCY_MINUTES_DISPLAY_THRESHOLD_SECONDS) {\n        const minutes = (latency / 60).toFixed(2)\n        return `${roundedLatency} s (${minutes} m)`\n    }\n    return `${roundedLatency} s`\n}\n\nconst usdFormatter = new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD',\n    maximumFractionDigits: 4,\n})\n\nexport function formatLLMCost(cost: number): string {\n    return usdFormatter.format(cost)\n}\n\nexport function isLLMEvent(item: LLMTrace | LLMTraceEvent): item is LLMTraceEvent {\n    return 'properties' in item\n}\n\nfunction normalizeSessionId(value: unknown): string | null {\n    return typeof value === 'string' && value.length > 0 ? value : null\n}\n\nfunction sessionIdFromEvents(events?: LLMTraceEvent[] | null): string | null {\n    if (!events || events.length === 0) {\n        return null\n    }\n\n    const uniqueSessionIds = events.reduce((acc, current) => {\n        const candidate = normalizeSessionId(current.properties?.$session_id)\n        if (candidate) {\n            acc.add(candidate)\n        }\n        return acc\n    }, new Set<string>())\n\n    if (uniqueSessionIds.size !== 1) {\n        return null\n    }\n\n    return Array.from(uniqueSessionIds)[0]\n}\n\nexport function getSessionID(event: LLMTrace | LLMTraceEvent, childEvents?: LLMTraceEvent[]): string | null {\n    if (isLLMEvent(event)) {\n        if (event.event === '$ai_trace') {\n            const directSessionId = normalizeSessionId(event.properties?.$session_id)\n\n            return directSessionId ?? sessionIdFromEvents(childEvents)\n        }\n\n        return normalizeSessionId(event.properties?.$session_id)\n    }\n\n    return sessionIdFromEvents(childEvents ?? event.events)\n}\n\nexport function getEventType(event: LLMTrace | LLMTraceEvent): string {\n    if (isLLMEvent(event)) {\n        switch (event.event) {\n            case '$ai_generation':\n                return 'generation'\n            case '$ai_embedding':\n                return 'embedding'\n            case '$ai_trace':\n                return 'trace'\n            default:\n                return 'span'\n        }\n    }\n    return 'trace'\n}\n\nexport function getRecordingStatus(event: LLMTrace | LLMTraceEvent): string | null {\n    if (isLLMEvent(event)) {\n        return event.properties.$recording_status || null\n    }\n\n    return event.events.find((e) => e.properties.$recording_status !== null)?.properties.$recording_status || null\n}\n\nexport function isOpenAICompatToolCall(input: unknown): input is OpenAIToolCall {\n    return (\n        input !== null &&\n        typeof input === 'object' &&\n        'type' in input &&\n        'function' in input &&\n        input.type === 'function' &&\n        typeof input.function === 'object' &&\n        input.function !== null\n    )\n}\n\nexport function isOpenAICompatToolCallsArray(input: any): input is OpenAIToolCall[] {\n    return Array.isArray(input) && input.every(isOpenAICompatToolCall)\n}\n\nexport function isOpenAICompatMessage(output: unknown): output is OpenAICompletionMessage {\n    return (\n        !!output &&\n        typeof output === 'object' &&\n        'role' in output &&\n        'content' in output &&\n        (typeof output.content === 'string' || output.content === null)\n    )\n}\n\nexport function parseOpenAIToolCalls(toolCalls: OpenAIToolCall[]): CompatToolCall[] {\n    const toolsWithParsedArguments = toolCalls.map((toolCall) => {\n        let parsedArguments = toolCall.function.arguments\n\n        if (typeof toolCall.function.arguments === 'string') {\n            try {\n                parsedArguments = JSON.parse(toolCall.function.arguments)\n            } catch (e) {\n                console.warn('Failed to parse tool call arguments as JSON:', toolCall.function.arguments, e)\n                // Keep the original string if parsing fails\n                parsedArguments = toolCall.function.arguments\n            }\n        }\n\n        return {\n            ...toolCall,\n            function: {\n                ...toolCall.function,\n                arguments: parsedArguments,\n            },\n        }\n    })\n\n    return toolsWithParsedArguments\n}\n\nexport function isAnthropicTextMessage(output: unknown): output is AnthropicTextMessage {\n    return !!output && typeof output === 'object' && 'type' in output && output.type === 'text' && 'text' in output\n}\n\nexport function isAnthropicToolCallMessage(output: unknown): output is AnthropicToolCallMessage {\n    return !!output && typeof output === 'object' && 'type' in output && output.type === 'tool_use'\n}\n\nexport function isAnthropicThinkingMessage(output: unknown): output is AnthropicThinkingMessage {\n    return !!output && typeof output === 'object' && 'type' in output && output.type === 'thinking'\n}\n\nexport function isAnthropicToolResultMessage(output: unknown): output is AnthropicToolResultMessage {\n    return !!output && typeof output === 'object' && 'type' in output && output.type === 'tool_result'\n}\n\nexport function isAnthropicRoleBasedMessage(input: unknown): input is AnthropicInputMessage {\n    return (\n        !!input &&\n        typeof input === 'object' &&\n        'role' in input &&\n        'content' in input &&\n        (typeof input.content === 'string' || Array.isArray(input.content))\n    )\n}\n\nexport function isVercelSDKTextMessage(input: unknown): input is VercelSDKTextMessage {\n    return (\n        !!input &&\n        typeof input === 'object' &&\n        'type' in input &&\n        input.type === 'text' &&\n        'content' in input &&\n        typeof input.content === 'string'\n    )\n}\n\nexport function isVercelSDKImageMessage(input: unknown): input is VercelSDKImageMessage {\n    return (\n        !!input &&\n        typeof input === 'object' &&\n        'type' in input &&\n        input.type === 'image' &&\n        'content' in input &&\n        typeof input.content === 'object' &&\n        input.content !== null &&\n        'image' in input.content &&\n        typeof input.content.image === 'string'\n    )\n}\n\nexport function isVercelSDKInputImageMessage(input: unknown): input is VercelSDKInputImageMessage {\n    return (\n        !!input &&\n        typeof input === 'object' &&\n        'type' in input &&\n        input.type === 'input_image' &&\n        'image_url' in input &&\n        typeof input.image_url === 'string'\n    )\n}\n\nexport function isVercelSDKInputTextMessage(input: unknown): input is VercelSDKInputTextMessage {\n    return (\n        !!input &&\n        typeof input === 'object' &&\n        'type' in input &&\n        input.type === 'input_text' &&\n        'text' in input &&\n        typeof input.text === 'string'\n    )\n}\n\nexport function isLiteLLMChoice(input: unknown): input is LiteLLMChoice {\n    return (\n        !!input &&\n        typeof input === 'object' &&\n        'finish_reason' in input &&\n        'index' in input &&\n        'message' in input &&\n        typeof input.message === 'object' &&\n        input.message !== null\n    )\n}\n\nexport function isLiteLLMResponse(input: unknown): input is LiteLLMResponse {\n    return (\n        !!input &&\n        typeof input === 'object' &&\n        'choices' in input &&\n        Array.isArray(input.choices) &&\n        input.choices.every(isLiteLLMChoice)\n    )\n}\n\nexport const roleMap: Record<string, string> = {\n    user: 'user',\n    human: 'user',\n\n    assistant: 'assistant',\n    model: 'assistant',\n    ai: 'assistant',\n    bot: 'assistant',\n\n    system: 'system',\n    instructions: 'system',\n}\n\nexport function normalizeRole(rawRole: unknown, fallback: string): string {\n    if (typeof rawRole !== 'string') {\n        return fallback\n    }\n    const lowercased = rawRole.toLowerCase()\n    return roleMap[lowercased] || lowercased\n}\n\n/**\n * Normalizes a message from an LLM provider into a format that is compatible with the PostHog LLM Analytics schema.\n *\n * @param rawMessage - Original message from an LLM provider.\n * @param defaultRole - The default role to use if the message doesn't have one.\n * @returns The normalized message.\n */\nexport function normalizeMessage(rawMessage: unknown, defaultRole: string): CompatMessage[] {\n    // Extract the role from the message if it exists, otherwise use defaultRole\n    // This ensures we preserve roles when recursing into nested content\n    const roleToUse =\n        rawMessage && typeof rawMessage === 'object' && 'role' in rawMessage && typeof rawMessage.role === 'string'\n            ? normalizeRole(rawMessage.role, defaultRole)\n            : defaultRole\n\n    // Handle new array-based content format (unified format with structured objects)\n    // Only apply this if the array contains objects with 'type' field (not Anthropic-specific formats)\n    // Supported types include: text, output_text, input_text, function, image, input_image\n    if (\n        rawMessage &&\n        typeof rawMessage === 'object' &&\n        'role' in rawMessage &&\n        'content' in rawMessage &&\n        typeof rawMessage.role === 'string' &&\n        Array.isArray(rawMessage.content) &&\n        rawMessage.content.length > 0 &&\n        rawMessage.content.every(\n            (item) =>\n                item &&\n                typeof item === 'object' &&\n                'type' in item &&\n                (item.type === 'text' ||\n                    item.type === 'output_text' ||\n                    item.type === 'input_text' ||\n                    item.type === 'function' ||\n                    item.type === 'image' ||\n                    item.type === 'input_image')\n        )\n    ) {\n        return [\n            {\n                role: roleToUse,\n                content: rawMessage.content,\n            },\n        ]\n    }\n\n    if (isLiteLLMChoice(rawMessage)) {\n        return normalizeMessage(rawMessage.message, roleToUse)\n    }\n\n    // Vercel SDK\n    if (isVercelSDKTextMessage(rawMessage)) {\n        return [\n            {\n                role: roleToUse,\n                content: rawMessage.content,\n            },\n        ]\n    }\n\n    // Vercel SDK Input Image\n    if (isVercelSDKInputImageMessage(rawMessage)) {\n        return [\n            {\n                role: roleToUse,\n                content: [\n                    {\n                        type: 'image',\n                        image: rawMessage.image_url,\n                    },\n                ],\n            },\n        ]\n    }\n\n    // Vercel SDK Input Text\n    if (isVercelSDKInputTextMessage(rawMessage)) {\n        return [\n            {\n                role: roleToUse,\n                content: rawMessage.text,\n            },\n        ]\n    }\n\n    // OpenAI\n    if (isOpenAICompatMessage(rawMessage)) {\n        return [\n            {\n                ...rawMessage,\n                role: roleToUse,\n                content: rawMessage.content,\n                tool_calls: isOpenAICompatToolCallsArray(rawMessage.tool_calls)\n                    ? parseOpenAIToolCalls(rawMessage.tool_calls)\n                    : undefined,\n                tool_call_id: rawMessage.tool_call_id,\n            },\n        ]\n    }\n\n    // Anthropic\n    // Text object\n    if (isAnthropicTextMessage(rawMessage)) {\n        return [\n            {\n                role: roleToUse,\n                content: rawMessage.text,\n            },\n        ]\n    }\n    // Tool call completion\n    if (isAnthropicToolCallMessage(rawMessage)) {\n        return [\n            {\n                role: roleToUse,\n                content: '',\n                tool_calls: [\n                    {\n                        type: 'function',\n                        id: rawMessage.id,\n                        function: {\n                            name: rawMessage.name,\n                            arguments: rawMessage.input,\n                        },\n                    },\n                ],\n            },\n        ]\n    }\n    // Thinking\n    if (isAnthropicThinkingMessage(rawMessage)) {\n        return [\n            {\n                role: normalizeRole('assistant (thinking)', roleToUse),\n                content: rawMessage.thinking,\n            },\n        ]\n    }\n    // Tool result completion\n    if (isAnthropicToolResultMessage(rawMessage)) {\n        if (Array.isArray(rawMessage.content)) {\n            return rawMessage.content\n                .map((content) => normalizeMessage(content, roleToUse))\n                .flat()\n                .map((msg) => ({\n                    ...msg,\n                    tool_call_id: rawMessage.tool_use_id,\n                }))\n        }\n        return [\n            {\n                role: roleToUse,\n                content: rawMessage.content,\n                tool_call_id: rawMessage.tool_use_id,\n            },\n        ]\n    }\n\n    // Input message\n    if (isAnthropicRoleBasedMessage(rawMessage)) {\n        // Content is a nested array (tool responses, etc.)\n        if (Array.isArray(rawMessage.content)) {\n            return rawMessage.content.map((content) => normalizeMessage(content, roleToUse)).flat()\n        }\n\n        return [\n            {\n                role: roleToUse,\n                content: rawMessage.content,\n            },\n        ]\n    }\n    // Unsupported message.\n    console.warn(\"AI message isn't in a shape of any known AI provider\", rawMessage)\n    let cajoledContent: string // Let's do what we can\n    if (typeof rawMessage === 'string') {\n        cajoledContent = rawMessage\n    } else if (\n        typeof rawMessage === 'object' &&\n        rawMessage !== null &&\n        'content' in rawMessage &&\n        typeof rawMessage.content === 'string'\n    ) {\n        cajoledContent = rawMessage.content\n    } else {\n        cajoledContent = JSON.stringify(rawMessage)\n    }\n    return [{ role: roleToUse, content: cajoledContent }]\n}\n\nexport function normalizeMessages(messages: unknown, defaultRole: string, tools?: unknown): CompatMessage[] {\n    const normalizedMessages: CompatMessage[] = []\n\n    if (tools) {\n        normalizedMessages.push({\n            role: 'available tools',\n            content: '',\n            tools,\n        })\n    }\n\n    if (Array.isArray(messages)) {\n        normalizedMessages.push(...messages.map((message) => normalizeMessage(message, defaultRole)).flat())\n    } else if (isLiteLLMResponse(messages)) {\n        normalizedMessages.push(\n            ...(messages.choices || []).map((choice) => normalizeMessage(choice, defaultRole)).flat()\n        )\n    } else if (typeof messages === 'object' && messages && 'choices' in messages && Array.isArray(messages.choices)) {\n        normalizedMessages.push(...messages.choices.map((message) => normalizeMessage(message, defaultRole)).flat())\n    } else if (typeof messages === 'string') {\n        normalizedMessages.push({\n            role: defaultRole,\n            content: messages,\n        })\n    } else if (typeof messages === 'object' && messages !== null) {\n        normalizedMessages.push(...normalizeMessage(messages, defaultRole))\n    }\n\n    return normalizedMessages\n}\n\nexport function removeMilliseconds(timestamp: string): string {\n    return dayjs(timestamp).utc().format('YYYY-MM-DDTHH:mm:ss[Z]')\n}\n\nexport function getTraceTimestamp(timestamp: string): string {\n    return dayjs(timestamp).utc().subtract(5, 'minutes').format('YYYY-MM-DDTHH:mm:ss[Z]')\n}\n\nexport function formatLLMEventTitle(event: LLMTrace | LLMTraceEvent): string {\n    if (isLLMEvent(event)) {\n        if (event.event === '$ai_generation') {\n            const spanName = event.properties.$ai_span_name\n            if (spanName) {\n                return `${spanName}`\n            }\n            const title = event.properties.$ai_model || 'Generation'\n            if (event.properties.$ai_provider) {\n                return `${title} (${event.properties.$ai_provider})`\n            }\n\n            return title\n        }\n\n        if (event.event === '$ai_embedding') {\n            const spanName = event.properties.$ai_span_name\n            if (spanName) {\n                return `${spanName}`\n            }\n            const title = event.properties.$ai_model || 'Embedding'\n            if (event.properties.$ai_provider) {\n                return `${title} (${event.properties.$ai_provider})`\n            }\n\n            return title\n        }\n\n        return event.properties.$ai_span_name ?? 'Span'\n    }\n\n    return event.traceName ?? 'Trace'\n}\n\n/**\n * Lightweight XML-ish content detector for UI toggles.\n * - NOTE: Scans only the first 2KB for signals (to avoid performance issues with regex)\n */\nexport function looksLikeXml(input: unknown): boolean {\n    if (typeof input !== 'string') {\n        return false\n    }\n\n    const sampleLimit = 2048\n    const sample = input.length > sampleLimit ? input.slice(0, sampleLimit) : input\n\n    if (sample.indexOf('<') === -1 || sample.indexOf('>') === -1) {\n        return false\n    }\n\n    if (sample.includes('</') || sample.includes('/>') || sample.includes('<?xml') || sample.includes('<!DOCTYPE')) {\n        return true\n    }\n\n    const lt = sample.indexOf('<')\n    const next = sample[lt + 1]\n    const isNameStart =\n        !!next && ((next >= 'A' && next <= 'Z') || (next >= 'a' && next <= 'z') || next === '_' || next === ':')\n    return isNameStart\n}\n\n/**\n * Formats an ID for display by truncating it to the first and last 4 characters:\n * `1234567890` -> `1234...7890`\n * @param value - The string to format.\n * @returns The formatted string.\n */\nexport function truncateValue(value: unknown): string {\n    if (value === null || value === undefined) {\n        return '-'\n    }\n\n    const stringValue = String(value)\n\n    if (stringValue.length <= 12) {\n        return stringValue\n    }\n\n    return stringValue.slice(0, 4) + '...' + stringValue.slice(-4)\n}\n\ntype RawEvaluationRunRow = [\n    id: string,\n    timestamp: string,\n    evaluation_id: string,\n    evaluation_name: string | null,\n    generation_id: string,\n    trace_id: string,\n    result: boolean | string,\n    reasoning: string | null,\n]\n\nexport function mapEvaluationRunRow(row: RawEvaluationRunRow): EvaluationRun {\n    return {\n        id: row[0],\n        timestamp: row[1],\n        evaluation_id: row[2],\n        evaluation_name: row[3] || 'Unknown Evaluation',\n        generation_id: row[4],\n        trace_id: row[5],\n        result: row[6] === true || row[6] === 'true',\n        reasoning: row[7] || 'No reasoning provided',\n        status: 'completed' as const,\n    }\n}\n\nexport async function queryEvaluationRuns(params: {\n    evaluationId?: string\n    generationEventId?: string\n    forceRefresh?: boolean\n}): Promise<EvaluationRun[]> {\n    const { evaluationId, generationEventId, forceRefresh } = params\n\n    if (!evaluationId && !generationEventId) {\n        throw new Error('Either evaluationId or generationEventId must be provided')\n    }\n\n    const propertyName = evaluationId ? '$ai_evaluation_id' : '$ai_target_event_id'\n    const propertyValue = evaluationId || generationEventId\n\n    const query = hogql`\n        SELECT\n            uuid,\n            timestamp,\n            properties.$ai_evaluation_id as evaluation_id,\n            properties.$ai_evaluation_name as evaluation_name,\n            properties.$ai_target_event_id as generation_id,\n            properties.$ai_trace_id as trace_id,\n            properties.$ai_evaluation_result as result,\n            properties.$ai_evaluation_reasoning as reasoning\n        FROM events\n        WHERE\n            event = '$ai_evaluation'\n            AND ${hogql.raw(`properties.${propertyName}`)} = ${propertyValue}\n        ORDER BY timestamp DESC\n        LIMIT 100\n    `\n\n    const response = await api.queryHogQL(query, {\n        ...(forceRefresh && { refresh: 'force_blocking' }),\n    })\n\n    return (response.results || []).map(mapEvaluationRunRow)\n}\n"],"names":[],"sourceRoot":""}