{"version":3,"file":"10999.59cde3da.iframe.bundle.js","mappings":";;;;AAyGA;;AAIA;;;;;;;;AAwBA","sources":["webpack://@posthog/storybook/../../frontend/src/scenes/heatmaps/heatmapsBrowserLogic.ts"],"sourcesContent":["import { actions, afterMount, connect, kea, listeners, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl, router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport {\n    authorizedUrlListLogic,\n    AuthorizedUrlListType,\n    defaultAuthorizedUrlProperties,\n} from 'lib/components/AuthorizedUrlList/authorizedUrlListLogic'\nimport { heatmapDataLogic } from 'lib/components/heatmaps/heatmapDataLogic'\nimport { CommonFilters, HeatmapFilters, HeatmapFixedPositionMode } from 'lib/components/heatmaps/types'\nimport {\n    calculateViewportRange,\n    DEFAULT_HEATMAP_FILTERS,\n    PostHogAppToolbarEvent,\n} from 'lib/components/IframedToolbarBrowser/utils'\nimport { LemonBannerProps } from 'lib/lemon-ui/LemonBanner'\nimport { objectsEqual } from 'lib/utils'\nimport posthog from 'posthog-js'\nimport { RefObject } from 'react'\nimport { removeReplayIframeDataFromLocalStorage } from 'scenes/session-recordings/player/sessionRecordingPlayerLogic'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\n\nimport type { heatmapsBrowserLogicType } from './heatmapsBrowserLogicType'\n\nexport type HeatmapsBrowserLogicProps = {\n    iframeRef: RefObject<HTMLIFrameElement | null>\n}\n\nexport interface IFrameBanner {\n    level: LemonBannerProps['type']\n    message: string | JSX.Element\n}\n\nexport interface ReplayIframeData {\n    html: string\n    width: number // NB this should be meta width\n    height: number // NB this should be meta height\n    startDateTime: string | undefined\n    url: string | undefined\n}\n\n// team id is always available on window\nconst teamId = window.POSTHOG_APP_CONTEXT?.current_team?.id\n\nexport const heatmapsBrowserLogic = kea<heatmapsBrowserLogicType>([\n    path(['scenes', 'heatmaps', 'heatmapsBrowserLogic']),\n    props({} as HeatmapsBrowserLogicProps),\n\n    connect(() => ({\n        values: [\n            authorizedUrlListLogic({\n                ...defaultAuthorizedUrlProperties,\n                type: AuthorizedUrlListType.TOOLBAR_URLS,\n            }),\n            ['urlsKeyed', 'checkUrlIsAuthorized'],\n            heatmapDataLogic,\n            ['heatmapEmpty'],\n        ],\n        actions: [heatmapDataLogic, ['loadHeatmap', 'setFetchFn', 'setHref']],\n    })),\n\n    actions({\n        setBrowserSearch: (searchTerm: string) => ({ searchTerm }),\n        setBrowserUrl: (url: string | null) => ({ url }),\n        onIframeLoad: true,\n        sendToolbarMessage: (type: PostHogAppToolbarEvent, payload?: Record<string, any>) => ({\n            type,\n            payload,\n        }),\n        loadTopUrls: true,\n        maybeLoadTopUrls: true,\n        loadBrowserSearchResults: true,\n        // TRICKY: duplicated with the heatmapLogic so that we can share the settings picker\n        patchHeatmapFilters: (filters: Partial<HeatmapFilters>) => ({ filters }),\n        setHeatmapColorPalette: (Palette: string | null) => ({ Palette }),\n        setHeatmapFixedPositionMode: (mode: HeatmapFixedPositionMode) => ({ mode }),\n        setCommonFilters: (filters: CommonFilters) => ({ filters }),\n        // TRICKY: duplication ends\n        setIframeWidth: (width: number | null) => ({ width }),\n        toggleFilterPanelCollapsed: true,\n        setIframeBanner: (banner: IFrameBanner | null) => ({ banner }),\n        startTrackingLoading: true,\n        stopTrackingLoading: true,\n        setReplayIframeData: (replayIframeData: ReplayIframeData | null) => ({ replayIframeData }),\n        setReplayIframeDataURL: (url: string | null) => ({ url }),\n    }),\n\n    loaders(({ values }) => ({\n        browserSearchResults: [\n            null as string[] | null,\n            {\n                loadBrowserSearchResults: async () => {\n                    if (!values.browserSearchTerm) {\n                        return []\n                    }\n\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT distinct properties.$current_url AS urls\n                                     FROM events\n                                     WHERE timestamp >= now() - INTERVAL 7 DAY\n                                       AND timestamp <= now()\n                                       AND properties.$current_url like '%${hogql.identifier(\n                                           values.browserSearchTerm\n                                       )}%'\n                                     ORDER BY timestamp DESC\n                                         limit 100`,\n                    }\n\n                    const res = await api.query(query)\n\n                    return res.results?.map((x) => x[0]) as string[]\n                },\n            },\n        ],\n\n        topUrls: [\n            null as { url: string; count: number }[] | null,\n            {\n                loadTopUrls: async () => {\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$current_url AS url, count() as count\n                                     FROM events\n                                     WHERE timestamp >= now() - INTERVAL 7 DAY\n                                       AND event in ('$pageview'\n                                         , '$autocapture')\n                                       AND timestamp <= now()\n                                     GROUP BY properties.$current_url\n                                     ORDER BY count DESC\n                                         LIMIT 10`,\n                    }\n\n                    const res = await api.query(query)\n\n                    return res.results?.map((x) => ({ url: x[0], count: x[1] })) as { url: string; count: number }[]\n                },\n            },\n        ],\n    })),\n\n    reducers({\n        hasValidReplayIframeData: [\n            false,\n            {\n                setReplayIframeData: (_, { replayIframeData }) =>\n                    !!replayIframeData?.url?.trim().length && !!replayIframeData?.html.trim().length,\n            },\n        ],\n        replayIframeData: [\n            null as ReplayIframeData | null,\n            {\n                setReplayIframeData: (_, { replayIframeData }) => replayIframeData,\n                setReplayIframeDataURL: (state, { url }) => {\n                    if (state === null) {\n                        return null\n                    }\n                    return { ...state, url } as ReplayIframeData\n                },\n            },\n        ],\n        filterPanelCollapsed: [\n            false as boolean,\n            { persist: true },\n            {\n                toggleFilterPanelCollapsed: (state) => !state,\n            },\n        ],\n        // they're called common filters in the toolbar because they're shared between heatmaps and clickmaps\n        // the name is continued here since they're passed down into the embedded iframe\n        commonFilters: [\n            { date_from: '-7d' } as CommonFilters,\n            {\n                setCommonFilters: (_, { filters }) => filters,\n            },\n        ],\n        heatmapColorPalette: [\n            'default' as string | null,\n            {\n                setHeatmapColorPalette: (_, { Palette }) => Palette,\n            },\n        ],\n        heatmapFilters: [\n            DEFAULT_HEATMAP_FILTERS,\n            {\n                patchHeatmapFilters: (state, { filters }) => ({ ...state, ...filters }),\n            },\n        ],\n        heatmapFixedPositionMode: [\n            'fixed' as HeatmapFixedPositionMode,\n            {\n                setHeatmapFixedPositionMode: (_, { mode }) => mode,\n            },\n        ],\n        iframeWidth: [\n            null as number | null,\n            {\n                setIframeWidth: (_, { width }) => width,\n            },\n        ],\n        browserSearchTerm: [\n            '',\n            {\n                setBrowserSearch: (_, { searchTerm }) => searchTerm,\n            },\n        ],\n        browserUrl: [\n            null as string | null,\n            { persist: true, prefix: `${teamId}__` },\n            {\n                setBrowserUrl: (_, { url }) => url,\n            },\n        ],\n        loading: [\n            false as boolean,\n            {\n                setBrowserUrl: (state, { url }) => (url?.trim().length ? true : state),\n                setIframeBanner: (state, { banner }) => (banner?.level == 'error' ? false : state),\n                startTrackingLoading: () => true,\n                stopTrackingLoading: () => false,\n            },\n        ],\n        iframeBanner: [\n            null as IFrameBanner | null,\n            {\n                setIframeBanner: (_, { banner }) => banner,\n            },\n        ],\n        widthOverride: [\n            null as number | null,\n            {\n                setIframeWidth: (_, { width }) => width,\n            },\n        ],\n    }),\n\n    selectors({\n        browserUrlSearchOptions: [\n            (s) => [s.browserSearchResults, s.topUrls, s.browserSearchTerm],\n            (browserSearchResults, topUrls, browserSearchTerm) => {\n                return browserSearchTerm ? browserSearchResults : topUrls?.map((x) => x.url) ?? []\n            },\n        ],\n\n        isBrowserUrlAuthorized: [\n            (s) => [s.browserUrl, s.checkUrlIsAuthorized],\n            (browserUrl, checkUrlIsAuthorized) => {\n                if (!browserUrl) {\n                    return false\n                }\n                return checkUrlIsAuthorized(browserUrl)\n            },\n        ],\n        isBrowserUrlValid: [\n            (s) => [s.browserUrl],\n            (browserUrl) => {\n                if (!browserUrl) {\n                    // an empty browserUrl is valid\n                    // since we just won't do anything with it\n                    return true\n                }\n\n                try {\n                    // must be something that can be parsed as a URL\n                    new URL(browserUrl)\n                    // and must be a valid URL that our redirects can cope with\n                    // this is a very loose check, but `http:/blaj` is not valid for PostHog\n                    // but survives new URL(http:/blaj)\n                    return browserUrl.includes('://')\n                } catch (e) {\n                    return false\n                }\n            },\n        ],\n\n        viewportRange: [\n            (s) => [s.heatmapFilters, s.iframeWidth],\n            (heatmapFilters, iframeWidth) => {\n                return iframeWidth ? calculateViewportRange(heatmapFilters, iframeWidth) : { min: 0, max: 1800 }\n            },\n        ],\n\n        noPageviews: [\n            (s) => [s.topUrlsLoading, s.topUrls],\n            (topUrlsLoading, topUrls) => !topUrlsLoading && (!topUrls || topUrls.length === 0),\n        ],\n    }),\n\n    listeners(({ actions, cache, props, values }) => ({\n        setReplayIframeData: ({ replayIframeData }) => {\n            if (replayIframeData && replayIframeData.url) {\n                // we don't want to use the toolbar fetch or the iframe message approach\n                actions.setFetchFn('native')\n                actions.setHref(replayIframeData.url)\n            } else {\n                removeReplayIframeDataFromLocalStorage()\n            }\n        },\n\n        setBrowserSearch: async (_, breakpoint) => {\n            await breakpoint(200)\n            actions.loadBrowserSearchResults()\n        },\n\n        sendToolbarMessage: ({ type, payload }) => {\n            props.iframeRef?.current?.contentWindow?.postMessage(\n                {\n                    type,\n                    payload,\n                },\n                '*'\n            )\n        },\n\n        patchHeatmapFilters: ({ filters }) => {\n            actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_PATCH_HEATMAP_FILTERS, { filters })\n        },\n\n        setHeatmapFixedPositionMode: ({ mode }) => {\n            actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_HEATMAPS_FIXED_POSITION_MODE, {\n                fixedPositionMode: mode,\n            })\n        },\n\n        setHeatmapColorPalette: ({ Palette }) => {\n            actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_HEATMAPS_COLOR_PALETTE, {\n                colorPalette: Palette,\n            })\n        },\n\n        setCommonFilters: ({ filters }) => {\n            actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_HEATMAPS_COMMON_FILTERS, { commonFilters: filters })\n        },\n\n        onIframeLoad: () => {\n            // if we've got valid replay iframe data we don't want to init and communicate with the embedded toolbar\n            // TODO this seems not fire with srcdoc\n            if (values.hasValidReplayIframeData) {\n                actions.loadHeatmap()\n                return\n            }\n            // we get this callback whether the iframe loaded successfully or not\n            // and don't get a signal if the load was successful, so we have to check\n            // but there's no slam dunk way to do that\n\n            const init = (): void => {\n                actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_APP_INIT, {\n                    filters: values.heatmapFilters,\n                    colorPalette: values.heatmapColorPalette,\n                    fixedPositionMode: values.heatmapFixedPositionMode,\n                    commonFilters: values.commonFilters,\n                })\n                actions.sendToolbarMessage(PostHogAppToolbarEvent.PH_HEATMAPS_CONFIG, {\n                    enabled: true,\n                })\n            }\n\n            const onIframeMessage = (e: MessageEvent): void => {\n                const type: PostHogAppToolbarEvent = e?.data?.type\n\n                if (!type || !type.startsWith('ph-')) {\n                    return\n                }\n                if (!values.checkUrlIsAuthorized(e.origin)) {\n                    console.warn(\n                        'ignoring message from iframe with origin not in authorized toolbar urls',\n                        e.origin,\n                        e.data\n                    )\n                    return\n                }\n\n                switch (type) {\n                    case PostHogAppToolbarEvent.PH_TOOLBAR_INIT:\n                        return init()\n                    case PostHogAppToolbarEvent.PH_TOOLBAR_READY:\n                        posthog.capture('in-app heatmap frame loaded', {\n                            inapp_heatmap_page_url_visited: values.browserUrl,\n                            inapp_heatmap_filters: values.heatmapFilters,\n                            inapp_heatmap_color_palette: values.heatmapColorPalette,\n                            inapp_heatmap_fixed_position_mode: values.heatmapFixedPositionMode,\n                        })\n                        // reset loading tracking - if we're e.g. slow this will avoid a flash of warning message\n                        return actions.startTrackingLoading()\n                    case PostHogAppToolbarEvent.PH_TOOLBAR_HEATMAP_LOADING:\n                        return actions.startTrackingLoading()\n                    case PostHogAppToolbarEvent.PH_TOOLBAR_HEATMAP_LOADED:\n                        posthog.capture('in-app heatmap loaded', {\n                            inapp_heatmap_page_url_visited: values.browserUrl,\n                            inapp_heatmap_filters: values.heatmapFilters,\n                            inapp_heatmap_color_palette: values.heatmapColorPalette,\n                            inapp_heatmap_fixed_position_mode: values.heatmapFixedPositionMode,\n                        })\n                        return actions.stopTrackingLoading()\n                    case PostHogAppToolbarEvent.PH_TOOLBAR_HEATMAP_FAILED:\n                        posthog.capture('in-app heatmap failed', {\n                            inapp_heatmap_page_url_visited: values.browserUrl,\n                            inapp_heatmap_filters: values.heatmapFilters,\n                            inapp_heatmap_color_palette: values.heatmapColorPalette,\n                            inapp_heatmap_fixed_position_mode: values.heatmapFixedPositionMode,\n                        })\n                        actions.stopTrackingLoading()\n                        actions.setIframeBanner({ level: 'error', message: 'The heatmap failed to load.' })\n                        return\n                    default:\n                        console.warn(`[PostHog Heatmaps] Received unknown child window message: ${type}`)\n                }\n            }\n\n            window.addEventListener('message', onIframeMessage, false)\n            // We call init in case the toolbar got there first (unlikely)\n            init()\n        },\n\n        maybeLoadTopUrls: () => {\n            if (!values.topUrls && !values.topUrlsLoading) {\n                actions.loadTopUrls()\n            }\n        },\n\n        setReplayIframeDataURL: async ({ url }, breakpoint) => {\n            await breakpoint(150)\n            if (url?.trim().length) {\n                // we don't want to use the toolbar fetch or the iframe message approach\n                actions.setFetchFn('native')\n                actions.setHref(url)\n            }\n        },\n\n        setBrowserUrl: ({ url }) => {\n            actions.maybeLoadTopUrls()\n            if (url?.trim().length) {\n                actions.startTrackingLoading()\n            }\n        },\n\n        startTrackingLoading: () => {\n            actions.setIframeBanner(null)\n\n            clearTimeout(cache.errorTimeout)\n            cache.errorTimeout = setTimeout(() => {\n                actions.setIframeBanner({ level: 'error', message: 'The heatmap failed to load (or is very slow).' })\n            }, 7500)\n\n            clearTimeout(cache.warnTimeout)\n            cache.warnTimeout = setTimeout(() => {\n                actions.setIframeBanner({ level: 'warning', message: 'Still waiting for the toolbar to load.' })\n            }, 3000)\n        },\n\n        stopTrackingLoading: () => {\n            actions.setIframeBanner(null)\n\n            clearTimeout(cache.errorTimeout)\n            clearTimeout(cache.warnTimeout)\n        },\n    })),\n\n    afterMount(({ actions, values }) => {\n        if (values.browserUrl?.trim().length) {\n            actions.startTrackingLoading()\n        } else {\n            actions.maybeLoadTopUrls()\n        }\n    }),\n\n    urlToAction(({ actions, values }) => ({\n        '/heatmaps': (_, searchParams) => {\n            if (searchParams.pageURL && searchParams.pageURL !== values.browserUrl) {\n                actions.setBrowserUrl(searchParams.pageURL)\n            }\n            if (searchParams.heatmapFilters && !objectsEqual(searchParams.heatmapFilters, values.heatmapFilters)) {\n                actions.patchHeatmapFilters(searchParams.heatmapFilters)\n            }\n            if (searchParams.heatmapPalette && searchParams.heatmapPalette !== values.heatmapColorPalette) {\n                actions.setHeatmapColorPalette(searchParams.heatmapPalette)\n            }\n            if (\n                searchParams.heatmapFixedPositionMode &&\n                searchParams.heatmapFixedPositionMode !== values.heatmapFixedPositionMode\n            ) {\n                actions.setHeatmapFixedPositionMode(searchParams.heatmapFixedPositionMode as HeatmapFixedPositionMode)\n            }\n            if (searchParams.commonFilters && !objectsEqual(searchParams.commonFilters, values.commonFilters)) {\n                actions.setCommonFilters(searchParams.commonFilters as CommonFilters)\n            }\n            if (searchParams.iframeStorage) {\n                const replayFrameData = JSON.parse(\n                    localStorage.getItem(searchParams.iframeStorage) || '{}'\n                ) as ReplayIframeData\n                actions.setReplayIframeData(replayFrameData)\n            }\n        },\n    })),\n\n    actionToUrl(({ values }) => ({\n        setBrowserUrl: ({ url }) => {\n            const searchParams = { ...router.values.searchParams, pageURL: url }\n            if (!url || url.trim() === '') {\n                delete searchParams.pageURL\n            }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n        patchHeatmapFilters: () => {\n            const searchParams = { ...router.values.searchParams, heatmapFilters: values.heatmapFilters }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n        setHeatmapColorPalette: ({ Palette }) => {\n            const searchParams = { ...router.values.searchParams, heatmapPalette: Palette }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n        setHeatmapFixedPositionMode: ({ mode }) => {\n            const searchParams = { ...router.values.searchParams, heatmapFixedPositionMode: mode }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n        setCommonFilters: ({ filters }) => {\n            const searchParams = { ...router.values.searchParams, commonFilters: filters }\n            return [router.values.location.pathname, searchParams, router.values.hashParams, { replace: true }]\n        },\n    })),\n])\n"],"names":[],"sourceRoot":""}