{"version":3,"file":"64505.53342fdc.iframe.bundle.js","mappings":";;;;;;;;AAkGA","sources":["webpack://@posthog/storybook/../../frontend/src/lib/components/VersionChecker/versionCheckerLogic.ts"],"sourcesContent":["import { actions, afterMount, kea, key, listeners, path, props, reducers, sharedListeners } from 'kea'\nimport { loaders } from 'kea-loaders'\n\nimport api from 'lib/api'\nimport { isNotNil } from 'lib/utils'\nimport {\n    SemanticVersion,\n    diffVersions,\n    highestVersion,\n    isEqualVersion,\n    parseVersion,\n    tryParseVersion,\n    versionToString,\n} from 'lib/utils/semver'\n\nimport { hogql } from '~/queries/utils'\n\nimport type { versionCheckerLogicType } from './versionCheckerLogicType'\n\n// If you would like to deprecate all posthog-js versions older than a specific version\n// (i.e. after fixing an important bug) please edit\n// https://github.com/PostHog/posthog-js/blob/main/deprecation.json\n\nconst CHECK_INTERVAL_MS = 1000 * 60 * 60 * 6 // 6 hour\n\nexport type SDKVersion = {\n    version: SemanticVersion\n    timestamp?: string\n}\n\nexport type SDKVersionWarning = {\n    latestUsedVersion: string\n    latestAvailableVersion: string\n    numVersionsBehind?: number\n    level: 'warning' | 'info' | 'error'\n}\n\nexport interface PosthogJSDeprecation {\n    deprecateBeforeVersion?: string\n    deprecateOlderThanDays?: number\n}\n\nexport interface AvailableVersions {\n    sdkVersions?: SemanticVersion[]\n    deprecation?: PosthogJSDeprecation\n}\n\nexport interface VersionCheckerLogicProps {\n    teamId: number | null\n}\n\nexport const versionCheckerLogic = kea<versionCheckerLogicType>([\n    props({ teamId: null } as VersionCheckerLogicProps),\n    key(({ teamId }) => teamId || 'no-team-id'),\n    path((key) => ['components', 'VersionChecker', 'versionCheckerLogic', key]),\n    actions({\n        setVersionWarning: (versionWarning: SDKVersionWarning | null) => ({ versionWarning }),\n        setSdkVersions: (sdkVersions: SDKVersion[]) => ({ sdkVersions }),\n    }),\n    loaders(({ values }) => ({\n        availableVersions: [\n            {} as AvailableVersions,\n            {\n                loadAvailableVersions: async (): Promise<AvailableVersions> => {\n                    // Make both requests simultaneously and don't return until both have finished, to avoid a flash\n                    // of partial results in the UI.\n                    const availableVersionsPromise: Promise<SemanticVersion[]> = fetch(\n                        'https://api.github.com/repos/posthog/posthog-js/tags'\n                    )\n                        .then((r) => r.json())\n                        .then((r) => r.map((x: any) => tryParseVersion(x.name)).filter(isNotNil))\n                    const deprecationPromise: Promise<PosthogJSDeprecation> = fetch(\n                        'https://raw.githubusercontent.com/PostHog/posthog-js/main/deprecation.json'\n                    ).then((r) => r.json())\n                    const settled = await Promise.allSettled([availableVersionsPromise, deprecationPromise])\n                    const availableVersions = settled[0].status === 'fulfilled' ? settled[0].value : []\n                    const deprecation = settled[1].status === 'fulfilled' ? settled[1].value : {}\n                    // if one or more of the requests failed, merge in the previous value if we have one\n                    return {\n                        ...values.availableVersions,\n                        sdkVersions: availableVersions,\n                        deprecation: deprecation,\n                    }\n                },\n            },\n        ],\n        usedVersions: [\n            null as SDKVersion[] | null,\n            {\n                loadUsedVersions: async () => {\n                    const query = hogql`\n                        SELECT properties.$lib_version AS lib_version, max(timestamp) AS latest_timestamp, count(lib_version) as count\n                        FROM events\n                        WHERE timestamp >= now() - INTERVAL 1 DAY \n                        AND timestamp <= now()\n                        AND properties.$lib = 'web'\n                        GROUP BY lib_version\n                        ORDER BY latest_timestamp DESC\n                        limit 10`\n\n                    const res = await api.queryHogQL(query, { refresh: 'force_blocking' })\n\n                    return (\n                        res.results\n                            ?.map((x) => {\n                                const version = tryParseVersion(x[0])\n                                if (!version) {\n                                    return null\n                                }\n                                return {\n                                    version,\n                                    timestamp: x[1],\n                                }\n                            })\n                            .filter(isNotNil) ?? null\n                    )\n                },\n            },\n        ],\n    })),\n\n    reducers({\n        lastCheckTimestamp: [\n            0,\n            { persist: true },\n            {\n                loadUsedVersionsSuccess: () => Date.now(),\n            },\n        ],\n        versionWarning: [\n            null as SDKVersionWarning | null,\n            // bumping cache key due to an incorrect tag being cached on 2024-02-12\n            { persist: true, prefix: '2024-02-12' },\n            {\n                setVersionWarning: (_, { versionWarning }) => versionWarning,\n            },\n        ],\n    }),\n\n    sharedListeners(({ values, actions }) => ({\n        checkForVersionWarning: () => {\n            if (!values.usedVersions?.length) {\n                return\n            }\n            const { deprecation, sdkVersions } = values.availableVersions\n\n            // We want the highest semantic version to be the latest used one, rather than\n            // the one with the latest timestamp, because secondary installations can spew old versions\n            const latestUsedVersion = highestVersion(values.usedVersions.map((v) => v.version))\n\n            // the latest version published on github\n            const latestAvailableVersion = sdkVersions?.[0]\n\n            // the version where, anything before this deprecated (i.e. this version is allowed, before it is not)\n            const deprecateBeforeVersion = deprecation?.deprecateBeforeVersion\n                ? parseVersion(deprecation.deprecateBeforeVersion)\n                : null\n\n            let warning: SDKVersionWarning | null = null\n\n            if (deprecateBeforeVersion) {\n                const diff = diffVersions(deprecateBeforeVersion, latestUsedVersion)\n                // if they are behind the deprecatedBeforeVersion by any amount, show an error\n                if (diff && diff.diff > 0) {\n                    warning = {\n                        latestUsedVersion: versionToString(latestUsedVersion),\n                        latestAvailableVersion: versionToString(latestAvailableVersion || deprecateBeforeVersion),\n                        level: 'error',\n                    }\n                }\n            }\n\n            if (!warning && sdkVersions && latestAvailableVersion) {\n                const diff = diffVersions(latestAvailableVersion, latestUsedVersion)\n\n                if (diff && diff.diff > 0) {\n                    // there's a difference between the latest used version and the latest available version\n\n                    let numVersionsBehind = sdkVersions.findIndex((v) => isEqualVersion(v, latestUsedVersion))\n                    if (numVersionsBehind === -1) {\n                        // if we couldn't find the versions, use the length of the list as a fallback\n                        numVersionsBehind = sdkVersions.length - 1\n                    }\n                    if (numVersionsBehind < diff.diff) {\n                        // we might have deleted versions, but if the actual diff is X then we must be at least X versions behind\n                        numVersionsBehind = diff.diff\n                    }\n\n                    let level: 'warning' | 'info' | 'error' | undefined\n                    if (diff.kind === 'major') {\n                        level = 'info' // it is desirable to be on the latest major version, but not critical\n                    } else if (diff.kind === 'minor') {\n                        level = numVersionsBehind >= 40 ? 'warning' : undefined\n                    }\n\n                    if (level === undefined && numVersionsBehind >= 50) {\n                        level = 'error'\n                    }\n\n                    // we check if there is a \"latest user version string\" to avoid returning odd data in unexpected cases\n                    if (level && !!versionToString(latestUsedVersion).trim().length) {\n                        warning = {\n                            latestUsedVersion: versionToString(latestUsedVersion),\n                            latestAvailableVersion: versionToString(latestAvailableVersion),\n                            level,\n                            numVersionsBehind,\n                        }\n                    }\n                }\n            }\n\n            actions.setVersionWarning(warning)\n        },\n    })),\n\n    listeners(({ sharedListeners }) => ({\n        loadAvailableVersionsSuccess: sharedListeners.checkForVersionWarning,\n        loadUsedVersionsSuccess: sharedListeners.checkForVersionWarning,\n    })),\n\n    afterMount(({ actions, values }) => {\n        if (values.lastCheckTimestamp < Date.now() - CHECK_INTERVAL_MS) {\n            actions.loadAvailableVersions()\n            actions.loadUsedVersions()\n        }\n    }),\n])\n"],"names":[],"sourceRoot":""}