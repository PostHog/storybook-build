{"version":3,"file":"main.fb68f426.iframe.bundle.js","mappings":";AA8PA;AACA;AA+GA;AAAA;;;;;ACnVA;AC+KA;;;;;;;;AC8CA;AAgKA;AACA;AACA;AACA;AACA;AACA;;;AChYA;;;AAsBA;;AAEA;ACYA;AAAA;ACrCA;AAUA;AAOA;AAuBA;AAaA;AAOA;AAOA;AA4YA;AAAA;AAAA;AAAA;AAAA;;;;;;;ACxYA;AC5EA;AAAA;ACsPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AAmDA;AACA;AACA;AACA;AACA;AACA;AACA;AC5UA;AACA;AACA;AC+CA;ACsiBA;AACA;ACokBA;AAAA;ACxqCA;AAqBA;AAMA;AASA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AAEA;AAEA;AACA;AAUA;AACA;AACA;AACA;AA6BA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAUA;AACA;AACA;AACA;AAuBA;AAMA;AASA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AAsBA;AAMA;AASA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AASA;AACA;AACA;AACA;AA2BA;AAMA;AASA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AASA;AACA;AACA;AACA;AA+BA;AAMA;AASA;AACA;AAEA;AACA;AAOA;AAKA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA8BA;AACA;AACA;AAuBA;AACA;AACA;AAsBA;AACA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AASA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AA2BA;AACA;AACA;AAIA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtpBA;AC+KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC4mCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtvBA;AACA;AACA;;;AAGA;;;AAKA;AACA;;AAEA;AAGA;AACA;AAIA;AACA;AAGA;AACA;AACA;;;;;;AA8EA;AACA;AACA;AACA;AClpBA;AAAA;;;;;;;;;;;;AC7CA;AACA;;;;;AAKA;AACA;AACA;ACwEA;AC3EA;AAAA;AAAA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACsGA;AACA;AACA;AAaA;AACA;AACA;AACA;AAyMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAkCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA0CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAwEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiDA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqiBA;AACA;AACA;AACA;AACA;AACA;AChrCA;AACA;AACA;AC4CA;AASA;AASA;AACA;AACA","sources":["webpack://@posthog/storybook/common/hogvm/typescript/src/stl/print.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/ReverseProxyChecker/reverseProxyCheckerLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/Alerts/views/EditAlertModal.tsx","webpack://@posthog/storybook/../../frontend/src/lib/components/AuthorizedUrlList/authorizedUrlListLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/Metalytics/metalyticsLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/Support/SupportForm.tsx","webpack://@posthog/storybook/../../frontend/src/lib/components/Support/supportLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/components/VersionChecker/versionCheckerLogic.ts","webpack://@posthog/storybook/../../frontend/src/lib/lemon-ui/LemonTextArea/LemonTextAreaMarkdown.tsx","webpack://@posthog/storybook/../../frontend/src/queries/examples.ts","webpack://@posthog/storybook/../../frontend/src/scenes/insights/filters/RetentionCumulativeButton.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/paths/renderPaths.ts","webpack://@posthog/storybook/../../frontend/src/scenes/billing/billingLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/experiments/experimentLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/feature-flags/FeatureFlagSnippets.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/notebooks/Nodes/NotebookNodeReplayTimestamp.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/notebooks/Notebook/SlashCommands.tsx","webpack://@posthog/storybook/../../ee/frontend/mobile-replay/transformer/transformers.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/player/sessionRecordingDataLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/player/share/playerShareLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/session-recordings/playlist/sessionRecordingsListPropertiesLogic.ts","webpack://@posthog/storybook/../../frontend/src/scenes/settings/environment/ManagedReverseProxy.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/settings/organization/VerifiedDomains/ConfigureSAMLModal.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/surveys/SurveySQLHelper.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/surveys/surveyLogic.tsx","webpack://@posthog/storybook/../../frontend/src/scenes/surveys/utils.ts","webpack://@posthog/storybook/../../products/early_access_features/frontend/InstructionsModal.tsx"],"sourcesContent":["import { isHogAST, isHogCallable, isHogClosure, isHogDate, isHogDateTime, isHogError } from '../objects'\nimport { convertJSToHog } from '../utils'\n\nconst escapeCharsMap: Record<string, string> = {\n    '\\b': '\\\\b',\n    '\\f': '\\\\f',\n    '\\r': '\\\\r',\n    '\\n': '\\\\n',\n    '\\t': '\\\\t',\n    '\\0': '\\\\0',\n    '\\v': '\\\\v',\n    '\\\\': '\\\\\\\\',\n}\n\nconst singlequoteEscapeCharsMap: Record<string, string> = {\n    ...escapeCharsMap,\n    \"'\": \"\\\\'\",\n}\n\nconst backquoteEscapeCharsMap: Record<string, string> = {\n    ...escapeCharsMap,\n    '`': '\\\\`',\n}\n\nexport function escapeString(value: string): string {\n    return `'${value\n        .split('')\n        .map((c) => singlequoteEscapeCharsMap[c] || c)\n        .join('')}'`\n}\n\nexport function escapeIdentifier(identifier: string | number): string {\n    if (typeof identifier === 'number') {\n        return identifier.toString()\n    }\n    if (/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(identifier)) {\n        return identifier\n    }\n    return `\\`${identifier\n        .split('')\n        .map((c) => backquoteEscapeCharsMap[c] || c)\n        .join('')}\\``\n}\n\nexport function printHogValue(obj: any, marked: Set<any> | undefined = undefined): string {\n    if (!marked) {\n        marked = new Set()\n    }\n    if (typeof obj === 'object' && obj !== null && obj !== undefined) {\n        if (\n            marked.has(obj) &&\n            !isHogDateTime(obj) &&\n            !isHogDate(obj) &&\n            !isHogError(obj) &&\n            !isHogClosure(obj) &&\n            !isHogCallable(obj) &&\n            !isHogAST(obj)\n        ) {\n            return 'null'\n        }\n        marked.add(obj)\n        try {\n            if (Array.isArray(obj)) {\n                if ((obj as any).__isHogTuple) {\n                    if (obj.length < 2) {\n                        return `tuple(${obj.map((o) => printHogValue(o, marked)).join(', ')})`\n                    }\n                    return `(${obj.map((o) => printHogValue(o, marked)).join(', ')})`\n                }\n                return `[${obj.map((o) => printHogValue(o, marked)).join(', ')}]`\n            }\n            if (isHogDateTime(obj)) {\n                const millis = String(obj.dt)\n                return `DateTime(${millis}${millis.includes('.') ? '' : '.0'}, ${escapeString(obj.zone)})`\n            }\n            if (isHogDate(obj)) {\n                return `Date(${obj.year}, ${obj.month}, ${obj.day})`\n            }\n            if (isHogError(obj)) {\n                return `${String(obj.type)}(${escapeString(obj.message)}${\n                    obj.payload ? `, ${printHogValue(obj.payload, marked)}` : ''\n                })`\n            }\n            if (isHogClosure(obj)) {\n                return printHogValue(obj.callable, marked)\n            }\n            if (isHogCallable(obj)) {\n                return `fn<${escapeIdentifier(obj.name ?? 'lambda')}(${printHogValue(obj.argCount)})>`\n            }\n            if (isHogAST(obj)) {\n                return `sql(${new HogQLPrinter(false, marked).print(obj)})`\n            }\n            if (obj instanceof Map) {\n                return `{${Array.from(obj.entries())\n                    .map(([key, value]) => `${printHogValue(key, marked)}: ${printHogValue(value, marked)}`)\n                    .join(', ')}}`\n            }\n            return `{${Object.entries(obj)\n                .map(([key, value]) => `${printHogValue(key, marked)}: ${printHogValue(value, marked)}`)\n                .join(', ')}}`\n        } finally {\n            marked.delete(obj)\n        }\n    } else if (typeof obj === 'boolean') {\n        return obj ? 'true' : 'false'\n    } else if (obj === null || obj === undefined) {\n        return 'null'\n    } else if (typeof obj === 'string') {\n        return escapeString(obj)\n    }\n    return obj.toString()\n}\n\nexport function printHogStringOutput(obj: any): string {\n    if (typeof obj === 'string') {\n        return obj\n    }\n    return printHogValue(obj)\n}\n\ntype ASTNode = Map<string, any> | null\n\n// Note: this printer currently is experimental and used for debugging/printing SQL only.\n// When making queries via run(query), we send the AST nodes directly to the server.\nexport class HogQLPrinter {\n    private stack: ASTNode[] = []\n    private indentLevel: number = -1\n    private tabSize: number = 4\n    private pretty: boolean\n    private marked: Set<any>\n\n    constructor(pretty: boolean = false, marked: Set<any> | undefined = undefined) {\n        this.pretty = pretty\n        this.marked = marked || new Set()\n    }\n\n    private indent(extra: number = 0): string {\n        return ' '.repeat(this.tabSize * (this.indentLevel + extra))\n    }\n\n    public print(node: ASTNode): string {\n        return this.visit(node)\n    }\n\n    private visit(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        if (!(node instanceof Map)) {\n            if (isHogAST(node)) {\n                node = convertJSToHog(node)\n            } else {\n                return this.escapeValue(node)\n            }\n        }\n\n        this.stack.push(node)\n        this.indentLevel += 1\n\n        let result: string\n        const nodeType = node?.get('__hx_ast') as string | undefined\n\n        if (!nodeType) {\n            throw new Error('Node type is missing or undefined.')\n        }\n\n        switch (nodeType) {\n            case 'SelectQuery':\n                result = this.visitSelectQuery(node)\n                break\n            case 'SelectSetQuery':\n                result = this.visitSelectSetQuery(node)\n                break\n            case 'Call':\n                result = this.visitCall(node)\n                break\n            case 'Constant':\n                result = this.visitConstant(node)\n                break\n            case 'Field':\n                result = this.visitField(node)\n                break\n            case 'Alias':\n                result = this.visitAlias(node)\n                break\n            case 'And':\n                result = this.visitAnd(node)\n                break\n            case 'Or':\n                result = this.visitOr(node)\n                break\n            case 'Not':\n                result = this.visitNot(node)\n                break\n            case 'CompareOperation':\n                result = this.visitCompareOperation(node)\n                break\n            case 'Tuple':\n                result = this.visitTuple(node)\n                break\n            case 'Array':\n                result = this.visitArray(node)\n                break\n            case 'Lambda':\n                result = this.visitLambda(node)\n                break\n            case 'OrderExpr':\n                result = this.visitOrderExpr(node)\n                break\n            case 'ArithmeticOperation':\n                result = this.visitArithmeticOperation(node)\n                break\n            case 'Asterisk':\n                result = this.visitAsterisk(node)\n                break\n            case 'JoinExpr':\n                result = this.visitJoinExpr(node)\n                break\n            case 'JoinConstraint':\n                result = this.visitJoinConstraint(node)\n                break\n            case 'WindowExpr':\n                result = this.visitWindowExpr(node)\n                break\n            case 'WindowFunction':\n                result = this.visitWindowFunction(node)\n                break\n            case 'WindowFrameExpr':\n                result = this.visitWindowFrameExpr(node)\n                break\n            case 'SampleExpr':\n                result = this.visitSampleExpr(node)\n                break\n            case 'RatioExpr':\n                result = this.visitRatioExpr(node)\n                break\n            default:\n                throw new Error(`Unknown AST node type: ${nodeType}`)\n        }\n\n        this.indentLevel -= 1\n        this.stack.pop()\n\n        return result\n    }\n\n    private visitSelectQuery(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const isTopLevelQuery = this.stack.length <= 1\n\n        const selectNodes = node.get('select') as ASTNode[] | undefined\n        const selectExpressions = selectNodes ? selectNodes.map((expr) => this.visit(expr)) : []\n        const space = this.pretty ? `\\n${this.indent(1)}` : ' '\n        const comma = this.pretty ? `,\\n${this.indent(1)}` : ', '\n\n        const clauses: string[] = [\n            `SELECT${node.get('distinct') ? ' DISTINCT' : ''}${space}${selectExpressions.join(comma)}`,\n        ]\n\n        if (node.has('select_from')) {\n            const fromExpr = this.visitJoinExpression(node.get('select_from'))\n            if (fromExpr) {\n                clauses.push(`FROM${space}${fromExpr}`)\n            }\n        }\n\n        if (node.has('prewhere')) {\n            const prewhereExpr = this.visit(node.get('prewhere'))\n            if (prewhereExpr) {\n                clauses.push(`PREWHERE${space}${prewhereExpr}`)\n            }\n        }\n\n        if (node.has('where')) {\n            const whereExpr = this.visit(node.get('where'))\n            if (whereExpr) {\n                clauses.push(`WHERE${space}${whereExpr}`)\n            }\n        }\n\n        if (\n            node.has('group_by') &&\n            Array.isArray(node.get('group_by')) &&\n            (node.get('group_by') as ASTNode[]).length > 0\n        ) {\n            const groupByExpressions = (node.get('group_by') as ASTNode[]).map((expr) => this.visit(expr))\n            clauses.push(`GROUP BY${space}${groupByExpressions.join(comma)}`)\n        }\n\n        if (node.has('having')) {\n            const havingExpr = this.visit(node.get('having'))\n            if (havingExpr) {\n                clauses.push(`HAVING${space}${havingExpr}`)\n            }\n        }\n\n        if (\n            node.has('order_by') &&\n            Array.isArray(node.get('order_by')) &&\n            (node.get('order_by') as ASTNode[]).length > 0\n        ) {\n            const orderByExpressions = (node.get('order_by') as ASTNode[]).map((expr) => this.visit(expr))\n            clauses.push(`ORDER BY${space}${orderByExpressions.join(comma)}`)\n        }\n\n        if (node.has('limit')) {\n            const limitExpr = this.visit(node.get('limit'))\n            if (limitExpr) {\n                clauses.push(`LIMIT ${limitExpr}`)\n            }\n            if (node.get('limit_with_ties')) {\n                clauses.push('WITH TIES')\n            }\n            if (node.has('offset')) {\n                const offsetExpr = this.visit(node.get('offset'))\n                if (offsetExpr) {\n                    clauses.push(`OFFSET ${offsetExpr}`)\n                }\n            }\n        }\n\n        if (node.has('window_exprs')) {\n            const windowExprs = node.get('window_exprs') as Map<string, ASTNode> | undefined\n            if (windowExprs) {\n                const windowExpressions = Array.from(windowExprs.entries())\n                    .map(([name, expr]) => `${escapeIdentifier(name)} AS (${this.visit(expr)})`)\n                    .join(comma)\n                if (windowExpressions) {\n                    clauses.push(`WINDOW${space}${windowExpressions}`)\n                }\n            }\n        }\n\n        let response = this.pretty ? clauses.map((clause) => `${this.indent()}${clause}`).join('\\n') : clauses.join(' ')\n\n        if (!isTopLevelQuery) {\n            response = `(${response})`\n        }\n\n        return response\n    }\n\n    private visitSelectSetQuery(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        this.indentLevel -= 1\n        const initialSelectQuery = node.get('initial_select_query') as ASTNode\n        let result = this.visit(initialSelectQuery)\n\n        if (this.pretty) {\n            result = result.trim()\n        }\n\n        const subsequentQueries = node.get('subsequent_select_queries') as {\n            select_query: ASTNode\n            set_operator: string\n        }[]\n        if (subsequentQueries) {\n            for (const expr of subsequentQueries) {\n                const query = this.visit(expr.select_query)\n                const trimmedQuery = this.pretty ? query.trim() : query\n\n                if (expr.set_operator) {\n                    if (this.pretty) {\n                        result += `\\n${this.indent(1)}${expr.set_operator}\\n${this.indent(1)}`\n                    } else {\n                        result += ` ${expr.set_operator} `\n                    }\n                }\n                result += trimmedQuery\n            }\n        }\n        this.indentLevel += 1\n\n        if (this.stack.length > 1) {\n            return `(${result.trim()})`\n        }\n        return result\n    }\n\n    // Helper method to handle join expressions in the FROM clause\n    private visitJoinExpression(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const nodeType = node.get('__hx_ast') as string\n\n        if (nodeType === 'JoinExpr') {\n            return this.visitJoinExpr(node)\n        }\n        // If it's not a JoinExpr, treat it as a regular table or subquery\n        return this.visit(node)\n    }\n\n    private visitJoinExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const joinParts: string[] = []\n\n        // Handle the initial table or subquery\n        const initialTable = this.visit(node.get('table'))\n\n        // Add alias if present\n        if (node.has('alias') && node.get('alias') !== initialTable) {\n            joinParts.push(`${initialTable} AS ${escapeIdentifier(node.get('alias'))}`)\n        } else {\n            joinParts.push(initialTable)\n        }\n\n        // Process the chain of joins via next_join\n        let currentJoin = node.get('next_join') as ASTNode | undefined\n        while (currentJoin) {\n            const joinType = currentJoin.get('join_type') || 'JOIN'\n            const table = this.visit(currentJoin.get('table'))\n            const constraint = currentJoin.get('constraint') as ASTNode | undefined\n            const constraintClause = constraint ? `${constraint.get('constraint_type')} ${this.visit(constraint)}` : ''\n\n            // Add alias if present\n            let tableWithAlias = table\n            if (currentJoin.has('alias') && currentJoin.get('alias') !== table) {\n                tableWithAlias = `${table} AS ${escapeIdentifier(currentJoin.get('alias'))}`\n            }\n\n            joinParts.push(`${joinType} ${tableWithAlias} ${constraintClause}`.trim())\n\n            currentJoin = currentJoin.get('next_join') as ASTNode | undefined\n        }\n\n        return joinParts.join(' ')\n    }\n\n    private visitJoinConstraint(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        return this.visit(node.get('expr'))\n    }\n\n    private visitCall(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const name = node.get('name') as string\n        const args = (node.get('args') as ASTNode[])?.map((arg) => this.visit(arg)) || []\n        return `${name}(${args.join(', ')})`\n    }\n\n    private visitConstant(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const value = node.get('value')\n        return this.escapeValue(value)\n    }\n\n    private visitField(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const chain = node.get('chain') as Array<string | number>\n        if (chain.length === 1 && chain[0] === '*') {\n            return '*'\n        }\n        return chain.map((identifier) => this.escapeIdentifierOrIndex(identifier)).join('.')\n    }\n\n    private visitAlias(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        if (node.get('hidden')) {\n            return this.visit(node.get('expr'))\n        }\n        let expr = node.get('expr') as ASTNode\n        while (expr && expr instanceof Map && expr.get('__hx_ast') === 'Alias' && expr.get('hidden')) {\n            expr = expr.get('expr')\n        }\n        const inside = this.visit(expr)\n        const alias = escapeIdentifier(node.get('alias') as string)\n        return `${inside} AS ${alias}`\n    }\n\n    private visitAnd(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const exprs = node.get('exprs') as ASTNode[] | undefined\n        if (!exprs || exprs.length === 0) {\n            return ''\n        }\n        if (exprs.length === 1) {\n            return this.visit(exprs[0])\n        }\n        const expressions = exprs.map((expr) => this.visit(expr))\n        return `and(${expressions.join(', ')})`\n    }\n\n    private visitOr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const exprs = node.get('exprs') as ASTNode[] | undefined\n        if (!exprs || exprs.length === 0) {\n            return ''\n        }\n        if (exprs.length === 1) {\n            return this.visit(exprs[0])\n        }\n        const expressions = exprs.map((expr) => this.visit(expr))\n        return `or(${expressions.join(', ')})`\n    }\n\n    private visitNot(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        return `not(${this.visit(node.get('expr'))})`\n    }\n\n    private visitCompareOperation(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const left = this.visit(node.get('left'))\n        const right = this.visit(node.get('right'))\n        const op = node.get('op') as string\n        const opMap: { [key: string]: string } = {\n            '==': 'equals',\n            '!=': 'notEquals',\n            '<': 'less',\n            '>': 'greater',\n            '<=': 'lessOrEquals',\n            '>=': 'greaterOrEquals',\n            in: 'in',\n            'not in': 'notIn',\n            like: 'like',\n            'not like': 'notLike',\n            ilike: 'ilike',\n            'not ilike': 'notILike',\n            '=~': 'match',\n            '!~': 'match',\n            '=~*': 'match',\n            '!~*': 'match',\n        }\n\n        const functionName = opMap[op] || op\n        if (op === '!~*') {\n            return `not(${functionName}(${left}, concat('(?i)', ${right})))`\n        }\n        if (op === '=~*') {\n            return `${functionName}(${left}, concat('(?i)', ${right}))`\n        }\n        if (op === '!~') {\n            return `not(${functionName}(${left}, ${right}))`\n        }\n        return `${functionName}(${left}, ${right})`\n    }\n\n    private visitTuple(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const exprs = node.get('exprs') as ASTNode[] | undefined\n        if (!exprs) {\n            return ''\n        }\n        const expressions = exprs.map((expr) => this.visit(expr))\n        return `tuple(${expressions.join(', ')})`\n    }\n\n    private visitArray(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const exprs = node.get('exprs') as ASTNode[] | undefined\n        if (!exprs) {\n            return ''\n        }\n        const expressions = exprs.map((expr) => this.visit(expr))\n        return `[${expressions.join(', ')}]`\n    }\n\n    private visitLambda(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const args = node.get('args') as string[] | undefined\n        if (!args || args.length === 0) {\n            throw new Error('Lambdas require at least one argument')\n        }\n        const escapedArgs = args.map((arg) => escapeIdentifier(arg))\n        const argList = escapedArgs.length === 1 ? escapedArgs[0] : `(${escapedArgs.join(', ')})`\n        return `${argList} -> ${this.visit(node.get('expr'))}`\n    }\n\n    private visitOrderExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        return `${this.visit(node.get('expr'))} ${node.get('order')}`\n    }\n\n    private visitArithmeticOperation(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const left = this.visit(node.get('left'))\n        const right = this.visit(node.get('right'))\n        const op = node.get('op') as string\n        switch (op) {\n            case '+':\n                return `plus(${left}, ${right})`\n            case '-':\n                return `minus(${left}, ${right})`\n            case '*':\n                return `multiply(${left}, ${right})`\n            case '/':\n                return `divide(${left}, ${right})`\n            case '%':\n                return `modulo(${left}, ${right})`\n            default:\n                throw new Error(`Unknown ArithmeticOperation operator: ${op}`)\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    private visitAsterisk(_: ASTNode): string {\n        return '*'\n    }\n\n    private visitWindowExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const parts: string[] = []\n        if (\n            node.has('partition_by') &&\n            Array.isArray(node.get('partition_by')) &&\n            (node.get('partition_by') as ASTNode[]).length > 0\n        ) {\n            const partitions = (node.get('partition_by') as ASTNode[]).map((expr) => this.visit(expr)).join(', ')\n            parts.push(`PARTITION BY ${partitions}`)\n        }\n        if (\n            node.has('order_by') &&\n            Array.isArray(node.get('order_by')) &&\n            (node.get('order_by') as ASTNode[]).length > 0\n        ) {\n            const orders = (node.get('order_by') as ASTNode[]).map((expr) => this.visit(expr)).join(', ')\n            parts.push(`ORDER BY ${orders}`)\n        }\n        if (node.has('frame_method')) {\n            const frameMethod = node.get('frame_method') as string\n            if (node.has('frame_start') && node.has('frame_end')) {\n                parts.push(\n                    `${frameMethod} BETWEEN ${this.visitWindowFrameExpr(\n                        node.get('frame_start')\n                    )} AND ${this.visitWindowFrameExpr(node.get('frame_end'))}`\n                )\n            } else if (node.has('frame_start')) {\n                parts.push(`${frameMethod} ${this.visitWindowFrameExpr(node.get('frame_start'))}`)\n            }\n        }\n        return parts.join(' ')\n    }\n\n    private visitWindowFunction(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const name = node.get('name') as string\n        const exprs = node.has('exprs')\n            ? (node.get('exprs') as ASTNode[]).map((expr) => this.visit(expr)).join(', ')\n            : ''\n        const args = node.has('args')\n            ? `(${(node.get('args') as ASTNode[]).map((arg) => this.visit(arg)).join(', ')})`\n            : ''\n        let over = ''\n        if (node.has('over_expr')) {\n            over = `(${this.visit(node.get('over_expr'))})`\n        } else if (node.has('over_identifier')) {\n            over = escapeIdentifier(node.get('over_identifier') as string)\n        } else {\n            over = '()'\n        }\n        return `${name}(${exprs})${args} OVER ${over}`\n    }\n\n    private visitWindowFrameExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const frameType = node.get('frame_type') as string\n        const frameValue = node.has('frame_value') ? node.get('frame_value').toString() : 'UNBOUNDED'\n        return `${frameValue} ${frameType}`\n    }\n\n    private visitSampleExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        const sampleValue = this.visitRatioExpr(node.get('sample_value'))\n        const offsetClause = node.has('offset_value') ? ` OFFSET ${this.visitRatioExpr(node.get('offset_value'))}` : ''\n        return `SAMPLE ${sampleValue}${offsetClause}`\n    }\n\n    private visitRatioExpr(node: ASTNode): string {\n        if (!node) {\n            return ''\n        }\n        if (node.has('right')) {\n            return `${this.visit(node.get('left'))}/${this.visit(node.get('right'))}`\n        }\n        return this.visit(node.get('left'))\n    }\n\n    private escapeIdentifierOrIndex(name: string | number): string {\n        if (typeof name === 'number' && /^\\d+$/.test(name.toString())) {\n            return name.toString()\n        }\n        return escapeIdentifier(name.toString())\n    }\n\n    private escapeValue(value: any): string {\n        return printHogValue(value, this.marked)\n    }\n}\n","import { afterMount, kea, listeners, path, reducers } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\n\nimport { ActivationTask } from '~/layout/navigation-3000/sidepanel/panels/activation/activationLogic'\nimport { activationLogic } from '~/layout/navigation-3000/sidepanel/panels/activation/activationLogic'\nimport { HogQLQuery, NodeKind } from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\n\nimport type { reverseProxyCheckerLogicType } from './reverseProxyCheckerLogicType'\n\nconst CHECK_INTERVAL_MS = 1000 * 60 * 60 // 1 hour\n\nexport const reverseProxyCheckerLogic = kea<reverseProxyCheckerLogicType>([\n    path(['components', 'ReverseProxyChecker', 'reverseProxyCheckerLogic']),\n    loaders({\n        hasReverseProxy: [\n            false as boolean | null,\n            {\n                loadHasReverseProxy: async () => {\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$lib_custom_api_host AS lib_custom_api_host\n                                FROM events\n                                WHERE timestamp >= now() - INTERVAL 1 DAY \n                                AND timestamp <= now()\n                                ORDER BY timestamp DESC\n                                limit 10`,\n                    }\n\n                    const res = await api.query(query)\n                    return !!res.results?.find((x) => !!x[0])\n                },\n            },\n        ],\n    }),\n    listeners(({ values }) => ({\n        loadHasReverseProxySuccess: () => {\n            if (values.hasReverseProxy) {\n                activationLogic.findMounted()?.actions.markTaskAsCompleted(ActivationTask.SetUpReverseProxy)\n            }\n        },\n    })),\n    reducers({\n        lastCheckedTimestamp: [\n            0,\n            { persist: true },\n            {\n                loadHasReverseProxySuccess: () => Date.now(),\n            },\n        ],\n    }),\n    afterMount(({ actions, values }) => {\n        if (values.lastCheckedTimestamp < Date.now() - CHECK_INTERVAL_MS) {\n            actions.loadHasReverseProxy()\n        }\n    }),\n])\n","import { IconInfo } from '@posthog/icons'\nimport {\n    LemonBanner,\n    LemonCheckbox,\n    LemonInput,\n    LemonSegmentedButton,\n    LemonSelect,\n    SpinnerOverlay,\n    Tooltip,\n} from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { Form, Group } from 'kea-forms'\nimport { AlertStateIndicator } from 'lib/components/Alerts/views/ManageAlertsModal'\nimport { MemberSelectMultiple } from 'lib/components/MemberSelectMultiple'\nimport { TZLabel } from 'lib/components/TZLabel'\nimport { UserActivityIndicator } from 'lib/components/UserActivityIndicator/UserActivityIndicator'\nimport { dayjs } from 'lib/dayjs'\nimport { IconChevronLeft } from 'lib/lemon-ui/icons'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonModal } from 'lib/lemon-ui/LemonModal'\nimport { alphabet, formatDate } from 'lib/utils'\nimport { useCallback } from 'react'\nimport { trendsDataLogic } from 'scenes/trends/trendsDataLogic'\n\nimport {\n    AlertCalculationInterval,\n    AlertConditionType,\n    AlertState,\n    InsightThresholdType,\n} from '~/queries/schema/schema-general'\nimport { InsightLogicProps, InsightShortId, QueryBasedInsightModel } from '~/types'\n\nimport { alertFormLogic, canCheckOngoingInterval } from '../alertFormLogic'\nimport { alertLogic } from '../alertLogic'\nimport { SnoozeButton } from '../SnoozeButton'\nimport { AlertType } from '../types'\n\nexport function AlertStateTable({ alert }: { alert: AlertType }): JSX.Element | null {\n    if (!alert.checks || alert.checks.length === 0) {\n        return null\n    }\n\n    return (\n        <div className=\"bg-primary p-4 mt-10 rounded-lg\">\n            <div className=\"flex flex-row gap-2 items-center mb-2\">\n                <h3 className=\"m-0\">Current status: </h3>\n                <AlertStateIndicator alert={alert} />\n                <h3 className=\"m-0\">\n                    {alert.snoozed_until && ` until ${formatDate(dayjs(alert?.snoozed_until), 'MMM D, HH:mm')}`}\n                </h3>\n            </div>\n            <table className=\"w-full table-auto border-spacing-2 border-collapse\">\n                <thead>\n                    <tr className=\"text-left\">\n                        <th>Status</th>\n                        <th className=\"text-right\">Time</th>\n                        <th className=\"text-right pr-4\">Value</th>\n                        <th>Targets notified</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    {alert.checks.map((check) => (\n                        <tr key={check.id}>\n                            <td>{check.state}</td>\n                            <td className=\"text-right\">\n                                <TZLabel time={check.created_at} />\n                            </td>\n                            <td className=\"text-right pr-4\">{check.calculated_value}</td>\n                            <td>{check.targets_notified ? 'Yes' : 'No'}</td>\n                        </tr>\n                    ))}\n                </tbody>\n            </table>\n        </div>\n    )\n}\n\ninterface EditAlertModalProps {\n    isOpen: boolean | undefined\n    alertId?: AlertType['id']\n    insightId: QueryBasedInsightModel['id']\n    insightShortId: InsightShortId\n    onEditSuccess: () => void\n    onClose?: () => void\n    insightLogicProps?: InsightLogicProps\n}\n\nexport function EditAlertModal({\n    isOpen,\n    alertId,\n    insightId,\n    insightShortId,\n    onClose,\n    onEditSuccess,\n    insightLogicProps,\n}: EditAlertModalProps): JSX.Element {\n    const _alertLogic = alertLogic({ alertId })\n    const { alert, alertLoading } = useValues(_alertLogic)\n    const { loadAlert } = useActions(_alertLogic)\n\n    // need to reload edited alert as well\n    const _onEditSuccess = useCallback(() => {\n        loadAlert()\n        onEditSuccess()\n    }, [loadAlert, onEditSuccess])\n\n    const formLogicProps = {\n        alert,\n        insightId,\n        onEditSuccess: _onEditSuccess,\n        insightVizDataLogicProps: insightLogicProps,\n    }\n    const formLogic = alertFormLogic(formLogicProps)\n    const { alertForm, isAlertFormSubmitting, alertFormChanged } = useValues(formLogic)\n    const { deleteAlert, snoozeAlert, clearSnooze } = useActions(formLogic)\n    const { setAlertFormValue } = useActions(formLogic)\n\n    const trendsLogic = trendsDataLogic({ dashboardItemId: insightShortId })\n    const { alertSeries, isNonTimeSeriesDisplay, isBreakdownValid, formula } = useValues(trendsLogic)\n\n    const creatingNewAlert = alertForm.id === undefined\n    // can only check ongoing interval for absolute value/increase alerts with upper threshold\n    const can_check_ongoing_interval = canCheckOngoingInterval(alertForm)\n\n    return (\n        <LemonModal onClose={onClose} isOpen={isOpen} width={600} simple title=\"\">\n            {alertLoading ? (\n                <SpinnerOverlay />\n            ) : (\n                <Form\n                    logic={alertFormLogic}\n                    props={formLogicProps}\n                    formKey=\"alertForm\"\n                    enableFormOnSubmit\n                    className=\"LemonModal__layout\"\n                >\n                    <LemonModal.Header>\n                        <div className=\"flex items-center gap-2\">\n                            <LemonButton icon={<IconChevronLeft />} onClick={onClose} size=\"xsmall\" />\n\n                            <h3>{creatingNewAlert ? 'New' : 'Edit '} Alert</h3>\n                        </div>\n                    </LemonModal.Header>\n\n                    <LemonModal.Content>\n                        <div className=\"deprecated-space-y-8\">\n                            <div className=\"deprecated-space-y-4\">\n                                <div className=\"flex gap-4 items-center\">\n                                    <LemonField className=\"flex-auto\" name=\"name\">\n                                        <LemonInput placeholder=\"Alert name\" data-attr=\"alertForm-name\" />\n                                    </LemonField>\n                                    <LemonField name=\"enabled\">\n                                        <LemonCheckbox\n                                            checked={alertForm?.enabled}\n                                            data-attr=\"alertForm-enabled\"\n                                            fullWidth\n                                            label=\"Enabled\"\n                                        />\n                                    </LemonField>\n                                </div>\n                                {alert?.created_by ? (\n                                    <UserActivityIndicator\n                                        at={alert.created_at}\n                                        by={alert.created_by}\n                                        prefix=\"Created\"\n                                        // className=\"mb-4\"\n                                    />\n                                ) : null}\n                            </div>\n\n                            <div className=\"deprecated-space-y-6\">\n                                <h3>Definition</h3>\n                                <div className=\"deprecated-space-y-5\">\n                                    {isBreakdownValid && (\n                                        <LemonBanner type=\"warning\">\n                                            For trends with breakdown, the alert will fire if any of the breakdown\n                                            values breaches the threshold.\n                                        </LemonBanner>\n                                    )}\n                                    <div className=\"flex gap-4 items-center\">\n                                        <div>When</div>\n                                        <Group name={['config']}>\n                                            <LemonField name=\"series_index\" className=\"flex-auto\">\n                                                <LemonSelect\n                                                    fullWidth\n                                                    data-attr=\"alertForm-series-index\"\n                                                    options={alertSeries?.map(\n                                                        ({ custom_name, name, event }, index) => ({\n                                                            label: isBreakdownValid\n                                                                ? 'any breakdown value'\n                                                                : formula\n                                                                ? `Formula (${formula})`\n                                                                : `${alphabet[index]} - ${\n                                                                      custom_name ?? name ?? event\n                                                                  }`,\n                                                            value: isBreakdownValid || formula ? 0 : index,\n                                                        })\n                                                    )}\n                                                    disabledReason={\n                                                        (isBreakdownValid &&\n                                                            `For trends with breakdown, the alert will fire if any of the breakdown\n                                            values breaches the threshold.`) ||\n                                                        (formula &&\n                                                            `When using formula mode, can only alert on formula value`)\n                                                    }\n                                                />\n                                            </LemonField>\n                                        </Group>\n                                        <Group name={['condition']}>\n                                            <LemonField name=\"type\">\n                                                <LemonSelect\n                                                    fullWidth\n                                                    className=\"w-40\"\n                                                    data-attr=\"alertForm-condition\"\n                                                    options={[\n                                                        {\n                                                            label: 'has value',\n                                                            value: AlertConditionType.ABSOLUTE_VALUE,\n                                                        },\n                                                        {\n                                                            label: 'increases by',\n                                                            value: AlertConditionType.RELATIVE_INCREASE,\n                                                            disabledReason:\n                                                                isNonTimeSeriesDisplay &&\n                                                                'This condition is only supported for time series trends',\n                                                        },\n                                                        {\n                                                            label: 'decreases by',\n                                                            value: AlertConditionType.RELATIVE_DECREASE,\n                                                            disabledReason:\n                                                                isNonTimeSeriesDisplay &&\n                                                                'This condition is only supported for time series trends',\n                                                        },\n                                                    ]}\n                                                />\n                                            </LemonField>\n                                        </Group>\n                                    </div>\n                                    <div className=\"flex gap-4 items-center\">\n                                        <div>less than</div>\n                                        <LemonField name=\"lower\">\n                                            <LemonInput\n                                                type=\"number\"\n                                                className=\"w-30\"\n                                                data-attr=\"alertForm-lower-threshold\"\n                                                value={\n                                                    alertForm.threshold.configuration.type ===\n                                                        InsightThresholdType.PERCENTAGE &&\n                                                    alertForm.threshold.configuration.bounds?.lower\n                                                        ? alertForm.threshold.configuration.bounds?.lower * 100\n                                                        : alertForm.threshold.configuration.bounds?.lower\n                                                }\n                                                onChange={(value) =>\n                                                    setAlertFormValue('threshold', {\n                                                        configuration: {\n                                                            type: alertForm.threshold.configuration.type,\n                                                            bounds: {\n                                                                ...alertForm.threshold.configuration.bounds,\n                                                                lower:\n                                                                    value &&\n                                                                    alertForm.threshold.configuration.type ===\n                                                                        InsightThresholdType.PERCENTAGE\n                                                                        ? value / 100\n                                                                        : value,\n                                                            },\n                                                        },\n                                                    })\n                                                }\n                                            />\n                                        </LemonField>\n                                        <div>or more than</div>\n                                        <LemonField name=\"upper\">\n                                            <LemonInput\n                                                type=\"number\"\n                                                className=\"w-30\"\n                                                data-attr=\"alertForm-upper-threshold\"\n                                                value={\n                                                    alertForm.threshold.configuration.type ===\n                                                        InsightThresholdType.PERCENTAGE &&\n                                                    alertForm.threshold.configuration.bounds?.upper\n                                                        ? alertForm.threshold.configuration.bounds?.upper * 100\n                                                        : alertForm.threshold.configuration.bounds?.upper\n                                                }\n                                                onChange={(value) =>\n                                                    setAlertFormValue('threshold', {\n                                                        configuration: {\n                                                            type: alertForm.threshold.configuration.type,\n                                                            bounds: {\n                                                                ...alertForm.threshold.configuration.bounds,\n                                                                upper:\n                                                                    value &&\n                                                                    alertForm.threshold.configuration.type ===\n                                                                        InsightThresholdType.PERCENTAGE\n                                                                        ? value / 100\n                                                                        : value,\n                                                            },\n                                                        },\n                                                    })\n                                                }\n                                            />\n                                        </LemonField>\n                                        {alertForm.condition.type !== AlertConditionType.ABSOLUTE_VALUE && (\n                                            <Group name={['threshold', 'configuration']}>\n                                                <LemonField name=\"type\">\n                                                    <LemonSegmentedButton\n                                                        options={[\n                                                            {\n                                                                value: InsightThresholdType.PERCENTAGE,\n                                                                label: '%',\n                                                                tooltip: 'Percent',\n                                                            },\n                                                            {\n                                                                value: InsightThresholdType.ABSOLUTE,\n                                                                label: '#',\n                                                                tooltip: 'Absolute number',\n                                                            },\n                                                        ]}\n                                                    />\n                                                </LemonField>\n                                            </Group>\n                                        )}\n                                    </div>\n                                    <div className=\"flex gap-4 items-center\">\n                                        <div>\n                                            {alertForm.condition.type === AlertConditionType.ABSOLUTE_VALUE\n                                                ? 'check'\n                                                : 'compare'}\n                                        </div>\n                                        <LemonField name=\"calculation_interval\">\n                                            <LemonSelect\n                                                fullWidth\n                                                className=\"w-28\"\n                                                data-attr=\"alertForm-calculation-interval\"\n                                                options={Object.values(AlertCalculationInterval).map((interval) => ({\n                                                    label: interval,\n                                                    value: interval,\n                                                }))}\n                                            />\n                                        </LemonField>\n                                        <div>and notify</div>\n                                        <div className=\"flex-auto\">\n                                            <MemberSelectMultiple\n                                                value={alertForm.subscribed_users?.map((u) => u.id) ?? []}\n                                                idKey=\"id\"\n                                                onChange={(value) => setAlertFormValue('subscribed_users', value)}\n                                            />\n                                        </div>\n                                    </div>\n                                </div>\n                            </div>\n\n                            <div className=\"deprecated-space-y-2\">\n                                <h3 className=\"text-secondary\">Advanced</h3>\n                                <Group name={['config']}>\n                                    <div className=\"flex gap-1\">\n                                        <LemonField name=\"check_ongoing_interval\">\n                                            <LemonCheckbox\n                                                checked={\n                                                    can_check_ongoing_interval &&\n                                                    alertForm?.config.check_ongoing_interval\n                                                }\n                                                data-attr=\"alertForm-check-ongoing-interval\"\n                                                fullWidth\n                                                label=\"Check ongoing period\"\n                                                disabledReason={\n                                                    !can_check_ongoing_interval &&\n                                                    'Can only alert for ongoing period when checking for absolute value/increase above threshold'\n                                                }\n                                            />\n                                        </LemonField>\n                                        <Tooltip\n                                            title={`Checks the insight value for the on going period (current week/month) that hasn't yet completed. Use this if you want to be alerted right away when the insight value rises/increases above threshold`}\n                                            placement=\"right\"\n                                            delayMs={0}\n                                        >\n                                            <IconInfo />\n                                        </Tooltip>\n                                    </div>\n                                </Group>\n                                <LemonField name=\"skip_weekend\">\n                                    <LemonCheckbox\n                                        checked={\n                                            (alertForm?.calculation_interval === AlertCalculationInterval.DAILY ||\n                                                alertForm?.calculation_interval === AlertCalculationInterval.HOURLY) &&\n                                            alertForm?.skip_weekend\n                                        }\n                                        data-attr=\"alertForm-skip-weekend\"\n                                        fullWidth\n                                        label=\"Skip checking on weekends\"\n                                        disabledReason={\n                                            alertForm?.calculation_interval !== AlertCalculationInterval.DAILY &&\n                                            alertForm?.calculation_interval !== AlertCalculationInterval.HOURLY &&\n                                            'Can only skip weekend checking for hourly/daily alerts'\n                                        }\n                                    />\n                                </LemonField>\n                            </div>\n                        </div>\n\n                        {alert && <AlertStateTable alert={alert} />}\n                    </LemonModal.Content>\n\n                    <LemonModal.Footer>\n                        <div className=\"flex-1\">\n                            <div className=\"flex gap-2\">\n                                {!creatingNewAlert ? (\n                                    <LemonButton type=\"secondary\" status=\"danger\" onClick={deleteAlert}>\n                                        Delete alert\n                                    </LemonButton>\n                                ) : null}\n                                {!creatingNewAlert && alert?.state === AlertState.FIRING ? (\n                                    <SnoozeButton onChange={snoozeAlert} value={alert?.snoozed_until} />\n                                ) : null}\n                                {!creatingNewAlert && alert?.state === AlertState.SNOOZED ? (\n                                    <LemonButton\n                                        type=\"secondary\"\n                                        status=\"default\"\n                                        onClick={clearSnooze}\n                                        tooltip={`Currently snoozed until ${formatDate(\n                                            dayjs(alert?.snoozed_until),\n                                            'MMM D, HH:mm'\n                                        )}`}\n                                    >\n                                        Clear snooze\n                                    </LemonButton>\n                                ) : null}\n                            </div>\n                        </div>\n                        <LemonButton\n                            type=\"primary\"\n                            htmlType=\"submit\"\n                            loading={isAlertFormSubmitting}\n                            disabledReason={!alertFormChanged && 'No changes to save'}\n                        >\n                            {creatingNewAlert ? 'Create alert' : 'Save'}\n                        </LemonButton>\n                    </LemonModal.Footer>\n                </Form>\n            )}\n        </LemonModal>\n    )\n}\n","import {\n    actions,\n    afterMount,\n    connect,\n    kea,\n    key,\n    listeners,\n    path,\n    props,\n    reducers,\n    selectors,\n    sharedListeners,\n} from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { encodeParams, urlToAction } from 'kea-router'\nimport { subscriptions } from 'kea-subscriptions'\nimport api from 'lib/api'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { isDomain, isURL } from 'lib/utils'\nimport { apiHostOrigin } from 'lib/utils/apiHost'\nimport { copyToClipboard } from 'lib/utils/copyToClipboard'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\nimport { ExperimentIdType, ToolbarParams, ToolbarUserIntent } from '~/types'\n\nimport type { authorizedUrlListLogicType } from './authorizedUrlListLogicType'\n\nexport interface ProposeNewUrlFormType {\n    url: string\n}\n\nexport enum AuthorizedUrlListType {\n    TOOLBAR_URLS = 'TOOLBAR_URLS',\n    RECORDING_DOMAINS = 'RECORDING_DOMAINS',\n    WEB_ANALYTICS = 'WEB_ANALYTICS',\n    WEB_EXPERIMENTS = 'WEB_EXPERIMENTS',\n}\n\n/**\n * Firefox does not allow you construct a new URL with e.g. https://*.example.com (which is to be fair more standards compliant than Chrome)\n * when used to probe for e.g. for authorized urls we only care if the proposed URL has a path so we can safely replace the wildcard with a character\n */\nexport function sanitizePossibleWildCardedURL(url: string): URL {\n    const deWildCardedURL = url.replace(/\\*/g, 'x')\n    return new URL(deWildCardedURL)\n}\n\n/**\n * Checks if the URL has a wildcard (*) in the port position e.g. http://localhost:*\n */\nexport function hasWildcardInPort(input: unknown): boolean {\n    if (!input || typeof input !== 'string') {\n        return false\n    }\n    // This regex matches URLs with a wildcard (*) in the port position\n    const portWildcardRegex = /^(https?:\\/\\/[^:/]+):\\*(.*)$/\n    return portWildcardRegex.test(input.trim())\n}\n\nexport const validateProposedUrl = (\n    proposedUrl: string,\n    currentUrls: string[],\n    onlyAllowDomains: boolean = false,\n    allowWildCards: boolean = true\n): string | undefined => {\n    if (!isURL(proposedUrl)) {\n        return 'Please enter a valid URL'\n    }\n\n    if (hasWildcardInPort(proposedUrl)) {\n        return 'Wildcards are not allowed in the port position'\n    }\n\n    if (onlyAllowDomains && !isDomain(sanitizePossibleWildCardedURL(proposedUrl))) {\n        return \"Please enter a valid domain (URLs with a path aren't allowed)\"\n    }\n\n    const hasWildCard = proposedUrl.indexOf('*') > -1\n    if (hasWildCard && allowWildCards === false) {\n        return 'Wildcards are not allowed'\n    }\n\n    if (\n        hasWildCard &&\n        !/^https?:\\/\\/((\\*\\.)?localhost|localhost)(:\\d+)?$/.test(proposedUrl) && // Allow http://*.localhost and localhost with ports\n        !proposedUrl.match(/^(.*)\\*[^*]*\\.[^*]+\\.[^*]+$/)\n    ) {\n        return 'Wildcards can only be used for subdomains'\n    }\n\n    if (currentUrls.indexOf(proposedUrl) > -1) {\n        return `This ${onlyAllowDomains ? 'domains' : 'URL'} already is registered`\n    }\n\n    return\n}\n\nfunction buildToolbarParams(options?: {\n    actionId?: number | null\n    experimentId?: ExperimentIdType\n    userIntent?: ToolbarUserIntent\n}): ToolbarParams {\n    return {\n        userIntent:\n            options?.userIntent ??\n            (options?.actionId ? 'edit-action' : options?.experimentId ? 'edit-experiment' : 'add-action'),\n        // Make sure to pass the app url, otherwise the api_host will be used by\n        // the toolbar, which isn't correct when used behind a reverse proxy as\n        // we require e.g. SSO login to the app, which will not work when placed\n        // behind a proxy unless we register each domain with the OAuth2 client.\n        apiURL: apiHostOrigin(),\n        ...(options?.actionId ? { actionId: options.actionId } : {}),\n        ...(options?.experimentId ? { experimentId: options.experimentId } : {}),\n    }\n}\n\n/** defaultIntent: whether to launch with empty intent (i.e. toolbar mode is default) */\nexport function appEditorUrl(\n    appUrl: string,\n    options?: {\n        actionId?: number | null\n        experimentId?: ExperimentIdType\n        userIntent?: ToolbarUserIntent\n        generateOnly?: boolean\n    }\n): string {\n    const params = buildToolbarParams(options) as Record<string, unknown>\n    // See https://github.com/PostHog/posthog-js/blob/f7119c/src/extensions/toolbar.ts#L52 for where these params\n    // are passed. `appUrl` is an extra `redirect_to_site` param.\n    params['appUrl'] = appUrl\n    params['generateOnly'] = options?.generateOnly\n    return '/api/user/redirect_to_site/' + encodeParams(params, '?')\n}\n\nexport const checkUrlIsAuthorized = (url: string | URL, authorizedUrls: string[]): boolean => {\n    try {\n        const parsedUrl = typeof url === 'string' ? sanitizePossibleWildCardedURL(url) : url\n        const urlWithoutPath = parsedUrl.protocol + '//' + parsedUrl.host\n        // Is this domain already in the list of urls?\n        const exactMatch =\n            authorizedUrls.filter((authorizedUrl) => authorizedUrl.indexOf(urlWithoutPath) > -1).length > 0\n\n        if (exactMatch) {\n            return true\n        }\n\n        const wildcardMatch = !!authorizedUrls.find((authorizedUrl) => {\n            // Matches something like `https://*.example.com` against the urlWithoutPath\n            const regex = new RegExp(authorizedUrl.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'))\n            return urlWithoutPath.match(regex)\n        })\n\n        if (wildcardMatch) {\n            return true\n        }\n    } catch (error) {\n        // Ignore invalid URLs\n    }\n\n    return false\n}\n\nexport interface SuggestedDomain {\n    url: string\n    count: number\n}\n\nexport const filterNotAuthorizedUrls = (\n    suggestions: SuggestedDomain[],\n    authorizedUrls: string[]\n): SuggestedDomain[] => {\n    const suggestedDomains: SuggestedDomain[] = []\n\n    suggestions.forEach(({ url, count }) => {\n        const parsedUrl = sanitizePossibleWildCardedURL(url)\n        const urlWithoutPath = parsedUrl.protocol + '//' + parsedUrl.host\n        // Have we already added this domain?\n        if (suggestedDomains.some((sd) => sd.url === urlWithoutPath)) {\n            return\n        }\n\n        if (!checkUrlIsAuthorized(parsedUrl, authorizedUrls)) {\n            suggestedDomains.push({ url: urlWithoutPath, count })\n        }\n    })\n\n    return suggestedDomains\n}\n\nexport const NEW_URL = 'https://'\n\nexport interface KeyedAppUrl {\n    url: string\n    type: 'authorized' | 'suggestion'\n    originalIndex: number\n    // how many seen in the last three days\n    count?: number\n}\n\nexport interface AuthorizedUrlListLogicProps {\n    actionId: number | null\n    experimentId: ExperimentIdType | null\n    type: AuthorizedUrlListType\n    allowWildCards?: boolean\n}\n\nexport const defaultAuthorizedUrlProperties = {\n    actionId: null,\n    experimentId: null,\n}\n\nexport const authorizedUrlListLogic = kea<authorizedUrlListLogicType>([\n    path((key) => ['lib', 'components', 'AuthorizedUrlList', 'authorizedUrlListLogic', key]),\n    key((props) => `${props.type}-${props.experimentId}-${props.actionId}`), // Some will be undefined but that's ok, this avoids experiment/action with same ID sharing same store\n    props({} as AuthorizedUrlListLogicProps),\n    connect({\n        values: [teamLogic, ['currentTeam', 'currentTeamId']],\n        actions: [teamLogic, ['updateCurrentTeam']],\n    }),\n    actions(() => ({\n        setAuthorizedUrls: (authorizedUrls: string[]) => ({ authorizedUrls }),\n        addUrl: (url: string, launch?: boolean) => ({ url, launch }),\n        newUrl: true,\n        removeUrl: (index: number) => ({ index }),\n        updateUrl: (index: number, url: string) => ({ index, url }),\n        launchAtUrl: (url: string) => ({ url }),\n        setEditUrlIndex: (originalIndex: number | null) => ({ originalIndex }),\n        cancelProposingUrl: true,\n        copyLaunchCode: (url: string) => ({ url }),\n    })),\n    loaders(({ values, props }) => ({\n        suggestions: {\n            __default: [] as SuggestedDomain[],\n            loadSuggestions: async () => {\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: hogql`select properties.$current_url, count()\n                        from events\n                           where event = '$pageview'\n                           and timestamp >= now() - interval 3 day \n                            and timestamp <= now()\n                           and properties.$current_url is not null\n                         group by properties.$current_url\n                         order by count() desc\n                        limit 25`,\n                }\n\n                const response = await api.query(query)\n                const result = response.results as [string, number][]\n\n                if (result && result.length === 0) {\n                    return []\n                }\n\n                const suggestedDomains = filterNotAuthorizedUrls(\n                    result.map(([url, count]) => ({ url, count })),\n                    values.authorizedUrls\n                )\n\n                return suggestedDomains.slice(0, 20)\n            },\n        },\n        manualLaunchParams: {\n            loadManualLaunchParams: async (url: string): Promise<string | undefined> => {\n                const response = await api.get(\n                    appEditorUrl(url, {\n                        ...(props?.actionId ? { actionId: props.actionId } : {}),\n                        ...(props?.experimentId ? { experimentId: props.experimentId } : {}),\n                        generateOnly: true,\n                    })\n                )\n\n                let decoded: string | undefined = undefined\n                try {\n                    if (response?.toolbarParams) {\n                        decoded = decodeURIComponent(response.toolbarParams)\n                    }\n                } catch {\n                    lemonToast.error('Failed to generate toolbar params')\n                }\n                return decoded\n            },\n        },\n    })),\n    subscriptions(({ props, actions }) => ({\n        currentTeam: (currentTeam) => {\n            actions.setAuthorizedUrls(\n                (props.type === AuthorizedUrlListType.RECORDING_DOMAINS\n                    ? currentTeam.recording_domains\n                    : currentTeam.app_urls) || []\n            )\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadSuggestions()\n    }),\n    forms(({ values, actions, props }) => ({\n        proposedUrl: {\n            defaults: { url: '' } as ProposeNewUrlFormType,\n            errors: ({ url }) => ({\n                // default to allowing wildcards because that was the original behavior\n                url: validateProposedUrl(\n                    url,\n                    values.authorizedUrls,\n                    values.onlyAllowDomains,\n                    props.allowWildCards ?? true\n                ),\n            }),\n            submit: async ({ url }) => {\n                if (values.editUrlIndex !== null && values.editUrlIndex >= 0) {\n                    actions.updateUrl(values.editUrlIndex, url)\n                } else {\n                    actions.addUrl(url)\n                }\n            },\n        },\n    })),\n    reducers(() => ({\n        showProposedURLForm: [\n            false as boolean,\n            {\n                newUrl: () => true,\n                submitProposedUrlSuccess: () => false,\n                cancelProposingUrl: () => false,\n            },\n        ],\n        authorizedUrls: [\n            [] as string[],\n            {\n                setAuthorizedUrls: (_, { authorizedUrls }) => authorizedUrls,\n                addUrl: (state, { url }) => (!state.includes(url) ? state.concat([url]) : state),\n                updateUrl: (state, { index, url }) => Object.assign([...state], { [index]: url }),\n                removeUrl: (state, { index }) => {\n                    const newUrls = [...state]\n                    newUrls.splice(index, 1)\n                    return newUrls\n                },\n            },\n        ],\n        suggestions: [\n            [],\n            {\n                addUrl: (state, { url }) => [...state].filter((sd) => url !== sd.url),\n            },\n        ],\n        editUrlIndex: [\n            null as number | null,\n            {\n                setEditUrlIndex: (_, { originalIndex }) => originalIndex,\n                removeUrl: (editUrlIndex, { index }) =>\n                    editUrlIndex && index < editUrlIndex\n                        ? editUrlIndex - 1\n                        : index === editUrlIndex\n                        ? null\n                        : editUrlIndex,\n                newUrl: () => -1,\n                updateUrl: () => null,\n                addUrl: () => null,\n                cancelProposingUrl: () => null,\n            },\n        ],\n    })),\n    sharedListeners(({ values, props }) => ({\n        saveUrls: async () => {\n            if (props.type === AuthorizedUrlListType.RECORDING_DOMAINS) {\n                await teamLogic.asyncActions.updateCurrentTeam({ recording_domains: values.authorizedUrls })\n            } else {\n                await teamLogic.asyncActions.updateCurrentTeam({ app_urls: values.authorizedUrls })\n            }\n        },\n    })),\n    listeners(({ sharedListeners, values, actions }) => ({\n        setEditUrlIndex: () => {\n            actions.setProposedUrlValue('url', values.urlToEdit)\n        },\n        newUrl: () => {\n            actions.setProposedUrlValue('url', NEW_URL)\n        },\n        addUrl: [\n            sharedListeners.saveUrls,\n            ({ url, launch }) => {\n                if (launch) {\n                    actions.launchAtUrl(url)\n                }\n            },\n        ],\n        removeUrl: sharedListeners.saveUrls,\n        updateUrl: sharedListeners.saveUrls,\n        launchAtUrl: ({ url }) => {\n            window.location.href = values.launchUrl(url)\n        },\n        cancelProposingUrl: () => {\n            actions.resetProposedUrl()\n        },\n        submitProposedUrlSuccess: () => {\n            actions.setEditUrlIndex(null)\n            actions.resetProposedUrl()\n        },\n        copyLaunchCode: ({ url }) => {\n            actions.loadManualLaunchParams(url)\n        },\n        loadManualLaunchParamsSuccess: async ({ manualLaunchParams }) => {\n            if (manualLaunchParams) {\n                const templateScript = `\n                if (!window?.posthog) {\n                    console.warn('PostHog must be added to the window object on this page, for this to work. This is normally done in the loaded callback of your posthog init code.')\n                } else {\n                    window.posthog.loadToolbar(${manualLaunchParams})\n                }\n                `\n                await copyToClipboard(templateScript, 'code to paste into the console')\n            }\n        },\n    })),\n    selectors({\n        urlToEdit: [\n            (s) => [s.authorizedUrls, s.editUrlIndex],\n            (authorizedUrls, editUrlIndex) => {\n                if (editUrlIndex === null || editUrlIndex === -1) {\n                    return NEW_URL\n                }\n                return authorizedUrls[editUrlIndex]\n            },\n        ],\n        urlsKeyed: [\n            (s) => [s.authorizedUrls, s.suggestions],\n            (authorizedUrls, suggestions): KeyedAppUrl[] => {\n                const keyedUrls = authorizedUrls\n                    .map((url, index) => ({\n                        url,\n                        type: 'authorized',\n                        originalIndex: index,\n                    }))\n                    .concat(\n                        suggestions.map(({ url, count }, index) => ({\n                            url,\n                            type: 'suggestion',\n                            originalIndex: index,\n                            count,\n                        }))\n                    ) as KeyedAppUrl[]\n\n                return keyedUrls\n            },\n        ],\n        launchUrl: [\n            (_, p) => [p.actionId, p.experimentId],\n            (actionId, experimentId) => (url: string) => {\n                if (experimentId) {\n                    return appEditorUrl(url, {\n                        experimentId,\n                    })\n                }\n\n                return appEditorUrl(url, {\n                    actionId,\n                })\n            },\n        ],\n        isAddUrlFormVisible: [(s) => [s.editUrlIndex], (editUrlIndex) => editUrlIndex === -1],\n        onlyAllowDomains: [(_, p) => [p.type], (type) => type === AuthorizedUrlListType.RECORDING_DOMAINS],\n\n        checkUrlIsAuthorized: [\n            (s) => [s.authorizedUrls],\n            (authorizedUrls) => (url: string) => {\n                return checkUrlIsAuthorized(url, authorizedUrls)\n            },\n        ],\n    }),\n    urlToAction(({ actions }) => ({\n        [urls.toolbarLaunch()]: (_, searchParams) => {\n            if (searchParams.addNew) {\n                actions.newUrl()\n            }\n        },\n    })),\n])\n","import { connect, kea, path, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { subscriptions } from 'kea-subscriptions'\nimport api from 'lib/api'\nimport { membersLogic } from 'scenes/organization/membersLogic'\n\nimport { sidePanelContextLogic } from '~/layout/navigation-3000/sidepanel/panels/sidePanelContextLogic'\nimport { SidePanelSceneContext } from '~/layout/navigation-3000/sidepanel/types'\nimport { HogQLQuery, NodeKind } from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\n\nimport type { metalyticsLogicType } from './metalyticsLogicType'\n\nexport const metalyticsLogic = kea<metalyticsLogicType>([\n    path(['lib', 'components', 'metalytics', 'metalyticsLogic']),\n    connect({\n        values: [sidePanelContextLogic, ['sceneSidePanelContext'], membersLogic, ['members']],\n    }),\n\n    loaders(({ values }) => ({\n        viewCount: [\n            null as { views: number; users: number } | null,\n            {\n                loadViewCount: async () => {\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT SUM(count) AS count, COUNT(DISTINCT app_source_id) AS unique_users\n                            FROM app_metrics\n                            WHERE app_source = 'metalytics'\n                            AND instance_id = ${values.instanceId}`,\n                    }\n\n                    // NOTE: I think this gets cached heavily - how to correctly invalidate?\n                    const response = await api.query(query, undefined, undefined, 'force_blocking')\n                    const result = response.results as number[][]\n                    return {\n                        views: result[0][0],\n                        users: result[0][1],\n                    }\n                },\n            },\n        ],\n        recentUsers: [\n            [] as string[],\n            {\n                loadUsersLast30days: async () => {\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT DISTINCT app_source_id\n                            FROM app_metrics\n                            WHERE app_source = 'metalytics'\n                            AND instance_id = ${values.instanceId}\n                            AND timestamp >= NOW() - INTERVAL 30 DAY\n                            ORDER BY timestamp DESC`,\n                    }\n\n                    const response = await api.query(query, undefined, undefined, 'force_blocking')\n                    return response.results.map((result) => result[0]) as string[]\n                },\n            },\n        ],\n    })),\n\n    selectors({\n        instanceId: [\n            (s) => [s.sceneSidePanelContext],\n            (sidePanelContext: SidePanelSceneContext) =>\n                sidePanelContext?.activity_item_id\n                    ? `${sidePanelContext.activity_scope}:${sidePanelContext.activity_item_id}`\n                    : null,\n        ],\n        scope: [\n            (s) => [s.sceneSidePanelContext],\n            (sidePanelContext: SidePanelSceneContext) => sidePanelContext?.activity_scope,\n        ],\n\n        recentUserMembers: [\n            (s) => [s.recentUsers, s.members],\n            (recentUsers, members) => {\n                if (!members || !recentUsers) {\n                    return []\n                }\n                // Filter members whose IDs match the recentUsers array\n                const filteredMembers = members.filter((member) => recentUsers.includes(String(member.user.id)))\n                return filteredMembers\n            },\n        ],\n    }),\n\n    subscriptions(({ actions }) => ({\n        instanceId: async (instanceId) => {\n            if (instanceId) {\n                actions.loadViewCount()\n                actions.loadUsersLast30days()\n\n                await api.create('/api/projects/@current/metalytics/', {\n                    metric_name: 'viewed',\n                    instance_id: instanceId,\n                })\n            }\n        },\n    })),\n])\n","import { IconBug, IconInfo, IconQuestion } from '@posthog/icons'\nimport {\n    LemonInput,\n    LemonSegmentedButton,\n    LemonSegmentedButtonOption,\n    lemonToast,\n    Link,\n    Tooltip,\n} from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\nimport { useUploadFiles } from 'lib/hooks/useUploadFiles'\nimport { IconFeedback } from 'lib/lemon-ui/icons'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonFileInput } from 'lib/lemon-ui/LemonFileInput/LemonFileInput'\nimport { LemonSelect } from 'lib/lemon-ui/LemonSelect/LemonSelect'\nimport { LemonTextArea } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { useRef } from 'react'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport {\n    SEVERITY_LEVEL_TO_NAME,\n    SUPPORT_TICKET_TEMPLATES,\n    supportLogic,\n    SupportTicketKind,\n    TARGET_AREA_TO_NAME,\n} from './supportLogic'\n\nconst SUPPORT_TICKET_OPTIONS: LemonSegmentedButtonOption<SupportTicketKind>[] = [\n    {\n        value: 'support',\n        label: 'Question',\n        icon: <IconQuestion />,\n    },\n    {\n        value: 'feedback',\n        label: 'Feedback',\n        icon: <IconFeedback />,\n    },\n    {\n        value: 'bug',\n        label: 'Bug',\n        icon: <IconBug />,\n    },\n]\n\nconst SUPPORT_TICKET_KIND_TO_PROMPT: Record<SupportTicketKind, string> = {\n    bug: \"What's the bug?\",\n    feedback: 'What feedback do you have?',\n    support: 'What can we help you with?',\n}\n\nexport function SupportForm(): JSX.Element | null {\n    const { sendSupportRequest } = useValues(supportLogic)\n    const { setSendSupportRequestValue } = useActions(supportLogic)\n    const { objectStorageAvailable } = useValues(preflightLogic)\n    // the support model can be shown when logged out, file upload is not offered to anonymous users\n    const { user } = useValues(userLogic)\n    // only allow authentication issues for logged out users\n\n    const dropRef = useRef<HTMLDivElement>(null)\n\n    const { setFilesToUpload, filesToUpload, uploading } = useUploadFiles({\n        onUpload: (url, fileName) => {\n            setSendSupportRequestValue('message', sendSupportRequest.message + `\\n\\nAttachment \"${fileName}\": ${url}`)\n        },\n        onError: (detail) => {\n            lemonToast.error(`Error uploading image: ${detail}`)\n        },\n    })\n\n    const changeKind = (kind: SupportTicketKind): void => {\n        setSendSupportRequestValue('kind', kind)\n        if (kind === 'bug') {\n            setSendSupportRequestValue('severity_level', 'medium')\n        } else {\n            setSendSupportRequestValue('severity_level', 'low')\n        }\n    }\n\n    return (\n        <Form\n            logic={supportLogic}\n            formKey=\"sendSupportRequest\"\n            id=\"support-modal-form\"\n            enableFormOnSubmit\n            className=\"deprecated-space-y-4\"\n        >\n            {!user && (\n                <>\n                    <LemonField name=\"name\" label=\"Name\">\n                        <LemonInput data-attr=\"name\" placeholder=\"Jane\" />\n                    </LemonField>\n                    <LemonField name=\"email\" label=\"Email\">\n                        <LemonInput data-attr=\"email\" placeholder=\"your@email.com\" />\n                    </LemonField>\n                </>\n            )}\n            <LemonField name=\"kind\" label=\"Message type\">\n                <LemonSegmentedButton onChange={changeKind} fullWidth options={SUPPORT_TICKET_OPTIONS} />\n            </LemonField>\n            <LemonField name=\"target_area\" label=\"Topic\">\n                <LemonSelect\n                    disabledReason={\n                        !user\n                            ? 'Please login to your account before opening a ticket unrelated to authentication issues.'\n                            : null\n                    }\n                    fullWidth\n                    options={TARGET_AREA_TO_NAME}\n                />\n            </LemonField>\n            <LemonField\n                name=\"message\"\n                label={sendSupportRequest.kind ? SUPPORT_TICKET_KIND_TO_PROMPT[sendSupportRequest.kind] : 'Content'}\n            >\n                {(props) => (\n                    <div ref={dropRef} className=\"flex flex-col gap-2\">\n                        <LemonTextArea\n                            placeholder={SUPPORT_TICKET_TEMPLATES[sendSupportRequest.kind] ?? 'Type your message here'}\n                            data-attr=\"support-form-content-input\"\n                            minRows={5}\n                            {...props}\n                        />\n                        {objectStorageAvailable && !!user && (\n                            <LemonFileInput\n                                accept=\"image/*\"\n                                multiple={false}\n                                alternativeDropTargetRef={dropRef}\n                                onChange={setFilesToUpload}\n                                loading={uploading}\n                                value={filesToUpload}\n                            />\n                        )}\n                    </div>\n                )}\n            </LemonField>\n            <div className=\"flex gap-2 flex-col\">\n                <div className=\"flex justify-between items-center\">\n                    <label className=\"LemonLabel\">\n                        Severity level\n                        <Tooltip title=\"Severity levels help us prioritize your request.\">\n                            <span>\n                                <IconInfo className=\"opacity-75\" />\n                            </span>\n                        </Tooltip>\n                    </label>\n                    <Link target=\"_blank\" to=\"https://posthog.com/docs/support-options#severity-levels\">\n                        Definitions\n                    </Link>\n                </div>\n                <LemonField name=\"severity_level\">\n                    <LemonSelect\n                        fullWidth\n                        options={Object.entries(SEVERITY_LEVEL_TO_NAME).map(([key, value]) => ({\n                            label: value,\n                            value: key,\n                        }))}\n                    />\n                </LemonField>\n            </div>\n        </Form>\n    )\n}\n","import { captureException } from '@sentry/react'\nimport * as Sentry from '@sentry/react'\nimport { actions, connect, kea, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { urlToAction } from 'kea-router'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'\nimport { uuid } from 'lib/utils'\nimport posthog from 'posthog-js'\nimport { organizationLogic } from 'scenes/organizationLogic'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { sidePanelStateLogic } from '~/layout/navigation-3000/sidepanel/sidePanelStateLogic'\nimport { AvailableFeature, OrganizationBasicType, Region, SidePanelTab, TeamPublicType, UserType } from '~/types'\n\nimport type { supportLogicType } from './supportLogicType'\nimport { openSupportModal } from './SupportModal'\n\nexport function getPublicSupportSnippet(\n    cloudRegion: Region | null | undefined,\n    currentOrganization: OrganizationBasicType | null,\n    currentTeam: TeamPublicType | null,\n    includeCurrentLocation = true\n): string {\n    if (!cloudRegion) {\n        return ''\n    }\n    return (\n        (includeCurrentLocation ? getCurrentLocationLink() : '') +\n        getSessionReplayLink() +\n        `\\nAdmin: http://go/adminOrg${cloudRegion}/${currentOrganization?.id} (project ID ${currentTeam?.id})` +\n        getSentryLink(cloudRegion, currentTeam)\n    ).trimStart()\n}\n\nfunction getCurrentLocationLink(): string {\n    const cleanedCurrentUrl = window.location.href.replace(/panel=support[^&]*(&)?/, '').replace(/#$/, '')\n    return `\\nLocation: ${cleanedCurrentUrl}`\n}\n\nfunction getSessionReplayLink(): string {\n    const replayUrl = posthog\n        .get_session_replay_url({ withTimestamp: true, timestampLookBack: 30 })\n        .replace(window.location.origin + '/replay/', 'http://go/session/')\n    return `\\nSession: ${replayUrl}`\n}\n\nfunction getErrorTrackingLink(): string {\n    const filterGroup = encodeURIComponent(\n        JSON.stringify({\n            type: 'AND',\n            values: [\n                {\n                    type: 'AND',\n                    values: [\n                        {\n                            key: '$session_id',\n                            value: [posthog.get_session_id()],\n                            operator: 'exact',\n                            type: 'event',\n                        },\n                    ],\n                },\n            ],\n        })\n    )\n\n    return `\\nExceptions: https://us.posthog.com/project/2/error_tracking?filterGroup=${filterGroup}`\n}\n\nfunction getDjangoAdminLink(\n    user: UserType | null,\n    cloudRegion: Region | null | undefined,\n    currentOrganization: OrganizationBasicType | null,\n    currentTeam: TeamPublicType | null\n): string {\n    if (!user || !cloudRegion) {\n        return ''\n    }\n    const link = `http://go/admin${cloudRegion}/${user.email}`\n    return `\\nAdmin: ${link} (organization ID ${currentOrganization?.id}: ${currentOrganization?.name}, project ID ${currentTeam?.id}: ${currentTeam?.name})`\n}\n\nfunction getBillingAdminLink(currentOrganization: OrganizationBasicType | null): string {\n    if (!currentOrganization) {\n        return ''\n    }\n    return `\\nBilling admin: http://go/billing/${currentOrganization.id}`\n}\n\nfunction getSentryLink(cloudRegion: Region | null | undefined, currentTeam: TeamPublicType | null): string {\n    if (!cloudRegion || !currentTeam) {\n        return ''\n    }\n    return `\\nSentry: http://go/sentry${cloudRegion}/${currentTeam.id}`\n}\n\nconst SUPPORT_TICKET_KIND_TO_TITLE: Record<SupportTicketKind, string> = {\n    support: 'Contact support',\n    feedback: 'Give feedback',\n    bug: 'Report a bug',\n}\n\nexport const TARGET_AREA_TO_NAME = [\n    {\n        title: 'General',\n        options: [\n            {\n                value: 'apps',\n                'data-attr': `support-form-target-area-apps`,\n                label: 'Data pipelines',\n            },\n            {\n                value: 'login',\n                'data-attr': `support-form-target-area-login`,\n                label: 'Authentication (incl. login, sign-up, invites)',\n            },\n            {\n                value: 'billing',\n                'data-attr': `support-form-target-area-billing`,\n                label: 'Billing',\n            },\n            {\n                value: 'onboarding',\n                'data-attr': `support-form-target-area-onboarding`,\n                label: 'Onboarding',\n            },\n            {\n                value: 'sdk',\n                'data-attr': `support-form-target-area-onboarding`,\n                label: 'SDK / Implementation',\n            },\n            {\n                value: 'cohorts',\n                'data-attr': `support-form-target-area-cohorts`,\n                label: 'Cohorts',\n            },\n            {\n                value: 'data_management',\n                'data-attr': `support-form-target-area-data_management`,\n                label: 'Data management (incl. events, actions, properties)',\n            },\n            {\n                value: 'notebooks',\n                'data-attr': `support-form-target-area-notebooks`,\n                label: 'Notebooks',\n            },\n            {\n                value: 'mobile',\n                'data-attr': `support-form-target-area-mobile`,\n                label: 'Mobile',\n            },\n        ],\n    },\n    {\n        title: 'Individual product',\n        options: [\n            {\n                value: 'experiments',\n                'data-attr': `support-form-target-area-experiments`,\n                label: 'Experiments',\n            },\n            {\n                value: 'data_warehouse',\n                'data-attr': `support-form-target-area-data_warehouse`,\n                label: 'Data warehouse',\n            },\n            {\n                value: 'batch_exports',\n                'data-attr': `support-form-target-area-batch-exports`,\n                label: 'Batch exports',\n            },\n            {\n                value: 'feature_flags',\n                'data-attr': `support-form-target-area-feature_flags`,\n                label: 'Feature flags',\n            },\n            {\n                value: 'analytics',\n                'data-attr': `support-form-target-area-analytics`,\n                label: 'Product analytics (incl. insights, dashboards, annotations)',\n            },\n            {\n                value: 'group_analytics',\n                'data-attr': `support-form-target-area-group-analytics`,\n                label: 'Group analytics',\n            },\n            {\n                value: 'session_replay',\n                'data-attr': `support-form-target-area-session_replay`,\n                label: 'Session replay (incl. recordings)',\n            },\n            {\n                value: 'toolbar',\n                'data-attr': `support-form-target-area-toolbar`,\n                label: 'Toolbar (incl. heatmaps)',\n            },\n            {\n                value: 'surveys',\n                'data-attr': `support-form-target-area-surveys`,\n                label: 'Surveys',\n            },\n            {\n                value: 'web_analytics',\n                'data-attr': `support-form-target-area-web_analytics`,\n                label: 'Web analytics',\n            },\n            {\n                value: 'error_tracking',\n                'data-attr': `support-form-target-area-error_tracking`,\n                label: 'Error tracking',\n            },\n            {\n                value: 'llm-observability',\n                'data-attr': `support-form-target-area-llm-observability`,\n                label: 'LLM observability',\n            },\n        ],\n    },\n]\n\nexport const SEVERITY_LEVEL_TO_NAME = {\n    critical: 'Outage, data loss, or data breach',\n    high: 'Feature is not working at all',\n    medium: 'Feature not working as expected',\n    low: 'Question or feature request',\n}\n\nexport const SUPPORT_KIND_TO_SUBJECT = {\n    bug: 'Bug Report',\n    feedback: 'Feedback',\n    support: 'Support Ticket',\n}\n\nexport type SupportTicketTargetArea =\n    | 'experiments'\n    | 'apps'\n    | 'login'\n    | 'billing'\n    | 'onboarding'\n    | 'cohorts'\n    | 'data_management'\n    | 'notebooks'\n    | 'data_warehouse'\n    | 'feature_flags'\n    | 'analytics'\n    | 'session_replay'\n    | 'toolbar'\n    | 'surveys'\n    | 'web_analytics'\n    | 'error_tracking'\nexport type SupportTicketSeverityLevel = keyof typeof SEVERITY_LEVEL_TO_NAME\nexport type SupportTicketKind = keyof typeof SUPPORT_KIND_TO_SUBJECT\n\nexport const getLabelBasedOnTargetArea = (target_area: SupportTicketTargetArea): null | string => {\n    for (const category of TARGET_AREA_TO_NAME) {\n        for (const option of category.options) {\n            if (option.value === target_area) {\n                return option.label\n            }\n        }\n    }\n    return null // Return null if the value is not found\n}\n\nexport const URL_PATH_TO_TARGET_AREA: Record<string, SupportTicketTargetArea> = {\n    insights: 'analytics',\n    recordings: 'session_replay',\n    replay: 'session_replay',\n    dashboard: 'analytics',\n    feature_flags: 'feature_flags',\n    experiments: 'experiments',\n    'web-performance': 'session_replay',\n    events: 'analytics',\n    'data-management': 'data_management',\n    cohorts: 'cohorts',\n    annotations: 'analytics',\n    persons: 'analytics',\n    groups: 'analytics',\n    app: 'apps',\n    toolbar: 'session_replay',\n    warehouse: 'data_warehouse',\n    surveys: 'surveys',\n    web: 'web_analytics',\n}\n\nexport const SUPPORT_TICKET_TEMPLATES = {\n    bug: 'Please describe the bug you saw, and how to reproduce it.\\n\\nIf the bug appeared on a specific insight or dashboard, please include a link to it.',\n    feedback:\n        \"If your request is due to a problem, please describe the problem as best you can.\\n\\nPlease also describe the solution you'd like to see, and any alternatives you considered.\\n\\nYou can add images below to help illustrate your request, if needed!\",\n    support:\n        \"Please explain as fully as possible what you're aiming to do, and what you'd like help with.\\n\\nIf your question involves an existing insight or dashboard, please include a link to it.\",\n}\n\nexport function getURLPathToTargetArea(pathname: string): SupportTicketTargetArea | null {\n    const first_part = pathname.split('/')[1]\n    return URL_PATH_TO_TARGET_AREA[first_part] ?? null\n}\n\nexport type SupportFormLogicProps = {\n    onClose?: () => void\n}\n\nexport type SupportFormFields = {\n    name: string\n    email: string\n    kind: SupportTicketKind\n    target_area: SupportTicketTargetArea | null\n    severity_level: SupportTicketSeverityLevel | null\n    message: string\n    isEmailFormOpen?: boolean | 'true' | 'false'\n}\n\nexport const supportLogic = kea<supportLogicType>([\n    props({} as SupportFormLogicProps),\n    path(['lib', 'components', 'support', 'supportLogic']),\n    connect(() => ({\n        values: [\n            userLogic,\n            ['user'],\n            preflightLogic,\n            ['preflight'],\n            sidePanelStateLogic,\n            ['sidePanelAvailable'],\n            userLogic,\n            ['hasAvailableFeature'],\n        ],\n        actions: [sidePanelStateLogic, ['openSidePanel', 'setSidePanelOptions']],\n    })),\n    actions(() => ({\n        closeSupportForm: true,\n        openSupportForm: (values: Partial<SupportFormFields>) => values,\n        submitZendeskTicket: (form: SupportFormFields) => form,\n        updateUrlParams: true,\n        openEmailForm: true,\n        closeEmailForm: true,\n        openMaxChatInterface: true,\n        closeMaxChatInterface: true,\n    })),\n    reducers(() => ({\n        isSupportFormOpen: [\n            false,\n            {\n                openSupportForm: () => true,\n                closeSupportForm: () => false,\n                openMaxChatInterface: () => false,\n            },\n        ],\n        isEmailFormOpen: [\n            false,\n            {\n                openEmailForm: () => true,\n                closeEmailForm: () => false,\n            },\n        ],\n        isMaxChatInterfaceOpen: [\n            false,\n            {\n                openMaxChatInterface: () => true,\n                closeMaxChatInterface: () => false,\n                openEmailForm: () => false,\n            },\n        ],\n    })),\n    forms(({ actions, values }) => ({\n        sendSupportRequest: {\n            defaults: {\n                name: '',\n                email: '',\n                kind: 'support',\n                severity_level: null,\n                target_area: null,\n                message: '',\n            } as SupportFormFields,\n            errors: ({ name, email, message, kind, target_area, severity_level }) => {\n                return {\n                    name: !values.user ? (!name ? 'Please enter your name' : '') : '',\n                    email: !values.user ? (!email ? 'Please enter your email' : '') : '',\n                    message: !message ? 'Please enter a message' : '',\n                    kind: !kind ? 'Please choose' : undefined,\n                    severity_level: !severity_level ? 'Please choose' : undefined,\n                    target_area: !target_area ? 'Please choose' : undefined,\n                }\n            },\n            submit: async (formValues) => {\n                // name must be present for zendesk to accept the ticket\n                formValues.name = values.user?.first_name ?? formValues.name ?? 'name not set'\n                formValues.email = values.user?.email ?? formValues.email ?? ''\n                actions.submitZendeskTicket(formValues)\n                actions.closeSupportForm()\n                actions.resetSendSupportRequest()\n            },\n        },\n    })),\n    selectors({\n        title: [\n            (s) => [s.sendSupportRequest ?? null],\n            (sendSupportRequest) =>\n                sendSupportRequest.kind\n                    ? SUPPORT_TICKET_KIND_TO_TITLE[sendSupportRequest.kind]\n                    : 'Leave a message with PostHog',\n        ],\n    }),\n    listeners(({ actions, props, values }) => ({\n        updateUrlParams: async () => {\n            const panelOptions = [\n                values.sendSupportRequest.kind ?? '',\n                values.sendSupportRequest.target_area ?? '',\n                values.sendSupportRequest.severity_level ?? '',\n                values.isEmailFormOpen ?? 'false',\n            ].join(':')\n\n            if (panelOptions !== ':') {\n                actions.setSidePanelOptions(panelOptions)\n            }\n        },\n        openSupportForm: async ({ name, email, isEmailFormOpen, kind, target_area, severity_level, message }) => {\n            let area = target_area ?? getURLPathToTargetArea(window.location.pathname)\n            if (!userLogic.values.user) {\n                area = 'login'\n            }\n            kind = kind ?? 'support'\n            actions.resetSendSupportRequest({\n                name: name ?? '',\n                email: email ?? '',\n                kind,\n                target_area: area,\n                severity_level: severity_level ?? null,\n                message: message ?? '',\n            })\n\n            if (isEmailFormOpen === 'true' || isEmailFormOpen === true) {\n                actions.openEmailForm()\n            } else {\n                actions.closeEmailForm()\n            }\n\n            if (values.sidePanelAvailable) {\n                const panelOptions = [kind ?? '', area ?? ''].join(':')\n                actions.openSidePanel(SidePanelTab.Support, panelOptions === ':' ? undefined : panelOptions)\n            } else {\n                openSupportModal()\n            }\n\n            actions.updateUrlParams()\n        },\n        submitZendeskTicket: async ({ name, email, kind, target_area, severity_level, message }) => {\n            const zendesk_ticket_uuid = uuid()\n            const subject =\n                SUPPORT_KIND_TO_SUBJECT[kind ?? 'support'] +\n                ': ' +\n                (target_area\n                    ? getLabelBasedOnTargetArea(target_area) ?? `${target_area} (feature preview)`\n                    : 'General') +\n                ' (' +\n                zendesk_ticket_uuid +\n                ')'\n            const cloudRegion = preflightLogic.values.preflight?.region\n\n            const payload = {\n                request: {\n                    requester: { name: name, email: email },\n                    subject: subject,\n                    custom_fields: [\n                        {\n                            id: 22084126888475,\n                            value: severity_level,\n                        },\n                        {\n                            id: 22129191462555,\n                            value: posthog.get_distinct_id(),\n                        },\n                        {\n                            id: 27242745654043,\n                            value: target_area ?? '',\n                        },\n                        {\n                            id: 27031528411291,\n                            value: userLogic?.values?.user?.organization?.id ?? '',\n                        },\n                        {\n                            id: 26073267652251,\n                            value: values.hasAvailableFeature(AvailableFeature.PRIORITY_SUPPORT)\n                                ? 'priority_support'\n                                : values.hasAvailableFeature(AvailableFeature.EMAIL_SUPPORT)\n                                ? 'email_support'\n                                : 'free_support',\n                        },\n                    ],\n                    comment: {\n                        body:\n                            message +\n                            `\\n\\n-----` +\n                            `\\nKind: ${kind}` +\n                            `\\nTarget area: ${target_area}` +\n                            `\\nReport event: http://go/ticketByUUID/${zendesk_ticket_uuid}` +\n                            getSessionReplayLink() +\n                            getErrorTrackingLink() +\n                            getCurrentLocationLink() +\n                            getDjangoAdminLink(\n                                userLogic.values.user,\n                                cloudRegion,\n                                organizationLogic.values.currentOrganization,\n                                teamLogic.values.currentTeam\n                            ) +\n                            (target_area === 'billing' || target_area === 'login' || target_area === 'onboarding'\n                                ? getBillingAdminLink(organizationLogic.values.currentOrganization)\n                                : '') +\n                            getSentryLink(cloudRegion, teamLogic.values.currentTeam) +\n                            (cloudRegion && teamLogic.values.currentTeam\n                                ? '\\nPersons-on-events mode for project: ' +\n                                  (teamLogic.values.currentTeam.modifiers?.personsOnEventsMode ??\n                                      teamLogic.values.currentTeam.default_modifiers?.personsOnEventsMode ??\n                                      'unknown')\n                                : ''),\n                    },\n                },\n            }\n\n            try {\n                const zendeskRequestBody = JSON.stringify(payload, undefined, 4)\n                const response = await fetch('https://posthoghelp.zendesk.com/api/v2/requests.json', {\n                    method: 'POST',\n                    body: zendeskRequestBody,\n                    headers: { 'Content-Type': 'application/json' },\n                })\n                if (!response.ok) {\n                    const error = new Error(`There was an error creating the support ticket with zendesk.`)\n                    const extra: Record<string, any> = { zendeskBody: zendeskRequestBody }\n                    Object.entries(payload).forEach(([key, value]) => {\n                        extra[`payload_${key}`] = value\n                    })\n                    const body = await response.text()\n                    const contexts = {\n                        response: {\n                            status_code: response.status,\n                            data: body,\n                            body_size: body?.length,\n                        },\n                    }\n                    captureException(error, {\n                        extra,\n                        contexts,\n                    })\n                    lemonToast.error(`There was an error sending the message.`)\n                    return\n                }\n\n                const json = await response.json()\n\n                const zendesk_ticket_id = json.request.id\n                const zendesk_ticket_link = `https://posthoghelp.zendesk.com/agent/tickets/${zendesk_ticket_id}`\n                const properties = {\n                    zendesk_ticket_uuid,\n                    kind,\n                    target_area,\n                    message,\n                    zendesk_ticket_id,\n                    zendesk_ticket_link,\n                }\n                posthog.capture('support_ticket', properties)\n                Sentry.captureMessage('User submitted Zendesk ticket', {\n                    tags: {\n                        zendesk_ticket_uuid,\n                        zendesk_ticket_link,\n                        support_request_kind: kind,\n                        support_request_area: target_area,\n                        team_id: teamLogic.values.currentTeamId,\n                    },\n                    extra: properties,\n                    level: 'log',\n                })\n                lemonToast.success(\"Got the message! If we have follow-up information for you, we'll reply via email.\")\n            } catch (e) {\n                captureException(e)\n                lemonToast.error(`There was an error sending the message.`)\n            }\n        },\n\n        closeSupportForm: () => {\n            props.onClose?.()\n        },\n\n        setSendSupportRequestValue: () => {\n            actions.updateUrlParams()\n        },\n        openMaxChatInterface: async () => {\n            const panelOptions = [\n                'max-chat',\n                '', // No target area needed for Max (yet)\n                '', // No severity level needed for Max\n                'false', // Make sure we don't open the email form instead\n            ].join(':')\n\n            if (values.sidePanelAvailable) {\n                actions.setSidePanelOptions(panelOptions)\n            }\n            actions.updateUrlParams()\n        },\n    })),\n\n    urlToAction(({ actions, values }) => ({\n        '*': (_, _search, hashParams) => {\n            if (values.isSupportFormOpen) {\n                return\n            }\n\n            const [panel, ...panelOptions] = (hashParams['panel'] ?? '').split(':')\n\n            if (panel === SidePanelTab.Support) {\n                const [kind, area, severity, isEmailFormOpen] = panelOptions\n\n                actions.openSupportForm({\n                    kind: Object.keys(SUPPORT_KIND_TO_SUBJECT).includes(kind) ? kind : null,\n                    target_area: getLabelBasedOnTargetArea(area) ? area : null,\n                    severity_level: Object.keys(SEVERITY_LEVEL_TO_NAME).includes(severity) ? severity : null,\n                    isEmailFormOpen: isEmailFormOpen ?? 'false',\n                })\n                return\n            }\n\n            // Legacy supportModal param\n            if ('supportModal' in hashParams) {\n                const [kind, area, severity] = (hashParams['supportModal'] || '').split(':')\n\n                actions.openSupportForm({\n                    kind: Object.keys(SUPPORT_KIND_TO_SUBJECT).includes(kind) ? kind : null,\n                    target_area: Object.keys(TARGET_AREA_TO_NAME).includes(area) ? area : null,\n                    severity_level: Object.keys(SEVERITY_LEVEL_TO_NAME).includes(severity) ? severity : null,\n                })\n            }\n        },\n    })),\n])\n","import { actions, afterMount, kea, key, listeners, path, props, reducers, sharedListeners } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { isNotNil } from 'lib/utils'\nimport {\n    diffVersions,\n    highestVersion,\n    isEqualVersion,\n    parseVersion,\n    SemanticVersion,\n    tryParseVersion,\n    versionToString,\n} from 'lib/utils/semver'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\n\nimport type { versionCheckerLogicType } from './versionCheckerLogicType'\n\n// If you would like to deprecate all posthog-js versions older than a specific version\n// (i.e. after fixing an important bug) please edit\n// https://github.com/PostHog/posthog-js/blob/main/deprecation.json\n\nconst CHECK_INTERVAL_MS = 1000 * 60 * 60 * 6 // 6 hour\n\nexport type SDKVersion = {\n    version: SemanticVersion\n    timestamp?: string\n}\n\nexport type SDKVersionWarning = {\n    latestUsedVersion: string\n    latestAvailableVersion: string\n    numVersionsBehind?: number\n    level: 'warning' | 'info' | 'error'\n}\n\nexport interface PosthogJSDeprecation {\n    deprecateBeforeVersion?: string\n    deprecateOlderThanDays?: number\n}\n\nexport interface AvailableVersions {\n    sdkVersions?: SemanticVersion[]\n    deprecation?: PosthogJSDeprecation\n}\n\nexport interface VersionCheckerLogicProps {\n    teamId: number | null\n}\n\nexport const versionCheckerLogic = kea<versionCheckerLogicType>([\n    props({ teamId: null } as VersionCheckerLogicProps),\n    key(({ teamId }) => teamId || 'no-team-id'),\n    path((key) => ['components', 'VersionChecker', 'versionCheckerLogic', key]),\n    actions({\n        setVersionWarning: (versionWarning: SDKVersionWarning | null) => ({ versionWarning }),\n        setSdkVersions: (sdkVersions: SDKVersion[]) => ({ sdkVersions }),\n    }),\n    loaders(({ values }) => ({\n        availableVersions: [\n            {} as AvailableVersions,\n            {\n                loadAvailableVersions: async (): Promise<AvailableVersions> => {\n                    // Make both requests simultaneously and don't return until both have finished, to avoid a flash\n                    // of partial results in the UI.\n                    const availableVersionsPromise: Promise<SemanticVersion[]> = fetch(\n                        'https://api.github.com/repos/posthog/posthog-js/tags'\n                    )\n                        .then((r) => r.json())\n                        .then((r) => r.map((x: any) => tryParseVersion(x.name)).filter(isNotNil))\n                    const deprecationPromise: Promise<PosthogJSDeprecation> = fetch(\n                        'https://raw.githubusercontent.com/PostHog/posthog-js/main/deprecation.json'\n                    ).then((r) => r.json())\n                    const settled = await Promise.allSettled([availableVersionsPromise, deprecationPromise])\n                    const availableVersions = settled[0].status === 'fulfilled' ? settled[0].value : []\n                    const deprecation = settled[1].status === 'fulfilled' ? settled[1].value : {}\n                    // if one or more of the requests failed, merge in the previous value if we have one\n                    return {\n                        ...values.availableVersions,\n                        sdkVersions: availableVersions,\n                        deprecation: deprecation,\n                    }\n                },\n            },\n        ],\n        usedVersions: [\n            null as SDKVersion[] | null,\n            {\n                loadUsedVersions: async () => {\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$lib_version AS lib_version, max(timestamp) AS latest_timestamp, count(lib_version) as count\n                                FROM events\n                                WHERE timestamp >= now() - INTERVAL 1 DAY \n                                AND timestamp <= now()\n                                AND properties.$lib = 'web'\n                                GROUP BY lib_version\n                                ORDER BY latest_timestamp DESC\n                                limit 10`,\n                    }\n\n                    const res = await api.query(query, undefined, undefined, 'force_blocking')\n\n                    return (\n                        res.results\n                            ?.map((x) => {\n                                const version = tryParseVersion(x[0])\n                                if (!version) {\n                                    return null\n                                }\n                                return {\n                                    version,\n                                    timestamp: x[1],\n                                }\n                            })\n                            .filter(isNotNil) ?? null\n                    )\n                },\n            },\n        ],\n    })),\n\n    reducers({\n        lastCheckTimestamp: [\n            0,\n            { persist: true },\n            {\n                loadUsedVersionsSuccess: () => Date.now(),\n            },\n        ],\n        versionWarning: [\n            null as SDKVersionWarning | null,\n            // bumping cache key due to an incorrect tag being cached on 2024-02-12\n            { persist: true, prefix: '2024-02-12' },\n            {\n                setVersionWarning: (_, { versionWarning }) => versionWarning,\n            },\n        ],\n    }),\n\n    sharedListeners(({ values, actions }) => ({\n        checkForVersionWarning: () => {\n            if (!values.usedVersions?.length) {\n                return\n            }\n            const { deprecation, sdkVersions } = values.availableVersions\n\n            // We want the highest semantic version to be the latest used one, rather than\n            // the one with the latest timestamp, because secondary installations can spew old versions\n            const latestUsedVersion = highestVersion(values.usedVersions.map((v) => v.version))\n\n            // the latest version published on github\n            const latestAvailableVersion = sdkVersions?.[0]\n\n            // the version where, anything before this deprecated (i.e. this version is allowed, before it is not)\n            const deprecateBeforeVersion = deprecation?.deprecateBeforeVersion\n                ? parseVersion(deprecation.deprecateBeforeVersion)\n                : null\n\n            let warning: SDKVersionWarning | null = null\n\n            if (deprecateBeforeVersion) {\n                const diff = diffVersions(deprecateBeforeVersion, latestUsedVersion)\n                // if they are behind the deprecatedBeforeVersion by any amount, show an error\n                if (diff && diff.diff > 0) {\n                    warning = {\n                        latestUsedVersion: versionToString(latestUsedVersion),\n                        latestAvailableVersion: versionToString(latestAvailableVersion || deprecateBeforeVersion),\n                        level: 'error',\n                    }\n                }\n            }\n\n            if (!warning && sdkVersions && latestAvailableVersion) {\n                const diff = diffVersions(latestAvailableVersion, latestUsedVersion)\n\n                if (diff && diff.diff > 0) {\n                    // there's a difference between the latest used version and the latest available version\n\n                    let numVersionsBehind = sdkVersions.findIndex((v) => isEqualVersion(v, latestUsedVersion))\n                    if (numVersionsBehind === -1) {\n                        // if we couldn't find the versions, use the length of the list as a fallback\n                        numVersionsBehind = sdkVersions.length - 1\n                    }\n                    if (numVersionsBehind < diff.diff) {\n                        // we might have deleted versions, but if the actual diff is X then we must be at least X versions behind\n                        numVersionsBehind = diff.diff\n                    }\n\n                    let level: 'warning' | 'info' | 'error' | undefined\n                    if (diff.kind === 'major') {\n                        level = 'info' // it is desirable to be on the latest major version, but not critical\n                    } else if (diff.kind === 'minor') {\n                        level = numVersionsBehind >= 40 ? 'warning' : undefined\n                    }\n\n                    if (level === undefined && numVersionsBehind >= 50) {\n                        level = 'error'\n                    }\n\n                    // we check if there is a \"latest user version string\" to avoid returning odd data in unexpected cases\n                    if (level && !!versionToString(latestUsedVersion).trim().length) {\n                        warning = {\n                            latestUsedVersion: versionToString(latestUsedVersion),\n                            latestAvailableVersion: versionToString(latestAvailableVersion),\n                            level,\n                            numVersionsBehind,\n                        }\n                    }\n                }\n            }\n\n            actions.setVersionWarning(warning)\n        },\n    })),\n\n    listeners(({ sharedListeners }) => ({\n        loadAvailableVersionsSuccess: sharedListeners.checkForVersionWarning,\n        loadUsedVersionsSuccess: sharedListeners.checkForVersionWarning,\n    })),\n\n    afterMount(({ actions, values }) => {\n        if (values.lastCheckTimestamp < Date.now() - CHECK_INTERVAL_MS) {\n            actions.loadAvailableVersions()\n            actions.loadUsedVersions()\n        }\n    }),\n])\n","import { useValues } from 'kea'\nimport { TextContent } from 'lib/components/Cards/TextCard/TextCard'\nimport { useUploadFiles } from 'lib/hooks/useUploadFiles'\nimport { IconMarkdown, IconTools } from 'lib/lemon-ui/icons'\nimport { LemonFileInput } from 'lib/lemon-ui/LemonFileInput'\nimport { LemonTabs } from 'lib/lemon-ui/LemonTabs'\nimport { LemonTextArea, LemonTextAreaProps } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { Link } from 'lib/lemon-ui/Link'\nimport { Tooltip } from 'lib/lemon-ui/Tooltip'\nimport posthog from 'posthog-js'\nimport React, { useRef, useState } from 'react'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\n\nexport const LemonTextAreaMarkdown = React.forwardRef<HTMLTextAreaElement, LemonTextAreaProps>(\n    function _LemonTextAreaMarkdown({ value, onChange, ...editAreaProps }, ref): JSX.Element {\n        const { objectStorageAvailable } = useValues(preflightLogic)\n\n        const [isPreviewShown, setIsPreviewShown] = useState(false)\n        const dropRef = useRef<HTMLDivElement>(null)\n\n        const { setFilesToUpload, filesToUpload, uploading } = useUploadFiles({\n            onUpload: (url, fileName) => {\n                onChange?.(value + `\\n\\n![${fileName}](${url})`)\n                posthog.capture('markdown image uploaded', { name: fileName })\n            },\n            onError: (detail) => {\n                posthog.capture('markdown image upload failed', { error: detail })\n                lemonToast.error(`Error uploading image: ${detail}`)\n            },\n        })\n\n        return (\n            <LemonTabs\n                activeKey={isPreviewShown ? 'preview' : 'write'}\n                onChange={(key) => setIsPreviewShown(key === 'preview')}\n                tabs={[\n                    {\n                        key: 'write',\n                        label: 'Write',\n                        content: (\n                            <div ref={dropRef} className=\"LemonTextMarkdown flex flex-col deprecated-space-y-1 rounded\">\n                                <LemonTextArea\n                                    ref={ref}\n                                    {...editAreaProps}\n                                    autoFocus\n                                    value={value}\n                                    onChange={onChange}\n                                />\n                                <div className=\"text-secondary inline-flex items-center deprecated-space-x-1\">\n                                    <IconMarkdown className=\"text-2xl\" />\n                                    <span>Markdown formatting support</span>\n                                </div>\n                                {objectStorageAvailable ? (\n                                    <LemonFileInput\n                                        accept={'image/*'}\n                                        multiple={false}\n                                        alternativeDropTargetRef={dropRef}\n                                        onChange={setFilesToUpload}\n                                        loading={uploading}\n                                        value={filesToUpload}\n                                    />\n                                ) : (\n                                    <div className=\"text-secondary inline-flex items-center deprecated-space-x-1\">\n                                        <Tooltip title=\"Enable object storage to add images by dragging and dropping.\">\n                                            <span>\n                                                <IconTools className=\"text-xl mr-1\" />\n                                            </span>\n                                        </Tooltip>\n                                        <span>\n                                            Add external images using{' '}\n                                            <Link to=\"https://www.markdownguide.org/basic-syntax/#images-1\">\n                                                {' '}\n                                                Markdown image links\n                                            </Link>\n                                            .\n                                        </span>\n                                    </div>\n                                )}\n                            </div>\n                        ),\n                    },\n                    {\n                        key: 'preview',\n                        label: 'Preview',\n                        content: value ? (\n                            <TextContent text={value} className=\"LemonTextArea--preview\" />\n                        ) : (\n                            <i>Nothing to preview</i>\n                        ),\n                    },\n                ]}\n            />\n        )\n    }\n)\n","// This file contains example queries, used in storybook and in the /query interface.\nimport { RETENTION_FIRST_TIME } from 'lib/constants'\n\nimport { defaultDataTableColumns } from '~/queries/nodes/DataTable/utils'\nimport {\n    ActionsNode,\n    DataTableNode,\n    DataVisualizationNode,\n    EventsNode,\n    EventsQuery,\n    FunnelsQuery,\n    HogQLQuery,\n    HogQuery,\n    InsightVizNode,\n    LifecycleQuery,\n    Node,\n    NodeKind,\n    PathsQuery,\n    PersonsNode,\n    RetentionQuery,\n    StickinessQuery,\n    TrendsQuery,\n    WebStatsBreakdown,\n    WebVitalsMetric,\n    WebVitalsPathBreakdownQuery,\n    WebVitalsPercentile,\n    WebVitalsQuery,\n} from '~/queries/schema/schema-general'\nimport {\n    BaseMathType,\n    ChartDisplayType,\n    FilterLogicalOperator,\n    InsightType,\n    PropertyFilterType,\n    PropertyGroupFilter,\n    PropertyMathType,\n    PropertyOperator,\n    RetentionPeriod,\n    StepOrderValue,\n} from '~/types'\n\nimport { WEB_VITALS_THRESHOLDS } from './nodes/WebVitals/definitions'\n\nconst Events: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: defaultDataTableColumns(NodeKind.EventsQuery),\n    properties: [\n        { type: PropertyFilterType.Event, key: '$browser', operator: PropertyOperator.Exact, value: 'Chrome' },\n    ],\n    after: '-24h',\n    limit: 100,\n}\n\nconst EventsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: Events,\n}\nconst EventsTableFull: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: Events,\n}\n\nconst TotalEvents: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: ['count()'],\n}\n\nexport const TotalEventsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: TotalEvents,\n}\n\nconst PropertyFormulas: EventsQuery = {\n    kind: NodeKind.EventsQuery,\n    select: [\n        '1 + 2 + 3',\n        'event',\n        'person.created_at',\n        \"concat(properties['$browser'], '  ', properties['$geoip_city_name']) -- Browser  City\",\n        \"'random string'\",\n    ],\n    limit: 100,\n}\n\nconst PropertyFormulasTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: PropertyFormulas,\n}\n\nconst EventAggregations: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: {\n        kind: NodeKind.EventsQuery,\n        select: [\n            \"concat(properties['$geoip_city_name'], ' ', 'Rocks') -- City\",\n            'event',\n            'count() + 100000 -- Inflamed total',\n            '1 + 2',\n        ],\n        orderBy: ['-count()'],\n    },\n}\n\nconst Persons: PersonsNode = {\n    kind: NodeKind.PersonsNode,\n    properties: [\n        { type: PropertyFilterType.Person, key: '$browser', operator: PropertyOperator.Exact, value: 'Chrome' },\n    ],\n}\n\nconst PersonsTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    columns: defaultDataTableColumns(NodeKind.PersonsNode),\n    source: Persons,\n}\n\nconst PersonsTableFull: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    columns: defaultDataTableColumns(NodeKind.PersonsNode),\n    source: Persons,\n}\n\nconst properties: PropertyGroupFilter = {\n    type: FilterLogicalOperator.And,\n    values: [\n        {\n            type: FilterLogicalOperator.Or,\n            values: [\n                {\n                    type: PropertyFilterType.Event,\n                    key: '$current_url',\n                    operator: PropertyOperator.Exact,\n                    value: ['https://hedgebox.net/files/'],\n                },\n                {\n                    type: PropertyFilterType.Event,\n                    key: '$geoip_country_code',\n                    operator: PropertyOperator.Exact,\n                    value: ['US', 'AU'],\n                },\n            ],\n        },\n    ],\n}\n\nconst filterTestAccounts = false\nconst series: (EventsNode | ActionsNode)[] = [\n    {\n        kind: NodeKind.EventsNode,\n        name: '$pageview',\n        custom_name: 'Views',\n        event: '$pageview',\n        properties: [\n            {\n                type: PropertyFilterType.Event,\n                key: '$browser',\n                operator: PropertyOperator.Exact,\n                value: 'Chrome',\n            },\n            {\n                type: PropertyFilterType.Cohort,\n                key: 'id',\n                operator: PropertyOperator.In,\n                value: 2,\n            },\n        ],\n    },\n    // {\n    //     kind: NodeKind.ActionsNode,\n    //     id: 1,\n    //     name: 'Interacted with file',\n    //     custom_name: 'Interactions',\n    //     properties: [\n    //         {\n    //             type: PropertyFilterType.Event,\n    //             key: '$geoip_country_code',\n    //             operator: PropertyOperator.Exact,\n    //             value: ['US'],\n    //         },\n    //     ],\n    //     math: PropertyMathType.Average,\n    //     math_property: '$session_duration',\n    // },\n]\n\nconst InsightTrendsQuery: TrendsQuery = {\n    kind: NodeKind.TrendsQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    trendsFilter: {\n        display: ChartDisplayType.ActionsAreaGraph,\n    },\n    breakdownFilter: {\n        breakdown: '$geoip_country_code',\n        breakdown_type: 'event',\n    },\n}\n\nconst InsightFunnelsQuery: FunnelsQuery = {\n    kind: NodeKind.FunnelsQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    funnelsFilter: {\n        funnelOrderType: StepOrderValue.ORDERED,\n    },\n    breakdownFilter: {\n        breakdown: '$geoip_country_code',\n        breakdown_type: 'event',\n    },\n}\n\nconst InsightRetentionQuery: RetentionQuery = {\n    kind: NodeKind.RetentionQuery,\n    properties,\n    filterTestAccounts,\n    retentionFilter: {\n        // TODO: this should be typed as (EventsNode | ActionsNode)[] without math and properties\n        targetEntity: { type: 'events', id: '$pageview', name: '$pageview' },\n        returningEntity: { type: 'events', id: '$pageview', name: '$pageview' },\n    },\n}\n\nconst InsightPathsQuery: PathsQuery = {\n    kind: NodeKind.PathsQuery,\n    properties,\n    filterTestAccounts,\n    pathsFilter: {},\n}\n\nconst InsightStickinessQuery: StickinessQuery = {\n    kind: NodeKind.StickinessQuery,\n    properties,\n    filterTestAccounts,\n    interval: 'day',\n    dateRange: {\n        date_from: '-7d',\n    },\n    series,\n    stickinessFilter: {},\n}\n\nconst InsightLifecycleQuery: LifecycleQuery = {\n    kind: NodeKind.LifecycleQuery,\n    properties,\n    filterTestAccounts,\n    dateRange: {\n        date_from: '-7d',\n    },\n    series, // TODO: Visualization only supports one event or action\n}\n\nconst HogQLRaw: HogQLQuery = {\n    kind: NodeKind.HogQLQuery,\n    query: `   select event,\n          person.properties.email,\n          properties.$browser,\n          count()\n     from events\n    where {filters} -- replaced with global date and property filters\n      and person.properties.email is not null\n group by event,\n          properties.$browser,\n          person.properties.email\n order by count() desc\n    limit 100`,\n    filters: {\n        dateRange: {\n            date_from: '-24h',\n        },\n    },\n}\n\nconst HogQLForDataVisualization: HogQLQuery = {\n    kind: NodeKind.HogQLQuery,\n    query: `select toDate(timestamp) as timestamp, count()\nfrom events\nwhere {filters} and timestamp <= now()\ngroup by timestamp\norder by timestamp asc\nlimit 100`,\n    explain: true,\n    filters: {\n        dateRange: {\n            date_from: '-7d',\n        },\n    },\n}\n\nconst HogQLForDataWarehouse: HogQLQuery = {\n    kind: NodeKind.HogQLQuery,\n    query: `select toDate(timestamp) as timestamp, count()\nfrom events\ngroup by timestamp\nlimit 100`,\n    explain: true,\n}\n\nconst DataWarehouse: DataVisualizationNode = {\n    kind: NodeKind.DataVisualizationNode,\n    source: HogQLForDataWarehouse,\n}\n\nconst HogQLTable: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    full: true,\n    source: HogQLRaw,\n}\n\nconst DataVisualization: DataVisualizationNode = {\n    kind: NodeKind.DataVisualizationNode,\n    source: HogQLForDataVisualization,\n    tableSettings: {\n        columns: [\n            {\n                column: 'timestamp',\n                settings: {\n                    formatting: {\n                        prefix: '',\n                        suffix: '',\n                    },\n                },\n            },\n            {\n                column: 'count()',\n                settings: {\n                    formatting: {\n                        prefix: '',\n                        suffix: '',\n                    },\n                },\n            },\n        ],\n    },\n    chartSettings: { goalLines: undefined },\n}\n\nconst Hog: HogQuery = {\n    kind: NodeKind.HogQuery,\n    code: 'return 1 + 2;',\n}\n\nconst Hoggonacci: HogQuery = {\n    kind: NodeKind.HogQuery,\n    code: `fn fibonacci(number) {\n    if (number < 2) {\n        return number;\n    } else {\n        return fibonacci(number - 1) + fibonacci(number - 2);\n    }\n}\nreturn fibonacci(16);`,\n}\n\nconst WebVitals: WebVitalsQuery = {\n    kind: NodeKind.WebVitalsQuery,\n    properties: [],\n    dateRange: {\n        date_from: '-7d',\n    },\n    source: {\n        kind: NodeKind.TrendsQuery,\n        dateRange: {\n            date_from: '-7d',\n        },\n        interval: 'day',\n        series: (['INP', 'LCP', 'CLS', 'FCP'] as WebVitalsMetric[]).flatMap((name) =>\n            [PropertyMathType.P75, PropertyMathType.P90, PropertyMathType.P99].map((math) => ({\n                kind: NodeKind.EventsNode,\n                event: '$web_vitals',\n                name: '$web_vitals',\n                custom_name: name,\n                math: math,\n                math_property: `$web_vitals_${name}_value`,\n            }))\n        ),\n        trendsFilter: { display: ChartDisplayType.ActionsLineGraph },\n        filterTestAccounts,\n    },\n}\n\nconst WebVitalsPathBreakdown: WebVitalsPathBreakdownQuery = {\n    kind: NodeKind.WebVitalsPathBreakdownQuery,\n    properties: [],\n    dateRange: {\n        date_from: '-7d',\n    },\n    filterTestAccounts,\n    percentile: 'p90' as WebVitalsPercentile,\n    metric: 'CLS' as WebVitalsMetric,\n    doPathCleaning: true,\n    thresholds: [WEB_VITALS_THRESHOLDS['CLS'].good, WEB_VITALS_THRESHOLDS['CLS'].poor],\n}\n\nconst WebAnalyticsReferrerDomain: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: {\n        kind: NodeKind.WebStatsTableQuery,\n        properties: [],\n        breakdownBy: WebStatsBreakdown.InitialReferringDomain,\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        compareFilter: { compare: false },\n        limit: 10,\n        filterTestAccounts: false,\n        conversionGoal: null,\n    },\n}\n\nconst WebAnalyticsPath: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: {\n        kind: NodeKind.WebStatsTableQuery,\n        properties: [],\n        breakdownBy: WebStatsBreakdown.Page,\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        compareFilter: { compare: false },\n        limit: 10,\n        filterTestAccounts: false,\n        conversionGoal: null,\n    },\n}\n\nconst WebAnalyticsBrowser: DataTableNode = {\n    kind: NodeKind.DataTableNode,\n    source: {\n        kind: NodeKind.WebStatsTableQuery,\n        properties: [],\n        breakdownBy: WebStatsBreakdown.Browser,\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        compareFilter: { compare: false },\n        limit: 10,\n        filterTestAccounts: false,\n        conversionGoal: null,\n    },\n}\n\nconst WebAnalyticsWorldMap: InsightVizNode<TrendsQuery> = {\n    kind: NodeKind.InsightVizNode,\n    source: {\n        kind: NodeKind.TrendsQuery,\n        breakdownFilter: {\n            breakdown: '$geoip_country_code',\n            breakdown_type: 'event',\n        },\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        series: [\n            {\n                event: '$pageview',\n                name: 'Pageview',\n                kind: NodeKind.EventsNode,\n                math: BaseMathType.MonthlyActiveUsers, // Should be DAU, but it's not supported yet\n            },\n        ],\n        trendsFilter: { display: ChartDisplayType.WorldMap },\n        filterTestAccounts: false,\n        properties: [],\n    },\n}\n\nconst WebAnalyticsRetention: InsightVizNode<RetentionQuery> = {\n    kind: NodeKind.InsightVizNode,\n    source: {\n        kind: NodeKind.RetentionQuery,\n        properties: [],\n        dateRange: {\n            date_from: '-14d',\n            date_to: null,\n        },\n        filterTestAccounts: false,\n        retentionFilter: {\n            retentionType: RETENTION_FIRST_TIME,\n            retentionReference: 'total',\n            totalIntervals: 8,\n            period: RetentionPeriod.Week,\n        },\n    },\n    vizSpecificOptions: {\n        [InsightType.RETENTION]: {\n            hideLineGraph: true,\n            hideSizeColumn: false,\n            useSmallLayout: false,\n        },\n    },\n}\n\n/* a subset of examples including only those we can show all users and that don't use HogQL */\nexport const queryExamples: Record<string, Node> = {\n    Events,\n    EventsTable,\n    EventsTableFull,\n    TotalEventsTable,\n    PropertyFormulasTable,\n    EventAggregations,\n    Persons,\n    PersonsTable,\n    PersonsTableFull,\n    InsightTrendsQuery,\n    InsightTrends: { kind: NodeKind.InsightVizNode, source: InsightTrendsQuery } as InsightVizNode<TrendsQuery>,\n    InsightFunnelsQuery,\n    InsightFunnels: { kind: NodeKind.InsightVizNode, source: InsightFunnelsQuery } as InsightVizNode<FunnelsQuery>,\n    InsightRetentionQuery,\n    InsightRetention: {\n        kind: NodeKind.InsightVizNode,\n        source: InsightRetentionQuery,\n    } as InsightVizNode<RetentionQuery>,\n    InsightPathsQuery,\n    InsightPaths: { kind: NodeKind.InsightVizNode, source: InsightPathsQuery } as InsightVizNode<PathsQuery>,\n    InsightStickinessQuery,\n    InsightStickiness: {\n        kind: NodeKind.InsightVizNode,\n        source: InsightStickinessQuery,\n    } as InsightVizNode<StickinessQuery>,\n    InsightLifecycleQuery,\n    InsightLifecycle: {\n        kind: NodeKind.InsightVizNode,\n        source: InsightLifecycleQuery,\n    } as InsightVizNode<LifecycleQuery>,\n    WebVitals,\n    WebVitalsPathBreakdown,\n    WebAnalyticsWorldMap,\n    WebAnalyticsReferrerDomain,\n    WebAnalyticsPath,\n    WebAnalyticsBrowser,\n    WebAnalyticsRetention,\n}\n\nexport const stringifiedQueryExamples: Record<string, string> = Object.fromEntries(\n    Object.entries(queryExamples).map(([key, node]) => [key, JSON.stringify(node)])\n)\n\nexport const examples: Record<string, Node> = {\n    ...queryExamples,\n    HogQLRaw,\n    HogQLTable,\n    DataVisualization,\n    Hog,\n    Hoggonacci,\n    DataWarehouse,\n}\n\nexport const stringifiedExamples: Record<string, string> = Object.fromEntries(\n    Object.entries(examples).map(([key, node]) => [key, JSON.stringify(node)])\n)\n","import { LemonSegmentedButton } from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { insightLogic } from 'scenes/insights/insightLogic'\nimport { insightVizDataLogic } from 'scenes/insights/insightVizDataLogic'\n\nexport function RetentionCumulativeButton(): JSX.Element | null {\n    const { insightProps, canEditInsight } = useValues(insightLogic)\n\n    const { retentionFilter } = useValues(insightVizDataLogic(insightProps))\n    const { updateInsightFilter } = useActions(insightVizDataLogic(insightProps))\n\n    const cumulativeRetention = retentionFilter?.cumulative || false\n\n    if (!canEditInsight) {\n        return null\n    }\n\n    return (\n        <LemonSegmentedButton\n            value={cumulativeRetention ? 1 : 0}\n            onChange={(value: number) => {\n                updateInsightFilter({ cumulative: value === 1 })\n            }}\n            options={[\n                {\n                    value: 0,\n                    label: 'on',\n                    tooltip: 'Retention value is the percentage of users who come back on a specific period',\n                },\n                {\n                    value: 1,\n                    label: 'on or after',\n                    tooltip: `\n                    Retention value is the percentage of users who come back on a specific time period or any of the following time periods.\n                    Also known as rolling, or unbounded retention.\n                    For example, if a user comes back on day 7, they are counted in all previous retention periods.`,\n                },\n            ]}\n        />\n    )\n}\n","import * as d3 from 'd3'\nimport * as Sankey from 'd3-sankey'\nimport { D3Selector } from 'lib/hooks/useD3'\nimport { stripHTTP } from 'lib/utils'\nimport { Dispatch, RefObject, SetStateAction } from 'react'\n\nimport { FunnelPathsFilter, PathsFilter } from '~/queries/schema/schema-general'\n\nimport { FALLBACK_CANVAS_WIDTH, HIDE_PATH_CARD_HEIGHT } from './Paths'\nimport { isSelectedPathStartOrEnd, PathNodeData, PathTargetLink, roundedRect } from './pathUtils'\nimport { Paths } from './types'\n\nconst createCanvas = (canvasRef: RefObject<HTMLDivElement>, width: number, height: number): D3Selector => {\n    return d3\n        .select(canvasRef.current)\n        .append('svg')\n        .classed('Paths__canvas', true)\n        .style('background', 'var(--item-background)')\n        .style('width', `${width}px`)\n        .style('height', `${height}px`)\n}\n\nconst createSankeyGenerator = (width: number, height: number): Sankey.SankeyLayout<any, any, any> => {\n    // @ts-expect-error - d3 sankey typing things\n    return new Sankey.sankey()\n        .nodeId((d: PathNodeData) => d.name)\n        .nodeAlign(Sankey.sankeyJustify)\n        .nodeSort(null)\n        .nodeWidth(15)\n        .size([width, height])\n}\n\nconst appendPathNodes = (\n    svg: any,\n    nodes: PathNodeData[],\n    pathsFilter: PathsFilter,\n    funnelPathsFilter: FunnelPathsFilter,\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void => {\n    svg.append('g')\n        .selectAll('rect')\n        .data(nodes)\n        .join('rect')\n        .attr('x', (d: PathNodeData) => d.x0 + 1)\n        .attr('y', (d: PathNodeData) => d.y0)\n        .attr('height', (d: PathNodeData) => d.y1 - d.y0)\n        .attr('width', (d: PathNodeData) => d.x1 - d.x0 - 2)\n        .attr('fill', (d: PathNodeData) => {\n            let c\n            for (const link of d.sourceLinks) {\n                if (c === undefined) {\n                    c = link.color\n                } else if (c !== link.color) {\n                    c = null\n                }\n            }\n            if (c === undefined) {\n                for (const link of d.targetLinks) {\n                    if (c === undefined) {\n                        c = link.color\n                    } else if (c !== link.color) {\n                        c = null\n                    }\n                }\n            }\n            if (isSelectedPathStartOrEnd(pathsFilter, funnelPathsFilter, d)) {\n                return 'var(--paths-node-start-or-end)'\n            }\n            const startNodeColor = c && d3.color(c) ? d3.color(c) : 'var(--paths-node)'\n            return startNodeColor\n        })\n        .on('mouseover', (_event: MouseEvent, data: PathNodeData) => {\n            if (data.y1 - data.y0 > HIDE_PATH_CARD_HEIGHT) {\n                return\n            }\n            setNodeCards(\n                nodes.map((node: PathNodeData) =>\n                    node.index === data.index\n                        ? { ...node, visible: true }\n                        : { ...node, visible: node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT }\n                )\n            )\n        })\n        .append('title')\n        .text((d: PathNodeData) => `${stripHTTP(d.name)}\\n${d.value.toLocaleString()}`)\n}\n\nconst appendDropoffs = (svg: D3Selector): void => {\n    const dropOffGradient = svg\n        .append('defs')\n        .append('linearGradient')\n        .attr('id', 'dropoff-gradient')\n        .attr('gradientTransform', 'rotate(90)')\n\n    dropOffGradient.append('stop').attr('offset', '0%').attr('stop-color', 'var(--paths-dropoff)')\n\n    dropOffGradient.append('stop').attr('offset', '100%').attr('stop-color', 'var(--bg-surface-primary)')\n}\n\nconst appendPathLinks = (\n    svg: any,\n    links: PathNodeData[],\n    nodes: PathNodeData[],\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void => {\n    const link = svg\n        .append('g')\n        .attr('fill', 'none')\n        .selectAll('g')\n        .data(links)\n        .join('g')\n        .attr('stroke', 'var(--paths-link)')\n        .attr('opacity', 0.35)\n\n    link.append('path')\n        .attr('d', Sankey.sankeyLinkHorizontal())\n        .attr('id', (d: PathNodeData) => `path-${d.index}`)\n        .attr('stroke-width', (d: PathNodeData) => {\n            return Math.max(1, d.width)\n        })\n        .on('mouseover', (_event: MouseEvent, data: PathNodeData) => {\n            svg.select(`#path-${data.index}`).attr('stroke', 'var(--paths-link-hover)')\n            if (data?.source?.targetLinks.length === 0) {\n                return\n            }\n            const nodesToColor = [data.source]\n            const pathCardsToShow: number[] = []\n            while (nodesToColor.length > 0) {\n                const _node = nodesToColor.pop()\n                _node?.targetLinks.forEach((_link: PathTargetLink) => {\n                    svg.select(`#path-${_link.index}`).attr('stroke', 'var(--paths-link-hover)')\n                    nodesToColor.push(_link.source)\n                    pathCardsToShow.push(_link.source.index)\n                })\n            }\n            const pathCards = [data.target]\n            pathCardsToShow.push(data.target.index, data.source.index)\n            while (pathCards.length > 0) {\n                const node = pathCards.pop()\n                node?.sourceLinks.forEach((l: PathTargetLink) => {\n                    pathCards.push(l.target)\n                    pathCardsToShow.push(l.target.index)\n                })\n            }\n            setNodeCards(\n                nodes.map((node: PathNodeData) => ({\n                    ...node,\n                    ...{\n                        visible: pathCardsToShow.includes(node.index)\n                            ? true\n                            : node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT,\n                    },\n                }))\n            )\n        })\n        .on('mouseleave', () => {\n            svg.selectAll('path').attr('stroke', 'var(--paths-link)')\n        })\n\n    link.append('g')\n        .append('path')\n        .attr('d', (data: PathNodeData) => {\n            if (data.source.layer === 0) {\n                return\n            }\n            const _height =\n                data.source.y1 - data.source.y0 - data.source.sourceLinks.reduce((prev, curr) => prev + curr.width, 0)\n            return roundedRect(0, 0, 30, _height, Math.min(25, _height), false, true, false, false)\n        })\n        .attr('fill', 'url(#dropoff-gradient)')\n        .attr('stroke-width', 0)\n        .attr('transform', (data: PathNodeData) => {\n            return (\n                'translate(' +\n                Math.round(data.source.x1) +\n                ',' +\n                Math.round(data.source.y0 + data.source.sourceLinks.reduce((prev, curr) => prev + curr.width, 0)) +\n                ')'\n            )\n        })\n}\n\nconst addChartAxisLines = (svg: D3Selector, height: number, nodes: PathNodeData[], maxLayer: number): void => {\n    if (maxLayer > 5) {\n        const arr = [...Array(maxLayer)]\n        const minWidthApart = nodes[1].x0 - nodes[0].x0\n        arr.forEach((_, i) => {\n            svg.append('line')\n                .style('stroke', 'var(--border-primary)')\n                .attr('stroke-width', 2)\n                .attr('x1', minWidthApart * (i + 1) - 20)\n                .attr('y1', 0)\n                .attr('x2', minWidthApart * (i + 1) - 20)\n                .attr('y2', height)\n        })\n    }\n}\n\nexport function renderPaths(\n    canvasRef: RefObject<HTMLDivElement>,\n    canvasWidth: number,\n    canvasHeight: number,\n    paths: Paths,\n    pathsFilter: PathsFilter,\n    funnelPathsFilter: FunnelPathsFilter,\n    setNodeCards: Dispatch<SetStateAction<PathNodeData[]>>\n): void {\n    if (!paths || paths.nodes.length === 0) {\n        return\n    }\n\n    const maxLayer = paths.links.reduce((prev, curr) => {\n        return Math.max(prev, Number(curr.target.match(/[^_]*/)))\n    }, 0)\n\n    const minWidth = canvasWidth > FALLBACK_CANVAS_WIDTH || maxLayer < 3 ? canvasWidth : FALLBACK_CANVAS_WIDTH\n\n    const width = maxLayer > 5 && canvasWidth ? (minWidth / 5) * maxLayer : minWidth\n    const height = canvasHeight\n\n    const svg = createCanvas(canvasRef, width, height)\n    const sankey = createSankeyGenerator(width, height)\n\n    // clone the paths, as sankey mutates the data\n    const clonedPaths = structuredClone(paths)\n    const { nodes, links } = sankey(clonedPaths)\n\n    setNodeCards(nodes.map((node: PathNodeData) => ({ ...node, visible: node.y1 - node.y0 > HIDE_PATH_CARD_HEIGHT })))\n\n    appendPathNodes(svg, nodes, pathsFilter, funnelPathsFilter, setNodeCards)\n    appendDropoffs(svg)\n    appendPathLinks(svg, links, nodes, setNodeCards)\n    addChartAxisLines(svg, height, nodes, maxLayer)\n}\n","import { LemonDialog, lemonToast, Link } from '@posthog/lemon-ui'\nimport { actions, afterMount, connect, kea, listeners, path, reducers, selectors } from 'kea'\nimport { FieldNamePath, forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { router, urlToAction } from 'kea-router'\nimport api, { getJSONOrNull } from 'lib/api'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { dayjs } from 'lib/dayjs'\nimport { LemonBannerAction } from 'lib/lemon-ui/LemonBanner/LemonBanner'\nimport { lemonBannerLogic } from 'lib/lemon-ui/LemonBanner/lemonBannerLogic'\nimport { LemonButtonPropsBase } from 'lib/lemon-ui/LemonButton'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { pluralize } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport posthog from 'posthog-js'\nimport { organizationLogic } from 'scenes/organizationLogic'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { BillingPlanType, BillingProductV2Type, BillingType, ProductKey } from '~/types'\n\nimport type { billingLogicType } from './billingLogicType'\nimport { DEFAULT_ESTIMATED_MONTHLY_CREDIT_AMOUNT_USD } from './CreditCTAHero'\n\nexport const ALLOCATION_THRESHOLD_ALERT = 0.85 // Threshold to show warning of event usage near limit\nexport const ALLOCATION_THRESHOLD_BLOCK = 1.2 // Threshold to block usage\n\nexport interface BillingAlertConfig {\n    status: 'info' | 'warning' | 'error'\n    title: string\n    message?: string\n    contactSupport?: boolean\n    buttonCTA?: string\n    dismissKey?: string\n    action?: LemonBannerAction\n    pathName?: string\n    onClose?: () => void\n}\n\nexport enum BillingAPIErrorCodes {\n    OPEN_INVOICES_ERROR = 'open_invoices_error',\n    NO_ACTIVE_PAYMENT_METHOD_ERROR = 'no_active_payment_method_error',\n    COULD_NOT_PAY_INVOICES_ERROR = 'could_not_pay_invoices_error',\n}\n\nexport interface UnsubscribeError {\n    detail: string | JSX.Element\n    link: JSX.Element\n}\n\nexport interface BillingError {\n    status: 'info' | 'warning' | 'error'\n    message: string\n    action: LemonButtonPropsBase\n}\n\nconst parseBillingResponse = (data: Partial<BillingType>): BillingType => {\n    if (data.billing_period) {\n        data.billing_period = {\n            current_period_start: dayjs(data.billing_period.current_period_start),\n            current_period_end: dayjs(data.billing_period.current_period_end),\n            interval: data.billing_period.interval,\n        }\n    }\n\n    data.free_trial_until = data.free_trial_until ? dayjs(data.free_trial_until) : undefined\n    data.amount_off_expires_at = data.amount_off_expires_at ? dayjs(data.amount_off_expires_at) : undefined\n    // If expiration is in the middle of the current period, we let it expire at the end of the period\n    if (\n        data.amount_off_expires_at &&\n        data.billing_period &&\n        data.amount_off_expires_at.isBefore(data.billing_period.current_period_end) &&\n        data.amount_off_expires_at.isAfter(data.billing_period.current_period_start)\n    ) {\n        data.amount_off_expires_at = data.billing_period.current_period_end\n    }\n\n    return data as BillingType\n}\n\nexport const billingLogic = kea<billingLogicType>([\n    path(['scenes', 'billing', 'billingLogic']),\n    actions({\n        setProductSpecificAlert: (productSpecificAlert: BillingAlertConfig | null) => ({ productSpecificAlert }),\n        setScrollToProductKey: (scrollToProductKey: ProductKey | null) => ({ scrollToProductKey }),\n        setShowLicenseDirectInput: (show: boolean) => ({ show }),\n        reportBillingAlertShown: (alertConfig: BillingAlertConfig) => ({ alertConfig }),\n        reportBillingAlertActionClicked: (alertConfig: BillingAlertConfig) => ({ alertConfig }),\n        reportCreditsFormSubmitted: (creditInput: number) => ({ creditInput }),\n        reportCreditsModalShown: true,\n        reportBillingShown: true,\n        registerInstrumentationProps: true,\n        reportCreditsCTAShown: (creditOverview: any) => ({ creditOverview }),\n        setRedirectPath: true,\n        setIsOnboarding: true,\n        determineBillingAlert: true,\n        setUnsubscribeError: (error: null | UnsubscribeError) => ({ error }),\n        resetUnsubscribeError: true,\n        setBillingAlert: (billingAlert: BillingAlertConfig | null) => ({ billingAlert }),\n        showPurchaseCreditsModal: (isOpen: boolean) => ({ isOpen }),\n        toggleCreditCTAHeroDismissed: (isDismissed: boolean) => ({ isDismissed }),\n        setComputedDiscount: (discount: number) => ({ discount }),\n    }),\n    connect(() => ({\n        values: [featureFlagLogic, ['featureFlags'], preflightLogic, ['preflight']],\n        actions: [\n            userLogic,\n            ['loadUser'],\n            organizationLogic,\n            ['loadCurrentOrganization'],\n            eventUsageLogic,\n            ['reportProductUnsubscribed'],\n            lemonBannerLogic({ dismissKey: 'usage-limit-exceeded' }),\n            ['resetDismissKey as resetUsageLimitExceededKey'],\n            lemonBannerLogic({ dismissKey: 'usage-limit-approaching' }),\n            ['resetDismissKey as resetUsageLimitApproachingKey'],\n        ],\n    })),\n    reducers({\n        billingAlert: [\n            null as BillingAlertConfig | null,\n            {\n                setBillingAlert: (_, { billingAlert }) => billingAlert,\n            },\n        ],\n        scrollToProductKey: [\n            null as ProductKey | null,\n            {\n                setScrollToProductKey: (_, { scrollToProductKey }) => scrollToProductKey,\n            },\n        ],\n        productSpecificAlert: [\n            null as BillingAlertConfig | null,\n            {\n                setProductSpecificAlert: (_, { productSpecificAlert }) => productSpecificAlert,\n            },\n        ],\n        showLicenseDirectInput: [\n            false,\n            {\n                setShowLicenseDirectInput: (_, { show }) => show,\n            },\n        ],\n        redirectPath: [\n            '' as string,\n            {\n                setRedirectPath: () => {\n                    return window.location.pathname.includes('/onboarding')\n                        ? window.location.pathname + window.location.search\n                        : ''\n                },\n            },\n        ],\n        isOnboarding: [\n            false,\n            {\n                setIsOnboarding: () => window.location.pathname.includes('/onboarding'),\n            },\n        ],\n        unsubscribeError: [\n            null as null | UnsubscribeError,\n            {\n                resetUnsubscribeError: () => null,\n                setUnsubscribeError: (_, { error }) => error,\n            },\n        ],\n        timeRemainingInSeconds: [\n            0,\n            {\n                loadBillingSuccess: (_, { billing }) => {\n                    if (!billing?.billing_period) {\n                        return 0\n                    }\n                    const currentTime = dayjs()\n                    const periodEnd = dayjs(billing.billing_period.current_period_end)\n                    return periodEnd.diff(currentTime, 'second')\n                },\n            },\n        ],\n        timeTotalInSeconds: [\n            0,\n            {\n                loadBillingSuccess: (_, { billing }) => {\n                    if (!billing?.billing_period) {\n                        return 0\n                    }\n                    const periodStart = dayjs(billing.billing_period.current_period_start)\n                    const periodEnd = dayjs(billing.billing_period.current_period_end)\n                    return periodEnd.diff(periodStart, 'second')\n                },\n            },\n        ],\n        isPurchaseCreditsModalOpen: [\n            false,\n            {\n                showPurchaseCreditsModal: (_, { isOpen }) => isOpen,\n            },\n        ],\n        isCreditCTAHeroDismissed: [\n            false,\n            { persist: true },\n            {\n                toggleCreditCTAHeroDismissed: (_, { isDismissed }) => isDismissed,\n            },\n        ],\n        computedDiscount: [\n            0,\n            {\n                setComputedDiscount: (_, { discount }) => discount,\n            },\n        ],\n    }),\n    loaders(({ actions, values }) => ({\n        billing: [\n            null as BillingType | null,\n            {\n                loadBilling: async () => {\n                    // Note: this is a temporary flag to skip forecasting in the billing page\n                    // for customers running into performance issues until we have a more permanent fix\n                    // of splitting the billing and forecasting data.\n                    const skipForecasting = values.featureFlags[FEATURE_FLAGS.BILLING_SKIP_FORECASTING]\n                    const response = await api.get(\n                        'api/billing' + (skipForecasting ? '?include_forecasting=false' : '')\n                    )\n\n                    return parseBillingResponse(response)\n                },\n\n                updateBillingLimits: async (limits: { [key: string]: number | null }) => {\n                    try {\n                        const response = await api.update('api/billing', { custom_limits_usd: limits })\n                        lemonToast.success('Billing limits updated')\n                        actions.loadBilling()\n                        return parseBillingResponse(response)\n                    } catch (error: any) {\n                        lemonToast.error(\n                            'There was an error updating your billing limits. Please try again or contact support.'\n                        )\n                        throw error\n                    }\n                },\n\n                deactivateProduct: async (key: string, breakpoint) => {\n                    // clear upgrade params from URL\n                    // Note(@zach): This is not working properly. We need to look into this.\n                    const currentURL = new URL(window.location.href)\n                    currentURL.searchParams.delete('upgraded')\n                    currentURL.searchParams.delete('products')\n                    router.actions.push(currentURL.pathname + currentURL.search)\n\n                    actions.resetUnsubscribeError()\n                    try {\n                        const response = await api.getResponse('api/billing/deactivate?products=' + key)\n                        const jsonRes = await getJSONOrNull(response)\n\n                        lemonToast.success(\n                            \"You have been unsubscribed. We're sad to see you go. May the hedgehogs be ever in your favor.\"\n                        )\n                        actions.reportProductUnsubscribed(key)\n\n                        // Reload billing, user, and organization to get the updated available features\n                        actions.loadBilling()\n                        await breakpoint(2000) // Wait enough time for the organization to be updated\n                        actions.loadUser()\n                        actions.loadCurrentOrganization()\n\n                        return parseBillingResponse(jsonRes)\n                    } catch (error: any) {\n                        if (error.code) {\n                            if (error.code === BillingAPIErrorCodes.OPEN_INVOICES_ERROR) {\n                                actions.setUnsubscribeError({\n                                    detail: error.detail,\n                                    link: (\n                                        <Link to={values.billing?.stripe_portal_url} target=\"_blank\">\n                                            View invoices\n                                        </Link>\n                                    ),\n                                } as UnsubscribeError)\n                            } else if (error.code === BillingAPIErrorCodes.NO_ACTIVE_PAYMENT_METHOD_ERROR) {\n                                actions.setUnsubscribeError({\n                                    detail: error.detail,\n                                } as UnsubscribeError)\n                            } else if (error.code === BillingAPIErrorCodes.COULD_NOT_PAY_INVOICES_ERROR) {\n                                actions.setUnsubscribeError({\n                                    detail: error.detail,\n                                    link: (\n                                        <Link to={error.link || values.billing?.stripe_portal_url} target=\"_blank\">\n                                            {error.link ? 'View invoice' : 'View invoices'}\n                                        </Link>\n                                    ),\n                                } as UnsubscribeError)\n                            }\n                        } else {\n                            actions.setUnsubscribeError({\n                                detail:\n                                    typeof error.detail === 'string'\n                                        ? error.detail\n                                        : `We encountered a problem. Please try again or submit a support ticket.`,\n                            } as UnsubscribeError)\n                        }\n                        console.error(error)\n                        // This is a bit of a hack to prevent the page from re-rendering.\n                        return values.billing\n                    }\n                },\n            },\n        ],\n        billingError: [\n            null as BillingError | null,\n            {\n                getInvoices: async () => {\n                    // First check to see if there are open invoices\n                    try {\n                        const res = await api.getResponse('api/billing/get_invoices?status=open')\n                        const jsonRes = await getJSONOrNull(res)\n                        const numOpenInvoices = jsonRes['count']\n                        if (numOpenInvoices > 0) {\n                            const viewInvoicesButton = {\n                                to:\n                                    numOpenInvoices == 1 && jsonRes['link']\n                                        ? jsonRes['link']\n                                        : values.billing?.stripe_portal_url,\n                                children: `View invoice${numOpenInvoices > 1 ? 's' : ''}`,\n                                targetBlank: true,\n                            }\n                            return {\n                                status: 'warning',\n                                message: `You have ${numOpenInvoices} open invoice${\n                                    numOpenInvoices > 1 ? 's' : ''\n                                }. Please pay ${\n                                    numOpenInvoices > 1 ? 'them' : 'it'\n                                } before adding items to your subscription.`,\n                                action: viewInvoicesButton,\n                            }\n                        }\n                    } catch (error: any) {\n                        console.error(error)\n                    }\n                    return null\n                },\n            },\n        ],\n        creditOverview: [\n            {\n                eligible: false,\n                estimated_monthly_credit_amount_usd: DEFAULT_ESTIMATED_MONTHLY_CREDIT_AMOUNT_USD,\n                status: 'none',\n                invoice_url: null,\n                collection_method: null,\n                cc_last_four: null,\n                email: null,\n            },\n            {\n                loadCreditOverview: async () => {\n                    // Check if the user is subscribed\n                    if (values.billing?.has_active_subscription) {\n                        const response = await api.get('api/billing/credits/overview')\n                        if (!values.creditForm.creditInput) {\n                            actions.setCreditFormValue(\n                                'creditInput',\n                                Math.round(\n                                    (response.estimated_monthly_credit_amount_usd ||\n                                        DEFAULT_ESTIMATED_MONTHLY_CREDIT_AMOUNT_USD) * 12\n                                )\n                            )\n                        }\n\n                        if (response.eligible && response.status === 'none') {\n                            actions.reportCreditsCTAShown(response)\n                        }\n                        return response\n                    }\n                    // Return default values if not subscribed\n                    return {\n                        eligible: false,\n                        estimated_monthly_credit_amount_usd: DEFAULT_ESTIMATED_MONTHLY_CREDIT_AMOUNT_USD,\n                        status: 'none',\n                        invoice_url: null,\n                        collection_method: null,\n                        cc_last_four: null,\n                        email: null,\n                    }\n                },\n            },\n        ],\n        products: [\n            [] as BillingProductV2Type[],\n            {\n                loadProducts: async () => {\n                    const response = await api.get('api/billing/available_products')\n                    return response\n                },\n            },\n        ],\n    })),\n    selectors({\n        upgradeLink: [(s) => [s.preflight], (): string => '/organization/billing'],\n        isUnlicensedDebug: [\n            (s) => [s.preflight, s.billing],\n            (preflight, billing): boolean => !!preflight?.is_debug && !billing?.billing_period,\n        ],\n        projectedTotalAmountUsdWithBillingLimits: [\n            (s) => [s.billing],\n            (billing: BillingType): number => {\n                if (!billing) {\n                    return 0\n                }\n                let projectedTotal = 0\n                for (const product of billing.products || []) {\n                    const billingLimit =\n                        billing?.custom_limits_usd?.[product.type] ||\n                        (product.usage_key ? billing?.custom_limits_usd?.[product.usage_key] || 0 : 0)\n                    projectedTotal += Math.min(parseFloat(product.projected_amount_usd || '0'), billingLimit)\n                }\n                return projectedTotal\n            },\n        ],\n        supportPlans: [\n            (s) => [s.billing],\n            (billing: BillingType): BillingPlanType[] => {\n                const platformAndSupportProduct = billing?.products?.find(\n                    (product) => product.type == ProductKey.PLATFORM_AND_SUPPORT\n                )\n                if (!platformAndSupportProduct?.plans) {\n                    return []\n                }\n\n                const addonPlans = platformAndSupportProduct?.addons?.map((addon) => addon.plans).flat()\n                const insertionIndex = Math.max(0, (platformAndSupportProduct?.plans?.length ?? 1) - 1)\n                const allPlans = platformAndSupportProduct?.plans?.slice(0) || []\n                allPlans.splice(insertionIndex, 0, ...addonPlans)\n                return allPlans\n            },\n        ],\n        hasSupportAddonPlan: [\n            (s) => [s.billing],\n            (billing: BillingType): boolean => {\n                return !!billing?.products\n                    ?.find((product) => product.type == ProductKey.PLATFORM_AND_SUPPORT)\n                    ?.addons.find((addon) => addon.plans.find((plan) => plan.current_plan))\n            },\n        ],\n        creditDiscount: [(s) => [s.computedDiscount], (computedDiscount) => computedDiscount || 0],\n    }),\n    forms(({ actions, values }) => ({\n        activateLicense: {\n            defaults: { license: '' } as { license: string },\n            errors: ({ license }) => ({\n                license: !license ? 'Please enter your license key' : undefined,\n            }),\n            submit: async ({ license }, breakpoint) => {\n                await breakpoint(500)\n                try {\n                    await api.update('api/billing/license', {\n                        license,\n                    })\n\n                    // Reset the URL so we don't trigger the license submission again\n                    router.actions.replace(\n                        `/${values.isOnboarding ? 'ingestion' : 'organization'}/billing?success=true`\n                    )\n                    setTimeout(() => {\n                        window.location.reload() // Permissions, projects etc will be out of date at this point, so refresh\n                    }, 100)\n                } catch (e: any) {\n                    actions.setActivateLicenseManualErrors({\n                        license: e.detail || 'License could not be activated. Please contact support.',\n                    })\n                    throw e\n                }\n            },\n        },\n        creditForm: {\n            defaults: {\n                creditInput: '',\n                collectionMethod: 'charge_automatically',\n            },\n            submit: async ({ creditInput, collectionMethod }) => {\n                await api.create('api/billing/credits/purchase', {\n                    annual_amount_usd: +Math.round(+creditInput - +creditInput * values.creditDiscount),\n                    discount_percent: values.computedDiscount * 100,\n                    collection_method: collectionMethod,\n                })\n\n                actions.showPurchaseCreditsModal(false)\n                actions.loadCreditOverview()\n                actions.reportCreditsFormSubmitted(+creditInput)\n\n                LemonDialog.open({\n                    title: 'Your credit purchase has been submitted',\n                    width: 536,\n                    content:\n                        collectionMethod === 'send_invoice' ? (\n                            <>\n                                <p className=\"mb-4\">\n                                    The invoice for your credits has been created and it will be emailed to the email on\n                                    file.\n                                </p>\n                                <p>\n                                    Once the invoice is paid we will apply the credits to your account. Until the\n                                    invoice is paid you will be charged for usage as normal.\n                                </p>\n                            </>\n                        ) : (\n                            <>\n                                <p>\n                                    Your card will be charged soon and the credits will be applied to your account.\n                                    Please make sure your{' '}\n                                    <Link to={values.billing?.stripe_portal_url} target=\"_blank\">\n                                        card on file\n                                    </Link>{' '}\n                                    is up to date. You will receive an email when the credits are applied.\n                                </p>\n                            </>\n                        ),\n                })\n            },\n            errors: ({ creditInput, collectionMethod }) => ({\n                creditInput: !creditInput\n                    ? 'Please enter the amount of credits you want to purchase'\n                    : // This value is used because 3333 - 10% = 3000\n                    +creditInput < 3333\n                    ? 'Please enter a credit amount of at least $3,333'\n                    : undefined,\n                collectionMethod: !collectionMethod ? 'Please select a collection method' : undefined,\n            }),\n        },\n    })),\n    listeners(({ actions, values }) => ({\n        reportBillingShown: () => {\n            posthog.capture('billing v2 shown')\n        },\n        reportBillingAlertShown: ({ alertConfig }) => {\n            posthog.capture('billing alert shown', {\n                ...alertConfig,\n            })\n        },\n        reportBillingAlertActionClicked: ({ alertConfig }) => {\n            posthog.capture('billing alert action clicked', {\n                ...alertConfig,\n            })\n        },\n        reportCreditsModalShown: () => {\n            posthog.capture('credits modal shown')\n        },\n        reportCreditsFormSubmitted: ({ creditInput }) => {\n            posthog.capture('credits modal credit form submitted', {\n                credit_amount_usd: creditInput,\n            })\n        },\n        reportCreditsCTAShown: ({ creditOverview }) => {\n            posthog.capture('credits cta shown', {\n                eligible: creditOverview.eligible,\n                status: creditOverview.status,\n                estimated_monthly_credit_amount_usd:\n                    creditOverview.estimated_monthly_credit_amount_usd || DEFAULT_ESTIMATED_MONTHLY_CREDIT_AMOUNT_USD,\n            })\n        },\n        toggleCreditCTAHeroDismissed: ({ isDismissed }) => {\n            if (isDismissed) {\n                posthog.capture('credits cta hero dismissed')\n            }\n        },\n        loadBillingSuccess: async (_, breakpoint) => {\n            actions.registerInstrumentationProps()\n            actions.determineBillingAlert()\n            actions.loadCreditOverview()\n\n            // If the activation is successful, we reload the user/organization to get the updated available features\n            // activation can be triggered from the billing page or onboarding\n            if (\n                (router.values.location.pathname.includes('/organization/billing') ||\n                    router.values.location.pathname.includes('/onboarding')) &&\n                (router.values.searchParams['success'] || router.values.searchParams['upgraded'])\n            ) {\n                // Wait enough time for the organization to be updated\n                await breakpoint(1000)\n                actions.loadUser()\n                actions.loadCurrentOrganization()\n                // Clear the params from the billing page so we don't trigger the activation again\n                if (router.values.location.pathname.includes('/organization/billing')) {\n                    router.actions.replace('/organization/billing')\n                }\n            }\n        },\n        determineBillingAlert: () => {\n            if (values.productSpecificAlert) {\n                actions.setBillingAlert(values.productSpecificAlert)\n                return\n            }\n\n            if (!values.billing || !values.preflight?.cloud) {\n                return\n            }\n\n            if (values.billing.free_trial_until && values.billing.free_trial_until.isAfter(dayjs())) {\n                const remainingDays = values.billing.free_trial_until.diff(dayjs(), 'days')\n                const remainingHours = values.billing.free_trial_until.diff(dayjs(), 'hours')\n\n                if (remainingHours > 72) {\n                    return\n                }\n\n                actions.setBillingAlert({\n                    status: 'info',\n                    title: `Your free trial will end in ${\n                        remainingHours < 24 ? pluralize(remainingHours, 'hour') : pluralize(remainingDays, 'day')\n                    }.`,\n                    message: `Setup billing now to ensure you don't lose access to premium features.`,\n                })\n                return\n            }\n\n            if (values.billing.deactivated) {\n                actions.setBillingAlert({\n                    status: 'error',\n                    title: 'Your organization has been temporarily suspended.',\n                    message: 'Please contact support to reactivate it.',\n                    contactSupport: true,\n                })\n                return\n            }\n\n            const productOverLimit = values.billing.products?.find((x: BillingProductV2Type) => {\n                return x.percentage_usage > 1 && x.usage_key\n            })\n\n            if (productOverLimit) {\n                actions.setBillingAlert({\n                    status: 'error',\n                    title: 'Usage limit exceeded',\n                    message: `You have exceeded the usage limit for ${productOverLimit.name}. Please \n                        ${productOverLimit.subscribed ? 'increase your billing limit' : 'upgrade your plan'}\n                        or ${\n                            productOverLimit.name === 'Data warehouse'\n                                ? 'data will not be synced'\n                                : productOverLimit.name === 'Feature flags & Experiments'\n                                ? 'feature flags will not evaluate'\n                                : 'data loss may occur'\n                        }.`,\n                    dismissKey: 'usage-limit-exceeded',\n                })\n                return\n            }\n\n            actions.resetUsageLimitExceededKey()\n\n            const productApproachingLimit = values.billing.products?.find(\n                (x) => x.percentage_usage > ALLOCATION_THRESHOLD_ALERT\n            )\n\n            if (productApproachingLimit) {\n                actions.setBillingAlert({\n                    status: 'info',\n                    title: 'You will soon hit your usage limit',\n                    message: `You have currently used ${parseFloat(\n                        (productApproachingLimit.percentage_usage * 100).toFixed(2)\n                    )}% of your ${\n                        productApproachingLimit.usage_key && productApproachingLimit.usage_key.toLowerCase()\n                    } allocation.`,\n                    dismissKey: 'usage-limit-approaching',\n                })\n                return\n            }\n\n            actions.resetUsageLimitApproachingKey()\n        },\n        setCreditFormValue: ({ name, value }) => {\n            if (name === 'creditInput' || (name as FieldNamePath)?.[0] === 'creditInput') {\n                const spend = +value\n                let discount = 0\n                if (spend >= 100000) {\n                    discount = 0.35\n                } else if (spend >= 60000) {\n                    discount = 0.25\n                } else if (spend >= 20000) {\n                    discount = 0.2\n                } else if (spend >= 3000) {\n                    discount = 0.1\n                }\n                actions.setComputedDiscount(discount)\n            }\n        },\n        registerInstrumentationProps: async (_, breakpoint) => {\n            await breakpoint(100)\n            if (posthog && values.billing) {\n                const payload = {\n                    has_billing_plan: !!values.billing.has_active_subscription,\n                    free_trial_until: values.billing.free_trial_until?.toISOString(),\n                    customer_deactivated: values.billing.deactivated,\n                    current_total_amount_usd: values.billing.current_total_amount_usd,\n                }\n                if (values.billing.custom_limits_usd) {\n                    for (const product of Object.keys(values.billing.custom_limits_usd)) {\n                        payload[`custom_limits_usd.${product}`] = values.billing.custom_limits_usd[product]\n                    }\n                }\n                if (values.billing.products) {\n                    for (const product of values.billing.products) {\n                        const type = product.type.toLowerCase()\n                        payload[`percentage_usage.${type}`] = product.percentage_usage\n                        payload[`current_amount_usd.${type}`] = product.current_amount_usd\n                        payload[`unit_amount_usd.${type}`] = product.unit_amount_usd\n                        payload[`usage_limit.${type}`] = product.usage_limit\n                        payload[`current_usage.${type}`] = product.current_usage\n                        payload[`projected_usage.${type}`] = product.projected_usage\n                        payload[`free_allocation.${type}`] = product.free_allocation\n                    }\n                }\n                if (values.billing.billing_period) {\n                    payload['billing_period_start'] = values.billing.billing_period.current_period_start\n                    payload['billing_period_end'] = values.billing.billing_period.current_period_end\n                }\n                posthog.register(payload)\n            }\n        },\n        showPurchaseCreditsModal: ({ isOpen }) => {\n            if (isOpen) {\n                actions.reportCreditsModalShown()\n            }\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadBilling()\n        actions.getInvoices()\n    }),\n    urlToAction(({ actions }) => ({\n        // IMPORTANT: This needs to be above the \"*\" so it takes precedence\n        '/*/billing': (_params, _search, hash) => {\n            if (hash.license) {\n                actions.setShowLicenseDirectInput(true)\n                actions.setActivateLicenseValues({ license: hash.license })\n                actions.submitActivateLicense()\n            }\n            if (_search.products) {\n                const products = _search.products.split(',')\n                actions.setScrollToProductKey(products[0])\n            }\n            if (_search.billing_error) {\n                actions.setBillingAlert({\n                    status: 'error',\n                    title: 'Error',\n                    message: _search.billing_error,\n                })\n            }\n            actions.setRedirectPath()\n            actions.setIsOnboarding()\n        },\n        '*': () => {\n            actions.setRedirectPath()\n            actions.setIsOnboarding()\n        },\n    })),\n])\n","import { actions, connect, isBreakpoint, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { EXPERIMENT_DEFAULT_DURATION, FEATURE_FLAGS } from 'lib/constants'\nimport { dayjs } from 'lib/dayjs'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { hasFormErrors, toParams } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { ProductIntentContext } from 'lib/utils/product-intents'\nimport { addProjectIdIfMissing } from 'lib/utils/router-utils'\nimport {\n    indexToVariantKeyFeatureFlagPayloads,\n    validateFeatureFlagKey,\n    variantKeyToIndexFeatureFlagPayloads,\n} from 'scenes/feature-flags/featureFlagLogic'\nimport { featureFlagLogic as sceneFeatureFlagLogic } from 'scenes/feature-flags/featureFlagLogic'\nimport { featureFlagsLogic } from 'scenes/feature-flags/featureFlagsLogic'\nimport { funnelDataLogic } from 'scenes/funnels/funnelDataLogic'\nimport { insightDataLogic } from 'scenes/insights/insightDataLogic'\nimport { projectLogic } from 'scenes/projectLogic'\nimport { sceneLogic } from 'scenes/sceneLogic'\nimport { Scene } from 'scenes/sceneTypes'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { trendsDataLogic } from 'scenes/trends/trendsDataLogic'\nimport { urls } from 'scenes/urls'\n\nimport { activationLogic, ActivationTask } from '~/layout/navigation-3000/sidepanel/panels/activation/activationLogic'\nimport { cohortsModel } from '~/models/cohortsModel'\nimport { groupsModel } from '~/models/groupsModel'\nimport { performQuery, QUERY_TIMEOUT_ERROR_MESSAGE } from '~/queries/query'\nimport {\n    AnyEntityNode,\n    CachedExperimentFunnelsQueryResponse,\n    CachedExperimentQueryResponse,\n    CachedExperimentTrendsQueryResponse,\n    ExperimentExposureCriteria,\n    ExperimentFunnelsQuery,\n    ExperimentMetric,\n    ExperimentMetricType,\n    ExperimentSignificanceCode,\n    ExperimentTrendsQuery,\n    InsightQueryNode,\n    InsightVizNode,\n    NodeKind,\n} from '~/queries/schema/schema-general'\nimport {\n    Breadcrumb,\n    BreakdownAttributionType,\n    BreakdownType,\n    CohortType,\n    CountPerActorMathType,\n    DashboardType,\n    Experiment,\n    FeatureFlagType,\n    FunnelExperimentVariant,\n    FunnelStep,\n    InsightType,\n    MultivariateFlagVariant,\n    ProductKey,\n    PropertyMathType,\n    TrendExperimentVariant,\n    TrendResult,\n} from '~/types'\n\nimport { EXPERIMENT_MIN_EXPOSURES_FOR_RESULTS, MetricInsightId } from './constants'\nimport type { experimentLogicType } from './experimentLogicType'\nimport { experimentsLogic } from './experimentsLogic'\nimport { holdoutsLogic } from './holdoutsLogic'\nimport { SharedMetric } from './SharedMetrics/sharedMetricLogic'\nimport { sharedMetricsLogic } from './SharedMetrics/sharedMetricsLogic'\nimport {\n    featureFlagEligibleForExperiment,\n    getMinimumDetectableEffect,\n    percentageDistribution,\n    transformFiltersForWinningVariant,\n} from './utils'\n\nconst NEW_EXPERIMENT: Experiment = {\n    id: 'new',\n    name: '',\n    type: 'product',\n    feature_flag_key: '',\n    filters: {},\n    metrics: [],\n    metrics_secondary: [],\n    saved_metrics_ids: [],\n    saved_metrics: [],\n    parameters: {\n        feature_flag_variants: [\n            { key: 'control', rollout_percentage: 50 },\n            { key: 'test', rollout_percentage: 50 },\n        ],\n    },\n    secondary_metrics: [],\n    created_at: null,\n    created_by: null,\n    updated_at: null,\n    holdout_id: null,\n}\n\nexport interface ExperimentLogicProps {\n    experimentId?: Experiment['id']\n}\n\ninterface MetricLoadingConfig {\n    metrics: any[]\n    experimentId: Experiment['id']\n    refresh?: boolean\n    onSetResults: (\n        results: (\n            | CachedExperimentQueryResponse\n            | CachedExperimentTrendsQueryResponse\n            | CachedExperimentFunnelsQueryResponse\n            | null\n        )[]\n    ) => void\n    onSetErrors: (errors: any[]) => void\n    onTimeout: (experimentId: Experiment['id'], metric: any) => void\n}\n\nconst loadMetrics = async ({\n    metrics,\n    experimentId,\n    refresh,\n    onSetResults,\n    onSetErrors,\n    onTimeout,\n}: MetricLoadingConfig): Promise<void[]> => {\n    const results: (\n        | CachedExperimentQueryResponse\n        | CachedExperimentTrendsQueryResponse\n        | CachedExperimentFunnelsQueryResponse\n        | null\n    )[] = []\n\n    const currentErrors = new Array(metrics.length).fill(null)\n\n    return await Promise.all(\n        metrics.map(async (metric, index) => {\n            try {\n                let queryWithExperimentId\n                if (metric.kind === NodeKind.ExperimentMetric) {\n                    queryWithExperimentId = {\n                        kind: NodeKind.ExperimentQuery,\n                        metric: metric,\n                        experiment_id: experimentId,\n                    }\n                } else {\n                    queryWithExperimentId = {\n                        ...metric,\n                        experiment_id: experimentId,\n                    }\n                }\n                const response = await performQuery(queryWithExperimentId, undefined, refresh ? 'force_async' : 'async')\n\n                results[index] = {\n                    ...response,\n                    fakeInsightId: Math.random().toString(36).substring(2, 15),\n                }\n                onSetResults([...results])\n            } catch (error: any) {\n                const errorDetailMatch = error.detail?.match(/\\{.*\\}/)\n                const errorDetail = errorDetailMatch ? JSON.parse(errorDetailMatch[0]) : error.detail || error.message\n\n                currentErrors[index] = {\n                    detail: errorDetail,\n                    statusCode: error.status,\n                    hasDiagnostics: !!errorDetailMatch,\n                }\n                onSetErrors(currentErrors)\n\n                if (errorDetail === QUERY_TIMEOUT_ERROR_MESSAGE) {\n                    onTimeout(experimentId, metric)\n                }\n\n                results[index] = null\n                onSetResults([...results])\n            }\n        })\n    )\n}\n\nexport const experimentLogic = kea<experimentLogicType>([\n    props({} as ExperimentLogicProps),\n    key((props) => props.experimentId || 'new'),\n    path((key) => ['scenes', 'experiment', 'experimentLogic', key]),\n    connect(() => ({\n        values: [\n            projectLogic,\n            ['currentProjectId'],\n            groupsModel,\n            ['aggregationLabel', 'groupTypes', 'showGroupsOptions'],\n            sceneLogic,\n            ['activeScene'],\n            featureFlagLogic,\n            ['featureFlags'],\n            holdoutsLogic,\n            ['holdouts'],\n            // Hook the insight state to get the results for the sample size estimation\n            funnelDataLogic({ dashboardItemId: MetricInsightId.Funnels }),\n            ['results as funnelResults', 'conversionMetrics'],\n            trendsDataLogic({ dashboardItemId: MetricInsightId.Trends }),\n            ['results as trendResults'],\n            // Hook into the loading state of the metric insight\n            insightDataLogic({ dashboardItemId: MetricInsightId.Trends }),\n            ['insightDataLoading as trendMetricInsightLoading'],\n            insightDataLogic({ dashboardItemId: MetricInsightId.Funnels }),\n            ['insightDataLoading as funnelMetricInsightLoading'],\n            sharedMetricsLogic,\n            ['sharedMetrics'],\n        ],\n        actions: [\n            experimentsLogic,\n            ['updateExperiments', 'addToExperiments'],\n            eventUsageLogic,\n            [\n                'reportExperimentCreated',\n                'reportExperimentViewed',\n                'reportExperimentLaunched',\n                'reportExperimentCompleted',\n                'reportExperimentArchived',\n                'reportExperimentReset',\n                'reportExperimentExposureCohortCreated',\n                'reportExperimentVariantShipped',\n                'reportExperimentVariantScreenshotUploaded',\n                'reportExperimentResultsLoadingTimeout',\n                'reportExperimentReleaseConditionsViewed',\n                'reportExperimentHoldoutAssigned',\n                'reportExperimentSharedMetricAssigned',\n                'reportExperimentDashboardCreated',\n                'reportExperimentMetricTimeout',\n            ],\n            teamLogic,\n            ['addProductIntent'],\n            featureFlagsLogic,\n            ['updateFlag'],\n        ],\n    })),\n    actions({\n        setExperimentMissing: true,\n        setExperiment: (experiment: Partial<Experiment>) => ({ experiment }),\n        createExperiment: (draft?: boolean) => ({ draft }),\n        setExperimentType: (type?: string) => ({ type }),\n        removeExperimentGroup: (idx: number) => ({ idx }),\n        setEditExperiment: (editing: boolean) => ({ editing }),\n        setFlagImplementationWarning: (warning: boolean) => ({ warning }),\n        setExposureAndSampleSize: (exposure: number, sampleSize: number) => ({ exposure, sampleSize }),\n        refreshExperimentResults: (forceRefresh?: boolean) => ({ forceRefresh }),\n        updateExperimentMetrics: true,\n        updateExperimentCollectionGoal: true,\n        updateExposureCriteria: true,\n        changeExperimentStartDate: (startDate: string) => ({ startDate }),\n        setExperimentStatsVersion: (version: number) => ({ version }),\n        launchExperiment: true,\n        endExperiment: true,\n        addVariant: true,\n        archiveExperiment: true,\n        resetRunningExperiment: true,\n        checkFlagImplementationWarning: true,\n        openExperimentCollectionGoalModal: true,\n        closeExperimentCollectionGoalModal: true,\n        openExposureCriteriaModal: true,\n        closeExposureCriteriaModal: true,\n        openShipVariantModal: true,\n        closeShipVariantModal: true,\n        openDistributionModal: true,\n        closeDistributionModal: true,\n        openReleaseConditionsModal: true,\n        closeReleaseConditionsModal: true,\n        openDescriptionModal: true,\n        closeDescriptionModal: true,\n        updateExperimentVariantImages: (variantPreviewMediaIds: Record<string, string[]>) => ({\n            variantPreviewMediaIds,\n        }),\n        setExposureCriteria: (exposureCriteria: ExperimentExposureCriteria) => ({ exposureCriteria }),\n        setMetric: ({\n            metricIdx,\n            name,\n            metric,\n            isSecondary = false,\n        }: {\n            metricIdx: number\n            name?: string\n            metric: ExperimentMetric\n            isSecondary?: boolean\n        }) => ({ metricIdx, name, metric, isSecondary }),\n        setTrendsMetric: ({\n            metricIdx,\n            name,\n            series,\n            filterTestAccounts,\n            isSecondary = false,\n        }: {\n            metricIdx: number\n            name?: string\n            series?: AnyEntityNode[]\n            filterTestAccounts?: boolean\n            isSecondary?: boolean\n        }) => ({ metricIdx, name, series, filterTestAccounts, isSecondary }),\n        setTrendsExposureMetric: ({\n            metricIdx,\n            name,\n            series,\n            filterTestAccounts,\n            isSecondary = false,\n        }: {\n            metricIdx: number\n            name?: string\n            series?: AnyEntityNode[]\n            filterTestAccounts?: boolean\n            isSecondary?: boolean\n        }) => ({ metricIdx, name, series, filterTestAccounts, isSecondary }),\n        setFunnelsMetric: ({\n            metricIdx,\n            name,\n            series,\n            filterTestAccounts,\n            breakdownAttributionType,\n            breakdownAttributionValue,\n            funnelWindowInterval,\n            funnelWindowIntervalUnit,\n            aggregation_group_type_index,\n            funnelAggregateByHogQL,\n            isSecondary,\n        }: {\n            metricIdx: number\n            name?: string\n            series?: AnyEntityNode[]\n            filterTestAccounts?: boolean\n            breakdownAttributionType?: BreakdownAttributionType\n            breakdownAttributionValue?: number\n            funnelWindowInterval?: number\n            funnelWindowIntervalUnit?: string\n            aggregation_group_type_index?: number\n            funnelAggregateByHogQL?: string\n            isSecondary?: boolean\n        }) => ({\n            metricIdx,\n            name,\n            series,\n            filterTestAccounts,\n            breakdownAttributionType,\n            breakdownAttributionValue,\n            funnelWindowInterval,\n            funnelWindowIntervalUnit,\n            aggregation_group_type_index,\n            funnelAggregateByHogQL,\n            isSecondary,\n        }),\n        setTabKey: (tabKey: string) => ({ tabKey }),\n        openPrimaryMetricModal: (index: number) => ({ index }),\n        closePrimaryMetricModal: true,\n        setMetricResultsLoading: (loading: boolean) => ({ loading }),\n        setMetricResults: (\n            results: (\n                | CachedExperimentQueryResponse\n                | CachedExperimentTrendsQueryResponse\n                | CachedExperimentFunnelsQueryResponse\n                | null\n            )[]\n        ) => ({ results }),\n        loadMetricResults: (refresh?: boolean) => ({ refresh }),\n        setPrimaryMetricsResultErrors: (errors: any[]) => ({ errors }),\n        setEditingPrimaryMetricIndex: (index: number | null) => ({ index }),\n        updateDistributionModal: (featureFlag: FeatureFlagType) => ({ featureFlag }),\n        openSecondaryMetricModal: (index: number) => ({ index }),\n        closeSecondaryMetricModal: true,\n        setSecondaryMetricResultsLoading: (loading: boolean) => ({ loading }),\n        setSecondaryMetricResults: (\n            results: (\n                | CachedExperimentQueryResponse\n                | CachedExperimentTrendsQueryResponse\n                | CachedExperimentFunnelsQueryResponse\n                | null\n            )[]\n        ) => ({ results }),\n        loadSecondaryMetricResults: (refresh?: boolean) => ({ refresh }),\n        setSecondaryMetricsResultErrors: (errors: any[]) => ({ errors }),\n        openPrimaryMetricSourceModal: true,\n        closePrimaryMetricSourceModal: true,\n        openSecondaryMetricSourceModal: true,\n        closeSecondaryMetricSourceModal: true,\n        openPrimarySharedMetricModal: (sharedMetricId: SharedMetric['id'] | null) => ({ sharedMetricId }),\n        closePrimarySharedMetricModal: true,\n        openSecondarySharedMetricModal: (sharedMetricId: SharedMetric['id'] | null) => ({ sharedMetricId }),\n        closeSecondarySharedMetricModal: true,\n        openVariantDeltaTimeseriesModal: true,\n        closeVariantDeltaTimeseriesModal: true,\n        addSharedMetricsToExperiment: (\n            sharedMetricIds: SharedMetric['id'][],\n            metadata: { type: 'primary' | 'secondary' }\n        ) => ({\n            sharedMetricIds,\n            metadata,\n        }),\n        removeSharedMetricFromExperiment: (sharedMetricId: SharedMetric['id']) => ({ sharedMetricId }),\n        createExperimentDashboard: true,\n        setIsCreatingExperimentDashboard: (isCreating: boolean) => ({ isCreating }),\n        setUnmodifiedExperiment: (experiment: Experiment) => ({ experiment }),\n        restoreUnmodifiedExperiment: true,\n        setValidExistingFeatureFlag: (featureFlag: FeatureFlagType | null) => ({ featureFlag }),\n        setFeatureFlagValidationError: (error: string) => ({ error }),\n        validateFeatureFlag: (featureFlagKey: string) => ({ featureFlagKey }),\n        openCalculateRunningTimeModal: true,\n        closeCalculateRunningTimeModal: true,\n    }),\n    reducers({\n        experiment: [\n            { ...NEW_EXPERIMENT } as Experiment,\n            {\n                setExperiment: (state, { experiment }) => {\n                    return { ...state, ...experiment }\n                },\n                addVariant: (state) => {\n                    if (state?.parameters?.feature_flag_variants) {\n                        const newRolloutPercentages = percentageDistribution(\n                            state.parameters.feature_flag_variants.length + 1\n                        )\n                        const updatedRolloutPercentageVariants = state.parameters.feature_flag_variants.map(\n                            (variant: MultivariateFlagVariant, i: number) => ({\n                                ...variant,\n                                rollout_percentage: newRolloutPercentages[i],\n                            })\n                        )\n                        return {\n                            ...state,\n                            parameters: {\n                                ...state.parameters,\n                                feature_flag_variants: [\n                                    ...updatedRolloutPercentageVariants,\n                                    {\n                                        key: `test_group_${state.parameters.feature_flag_variants.length}`,\n                                        rollout_percentage: newRolloutPercentages[newRolloutPercentages.length - 1],\n                                    },\n                                ],\n                            },\n                        }\n                    }\n                    return state\n                },\n                removeExperimentGroup: (state, { idx }) => {\n                    if (!state) {\n                        return state\n                    }\n                    const variants = [...(state.parameters?.feature_flag_variants || [])]\n                    variants.splice(idx, 1)\n                    const newRolloutPercentages = percentageDistribution(\n                        (state?.parameters?.feature_flag_variants || []).length - 1\n                    )\n                    const updatedVariants = variants.map((variant: MultivariateFlagVariant, i: number) => ({\n                        ...variant,\n                        rollout_percentage: newRolloutPercentages[i],\n                    }))\n\n                    return {\n                        ...state,\n                        parameters: {\n                            ...state.parameters,\n                            feature_flag_variants: updatedVariants,\n                        },\n                    }\n                },\n                setExposureCriteria: (\n                    state,\n                    { exposureCriteria }: { exposureCriteria: ExperimentExposureCriteria }\n                ) => {\n                    return {\n                        ...state,\n                        exposure_criteria: { ...state.exposure_criteria, ...exposureCriteria },\n                    }\n                },\n                setMetric: (state, { metricIdx, metric, isSecondary }) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n\n                    metrics[metricIdx] = metric\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n                setTrendsMetric: (state, { metricIdx, name, series, filterTestAccounts, isSecondary }) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n                    const metric = metrics[metricIdx]\n\n                    metrics[metricIdx] = {\n                        ...metric,\n                        ...(name !== undefined && { name }),\n                        count_query: {\n                            ...(metric as ExperimentTrendsQuery).count_query,\n                            ...(series && { series }),\n                            ...(filterTestAccounts !== undefined && { filterTestAccounts }),\n                        },\n                    } as ExperimentTrendsQuery\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n                setTrendsExposureMetric: (state, { metricIdx, name, series, filterTestAccounts, isSecondary }) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n                    const metric = metrics[metricIdx]\n\n                    metrics[metricIdx] = {\n                        ...metric,\n                        ...(name !== undefined && { name }),\n                        exposure_query: {\n                            ...(metric as ExperimentTrendsQuery).exposure_query,\n                            ...(series && { series }),\n                            ...(filterTestAccounts !== undefined && { filterTestAccounts }),\n                        },\n                    } as ExperimentTrendsQuery\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n                setFunnelsMetric: (\n                    state,\n                    {\n                        metricIdx,\n                        name,\n                        series,\n                        filterTestAccounts,\n                        breakdownAttributionType,\n                        breakdownAttributionValue,\n                        funnelWindowInterval,\n                        funnelWindowIntervalUnit,\n                        aggregation_group_type_index,\n                        funnelAggregateByHogQL,\n                        isSecondary,\n                    }\n                ) => {\n                    const metricsKey = isSecondary ? 'metrics_secondary' : 'metrics'\n                    const metrics = [...(state?.[metricsKey] || [])]\n                    const metric = metrics[metricIdx]\n\n                    metrics[metricIdx] = {\n                        ...metric,\n                        ...(name !== undefined && { name }),\n                        funnels_query: {\n                            ...(metric as ExperimentFunnelsQuery).funnels_query,\n                            ...(series && { series }),\n                            ...(filterTestAccounts !== undefined && { filterTestAccounts }),\n                            ...(aggregation_group_type_index !== undefined && { aggregation_group_type_index }),\n                            funnelsFilter: {\n                                ...(metric as ExperimentFunnelsQuery).funnels_query.funnelsFilter,\n                                ...(breakdownAttributionType && { breakdownAttributionType }),\n                                ...(breakdownAttributionValue !== undefined && { breakdownAttributionValue }),\n                                ...(funnelWindowInterval !== undefined && { funnelWindowInterval }),\n                                ...(funnelWindowIntervalUnit && { funnelWindowIntervalUnit }),\n                                ...(funnelAggregateByHogQL !== undefined && { funnelAggregateByHogQL }),\n                            },\n                        },\n                    } as ExperimentFunnelsQuery\n\n                    return {\n                        ...state,\n                        [metricsKey]: metrics,\n                    }\n                },\n            },\n        ],\n        experimentMissing: [\n            false,\n            {\n                setExperimentMissing: () => true,\n            },\n        ],\n        editingExistingExperiment: [\n            false,\n            {\n                setEditExperiment: (_, { editing }) => editing,\n            },\n        ],\n        flagImplementationWarning: [\n            false as boolean,\n            {\n                setFlagImplementationWarning: (_, { warning }) => warning,\n            },\n        ],\n        isExperimentCollectionGoalModalOpen: [\n            false,\n            {\n                openExperimentCollectionGoalModal: () => true,\n                closeExperimentCollectionGoalModal: () => false,\n            },\n        ],\n        isExposureCriteriaModalOpen: [\n            false,\n            {\n                openExposureCriteriaModal: () => true,\n                closeExposureCriteriaModal: () => false,\n            },\n        ],\n        isShipVariantModalOpen: [\n            false,\n            {\n                openShipVariantModal: () => true,\n                closeShipVariantModal: () => false,\n            },\n        ],\n        isDistributionModalOpen: [\n            false,\n            {\n                openDistributionModal: () => true,\n                closeDistributionModal: () => false,\n            },\n        ],\n        isReleaseConditionsModalOpen: [\n            false,\n            {\n                openReleaseConditionsModal: () => true,\n                closeReleaseConditionsModal: () => false,\n            },\n        ],\n        experimentValuesChangedLocally: [\n            false,\n            {\n                setExperiment: () => true,\n                loadExperiment: () => false,\n                updateExperiment: () => false,\n            },\n        ],\n        unmodifiedExperiment: [\n            null as Experiment | null,\n            {\n                setUnmodifiedExperiment: (_, { experiment }) => experiment,\n            },\n        ],\n        tabKey: [\n            'results',\n            {\n                setTabKey: (_, { tabKey }) => tabKey,\n            },\n        ],\n        isPrimaryMetricModalOpen: [\n            false,\n            {\n                openPrimaryMetricModal: () => true,\n                closePrimaryMetricModal: () => false,\n            },\n        ],\n        metricResultsLoading: [\n            false,\n            {\n                setMetricResultsLoading: (_, { loading }) => loading,\n            },\n        ],\n        metricResults: [\n            [] as (\n                | CachedExperimentQueryResponse\n                | CachedExperimentTrendsQueryResponse\n                | CachedExperimentFunnelsQueryResponse\n                | null\n            )[],\n            {\n                setMetricResults: (_, { results }) => results,\n            },\n        ],\n        secondaryMetricResultsLoading: [\n            false,\n            {\n                setSecondaryMetricResultsLoading: (_, { loading }) => loading,\n            },\n        ],\n        secondaryMetricResults: [\n            [] as (\n                | CachedExperimentQueryResponse\n                | CachedExperimentTrendsQueryResponse\n                | CachedExperimentFunnelsQueryResponse\n                | null\n            )[],\n            {\n                setSecondaryMetricResults: (_, { results }) => results,\n            },\n        ],\n        editingPrimaryMetricIndex: [\n            null as number | null,\n            {\n                openPrimaryMetricModal: (_, { index }) => index,\n                closePrimaryMetricModal: () => null,\n                updateExperimentMetrics: () => null,\n                setEditingPrimaryMetricIndex: (_, { index }) => index,\n            },\n        ],\n        primaryMetricsResultErrors: [\n            [] as any[],\n            {\n                setPrimaryMetricsResultErrors: (_, { errors }) => errors,\n                loadMetricResults: () => [],\n                loadExperiment: () => [],\n            },\n        ],\n        isSecondaryMetricModalOpen: [\n            false,\n            {\n                openSecondaryMetricModal: () => true,\n                closeSecondaryMetricModal: () => false,\n            },\n        ],\n        editingSecondaryMetricIndex: [\n            null as number | null,\n            {\n                openSecondaryMetricModal: (_, { index }) => index,\n                closeSecondaryMetricModal: () => null,\n                updateExperimentMetrics: () => null,\n            },\n        ],\n        editingSharedMetricId: [\n            null as SharedMetric['id'] | null,\n            {\n                openPrimarySharedMetricModal: (_, { sharedMetricId }) => sharedMetricId,\n                openSecondarySharedMetricModal: (_, { sharedMetricId }) => sharedMetricId,\n                updateExperimentMetrics: () => null,\n            },\n        ],\n        secondaryMetricsResultErrors: [\n            [] as any[],\n            {\n                setSecondaryMetricsResultErrors: (_, { errors }) => errors,\n                loadSecondaryMetricResults: () => [],\n                loadExperiment: () => [],\n            },\n        ],\n        isPrimaryMetricSourceModalOpen: [\n            false,\n            {\n                openPrimaryMetricSourceModal: () => true,\n                closePrimaryMetricSourceModal: () => false,\n            },\n        ],\n        isSecondaryMetricSourceModalOpen: [\n            false,\n            {\n                openSecondaryMetricSourceModal: () => true,\n                closeSecondaryMetricSourceModal: () => false,\n            },\n        ],\n        isPrimarySharedMetricModalOpen: [\n            false,\n            {\n                openPrimarySharedMetricModal: () => true,\n                closePrimarySharedMetricModal: () => false,\n            },\n        ],\n        isSecondarySharedMetricModalOpen: [\n            false,\n            {\n                openSecondarySharedMetricModal: () => true,\n                closeSecondarySharedMetricModal: () => false,\n            },\n        ],\n        isVariantDeltaTimeseriesModalOpen: [\n            false,\n            {\n                openVariantDeltaTimeseriesModal: () => true,\n                closeVariantDeltaTimeseriesModal: () => false,\n            },\n        ],\n        isCreatingExperimentDashboard: [\n            false,\n            {\n                setIsCreatingExperimentDashboard: (_, { isCreating }) => isCreating,\n            },\n        ],\n        validExistingFeatureFlag: [\n            null as FeatureFlagType | null,\n            {\n                setValidExistingFeatureFlag: (_, { featureFlag }) => featureFlag,\n            },\n        ],\n        featureFlagValidationError: [\n            null as string | null,\n            {\n                setFeatureFlagValidationError: (_, { error }) => error,\n            },\n        ],\n        isCalculateRunningTimeModalOpen: [\n            false,\n            {\n                openCalculateRunningTimeModal: () => true,\n                closeCalculateRunningTimeModal: () => false,\n            },\n        ],\n        isDescriptionModalOpen: [\n            false,\n            {\n                openDescriptionModal: () => true,\n                closeDescriptionModal: () => false,\n            },\n        ],\n    }),\n    listeners(({ values, actions }) => ({\n        createExperiment: async ({ draft }) => {\n            const { recommendedRunningTime, recommendedSampleSize, minimumDetectableEffect } = values\n\n            actions.touchExperimentField('name')\n            actions.touchExperimentField('feature_flag_key')\n            values.experiment.parameters.feature_flag_variants.forEach((_, i) =>\n                actions.touchExperimentField(`parameters.feature_flag_variants.${i}.key`)\n            )\n\n            if (hasFormErrors(values.experimentErrors)) {\n                return\n            }\n\n            // Minimum Detectable Effect is calculated based on a loaded insight\n            // Terminate if the insight did not manage to load in time\n            if (!minimumDetectableEffect) {\n                eventUsageLogic.actions.reportExperimentInsightLoadFailed()\n                return lemonToast.error(\n                    'Failed to load insight. Experiment cannot be saved without this value. Try changing the experiment goal.'\n                )\n            }\n\n            let response: Experiment | null = null\n            const isUpdate = !!values.experimentId && values.experimentId !== 'new'\n            try {\n                if (isUpdate) {\n                    response = await api.update(\n                        `api/projects/${values.currentProjectId}/experiments/${values.experimentId}`,\n                        {\n                            ...values.experiment,\n                            parameters: {\n                                ...values.experiment?.parameters,\n                                recommended_running_time: recommendedRunningTime,\n                                recommended_sample_size: recommendedSampleSize,\n                                minimum_detectable_effect: minimumDetectableEffect,\n                            },\n                            ...(!draft && { start_date: dayjs() }),\n                            // backwards compatibility: Remove any global properties set on the experiment.\n                            // These were used to change feature flag targeting, but this is controlled directly\n                            // on the feature flag now.\n                            filters: {\n                                events: [],\n                                actions: [],\n                                ...values.experiment.filters,\n                                properties: [],\n                            },\n                        }\n                    )\n\n                    if (response?.id) {\n                        actions.updateExperiments(response)\n                        actions.setEditExperiment(false)\n                        actions.loadExperimentSuccess(response)\n                        return\n                    }\n                } else {\n                    response = await api.create(`api/projects/${values.currentProjectId}/experiments`, {\n                        ...values.experiment,\n                        parameters: {\n                            ...values.experiment?.parameters,\n                            recommended_running_time: recommendedRunningTime,\n                            recommended_sample_size: recommendedSampleSize,\n                            minimum_detectable_effect: minimumDetectableEffect,\n                        },\n                        ...(!draft && { start_date: dayjs() }),\n                    })\n                    if (response) {\n                        actions.reportExperimentCreated(response)\n                        actions.addProductIntent({\n                            product_type: ProductKey.EXPERIMENTS,\n                            intent_context: ProductIntentContext.EXPERIMENT_CREATED,\n                        })\n                    }\n                }\n            } catch (error: any) {\n                lemonToast.error(error.detail || 'Failed to create experiment')\n                return\n            }\n\n            if (response?.id) {\n                const experimentId = response.id\n                router.actions.push(urls.experiment(experimentId))\n                actions.addToExperiments(response)\n                lemonToast.success(`Experiment ${isUpdate ? 'updated' : 'created'}`, {\n                    button: {\n                        label: 'View it',\n                        action: () => {\n                            router.actions.push(urls.experiment(experimentId))\n                        },\n                    },\n                })\n            }\n        },\n        setExperimentType: async ({ type }) => {\n            actions.setExperiment({ type: type })\n        },\n        loadExperimentSuccess: async ({ experiment }) => {\n            const duration = experiment?.start_date ? dayjs().diff(experiment.start_date, 'second') : null\n            experiment && actions.reportExperimentViewed(experiment, duration)\n\n            if (experiment?.start_date) {\n                actions.refreshExperimentResults()\n            }\n        },\n        launchExperiment: async () => {\n            const startDate = dayjs()\n            actions.updateExperiment({ start_date: startDate.toISOString() })\n            values.experiment && eventUsageLogic.actions.reportExperimentLaunched(values.experiment, startDate)\n            activationLogic.findMounted()?.actions.markTaskAsCompleted(ActivationTask.LaunchExperiment)\n        },\n        changeExperimentStartDate: async ({ startDate }) => {\n            actions.updateExperiment({ start_date: startDate })\n            values.experiment && eventUsageLogic.actions.reportExperimentStartDateChange(values.experiment, startDate)\n        },\n        setExperimentStatsVersion: async ({ version }, breakpoint) => {\n            actions.updateExperiment({ stats_config: { version } })\n            await breakpoint(100)\n            if (values.experiment?.start_date) {\n                actions.refreshExperimentResults(true)\n            }\n        },\n        endExperiment: async () => {\n            const endDate = dayjs()\n            actions.updateExperiment({ end_date: endDate.toISOString() })\n            const duration = endDate.diff(values.experiment?.start_date, 'second')\n            values.experiment &&\n                actions.reportExperimentCompleted(\n                    values.experiment,\n                    endDate,\n                    duration,\n                    values.isPrimaryMetricSignificant(0)\n                )\n        },\n        archiveExperiment: async () => {\n            actions.updateExperiment({ archived: true })\n            values.experiment && actions.reportExperimentArchived(values.experiment)\n        },\n        refreshExperimentResults: async ({ forceRefresh }) => {\n            actions.loadMetricResults(forceRefresh)\n            actions.loadSecondaryMetricResults(forceRefresh)\n            actions.loadExposures(forceRefresh)\n        },\n        updateExperimentMetrics: async () => {\n            actions.updateExperiment({\n                metrics: values.experiment.metrics,\n                metrics_secondary: values.experiment.metrics_secondary,\n            })\n        },\n        updateExperimentCollectionGoal: async () => {\n            const { recommendedRunningTime, recommendedSampleSize, minimumDetectableEffect } = values\n\n            actions.updateExperiment({\n                parameters: {\n                    ...values.experiment?.parameters,\n                    recommended_running_time: recommendedRunningTime,\n                    recommended_sample_size: recommendedSampleSize,\n                    minimum_detectable_effect: minimumDetectableEffect || 0,\n                },\n            })\n        },\n        updateExposureCriteria: async () => {\n            actions.updateExperiment({\n                exposure_criteria: {\n                    ...values.experiment.exposure_criteria,\n                },\n            })\n            actions.refreshExperimentResults(true)\n        },\n        resetRunningExperiment: async () => {\n            actions.updateExperiment({ start_date: null, end_date: null, archived: false })\n            values.experiment && actions.reportExperimentReset(values.experiment)\n            actions.setMetricResults([])\n            actions.setSecondaryMetricResults([])\n        },\n        updateExperimentSuccess: async ({ experiment, payload }) => {\n            actions.updateExperiments(experiment)\n            if (experiment.start_date) {\n                const forceRefresh = payload?.start_date !== undefined\n                actions.refreshExperimentResults(forceRefresh)\n            }\n        },\n        setExperiment: async ({ experiment }) => {\n            const experimentEntitiesChanged =\n                (experiment.filters?.events && experiment.filters.events.length > 0) ||\n                (experiment.filters?.actions && experiment.filters.actions.length > 0) ||\n                (experiment.filters?.data_warehouse && experiment.filters.data_warehouse.length > 0)\n\n            if (!experiment.filters || Object.keys(experiment.filters).length === 0) {\n                return\n            }\n\n            if (experimentEntitiesChanged) {\n                actions.checkFlagImplementationWarning()\n            }\n        },\n        setExperimentValue: async ({ name, value }, breakpoint) => {\n            if (Array.isArray(name) && name[0] === 'feature_flag_key') {\n                actions.validateFeatureFlag(value)\n            }\n\n            await breakpoint(100)\n\n            if (name === 'filters') {\n                const experimentEntitiesChanged =\n                    (value?.events && value.events.length > 0) ||\n                    (value?.actions && value.actions.length > 0) ||\n                    (value?.data_warehouse && value.data_warehouse.length > 0)\n\n                if (!value || Object.keys(value).length === 0) {\n                    return\n                }\n\n                if (experimentEntitiesChanged) {\n                    actions.checkFlagImplementationWarning()\n                }\n            }\n        },\n        setExperimentValues: async ({ values }, breakpoint) => {\n            await breakpoint(100)\n\n            const experiment = values\n\n            const experimentEntitiesChanged =\n                (experiment.filters?.events && experiment.filters.events.length > 0) ||\n                (experiment.filters?.actions && experiment.filters.actions.length > 0) ||\n                (experiment.filters?.data_warehouse && experiment.filters.data_warehouse.length > 0)\n\n            if (!experiment.filters || Object.keys(experiment.filters).length === 0) {\n                return\n            }\n\n            if (experimentEntitiesChanged) {\n                actions.checkFlagImplementationWarning()\n            }\n        },\n        checkFlagImplementationWarning: async (_, breakpoint) => {\n            const experiment = values.experiment\n            const experimentEntitiesChanged =\n                (experiment.filters?.events && experiment.filters.events.length > 0) ||\n                (experiment.filters?.actions && experiment.filters.actions.length > 0) ||\n                (experiment.filters?.data_warehouse && experiment.filters.data_warehouse.length > 0)\n\n            if (!experiment.filters || Object.keys(experiment.filters).length === 0) {\n                return\n            }\n\n            if (experimentEntitiesChanged) {\n                const url = `/api/projects/${\n                    values.currentProjectId\n                }/experiments/requires_flag_implementation?${toParams(experiment.filters || {})}`\n                await breakpoint(100)\n\n                try {\n                    const response = await api.get(url)\n                    actions.setFlagImplementationWarning(response.result)\n                } catch (e) {\n                    // default to not showing the warning\n                    actions.setFlagImplementationWarning(false)\n                }\n            }\n        },\n        createExposureCohortSuccess: ({ exposureCohort }) => {\n            if (exposureCohort && exposureCohort.id !== 'new') {\n                cohortsModel.actions.cohortCreated(exposureCohort)\n                actions.reportExperimentExposureCohortCreated(values.experiment, exposureCohort)\n                actions.setExperiment({ exposure_cohort: exposureCohort.id })\n                lemonToast.success('Exposure cohort created successfully', {\n                    button: {\n                        label: 'View cohort',\n                        action: () => router.actions.push(urls.cohort(exposureCohort.id)),\n                    },\n                })\n            }\n        },\n        shipVariantSuccess: ({ payload }) => {\n            lemonToast.success('The selected variant has been shipped')\n            actions.closeShipVariantModal()\n            if (payload.shouldStopExperiment && !values.isExperimentStopped) {\n                actions.endExperiment()\n            }\n            actions.loadExperiment()\n            actions.reportExperimentVariantShipped(values.experiment)\n        },\n        shipVariantFailure: ({ error }) => {\n            lemonToast.error(error)\n            actions.closeShipVariantModal()\n        },\n        updateExperimentVariantImages: async ({ variantPreviewMediaIds }) => {\n            try {\n                const updatedParameters = {\n                    ...values.experiment.parameters,\n                    variant_screenshot_media_ids: variantPreviewMediaIds,\n                }\n                await api.update(`api/projects/${values.currentProjectId}/experiments/${values.experimentId}`, {\n                    parameters: updatedParameters,\n                })\n                actions.setExperiment({\n                    parameters: updatedParameters,\n                })\n            } catch (error) {\n                lemonToast.error('Failed to update experiment variant images')\n            }\n        },\n        updateDistributionModal: async ({ featureFlag }) => {\n            const { created_at, id, ...flag } = featureFlag\n\n            const preparedFlag = indexToVariantKeyFeatureFlagPayloads(flag)\n\n            const savedFlag = await api.update(\n                `api/projects/${values.currentProjectId}/feature_flags/${id}`,\n                preparedFlag\n            )\n\n            const updatedFlag = variantKeyToIndexFeatureFlagPayloads(savedFlag)\n            actions.updateFlag(updatedFlag)\n\n            actions.updateExperiment({\n                holdout_id: values.experiment.holdout_id,\n            })\n        },\n        addSharedMetricsToExperiment: async ({ sharedMetricIds, metadata }) => {\n            const existingMetricsIds = values.experiment.saved_metrics.map((sharedMetric) => ({\n                id: sharedMetric.saved_metric,\n                metadata: sharedMetric.metadata,\n            }))\n\n            const newMetricsIds = sharedMetricIds.map((id: SharedMetric['id']) => ({ id, metadata }))\n            newMetricsIds.forEach((metricId) => {\n                const metric = values.sharedMetrics.find((m: SharedMetric) => m.id === metricId.id)\n                if (metric) {\n                    actions.reportExperimentSharedMetricAssigned(values.experimentId, metric)\n                }\n            })\n            const combinedMetricsIds = [...existingMetricsIds, ...newMetricsIds]\n\n            await api.update(`api/projects/${values.currentProjectId}/experiments/${values.experimentId}`, {\n                saved_metrics_ids: combinedMetricsIds,\n            })\n\n            actions.loadExperiment()\n        },\n        removeSharedMetricFromExperiment: async ({ sharedMetricId }) => {\n            const sharedMetricsIds = values.experiment.saved_metrics\n                .filter((sharedMetric) => sharedMetric.saved_metric !== sharedMetricId)\n                .map((sharedMetric) => ({\n                    id: sharedMetric.saved_metric,\n                    metadata: sharedMetric.metadata,\n                }))\n            await api.update(`api/projects/${values.currentProjectId}/experiments/${values.experimentId}`, {\n                saved_metrics_ids: sharedMetricsIds,\n            })\n\n            actions.loadExperiment()\n        },\n        createExperimentDashboard: async () => {\n            actions.setIsCreatingExperimentDashboard(true)\n            try {\n                // 1. Create the dashboard\n                // 2. Create secondary metric insights in reverse order\n                // 3. Create primary metric insights in reverse order\n\n                const experimentUrl =\n                    window.location.origin + addProjectIdIfMissing(urls.experiment(values.experimentId))\n                const dashboard: DashboardType = await api.create(\n                    `api/environments/${teamLogic.values.currentTeamId}/dashboards/`,\n                    {\n                        name: 'Experiment: ' + values.experiment.name,\n                        description: `Dashboard for [${experimentUrl}](${experimentUrl})`,\n                        filters: {\n                            date_from: values.experiment.start_date,\n                            date_to: values.experiment.end_date,\n                            properties: [],\n                            breakdown_filter: {\n                                breakdown: '$feature/' + values.experiment.feature_flag_key,\n                                breakdown_type: 'event' as BreakdownType,\n                            },\n                        },\n                    } as Partial<DashboardType>\n                )\n\n                // Reverse order because adding an insight to the dashboard\n                // places it at the beginning of the list\n                for (const type of ['secondary', 'primary']) {\n                    const singleMetrics =\n                        type === 'secondary' ? values.experiment.metrics_secondary : values.experiment.metrics\n                    const sharedMetrics = values.experiment?.saved_metrics.filter(\n                        (sharedMetric) => sharedMetric.metadata.type === type\n                    )\n                    const metrics = [\n                        ...singleMetrics,\n                        ...sharedMetrics.map((m) => ({ name: m.name, ...m.query })),\n                    ].reverse()\n                    for (const query of metrics) {\n                        const insightQuery: InsightVizNode = {\n                            kind: NodeKind.InsightVizNode,\n                            source: (query.kind === NodeKind.ExperimentTrendsQuery\n                                ? query.count_query\n                                : query.funnels_query) as InsightQueryNode,\n                        }\n                        await api.create(`api/projects/${projectLogic.values.currentProjectId}/insights`, {\n                            name: query.name || undefined,\n                            query: insightQuery,\n                            dashboards: [dashboard.id],\n                        })\n                    }\n                }\n\n                actions.reportExperimentDashboardCreated(values.experiment, dashboard.id)\n\n                const dashboardUrl = window.location.origin + addProjectIdIfMissing(urls.dashboard(dashboard.id))\n                actions.updateExperiment({\n                    description:\n                        (values.experiment.description ? values.experiment.description + `\\n\\n` : '') +\n                        `Dashboard: [${dashboardUrl}](${dashboardUrl})`,\n                })\n\n                lemonToast.success('Dashboard created successfully', {\n                    button: {\n                        label: 'View dashboard',\n                        action: () => router.actions.push(`/dashboard/${dashboard.id}`),\n                    },\n                })\n            } catch (error: any) {\n                if (!isBreakpoint(error)) {\n                    const message = error.code && error.detail ? `${error.code}: ${error.detail}` : error\n                    lemonToast.error(`Could not create dashboard: ${message}`)\n                }\n            }\n            actions.setIsCreatingExperimentDashboard(false)\n        },\n        restoreUnmodifiedExperiment: () => {\n            if (values.unmodifiedExperiment) {\n                actions.setExperiment(structuredClone(values.unmodifiedExperiment))\n            }\n        },\n        validateFeatureFlag: async ({ featureFlagKey }: { featureFlagKey: string }, breakpoint) => {\n            await breakpoint(200)\n            const response = await api.get(\n                `api/projects/${values.currentProjectId}/feature_flags/?${toParams({ search: featureFlagKey })}`\n            )\n            const existingErrors = {\n                // :KLUDGE: If there is no name error, we don't want to trigger the 'required' error early\n                name: undefined,\n                ...values.experimentErrors,\n            }\n            if (response.results.length > 0) {\n                const matchingFlag = response.results.find((flag: FeatureFlagType) => flag.key === featureFlagKey)\n                if (matchingFlag) {\n                    let isValid\n                    try {\n                        isValid = featureFlagEligibleForExperiment(matchingFlag)\n                    } catch (error) {\n                        isValid = false\n                    }\n                    actions.setValidExistingFeatureFlag(isValid ? matchingFlag : null)\n                    actions.setFeatureFlagValidationError(\n                        isValid ? '' : 'Existing feature flag is not eligible for experiments.'\n                    )\n                    actions.setExperimentManualErrors({\n                        ...existingErrors,\n                        feature_flag_key: values.featureFlagValidationError || undefined,\n                    })\n                    return\n                }\n            }\n\n            actions.setValidExistingFeatureFlag(null)\n            actions.setFeatureFlagValidationError(validateFeatureFlagKey(featureFlagKey) || '')\n            actions.setExperimentManualErrors({\n                ...existingErrors,\n                feature_flag_key: values.featureFlagValidationError || undefined,\n            })\n        },\n        touchExperimentField: ({ key }) => {\n            // :KLUDGE: Persist the existing feature_flag_key validation when the field is blurred.\n            if (key === 'feature_flag_key') {\n                actions.setExperimentManualErrors({\n                    feature_flag_key: values.featureFlagValidationError || undefined,\n                })\n            }\n        },\n        loadMetricResults: async ({ refresh }: { refresh?: boolean }) => {\n            actions.setMetricResultsLoading(true)\n            actions.setMetricResults([])\n\n            let metrics = values.experiment?.metrics\n            const sharedMetrics = values.experiment?.saved_metrics\n                .filter((sharedMetric) => sharedMetric.metadata.type === 'primary')\n                .map((sharedMetric) => sharedMetric.query)\n            if (sharedMetrics) {\n                metrics = [...metrics, ...sharedMetrics]\n            }\n\n            await loadMetrics({\n                metrics,\n                experimentId: values.experimentId,\n                refresh,\n                onSetResults: actions.setMetricResults,\n                onSetErrors: actions.setPrimaryMetricsResultErrors,\n                onTimeout: actions.reportExperimentMetricTimeout,\n            })\n\n            actions.setMetricResultsLoading(false)\n        },\n        loadSecondaryMetricResults: async ({ refresh }: { refresh?: boolean }) => {\n            actions.setSecondaryMetricResultsLoading(true)\n            actions.setSecondaryMetricResults([])\n\n            let secondaryMetrics = values.experiment?.metrics_secondary\n            const sharedMetrics = values.experiment?.saved_metrics\n                .filter((sharedMetric) => sharedMetric.metadata.type === 'secondary')\n                .map((sharedMetric) => sharedMetric.query)\n            if (sharedMetrics) {\n                secondaryMetrics = [...secondaryMetrics, ...sharedMetrics]\n            }\n\n            await loadMetrics({\n                metrics: secondaryMetrics,\n                experimentId: values.experimentId,\n                refresh,\n                onSetResults: actions.setSecondaryMetricResults,\n                onSetErrors: actions.setSecondaryMetricsResultErrors,\n                onTimeout: actions.reportExperimentMetricTimeout,\n            })\n\n            actions.setSecondaryMetricResultsLoading(false)\n        },\n        openReleaseConditionsModal: () => {\n            const numericFlagId = values.experiment.feature_flag?.id\n            if (numericFlagId) {\n                const logic = sceneFeatureFlagLogic.findMounted() || sceneFeatureFlagLogic({ id: numericFlagId })\n                if (logic) {\n                    logic.actions.loadFeatureFlag() // Access the loader through actions\n                }\n            }\n        },\n    })),\n    loaders(({ actions, props, values }) => ({\n        experiment: {\n            loadExperiment: async () => {\n                if (props.experimentId && props.experimentId !== 'new') {\n                    try {\n                        const response: Experiment = await api.get(\n                            `api/projects/${values.currentProjectId}/experiments/${props.experimentId}`\n                        )\n                        actions.setUnmodifiedExperiment(structuredClone(response))\n                        return response\n                    } catch (error: any) {\n                        if (error.status === 404) {\n                            actions.setExperimentMissing()\n                        } else {\n                            throw error\n                        }\n                    }\n                }\n                return NEW_EXPERIMENT\n            },\n            updateExperiment: async (update: Partial<Experiment>) => {\n                const response: Experiment = await api.update(\n                    `api/projects/${values.currentProjectId}/experiments/${values.experimentId}`,\n                    update\n                )\n                actions.setUnmodifiedExperiment(structuredClone(response))\n                return response\n            },\n        },\n        exposureCohort: [\n            null as CohortType | null,\n            {\n                createExposureCohort: async () => {\n                    if (props.experimentId && props.experimentId !== 'new' && props.experimentId !== 'web') {\n                        return (await api.experiments.createExposureCohort(props.experimentId)).cohort\n                    }\n                    return null\n                },\n            },\n        ],\n        featureFlag: [\n            null as FeatureFlagType | null,\n            {\n                shipVariant: async ({ selectedVariantKey, shouldStopExperiment }) => {\n                    if (!values.experiment.feature_flag) {\n                        throw new Error('Experiment does not have a feature flag linked')\n                    }\n\n                    const currentFlagFilters = values.experiment.feature_flag?.filters\n                    const newFilters = transformFiltersForWinningVariant(currentFlagFilters, selectedVariantKey)\n\n                    await api.update(\n                        `api/projects/${values.currentProjectId}/feature_flags/${values.experiment.feature_flag?.id}`,\n                        { filters: newFilters }\n                    )\n\n                    return shouldStopExperiment\n                },\n            },\n        ],\n        exposures: [\n            null as any,\n            {\n                loadExposures: async (refresh: boolean = false) => {\n                    const query = {\n                        kind: NodeKind.ExperimentExposureQuery,\n                        experiment_id: props.experimentId,\n                    }\n                    return await performQuery(query, undefined, refresh ? 'force_async' : 'async')\n                },\n            },\n        ],\n    })),\n    selectors({\n        props: [() => [(_, props) => props], (props) => props],\n        experimentId: [\n            () => [(_, props) => props.experimentId ?? 'new'],\n            (experimentId): Experiment['id'] => experimentId,\n        ],\n        getInsightType: [\n            () => [],\n            () =>\n                (\n                    metric: ExperimentMetric | ExperimentTrendsQuery | ExperimentFunnelsQuery | undefined\n                ): InsightType => {\n                    return metric &&\n                        ((metric?.kind === NodeKind.ExperimentMetric &&\n                            metric.metric_type === ExperimentMetricType.MEAN) ||\n                            metric?.kind === NodeKind.ExperimentTrendsQuery)\n                        ? InsightType.TRENDS\n                        : InsightType.FUNNELS\n                },\n        ],\n        getExperimentMetricType: [\n            () => [],\n            () =>\n                (metric: ExperimentMetric | undefined): ExperimentMetricType => {\n                    return metric?.metric_type || ExperimentMetricType.MEAN\n                },\n        ],\n        isExperimentRunning: [\n            (s) => [s.experiment],\n            (experiment): boolean => {\n                return !!experiment?.start_date\n            },\n        ],\n        isExperimentStopped: [\n            (s) => [s.experiment],\n            (experiment): boolean => {\n                return (\n                    !!experiment?.end_date &&\n                    dayjs().isSameOrAfter(dayjs(experiment.end_date), 'day') &&\n                    !experiment.archived\n                )\n            },\n        ],\n        breadcrumbs: [\n            (s) => [s.experiment, s.experimentId],\n            (experiment, experimentId): Breadcrumb[] => [\n                {\n                    key: Scene.Experiments,\n                    name: 'Experiments',\n                    path: urls.experiments(),\n                },\n                {\n                    key: [Scene.Experiment, experimentId],\n                    name: experiment?.name || '',\n                    onRename: async (name: string) => {\n                        // :KLUDGE: work around a type error when using asyncActions accessed via a callback passed to selectors()\n                        const logic = experimentLogic({ experimentId })\n                        await logic.asyncActions.updateExperiment({ name })\n                    },\n                },\n            ],\n        ],\n        variants: [\n            (s) => [s.experiment],\n            (experiment): MultivariateFlagVariant[] => {\n                return experiment?.parameters?.feature_flag_variants || []\n            },\n        ],\n        experimentMathAggregationForTrends: [\n            (s) => [s.experiment],\n            (experiment) => (): PropertyMathType | CountPerActorMathType | undefined => {\n                const query = experiment?.metrics?.[0] as ExperimentTrendsQuery\n                if (!query) {\n                    return undefined\n                }\n                const entities = query.count_query?.series || []\n\n                // Find out if we're using count per actor math aggregates averages per user\n                const userMathValue = entities.filter((entity) =>\n                    Object.values(CountPerActorMathType).includes(entity?.math as CountPerActorMathType)\n                )[0]?.math\n\n                // alternatively, if we're using property math\n                // remove 'sum' property math from the list of math types\n                // since we can handle that as a regular case\n                const targetValues = Object.values(PropertyMathType).filter((value) => value !== PropertyMathType.Sum)\n\n                const propertyMathValue = entities.filter((entity) =>\n                    targetValues.includes(entity?.math as PropertyMathType)\n                )[0]?.math\n\n                return (userMathValue ?? propertyMathValue) as PropertyMathType | CountPerActorMathType | undefined\n            },\n        ],\n        minimumDetectableEffect: [\n            (s) => [s.experiment, s.getInsightType, s.conversionMetrics, s.trendResults, s.firstPrimaryMetric],\n            (newExperiment, getInsightType, conversionMetrics, trendResults, firstPrimaryMetric): number => {\n                return (\n                    newExperiment?.parameters?.minimum_detectable_effect ||\n                    // :KLUDGE: extracted the method due to difficulties with logic tests\n                    getMinimumDetectableEffect(getInsightType(firstPrimaryMetric), conversionMetrics, trendResults) ||\n                    0\n                )\n            },\n        ],\n        minimumSampleSizePerVariant: [\n            (s) => [s.minimumDetectableEffect],\n            (mde) => (conversionRate: number) => {\n                // Using the rule of thumb: sampleSize = 16 * sigma^2 / (mde^2)\n                // refer https://en.wikipedia.org/wiki/Sample_size_determination with default beta and alpha\n                // The results are same as: https://www.evanmiller.org/ab-testing/sample-size.html\n                // and also: https://marketing.dynamicyield.com/ab-test-duration-calculator/\n                if (!mde) {\n                    return 0\n                }\n\n                return Math.ceil((1600 * conversionRate * (1 - conversionRate / 100)) / (mde * mde))\n            },\n        ],\n        isPrimaryMetricSignificant: [\n            (s) => [s.metricResults],\n            (\n                    metricResults: (\n                        | CachedExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[]\n                ) =>\n                (metricIndex: number = 0): boolean => {\n                    return metricResults?.[metricIndex]?.significant || false\n                },\n        ],\n        isSecondaryMetricSignificant: [\n            (s) => [s.secondaryMetricResults],\n            (\n                    secondaryMetricResults: (\n                        | CachedExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[]\n                ) =>\n                (metricIndex: number = 0): boolean => {\n                    return secondaryMetricResults?.[metricIndex]?.significant || false\n                },\n        ],\n        significanceDetails: [\n            (s) => [s.metricResults, s.experimentStatsVersion],\n            (\n                    metricResults: (\n                        | CachedExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    experimentStatsVersion: number\n                ) =>\n                (metricIndex: number = 0): string => {\n                    const results = metricResults?.[metricIndex]\n\n                    if (results?.significance_code === ExperimentSignificanceCode.HighLoss) {\n                        return `This is because the expected loss in conversion is greater than 1% (current value is ${(\n                            (results as CachedExperimentFunnelsQueryResponse)?.expected_loss || 0\n                        )?.toFixed(2)}%).`\n                    }\n\n                    if (results?.significance_code === ExperimentSignificanceCode.HighPValue) {\n                        return `This is because the p value is greater than 0.05 (current value is ${\n                            (results as CachedExperimentTrendsQueryResponse)?.p_value?.toFixed(3) || 1\n                        }).`\n                    }\n\n                    if (results?.significance_code === ExperimentSignificanceCode.LowWinProbability) {\n                        if (experimentStatsVersion === 2) {\n                            return 'This is because no variant (control or test) has a win probability higher than 90%.'\n                        }\n                        return 'This is because the win probability of all test variants combined is less than 90%.'\n                    }\n\n                    if (results?.significance_code === ExperimentSignificanceCode.NotEnoughExposure) {\n                        return 'This is because we need at least 100 people per variant to declare significance.'\n                    }\n\n                    return ''\n                },\n        ],\n        recommendedSampleSize: [\n            (s) => [s.conversionMetrics, s.minimumSampleSizePerVariant, s.variants],\n            (conversionMetrics, minimumSampleSizePerVariant, variants): number => {\n                const conversionRate = conversionMetrics.totalRate * 100\n                const sampleSizePerVariant = minimumSampleSizePerVariant(conversionRate)\n                const sampleSize = sampleSizePerVariant * variants.length\n                return sampleSize\n            },\n        ],\n        recommendedRunningTime: [\n            (s) => [\n                s.experiment,\n                s.variants,\n                s.getInsightType,\n                s.firstPrimaryMetric,\n                s.funnelResults,\n                s.conversionMetrics,\n                s.expectedRunningTime,\n                s.trendResults,\n                s.minimumSampleSizePerVariant,\n                s.recommendedExposureForCountData,\n            ],\n            (\n                experiment,\n                variants,\n                getInsightType,\n                firstPrimaryMetric,\n                funnelResults,\n                conversionMetrics,\n                expectedRunningTime,\n                trendResults,\n                minimumSampleSizePerVariant,\n                recommendedExposureForCountData\n            ): number => {\n                if (getInsightType(firstPrimaryMetric) === InsightType.FUNNELS) {\n                    const currentDuration = dayjs().diff(dayjs(experiment?.start_date), 'hour')\n                    const funnelEntrants = funnelResults?.[0]?.count\n\n                    const conversionRate = conversionMetrics.totalRate * 100\n                    const sampleSizePerVariant = minimumSampleSizePerVariant(conversionRate)\n                    const funnelSampleSize = sampleSizePerVariant * variants.length\n                    if (experiment?.start_date) {\n                        return expectedRunningTime(funnelEntrants || 1, funnelSampleSize || 0, currentDuration)\n                    }\n                    return expectedRunningTime(funnelEntrants || 1, funnelSampleSize || 0)\n                }\n\n                const trendCount = trendResults[0]?.count\n                const runningTime = recommendedExposureForCountData(trendCount)\n                return runningTime\n            },\n        ],\n        recommendedExposureForCountData: [\n            (s) => [s.minimumDetectableEffect],\n            (mde) =>\n                (baseCountData: number): number => {\n                    // http://www.columbia.edu/~cjd11/charles_dimaggio/DIRE/styled-4/code-12/\n                    if (!mde) {\n                        return 0\n                    }\n\n                    const minCountData = (baseCountData * mde) / 100\n                    const lambda1 = baseCountData\n                    const lambda2 = minCountData + baseCountData\n\n                    // This is exposure in units of days\n                    return parseFloat(\n                        (\n                            4 /\n                            Math.pow(\n                                Math.sqrt(lambda1 / EXPERIMENT_DEFAULT_DURATION) -\n                                    Math.sqrt(lambda2 / EXPERIMENT_DEFAULT_DURATION),\n                                2\n                            )\n                        ).toFixed(1)\n                    )\n                },\n        ],\n        expectedRunningTime: [\n            () => [],\n            () =>\n                (entrants: number, sampleSize: number, duration: number = EXPERIMENT_DEFAULT_DURATION): number => {\n                    // recommended people / (actual people / day) = expected days\n                    return parseFloat((sampleSize / (entrants / duration)).toFixed(1))\n                },\n        ],\n        conversionRateForVariant: [\n            () => [],\n            () =>\n                (\n                    metricResult:\n                        | CachedExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null,\n                    variantKey: string\n                ): number | null => {\n                    if (!metricResult) {\n                        return null\n                    }\n\n                    if (\n                        metricResult.kind === NodeKind.ExperimentQuery &&\n                        metricResult.metric.metric_type === ExperimentMetricType.FUNNEL\n                    ) {\n                        const variants = metricResult.variants as FunnelExperimentVariant[]\n                        const variantResults = variants.find((variant) => variant.key === variantKey)\n\n                        if (!variantResults) {\n                            return null\n                        }\n                        return (\n                            (variantResults.success_count /\n                                (variantResults.success_count + variantResults.failure_count)) *\n                            100\n                        )\n                    } else if (metricResult.kind === NodeKind.ExperimentFunnelsQuery && metricResult.insight) {\n                        const variantResults = (metricResult.insight as FunnelStep[][]).find(\n                            (variantFunnel: FunnelStep[]) => {\n                                const breakdownValue = variantFunnel[0]?.breakdown_value\n                                return Array.isArray(breakdownValue) && breakdownValue[0] === variantKey\n                            }\n                        )\n\n                        if (!variantResults) {\n                            return null\n                        }\n\n                        return (variantResults[variantResults.length - 1].count / variantResults[0].count) * 100\n                    }\n\n                    return null\n                },\n        ],\n        credibleIntervalForVariant: [\n            () => [],\n            () =>\n                (\n                    metricResult:\n                        | CachedExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null,\n                    variantKey: string,\n                    metricType: InsightType\n                ): [number, number] | null => {\n                    const credibleInterval = metricResult?.credible_intervals?.[variantKey]\n                    if (!credibleInterval) {\n                        return null\n                    }\n\n                    if (metricType === InsightType.FUNNELS) {\n                        const controlVariant = (metricResult.variants as FunnelExperimentVariant[]).find(\n                            ({ key }) => key === 'control'\n                        ) as FunnelExperimentVariant\n                        const controlConversionRate =\n                            controlVariant.success_count / (controlVariant.success_count + controlVariant.failure_count)\n\n                        if (!controlConversionRate) {\n                            return null\n                        }\n\n                        // Calculate the percentage difference between the credible interval bounds of the variant and the control's conversion rate.\n                        // This represents the range in which the true percentage change relative to the control is likely to fall.\n                        const lowerBound = ((credibleInterval[0] - controlConversionRate) / controlConversionRate) * 100\n                        const upperBound = ((credibleInterval[1] - controlConversionRate) / controlConversionRate) * 100\n                        return [lowerBound, upperBound]\n                    }\n\n                    const controlVariant = (metricResult.variants as TrendExperimentVariant[]).find(\n                        ({ key }) => key === 'control'\n                    ) as TrendExperimentVariant\n\n                    const controlMean = controlVariant.count / controlVariant.absolute_exposure\n                    if (!controlMean) {\n                        return null\n                    }\n\n                    // Calculate the percentage difference between the credible interval bounds of the variant and the control's mean.\n                    // This represents the range in which the true percentage change relative to the control is likely to fall.\n                    const relativeLowerBound = ((credibleInterval[0] - controlMean) / controlMean) * 100\n                    const relativeUpperBound = ((credibleInterval[1] - controlMean) / controlMean) * 100\n                    return [relativeLowerBound, relativeUpperBound]\n                },\n        ],\n        getIndexForVariant: [\n            (s) => [s.getInsightType, s.firstPrimaryMetric],\n            (getInsightType, firstPrimaryMetric) =>\n                (\n                    metricResult:\n                        | CachedExperimentQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | null,\n                    variant: string\n                ): number | null => {\n                    // Ensures we get the right index from results, so the UI can\n                    // display the right colour for the variant\n                    if (!metricResult || !metricResult.insight) {\n                        return null\n                    }\n\n                    let index = -1\n                    if (getInsightType(firstPrimaryMetric) === InsightType.FUNNELS) {\n                        // Funnel Insight is displayed in order of decreasing count\n                        index = (Array.isArray(metricResult.insight) ? [...metricResult.insight] : [])\n                            .sort((a, b) => {\n                                const aCount = (a && Array.isArray(a) && a[0]?.count) || 0\n                                const bCount = (b && Array.isArray(b) && b[0]?.count) || 0\n                                return bCount - aCount\n                            })\n                            .findIndex((variantFunnel) => {\n                                if (!Array.isArray(variantFunnel) || !variantFunnel[0]?.breakdown_value) {\n                                    return false\n                                }\n                                const breakdownValue = variantFunnel[0].breakdown_value\n                                return Array.isArray(breakdownValue) && breakdownValue[0] === variant\n                            })\n                    } else {\n                        index = (metricResult.insight as TrendResult[]).findIndex(\n                            (variantTrend: TrendResult) => variantTrend.breakdown_value === variant\n                        )\n                    }\n                    const result = index === -1 ? null : index\n\n                    if (result !== null && getInsightType(firstPrimaryMetric) === InsightType.FUNNELS) {\n                        return result + 1\n                    }\n                    return result\n                },\n        ],\n        countDataForVariant: [\n            (s) => [s.experimentMathAggregationForTrends],\n            (experimentMathAggregationForTrends) =>\n                (\n                    metricResult:\n                        | CachedExperimentQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | null,\n                    variant: string,\n                    type: 'primary' | 'secondary' = 'primary'\n                ): number | null => {\n                    if (!metricResult) {\n                        return null\n                    }\n\n                    if ('kind' in metricResult && metricResult.kind === NodeKind.ExperimentQuery) {\n                        const variantResults = (\n                            metricResult.variants as Array<{ key: string } & Record<string, any>>\n                        ).find((variantData) => variantData.key === variant)\n                        // NOTE: Unfortunately, there does not seem to be a better way at the moment to figure out which type it is.\n                        // Something we can improve later when we replace the ExperimentVariantTrendsBaseStats with a new type / interface.\n                        if (variantResults && 'success_count' in variantResults) {\n                            return variantResults.success_count + variantResults.failure_count\n                        } else if (variantResults && 'count' in variantResults) {\n                            return variantResults.count\n                        }\n                        return null\n                    }\n\n                    const usingMathAggregationType = type === 'primary' ? experimentMathAggregationForTrends() : false\n                    if (!metricResult.insight) {\n                        return null\n                    }\n                    const variantResults = (metricResult.insight as TrendResult[]).find(\n                        (variantTrend: TrendResult) => variantTrend.breakdown_value === variant\n                    )\n                    if (!variantResults) {\n                        return null\n                    }\n\n                    let result = variantResults.count\n\n                    if (usingMathAggregationType) {\n                        // TODO: Aggregate end result appropriately for nth percentile\n                        if (\n                            [\n                                CountPerActorMathType.Average,\n                                CountPerActorMathType.Median,\n                                PropertyMathType.Average,\n                                PropertyMathType.Median,\n                            ].includes(usingMathAggregationType)\n                        ) {\n                            result = variantResults.count / variantResults.data.length\n                        } else if (\n                            [CountPerActorMathType.Maximum, PropertyMathType.Maximum].includes(usingMathAggregationType)\n                        ) {\n                            result = Math.max(...variantResults.data)\n                        } else if (\n                            [CountPerActorMathType.Minimum, PropertyMathType.Minimum].includes(usingMathAggregationType)\n                        ) {\n                            result = Math.min(...variantResults.data)\n                        }\n                    }\n\n                    return result\n                },\n        ],\n        exposureCountDataForVariant: [\n            () => [],\n            () =>\n                (\n                    metricResult:\n                        | CachedExperimentQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | null,\n                    variant: string\n                ): number | null => {\n                    if (!metricResult || !metricResult.variants) {\n                        return null\n                    }\n\n                    if ('kind' in metricResult && metricResult.kind === NodeKind.ExperimentQuery) {\n                        const variantResults = (\n                            metricResult.variants as Array<{ key: string; exposure?: number }>\n                        ).find((variantData) => variantData.key === variant)\n                        return variantResults?.exposure ?? null\n                    }\n\n                    const variantResults = (metricResult.variants as TrendExperimentVariant[]).find(\n                        (variantTrend: TrendExperimentVariant) => variantTrend.key === variant\n                    )\n                    if (!variantResults || !variantResults.absolute_exposure) {\n                        return null\n                    }\n\n                    return variantResults.absolute_exposure\n                },\n        ],\n        getHighestProbabilityVariant: [\n            () => [],\n            () =>\n                (\n                    results:\n                        | CachedExperimentQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | null\n                ) => {\n                    if (results && results.probability) {\n                        const maxValue = Math.max(...Object.values(results.probability))\n                        return Object.keys(results.probability).find(\n                            (key) => Math.abs(results.probability[key] - maxValue) < Number.EPSILON\n                        )\n                    }\n                },\n        ],\n        tabularExperimentResults: [\n            (s) => [s.experiment, s.metricResults, s.secondaryMetricResults, s.getInsightType],\n            (\n                    experiment,\n                    metricResults: (\n                        | CachedExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    secondaryMetricResults: (\n                        | CachedExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    getInsightType\n                ) =>\n                (metricIndex: number = 0, isSecondary: boolean = false): any[] => {\n                    const tabularResults = []\n                    const metricType = isSecondary\n                        ? getInsightType(experiment.metrics_secondary[metricIndex])\n                        : getInsightType(experiment.metrics[metricIndex])\n                    const result = isSecondary ? secondaryMetricResults[metricIndex] : metricResults[metricIndex]\n\n                    if (result) {\n                        for (const variantObj of result.variants) {\n                            if (metricType === InsightType.FUNNELS) {\n                                const { key, success_count, failure_count } = variantObj as FunnelExperimentVariant\n                                tabularResults.push({ key, success_count, failure_count })\n                            } else if (metricType === InsightType.TRENDS) {\n                                const { key, count, exposure, absolute_exposure } = variantObj as TrendExperimentVariant\n                                tabularResults.push({ key, count, exposure, absolute_exposure })\n                            }\n                        }\n                    }\n\n                    if (experiment.feature_flag?.filters.multivariate?.variants) {\n                        for (const { key } of experiment.feature_flag.filters.multivariate.variants) {\n                            if (tabularResults.find((variantObj) => variantObj.key === key)) {\n                                continue\n                            }\n\n                            if (metricType === InsightType.FUNNELS) {\n                                tabularResults.push({ key, success_count: null, failure_count: null })\n                            } else if (metricType === InsightType.TRENDS) {\n                                tabularResults.push({ key, count: null, exposure: null, absolute_exposure: null })\n                            }\n                        }\n                    }\n\n                    return tabularResults\n                },\n        ],\n        sortedWinProbabilities: [\n            (s) => [s.metricResults, s.conversionRateForVariant],\n            (\n                    metricResults: (\n                        | CachedExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    conversionRateForVariant\n                ) =>\n                (metricIndex: number = 0) => {\n                    const result = metricResults?.[metricIndex]\n\n                    if (!result || !result.probability) {\n                        return []\n                    }\n\n                    return Object.keys(result.probability)\n                        .map((key) => ({\n                            key,\n                            winProbability: result.probability[key],\n                            conversionRate: conversionRateForVariant(result, key),\n                        }))\n                        .sort((a, b) => b.winProbability - a.winProbability)\n                },\n        ],\n        funnelResultsPersonsTotal: [\n            (s) => [s.experiment, s.metricResults, s.getInsightType],\n            (\n                    experiment,\n                    metricResults: (\n                        | CachedExperimentQueryResponse\n                        | CachedExperimentFunnelsQueryResponse\n                        | CachedExperimentTrendsQueryResponse\n                        | null\n                    )[],\n                    getInsightType\n                ) =>\n                (metricIndex: number = 0): number => {\n                    const result = metricResults?.[metricIndex]\n\n                    if (getInsightType(experiment.metrics[metricIndex]) !== InsightType.FUNNELS || !result?.insight) {\n                        return 0\n                    }\n\n                    let sum = 0\n                    result.insight.forEach((variantResult) => {\n                        if (variantResult[0]?.count) {\n                            sum += variantResult[0].count\n                        }\n                    })\n                    return sum\n                },\n        ],\n        actualRunningTime: [\n            (s) => [s.experiment],\n            (experiment: Experiment): number => {\n                if (!experiment.start_date) {\n                    return 0\n                }\n\n                if (experiment.end_date) {\n                    return dayjs(experiment.end_date).diff(experiment.start_date, 'day')\n                }\n\n                return dayjs().diff(experiment.start_date, 'day')\n            },\n        ],\n        isSingleVariantShipped: [\n            (s) => [s.experiment],\n            (experiment: Experiment): boolean => {\n                const filters = experiment.feature_flag?.filters\n\n                return (\n                    !!filters &&\n                    Array.isArray(filters.groups?.[0]?.properties) &&\n                    filters.groups?.[0]?.properties?.length === 0 &&\n                    filters.groups?.[0]?.rollout_percentage === 100 &&\n                    (filters.multivariate?.variants?.some(({ rollout_percentage }) => rollout_percentage === 100) ||\n                        false)\n                )\n            },\n        ],\n        hasPrimaryMetricSet: [\n            (s) => [s.primaryMetricsLengthWithSharedMetrics],\n            (primaryMetricsLengthWithSharedMetrics): boolean => {\n                return primaryMetricsLengthWithSharedMetrics > 0\n            },\n        ],\n        firstPrimaryMetric: [\n            (s) => [s.experiment],\n            (experiment: Experiment): ExperimentMetric | ExperimentTrendsQuery | ExperimentFunnelsQuery | undefined => {\n                if (experiment.metrics.length) {\n                    return experiment.metrics[0]\n                }\n                const primaryMetric = experiment.saved_metrics.find((metric) => metric.metadata.type === 'primary')\n                if (primaryMetric) {\n                    return primaryMetric.query\n                }\n            },\n        ],\n        experimentStatsVersion: [\n            (s) => [s.experiment],\n            (experiment: Experiment): number => {\n                return experiment.stats_config?.version || 1\n            },\n        ],\n        primaryMetricsLengthWithSharedMetrics: [\n            (s) => [s.experiment],\n            (experiment: Experiment): number => {\n                return (\n                    experiment.metrics.length +\n                    experiment.saved_metrics.filter((savedMetric) => savedMetric.metadata.type === 'primary').length\n                )\n            },\n        ],\n        secondaryMetricsLengthWithSharedMetrics: [\n            (s) => [s.experiment],\n            (experiment: Experiment): number => {\n                return (\n                    experiment.metrics_secondary.length +\n                    experiment.saved_metrics.filter((savedMetric) => savedMetric.metadata.type === 'secondary').length\n                )\n            },\n        ],\n        compatibleSharedMetrics: [\n            (s) => [s.sharedMetrics, s.shouldUseExperimentMetrics],\n            (sharedMetrics: SharedMetric[], shouldUseExperimentMetrics: boolean): SharedMetric[] => {\n                if (!sharedMetrics) {\n                    return []\n                }\n                if (shouldUseExperimentMetrics) {\n                    return sharedMetrics.filter((metric) => metric.query.kind === NodeKind.ExperimentMetric)\n                }\n                return sharedMetrics.filter((metric) => metric.query.kind !== NodeKind.ExperimentMetric)\n            },\n        ],\n        shouldUseExperimentMetrics: [\n            (s) => [s.experiment, s.featureFlags],\n            (experiment: Experiment, featureFlags: Record<string, boolean>): boolean => {\n                const allMetrics = [...experiment.metrics, ...experiment.metrics_secondary, ...experiment.saved_metrics]\n                const hasExperimentMetrics = allMetrics.some((query) => query.kind === NodeKind.ExperimentMetric)\n                const hasLegacyMetrics = allMetrics.some(\n                    (query) =>\n                        query.kind === NodeKind.ExperimentTrendsQuery || query.kind === NodeKind.ExperimentFunnelsQuery\n                )\n                if (hasExperimentMetrics) {\n                    return true\n                }\n                if (hasLegacyMetrics) {\n                    return false\n                }\n                return featureFlags[FEATURE_FLAGS.EXPERIMENTS_NEW_QUERY_RUNNER]\n            },\n        ],\n        hasMinimumExposureForResults: [\n            (s) => [s.exposures, s.shouldUseExperimentMetrics, s.experiment],\n            (exposures, shouldUseExperimentMetrics, experiment): boolean => {\n                // Not relevant for old metrics\n                if (!shouldUseExperimentMetrics) {\n                    return true\n                }\n\n                if (!exposures || !exposures.total_exposures) {\n                    return false\n                }\n\n                const variantKeys = experiment.parameters.feature_flag_variants?.map((variant) => variant.key) || []\n                for (const variant of variantKeys) {\n                    const exposure = exposures.total_exposures[variant]\n                    if (!exposure || exposure < EXPERIMENT_MIN_EXPOSURES_FOR_RESULTS) {\n                        return false\n                    }\n                }\n\n                return true\n            },\n        ],\n        exposureCriteriaLabel: [\n            () => [],\n            (): string => {\n                // TODO: Implement exposure criteria label\n                return 'Default ($feature_flag_called)'\n            },\n        ],\n    }),\n    forms(({ actions }) => ({\n        experiment: {\n            options: { showErrorsOnTouch: true },\n            defaults: { ...NEW_EXPERIMENT } as Experiment,\n            errors: ({ name, parameters }) => ({\n                name: !name && 'Please enter a name',\n                // feature_flag_key is handled asynchronously\n                parameters: {\n                    feature_flag_variants: parameters.feature_flag_variants?.map(({ key }) => ({\n                        key: !key.match?.(/^([A-z]|[a-z]|[0-9]|-|_)+$/)\n                            ? 'Only letters, numbers, hyphens (-) & underscores (_) are allowed.'\n                            : undefined,\n                    })),\n                },\n            }),\n            submit: () => actions.createExperiment(true),\n        },\n    })),\n    urlToAction(({ actions, values }) => ({\n        '/experiments/:id': ({ id }, query, __, currentLocation, previousLocation) => {\n            const didPathChange = currentLocation.initial || currentLocation.pathname !== previousLocation?.pathname\n\n            actions.setEditExperiment(false)\n\n            if (id && didPathChange) {\n                const parsedId = id === 'new' ? 'new' : parseInt(id)\n                if (parsedId === 'new') {\n                    actions.resetExperiment({\n                        ...NEW_EXPERIMENT,\n                        metrics: query.metric ? [query.metric] : [],\n                        name: query.name ?? '',\n                    })\n                }\n                if (parsedId !== 'new' && parsedId === values.experimentId) {\n                    actions.loadExperiment()\n                    if (values.isExperimentRunning) {\n                        actions.loadExposures()\n                    }\n                }\n            }\n        },\n    })),\n])\n","import { useValues } from 'kea'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { apiHostOrigin } from 'lib/utils/apiHost'\nimport { teamLogic } from 'scenes/teamLogic'\n\nimport { GroupType } from '~/types'\n\nexport const UTM_TAGS = '?utm_medium=in-product&utm_campaign=feature-flag'\nexport interface FeatureFlagSnippet {\n    flagKey: string\n    multivariant?: boolean\n    groupType?: GroupType\n    localEvaluation?: boolean\n    payload?: boolean\n    remoteConfiguration?: boolean\n    encryptedPayload?: boolean\n    samplePropertyName?: string\n    instantlyAvailableProperties?: boolean\n}\n\nconst LOCAL_EVAL_REMINDER = `Remember to set a personal API key in the SDK to enable local evaluation.\n`\n\nconst REMOTE_CONFIG_REMINDER = `Must initialize SDK with a personal API key to enable remote configuration.`\nconst ENCRYPTED_PAYLOAD_REMINDER = `Encrypted payloads are automatically decrypted on the server before being sent to the client.`\n\nexport function NodeJSSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'await client.'\n    const flagFunction = payload ? 'getFeatureFlagPayload' : multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    if (remoteConfiguration) {\n        const reminder = REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n// ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.JavaScript} wrap>\n                    {`// ${reminder}\nconst remoteConfigPayload = await client.getRemoteConfigPayload('${flagKey}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n        // add group properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        groupProperties: { ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n        // add person properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        personProperties: {'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${\n        payload\n            ? `\n    undefined,`\n            : ''\n    }\n    {\n        groups: { '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n    }\n)`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${\n        payload\n            ? `\n    undefined,`\n            : ''\n    }\n    {${localEvalAddition}\n    }\n)`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n\n    const variableName = payload ? 'matchedFlagPayload' : multivariant ? 'enabledVariant' : 'isMyFlagEnabledForUser'\n\n    const conditional = multivariant ? `${variableName} === 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif (${conditional}) {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`\n\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`${\n                    localEvaluation ? '// ' + LOCAL_EVAL_REMINDER : ''\n                }const ${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function PHPSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHog::'\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n    // empty person properties\n    [],\n    // add group properties used in the flag to ensure the flag\n    // is evaluated locally, vs. going to our servers\n    [${groupType.group_type} =>  ['${propertyName}' => 'value', 'name' => 'xyz']]`\n            : `\n    // add person properties used in the flag to ensure the flag\n    // is evaluated locally, vs. going to our servers\n    ['${propertyName}' => 'value']`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',\n    // group types\n    ['${groupType.group_type}' => '<${groupType.name_singular || 'group'} ID>'],${localEvalAddition}\n)`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${localEvalAddition}\n)`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = multivariant ? '$enabledVariant' : '$isMyFlagEnabledForUser'\n\n    const conditional = multivariant ? `${variableName} === 'example-variant'` : `${variableName}`\n\n    return (\n        <>\n            <CodeSnippet language={Language.PHP} wrap>\n                {`${localEvaluation ? '// ' + LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}\n\nif (${conditional}) {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function GolangSnippet({\n    flagKey,\n    groupType,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    multivariant,\n    localEvaluation,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'client.'\n\n    const flagFunction = payload ? 'GetFeatureFlagPayload' : multivariant ? 'GetFeatureFlag' : 'IsFeatureEnabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    if (remoteConfiguration) {\n        const reminder = REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n// ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.Go} wrap>\n                    {`// ${reminder}\nremoteConfigPayload, err := ${clientSuffix}GetRemoteConfigPayload(\"${flagKey}\")`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n        // add group properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        groupProperties: map[string]Properties{\"${groupType.group_type}\": posthog.NewProperties().Set(\"${propertyName}\", \"value\").Set(\"name\", \"xyz\")}`\n            : `\n        // add person properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        PersonProperties: posthog.NewProperties().Set(\"${propertyName}\", \"value\")`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    FeatureFlagPayload{\n        Key:        \"${flagKey}\",\n        DistinctId: \"distinct-id\",\n        Groups:     Groups{'${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>'},${localEvalAddition}\n    }\n)`\n        : `${clientSuffix}${flagFunction}(\n    FeatureFlagPayload{\n        Key:        '${flagKey}',\n        DistinctId: \"distinct-id\",${localEvalAddition}\n    })`\n    const variableName = multivariant ? 'enabledVariant, err' : 'isMyFlagEnabledForUser, err'\n\n    const conditional = multivariant ? `enabledVariant == 'example-variant'` : `isMyFlagEnabledForUser`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Go} wrap>\n                {`${localEvaluation ? '// ' + LOCAL_EVAL_REMINDER : ''}${variableName} := ${flagSnippet}\n\nif ${conditional} {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function RubySnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n    const flagFunction = payload ? 'get_feature_flag_payload' : multivariant ? 'get_feature_flag' : 'is_feature_enabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    if (remoteConfiguration) {\n        const reminder = `# ` + REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n# ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.Ruby} wrap>\n                    {`${reminder}\nremote_config_payload = posthog.get_remote_config_payload('${flagKey}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n    # add group properties used in the flag to ensure the flag\n    # is evaluated locally, vs. going to our servers\n    group_properties: { ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n    # add person properties used in the flag to ensure the flag\n    # is evaluated locally, vs. going to our servers\n    person_properties: {'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',\n    groups: { '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n)`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${localEvalAddition}\n)`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = payload ? 'matched_flag_payload' : multivariant ? 'enabled_variant' : 'is_my_flag_enabled'\n\n    const conditional = multivariant ? `${variableName} == 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif ${conditional}\n    # Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\nend`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Ruby} wrap>\n                {`${localEvaluation ? '# ' + LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function PythonSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n    const flagFunction = payload ? 'get_feature_flag_payload' : multivariant ? 'get_feature_flag' : 'feature_enabled'\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    if (remoteConfiguration) {\n        const reminder = `# ` + REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n# ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.Python} wrap>\n                    {`${reminder}\nremote_config_payload = posthog.get_remote_config_payload('${flagKey}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalAddition = localEvaluation\n        ? groupType\n            ? `\n    # add group properties used in the flag to ensure the flag\n    # is evaluated locally, vs. going to our servers\n    group_properties={ ${groupType.group_type}: {'${propertyName}': 'value', 'name': 'xyz'}}`\n            : `\n    # add person properties used in the flag to ensure the flag\n    # is evaluated locally, vs. going to our servers\n    person_properties={'${propertyName}': 'value'}`\n        : ''\n\n    const flagSnippet = groupType\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',\n    groups={ '${groupType.group_type}': '<${groupType.name_singular || 'group'} ID>' },${localEvalAddition}\n)`\n        : localEvalAddition\n        ? `${clientSuffix}${flagFunction}(\n    '${flagKey}',\n    'user distinct id',${localEvalAddition}\n)`\n        : `${clientSuffix}${flagFunction}('${flagKey}', 'user distinct id')`\n    const variableName = payload ? 'matched_flag_payload' : multivariant ? 'enabled_variant' : 'is_my_flag_enabled'\n\n    const conditional = multivariant ? `${variableName} == 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? ''\n        : `\n\nif ${conditional}:\n    # Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n`\n\n    return (\n        <>\n            <CodeSnippet language={Language.Python} wrap>\n                {`${localEvaluation ? '# ' + LOCAL_EVAL_REMINDER : ''}${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function CSharpSnippet({\n    flagKey,\n    groupType,\n    multivariant,\n    localEvaluation,\n    payload,\n    remoteConfiguration,\n    encryptedPayload,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n    const flagFunction = payload\n        ? 'GetFeatureFlagAsync'\n        : multivariant\n        ? 'GetFeatureFlagAsync'\n        : 'IsFeatureEnabledAsync'\n\n    const propertyName = samplePropertyName || 'isAuthorized'\n\n    if (remoteConfiguration) {\n        const reminder = `// ` + REMOTE_CONFIG_REMINDER + (encryptedPayload ? `\\n// ${ENCRYPTED_PAYLOAD_REMINDER}` : '')\n\n        return (\n            <>\n                <CodeSnippet language={Language.CSharp} wrap>\n                    {`${reminder}\nvar remoteConfigPayload = await posthog.GetRemoteConfigPayloadAsync(\"${flagKey}\");`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const localEvalCommentAddition = localEvaluation\n        ? groupType\n            ? `// add group properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        `\n            : `// add person properties used in the flag to ensure the flag\n        // is evaluated locally, vs. going to our servers\n        `\n        : ''\n\n    const localEvalCodeAddition = localEvaluation\n        ? groupType\n            ? `{ [\"${propertyName}\"] = \"value\", [\"name\"] = \"xyz\" }`\n            : `\n    personProperties: new() { [\"${propertyName}\"] = \"value\" }`\n        : ''\n\n    const flagSnippet = groupType\n        ? `await ${clientSuffix}${flagFunction}(\n    \"${flagKey}\",\n    \"user distinct id\",\n    new FeatureFlagOptions\n    {\n        ${localEvalCommentAddition}Groups = [new Group(\"${groupType.group_type}\", \"<${\n              groupType.name_singular || 'group'\n          } ID>\")${localEvalCodeAddition}]\n    }\n);`\n        : localEvalCodeAddition\n        ? `await ${clientSuffix}${flagFunction}(\n    \"${flagKey}\",\n    \"user distinct id\",${localEvalCodeAddition}\n);`\n        : `await ${clientSuffix}${flagFunction}(\"${flagKey}\", \"user distinct id\");`\n    const variableName = payload ? 'matchedFlagPayload' : multivariant ? 'enabledVariant' : 'isMyFlagEnabled'\n\n    const conditional = multivariant ? `${variableName} == 'example-variant'` : `${variableName}`\n\n    const followUpCode = payload\n        ? `\nif (matchedFlagPayload is { Payload: {} payload })\n{\n    // The payload is a JsonDocument.\n    Console.WriteLine(payload.RootElement.GetRawText());\n}`\n        : `\n\nif (${conditional}) {\n    // Do something differently for this ${groupType ? groupType.name_singular || 'group' : 'user'}\n}\n`\n\n    return (\n        <>\n            <CodeSnippet language={Language.CSharp} wrap>\n                {`${\n                    localEvaluation ? '// ' + LOCAL_EVAL_REMINDER : ''\n                }var ${variableName} = ${flagSnippet}${followUpCode}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function AndroidSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHog.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Kotlin} wrap>\n                {`${clientSuffix}getFeatureFlagPayload(\"${flagKey}\")`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == \"example-variant\"` : ''\n    return (\n        <CodeSnippet language={Language.Kotlin} wrap>\n            {`if (${clientSuffix}${flagFunction}(\"${flagKey}\")${variantSuffix}) {\n    // do something\n}\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function FlutterSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'await Posthog().'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Dart} wrap>\n                {`${clientSuffix}getFeatureFlagPayload('${flagKey}');`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n\n    return (\n        <CodeSnippet language={Language.Dart} wrap>\n            {`if (${clientSuffix}${flagFunction}('${flagKey}')${variantSuffix}) {\n  // do something\n}\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function iOSSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'PostHogSDK.shared.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.Swift} wrap>\n                {`${clientSuffix}getFeatureFlagPayload(\"${flagKey}\")`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? `as? String == \"example-variant\"` : ''\n    return (\n        <CodeSnippet language={Language.Swift} wrap>\n            {`if ${clientSuffix}${flagFunction}(\"${flagKey}\")${variantSuffix} {\n    // do something\n}`}\n        </CodeSnippet>\n    )\n}\n\nexport function ReactNativeSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const clientSuffix = 'posthog.'\n\n    if (payload) {\n        return (\n            <CodeSnippet language={Language.JSX} wrap>\n                {`${clientSuffix}getFeatureFlagPayload('${flagKey}')`}\n            </CodeSnippet>\n        )\n    }\n\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n    return (\n        <CodeSnippet language={Language.JSX} wrap>\n            {`// With a hook\nimport { useFeatureFlag } from 'posthog-react-native'\n\nconst MyComponent = () => {\n    const showFlaggedFeature = useFeatureFlag('${flagKey}')\n\n    if (showFlaggedFeature === undefined) {\n        // the response is undefined if the flags are being loaded\n        return null\n    }\n\n    return showFlaggedFeature ${variantSuffix} ? <Text>Testing feature </Text> : <Text>Not Testing feature </Text>\n}\n\n// Or calling on the method directly\n${clientSuffix}${flagFunction}('${flagKey}')\n            `}\n        </CodeSnippet>\n    )\n}\n\nexport function ReactSnippet({ flagKey, multivariant, payload }: FeatureFlagSnippet): JSX.Element {\n    const flagFunction = payload\n        ? 'useFeatureFlagPayload'\n        : multivariant\n        ? 'useFeatureFlagVariantKey'\n        : 'useFeatureFlagEnabled'\n\n    const variable = payload ? 'payload' : multivariant ? 'variant' : 'flagEnabled'\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n\n    return (\n        <CodeSnippet language={Language.JSX} wrap>\n            {`\nimport { ${flagFunction} } from 'posthog-js/react'\n\nfunction App() {\n    const ${variable} = ${flagFunction}('${flagKey}')\n\n    if (${variable}${variantSuffix}) {\n        // do something\n    }\n}`}\n        </CodeSnippet>\n    )\n}\n\nexport function APISnippet({ flagKey, groupType, remoteConfiguration }: FeatureFlagSnippet): JSX.Element {\n    const { currentTeam } = useValues(teamLogic)\n\n    const groupAddition = groupType\n        ? `,\n    \"groups\": { \"${groupType.group_type}\": \"<${groupType.name_singular || 'group'} ID>\" },`\n        : ''\n\n    if (remoteConfiguration) {\n        return (\n            <>\n                <CodeSnippet language={Language.Bash} wrap>\n                    {`curl ${apiHostOrigin()}/api/projects/${currentTeam?.id || ':projectId'}/feature_flags/${\n                        flagKey || ':featureFlagKey'\n                    }/remote_config/ \\\\\n-H 'Content-Type: application/json' \\\\\n-H 'Authorization: Bearer [personal_api_key]'`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    return (\n        <>\n            <CodeSnippet language={Language.Bash} wrap>\n                {`curl ${apiHostOrigin()}/decide?v=3/ \\\\\n-X POST -H 'Content-Type: application/json' \\\\\n-d '{\n    \"api_key\": \"${currentTeam ? currentTeam.api_token : '[project_api_key]'}\",\n    \"distinct_id\": \"[user distinct id]\"${groupAddition}\n}'\n                `}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function JSSnippet({\n    flagKey,\n    multivariant,\n    payload,\n    groupType,\n    instantlyAvailableProperties,\n    samplePropertyName,\n}: FeatureFlagSnippet): JSX.Element {\n    if (payload) {\n        return (\n            <>\n                <CodeSnippet language={Language.JavaScript} wrap>\n                    {`posthog.getFeatureFlagPayload('${flagKey ?? ''}')`}\n                </CodeSnippet>\n            </>\n        )\n    }\n\n    const propertyName = samplePropertyName || 'is_authorized'\n\n    const propertyOverrideSnippet = `// Your flag depends on properties that are not instantly available. If you want\n// to make them available without waiting for server delays, send these properties for flag evaluation, like so:\n// Make sure to call this before evaluating flags. More info: https://posthog.com/docs/libraries/js#overriding-server-properties \nposthog.${\n        groupType\n            ? `setGroupPropertiesForFlags({ '${groupType.group_type}': {'${propertyName}': 'value'}})`\n            : `setPersonPropertiesForFlags({'${propertyName}': 'value'})`\n    }\n\n`\n\n    const clientSuffix = 'posthog.'\n    const flagFunction = multivariant ? 'getFeatureFlag' : 'isFeatureEnabled'\n\n    const variantSuffix = multivariant ? ` == 'example-variant'` : ''\n    return (\n        <>\n            <CodeSnippet language={Language.JavaScript} wrap>\n                {`${instantlyAvailableProperties ? '' : propertyOverrideSnippet}// Ensure flags are loaded before usage.\n// You'll only need to call this on the code for when the first time a user visits.\n${clientSuffix}onFeatureFlags(function() {\n    // feature flags should be available at this point\n    if (${clientSuffix}${flagFunction}('${flagKey ?? ''}') ${variantSuffix}) {\n        // do something\n    }\n})\n\n// Otherwise, you can just do:\nif (${clientSuffix}${flagFunction}('${flagKey ?? ''}') ${variantSuffix}) {\n    // do something\n}`}\n            </CodeSnippet>\n        </>\n    )\n}\n\nexport function JSBootstrappingSnippet(): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`// Initialise the posthog library with a distinct ID and feature flags for immediate loading\n// This avoids the delay between the library loading and feature flags becoming available to use.\n\nposthog.init('{project_api_key}', {\n    api_host: '${apiHostOrigin()}'\n    bootstrap:\n    {\n        distinctID: 'your-anonymous-id',\n        featureFlags: {\n    // input the flag values here from 'posthog.getAllFlags(distinct_id)' which you can find in the server-side libraries.\n        // example:\n            // 'flag-1': true,\n            // 'variant-flag': 'control',\n            // 'other-flag': false\n        },\n    }\n})\n            `}\n        </CodeSnippet>\n    )\n}\n","import { mergeAttributes, Node, NodeViewProps } from '@tiptap/core'\nimport { NodeViewWrapper, ReactNodeViewRenderer } from '@tiptap/react'\nimport { NotebookNodeType, NotebookTarget } from '~/types'\nimport { dayjs } from 'lib/dayjs'\nimport { JSONContent } from '../Notebook/utils'\nimport clsx from 'clsx'\nimport { urls } from 'scenes/urls'\nimport { LemonButton } from '@posthog/lemon-ui'\nimport { notebookLogic } from '../Notebook/notebookLogic'\nimport { useValues } from 'kea'\nimport { useMemo } from 'react'\nimport { openNotebook } from '~/models/notebooksModel'\n\nexport interface NotebookNodeReplayTimestampAttrs {\n    playbackTime?: number\n    sessionRecordingId: string\n    sourceNodeId?: string\n}\n\nconst Component = (props: NodeViewProps): JSX.Element => {\n    const { shortId, findNodeLogic, findNodeLogicById } = useValues(notebookLogic)\n    const { sessionRecordingId, playbackTime = 0, sourceNodeId } = props.node.attrs as NotebookNodeReplayTimestampAttrs\n\n    const relatedNodeInNotebook = useMemo(() => {\n        const logicById = sourceNodeId ? findNodeLogicById(sourceNodeId) : null\n\n        return logicById ?? findNodeLogic(NotebookNodeType.Recording, { id: sessionRecordingId })\n    }, [findNodeLogic])\n\n    const handlePlayInNotebook = (): void => {\n        // TODO: Figure out how to send this action info to the playlist OR the replay node...\n\n        relatedNodeInNotebook?.values.sendMessage('play-replay', {\n            sessionRecordingId,\n            time: playbackTime ?? 0,\n        })\n    }\n\n    return (\n        <NodeViewWrapper\n            as=\"span\"\n            className={clsx('NotebookRecordingTimestamp', props.selected && 'NotebookRecordingTimestamp--selected')}\n        >\n            <LemonButton\n                size=\"small\"\n                noPadding\n                active\n                onClick={\n                    relatedNodeInNotebook ? handlePlayInNotebook : () => openNotebook(shortId, NotebookTarget.Popover)\n                }\n                to={\n                    !relatedNodeInNotebook\n                        ? urls.replaySingle(sessionRecordingId) + `?t=${playbackTime / 1000}`\n                        : undefined\n                }\n            >\n                <span className=\"p-1\">{formatTimestamp(playbackTime)}</span>\n            </LemonButton>\n        </NodeViewWrapper>\n    )\n}\n\nexport const NotebookNodeReplayTimestamp = Node.create({\n    name: NotebookNodeType.ReplayTimestamp,\n    inline: true,\n    group: 'inline',\n    atom: true,\n\n    serializedText: (attrs: NotebookNodeReplayTimestampAttrs): string => {\n        // timestamp is not a block so `getText` does not add a separator.\n        // we need to add it manually\n        return `${attrs.playbackTime ? formatTimestamp(attrs.playbackTime) : '00:00'}:\\n`\n    },\n\n    addAttributes() {\n        return {\n            playbackTime: { default: null, keepOnSplit: false },\n            sessionRecordingId: { default: null, keepOnSplit: true, isRequired: true },\n            sourceNodeId: { default: null, keepOnSplit: true },\n        }\n    },\n\n    parseHTML() {\n        return [{ tag: NotebookNodeType.ReplayTimestamp }]\n    },\n\n    renderHTML({ HTMLAttributes }) {\n        return [NotebookNodeType.ReplayTimestamp, mergeAttributes(HTMLAttributes)]\n    },\n\n    addNodeView() {\n        return ReactNodeViewRenderer(Component)\n    },\n})\n\nexport function formatTimestamp(time: number): string {\n    return dayjs.duration(time, 'milliseconds').format('HH:mm:ss').replace(/^00:/, '').trim()\n}\n\nexport function buildTimestampCommentContent(attrs: NotebookNodeReplayTimestampAttrs): JSONContent {\n    return {\n        type: 'paragraph',\n        content: [\n            {\n                type: NotebookNodeType.ReplayTimestamp,\n                attrs,\n            },\n            { type: 'text', text: ' ' },\n        ],\n    }\n}\n","import {\n    IconCursor,\n    IconFunnels,\n    IconHogQL,\n    IconLifecycle,\n    IconPeople,\n    IconRetention,\n    IconRewindPlay,\n    IconStickiness,\n    IconTrends,\n    IconUpload,\n    IconUserPaths,\n} from '@posthog/icons'\nimport { IconCode } from '@posthog/icons'\nimport { LemonButton, LemonDivider, lemonToast } from '@posthog/lemon-ui'\nimport { Extension } from '@tiptap/core'\nimport { ReactRenderer } from '@tiptap/react'\nimport Suggestion from '@tiptap/suggestion'\nimport Fuse from 'fuse.js'\nimport { useValues } from 'kea'\nimport { IconBold, IconItalic } from 'lib/lemon-ui/icons'\nimport { Popover } from 'lib/lemon-ui/Popover'\nimport { selectFiles } from 'lib/utils/file-utils'\nimport { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useState } from 'react'\n\nimport { KeyboardShortcut } from '~/layout/navigation-3000/components/KeyboardShortcut'\nimport { defaultDataTableColumns } from '~/queries/nodes/DataTable/utils'\nimport { NodeKind } from '~/queries/schema/schema-general'\nimport { BaseMathType, ChartDisplayType, FunnelVizType, NotebookNodeType, PathType, RetentionPeriod } from '~/types'\n\nimport { buildNodeEmbed } from '../Nodes/NotebookNodeEmbed'\nimport { buildInsightVizQueryContent, buildNodeQueryContent } from '../Nodes/NotebookNodeQuery'\nimport NotebookIconHeading from './NotebookIconHeading'\nimport { notebookLogic } from './notebookLogic'\nimport { EditorCommands, EditorRange } from './utils'\n\ntype SlashCommandConditionalProps =\n    | {\n          mode: 'add'\n          getPos: () => number\n          range?: never\n      }\n    | {\n          mode: 'slash'\n          getPos?: never\n          range: EditorRange\n      }\n\ntype SlashCommandsProps = SlashCommandConditionalProps & {\n    query?: string\n    decorationNode?: any\n    onClose?: () => void\n}\n\ntype SlashCommandsPopoverProps = SlashCommandsProps & {\n    visible: boolean\n    children?: JSX.Element\n}\n\ntype SlashCommandsRef = {\n    onKeyDown: (event: KeyboardEvent) => boolean\n}\n\ntype SlashCommandsItem = {\n    title: string\n    search?: string\n    icon?: JSX.Element\n    command: (chain: EditorCommands, pos: number | EditorRange) => EditorCommands | Promise<EditorCommands>\n}\n\nconst TEXT_CONTROLS: SlashCommandsItem[] = [\n    {\n        title: 'h1',\n        icon: <NotebookIconHeading level={1} />,\n        command: (chain) => chain.toggleHeading({ level: 1 }),\n    },\n    {\n        title: 'h2',\n        icon: <NotebookIconHeading level={2} />,\n        command: (chain) => chain.toggleHeading({ level: 2 }),\n    },\n    {\n        title: 'h3',\n        icon: <NotebookIconHeading level={3} />,\n        command: (chain) => chain.toggleHeading({ level: 3 }),\n    },\n    {\n        title: 'bold',\n        icon: <IconBold />,\n        command: (chain) => chain.toggleBold(),\n    },\n    {\n        title: 'italic',\n        icon: <IconItalic />,\n        command: (chain) => chain.toggleItalic(),\n    },\n]\n\nconst SLASH_COMMANDS: SlashCommandsItem[] = [\n    {\n        title: 'Trend',\n        search: 'graph trend insight',\n        icon: <IconTrends color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.TrendsQuery,\n                    filterTestAccounts: false,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            event: '$pageview',\n                            name: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                    interval: 'day',\n                    trendsFilter: {\n                        display: ChartDisplayType.ActionsLineGraph,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Funnel',\n        search: 'funnel insight',\n        icon: <IconFunnels color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.FunnelsQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                        },\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                        },\n                    ],\n                    funnelsFilter: {\n                        funnelVizType: FunnelVizType.Steps,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Retention',\n        search: 'retention insight',\n        icon: <IconRetention color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.RetentionQuery,\n                    retentionFilter: {\n                        period: RetentionPeriod.Day,\n                        totalIntervals: 11,\n                        targetEntity: {\n                            id: '$pageview',\n                            name: '$pageview',\n                            type: 'events',\n                        },\n                        returningEntity: {\n                            id: '$pageview',\n                            name: '$pageview',\n                            type: 'events',\n                        },\n                        retentionType: 'retention_first_time',\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Paths',\n        search: 'user paths insight',\n        icon: <IconUserPaths color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.PathsQuery,\n                    pathsFilter: {\n                        includeEventTypes: [PathType.PageView],\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Stickiness',\n        search: 'stickiness insight',\n        icon: <IconStickiness color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.StickinessQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                    stickinessFilter: {},\n                })\n            ),\n    },\n    {\n        title: 'Lifecycle',\n        search: 'lifecycle insight',\n        icon: <IconLifecycle color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildInsightVizQueryContent({\n                    kind: NodeKind.LifecycleQuery,\n                    series: [\n                        {\n                            kind: NodeKind.EventsNode,\n                            name: '$pageview',\n                            event: '$pageview',\n                            math: BaseMathType.TotalCount,\n                        },\n                    ],\n                })\n            ),\n    },\n    {\n        title: 'SQL',\n        search: 'sql',\n        icon: <IconHogQL color=\"currentColor\" />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.HogQLQuery,\n                        query: `select event,\n        person.properties.email,\n        properties.$browser,\n        count()\n    from events\n    where {filters} -- replaced with global date and property filters\n    and person.properties.email is not null\ngroup by event,\n        properties.$browser,\n        person.properties.email\norder by count() desc\n    limit 100`,\n                        filters: {\n                            dateRange: {\n                                date_from: '-24h',\n                            },\n                        },\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Events',\n        search: 'data explore',\n        icon: <IconCursor />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.EventsQuery,\n                        select: defaultDataTableColumns(NodeKind.EventsQuery),\n                        properties: [],\n                        after: '-24h',\n                        limit: 100,\n                    },\n                })\n            ),\n    },\n    {\n        title: 'People',\n        search: 'persons users',\n        icon: <IconPeople />,\n        command: (chain, pos) =>\n            chain.insertContentAt(\n                pos,\n                buildNodeQueryContent({\n                    kind: NodeKind.DataTableNode,\n                    columns: defaultDataTableColumns(NodeKind.ActorsQuery),\n                    source: {\n                        kind: NodeKind.ActorsQuery,\n                        properties: [],\n                    },\n                })\n            ),\n    },\n    {\n        title: 'Session recordings',\n        search: 'video replay',\n        icon: <IconRewindPlay />,\n        command: (chain, pos) => chain.insertContentAt(pos, { type: NotebookNodeType.RecordingPlaylist, attrs: {} }),\n    },\n    {\n        title: 'Image',\n        search: 'picture gif',\n        icon: <IconUpload />,\n        command: async (chain, pos) => {\n            // Trigger upload followed by insert\n            try {\n                const files = await selectFiles({ contentType: 'image/*', multiple: false })\n\n                if (files.length) {\n                    return chain.insertContentAt(pos, { type: NotebookNodeType.Image, attrs: { file: files[0] } })\n                }\n            } catch (e) {\n                lemonToast.error('Something went wrong when trying to select a file.')\n            }\n\n            return chain\n        },\n    },\n    {\n        title: 'Embedded iframe',\n        search: 'iframe embed',\n        icon: <IconCode />,\n        command: async (chain, pos) => {\n            return chain.insertContentAt(pos, buildNodeEmbed())\n        },\n    },\n]\n\nexport const SlashCommands = forwardRef<SlashCommandsRef, SlashCommandsProps>(function SlashCommands(\n    { mode, range, getPos, onClose, query }: SlashCommandsProps,\n    ref\n): JSX.Element | null {\n    const { editor } = useValues(notebookLogic)\n    // We start with 1 because the first item is the text controls\n    const [selectedIndex, setSelectedIndex] = useState(0)\n    const [selectedHorizontalIndex, setSelectedHorizontalIndex] = useState(0)\n\n    const allCommmands = [...TEXT_CONTROLS, ...SLASH_COMMANDS]\n\n    const fuse = useMemo(() => {\n        return new Fuse(allCommmands, {\n            keys: ['title', 'search'],\n            threshold: 0.3,\n        })\n    }, [allCommmands])\n\n    const filteredCommands = useMemo(() => {\n        if (!query) {\n            return allCommmands\n        }\n        return fuse.search(query).map((result) => result.item)\n    }, [query, fuse])\n\n    const filteredSlashCommands = useMemo(\n        () => filteredCommands.filter((item) => SLASH_COMMANDS.includes(item)),\n        [filteredCommands]\n    )\n\n    useEffect(() => {\n        setSelectedIndex(0)\n        setSelectedHorizontalIndex(0)\n    }, [query])\n\n    const execute = async (item: SlashCommandsItem): Promise<void> => {\n        if (editor) {\n            const selectedNode = editor.getSelectedNode()\n            const isTextNode = selectedNode === null || selectedNode.isText\n            const isTextCommand = TEXT_CONTROLS.map((c) => c.title).includes(item.title)\n\n            const position = mode === 'slash' ? range.from : getPos()\n            let chain = mode === 'slash' ? editor.deleteRange(range) : editor.chain()\n\n            if (!isTextNode && isTextCommand) {\n                chain = chain.insertContentAt(position, { type: 'paragraph' })\n            }\n\n            const partialCommand = await item.command(chain, position)\n            partialCommand.run()\n\n            onClose?.()\n        }\n    }\n\n    const onPressEnter = async (): Promise<void> => {\n        const command =\n            selectedIndex === -1 ? TEXT_CONTROLS[selectedHorizontalIndex] : filteredSlashCommands[selectedIndex]\n\n        await execute(command)\n    }\n    const onPressUp = (): void => {\n        setSelectedIndex(Math.max(selectedIndex - 1, -1))\n    }\n    const onPressDown = (): void => {\n        setSelectedIndex(Math.min(selectedIndex + 1, SLASH_COMMANDS.length - 1))\n    }\n\n    const onPressLeft = (): void => {\n        setSelectedHorizontalIndex(Math.max(selectedHorizontalIndex - 1, 0))\n    }\n    const onPressRight = (): void => {\n        setSelectedHorizontalIndex(Math.min(selectedHorizontalIndex + 1, TEXT_CONTROLS.length - 1))\n    }\n\n    const onKeyDown = useCallback(\n        (event: KeyboardEvent): boolean => {\n            const keyMappings = {\n                ArrowUp: onPressUp,\n                ArrowDown: onPressDown,\n                ArrowLeft: onPressLeft,\n                ArrowRight: onPressRight,\n                Enter: onPressEnter,\n            }\n\n            if (keyMappings[event.key]) {\n                keyMappings[event.key]()\n                return true\n            }\n\n            return false\n        },\n        [selectedIndex, selectedHorizontalIndex, filteredCommands]\n    )\n\n    // Expose the keydown handler to the tiptap extension\n    useImperativeHandle(ref, () => ({ onKeyDown }), [onKeyDown])\n\n    useEffect(() => {\n        if (mode !== 'add') {\n            return\n        }\n\n        // If not opened from a slash command, we want to add our own keyboard listeners\n        const keyDownListener = (event: KeyboardEvent): void => {\n            const preventDefault = onKeyDown(event)\n            if (preventDefault) {\n                event.preventDefault()\n            }\n        }\n\n        window.addEventListener('keydown', keyDownListener, true)\n\n        return () => window.removeEventListener('keydown', keyDownListener, true)\n    }, [onKeyDown, mode])\n\n    if (!editor) {\n        return null\n    }\n\n    return (\n        <div className=\"deprecated-space-y-px\">\n            <div className=\"flex items-center gap-1\">\n                {TEXT_CONTROLS.map((item, index) => (\n                    <LemonButton\n                        key={item.title}\n                        size=\"small\"\n                        active={selectedIndex === -1 && selectedHorizontalIndex === index}\n                        onClick={() => void execute(item)}\n                        icon={item.icon}\n                    />\n                ))}\n            </div>\n\n            <LemonDivider />\n\n            {filteredSlashCommands.map((item, index) => (\n                <LemonButton\n                    key={item.title}\n                    fullWidth\n                    icon={item.icon}\n                    active={index === selectedIndex}\n                    onClick={() => void execute(item)}\n                >\n                    {item.title}\n                </LemonButton>\n            ))}\n\n            {filteredSlashCommands.length === 0 && (\n                <div className=\"text-secondary p-1\">\n                    Nothing matching <code>/{query}</code>\n                </div>\n            )}\n\n            {mode === 'add' && (\n                <>\n                    <LemonDivider className=\"my-0\" />\n                    <div className=\"text-xs text-secondary p-1\">\n                        You can trigger this menu by typing <KeyboardShortcut forwardslash />\n                    </div>\n                </>\n            )}\n        </div>\n    )\n})\n\nexport const SlashCommandsPopover = forwardRef<SlashCommandsRef, SlashCommandsPopoverProps>(\n    function SlashCommandsPopover(\n        { visible = true, decorationNode, children, onClose, ...props }: SlashCommandsPopoverProps,\n        ref\n    ): JSX.Element | null {\n        return (\n            <Popover\n                placement=\"right-start\"\n                fallbackPlacements={['left-start', 'right-end']}\n                overlay={<SlashCommands ref={ref} onClose={onClose} {...props} />}\n                referenceElement={decorationNode}\n                visible={visible}\n                onClickOutside={onClose}\n            >\n                {children}\n            </Popover>\n        )\n    }\n)\n\nexport const SlashCommandsExtension = Extension.create({\n    name: 'slash-commands',\n\n    addProseMirrorPlugins() {\n        return [\n            Suggestion({\n                editor: this.editor,\n                char: '/',\n                startOfLine: true,\n                render: () => {\n                    let renderer: ReactRenderer<SlashCommandsRef>\n\n                    return {\n                        onStart: (props) => {\n                            renderer = new ReactRenderer(SlashCommandsPopover, {\n                                props: { ...props, mode: 'slash' },\n                                editor: props.editor,\n                            })\n                        },\n\n                        onUpdate(props) {\n                            renderer.updateProps(props)\n\n                            if (!props.clientRect) {\n                                return\n                            }\n                        },\n\n                        onKeyDown(props) {\n                            if (props.event.key === 'Escape') {\n                                renderer.destroy()\n                                return true\n                            }\n                            return renderer.ref?.onKeyDown(props.event) ?? false\n                        },\n\n                        onExit() {\n                            renderer.destroy()\n                        },\n                    }\n                },\n            }),\n        ]\n    },\n})\n","import {\n    addedNodeMutation,\n    customEvent,\n    EventType,\n    fullSnapshotEvent,\n    incrementalSnapshotEvent,\n    IncrementalSource,\n    metaEvent,\n    mutationData,\n    removedNodeMutation,\n} from '@posthog/rrweb-types'\nimport { captureMessage } from '@sentry/react'\nimport { isObject } from 'lib/utils'\nimport { PLACEHOLDER_SVG_DATA_IMAGE_URL } from 'scenes/session-recordings/player/rrweb'\n\nimport {\n    attributes,\n    documentNode,\n    elementNode,\n    fullSnapshotEvent as MobileFullSnapshotEvent,\n    keyboardEvent,\n    metaEvent as MobileMetaEvent,\n    MobileIncrementalSnapshotEvent,\n    MobileNodeMutation,\n    MobileNodeType,\n    NodeType,\n    serializedNodeWithId,\n    textNode,\n    wireframe,\n    wireframeButton,\n    wireframeCheckBox,\n    wireframeDiv,\n    wireframeImage,\n    wireframeInputComponent,\n    wireframeNavigationBar,\n    wireframePlaceholder,\n    wireframeProgress,\n    wireframeRadio,\n    wireframeRadioGroup,\n    wireframeRectangle,\n    wireframeScreenshot,\n    wireframeSelect,\n    wireframeStatusBar,\n    wireframeText,\n    wireframeToggle,\n} from '../mobile.types'\nimport { makeNavigationBar, makeOpenKeyboardPlaceholder, makeStatusBar } from './screen-chrome'\nimport { ConversionContext, ConversionResult } from './types'\nimport {\n    asStyleString,\n    makeBodyStyles,\n    makeColorStyles,\n    makeDeterminateProgressStyles,\n    makeHTMLStyles,\n    makeIndeterminateProgressStyles,\n    makeMinimalStyles,\n    makePositionStyles,\n    makeStylesString,\n} from './wireframeStyle'\n\nexport const BACKGROUND = '#f3f4ef'\nconst FOREGROUND = '#35373e'\n\n/**\n * generates a sequence of ids\n * from 100 to 9,999,999\n * the transformer reserves ids in the range 0 to 9,999,999\n * we reserve a range of ids because we need nodes to have stable ids across snapshots\n * in order for incremental snapshots to work\n * some mobile elements have to be wrapped in other elements in order to be styled correctly\n * which means the web version of a mobile replay will use ids that don't exist in the mobile replay,\n * and we need to ensure they don't clash\n * -----\n * id is typed as a number in rrweb\n * and there's a few places in their code where rrweb uses a check for `id === -1` to bail out of processing\n * so, it's safest to assume that id is expected to be a positive integer\n */\nfunction* ids(): Generator<number> {\n    let i = 100\n    while (i < 9999999) {\n        yield i++\n    }\n}\n\nlet globalIdSequence = ids()\n\n// there are some fixed ids that we need to use for fixed elements or artificial mutations\nconst DOCUMENT_ID = 1\nconst HTML_DOC_TYPE_ID = 2\nconst HTML_ELEMENT_ID = 3\nconst HEAD_ID = 4\nconst BODY_ID = 5\n// the nav bar should always be the last item in the body so that it is at the top of the stack\nconst NAVIGATION_BAR_PARENT_ID = 7\nexport const NAVIGATION_BAR_ID = 8\n// the keyboard so that it is still before the nav bar\nconst KEYBOARD_PARENT_ID = 9\nexport const KEYBOARD_ID = 10\nexport const STATUS_BAR_PARENT_ID = 11\nexport const STATUS_BAR_ID = 12\n\nfunction isKeyboardEvent(x: unknown): x is keyboardEvent {\n    return isObject(x) && 'data' in x && isObject(x.data) && 'tag' in x.data && x.data.tag === 'keyboard'\n}\n\nexport function _isPositiveInteger(id: unknown): id is number {\n    return typeof id === 'number' && id > 0 && id % 1 === 0\n}\n\nfunction _isNullish(x: unknown): x is null | undefined {\n    return x === null || x === undefined\n}\n\nfunction isRemovedNodeMutation(x: addedNodeMutation | removedNodeMutation): x is removedNodeMutation {\n    return isObject(x) && 'id' in x\n}\n\nexport const makeCustomEvent = (\n    mobileCustomEvent: (customEvent | keyboardEvent) & {\n        timestamp: number\n        delay?: number\n    }\n): (customEvent | incrementalSnapshotEvent) & {\n    timestamp: number\n    delay?: number\n} => {\n    if (isKeyboardEvent(mobileCustomEvent)) {\n        // keyboard events are handled as incremental snapshots to add or remove a keyboard from the DOM\n        // TODO eventually we can pass something to makeIncrementalEvent here\n        const adds: addedNodeMutation[] = []\n        const removes = []\n        if (mobileCustomEvent.data.payload.open) {\n            const keyboardPlaceHolder = makeOpenKeyboardPlaceholder(mobileCustomEvent, {\n                timestamp: mobileCustomEvent.timestamp,\n                idSequence: globalIdSequence,\n            })\n            if (keyboardPlaceHolder) {\n                adds.push({\n                    parentId: KEYBOARD_PARENT_ID,\n                    nextId: null,\n                    node: keyboardPlaceHolder.result,\n                })\n                // mutations seem not to want a tree of nodes to add\n                // so even though `keyboardPlaceholder` is a tree with content\n                // we have to add the text content as well\n                adds.push({\n                    parentId: keyboardPlaceHolder.result.id,\n                    nextId: null,\n                    node: {\n                        type: NodeType.Text,\n                        id: globalIdSequence.next().value,\n                        textContent: 'keyboard',\n                    },\n                })\n            } else {\n                captureMessage('Failed to create keyboard placeholder', { extra: { mobileCustomEvent } })\n            }\n        } else {\n            removes.push({\n                parentId: KEYBOARD_PARENT_ID,\n                id: KEYBOARD_ID,\n            })\n        }\n        const mutation: mutationData = { adds, attributes: [], removes, source: IncrementalSource.Mutation, texts: [] }\n        return {\n            type: EventType.IncrementalSnapshot,\n            data: mutation,\n            timestamp: mobileCustomEvent.timestamp,\n        }\n    }\n    return mobileCustomEvent\n}\n\nexport const makeMetaEvent = (\n    mobileMetaEvent: MobileMetaEvent & {\n        timestamp: number\n    }\n): metaEvent & {\n    timestamp: number\n    delay?: number\n} => ({\n    type: EventType.Meta,\n    data: {\n        href: mobileMetaEvent.data.href || '', // the replay doesn't use the href, so we safely ignore any absence\n        // mostly we need width and height in order to size the viewport\n        width: mobileMetaEvent.data.width,\n        height: mobileMetaEvent.data.height,\n    },\n    timestamp: mobileMetaEvent.timestamp,\n})\n\nexport function makeDivElement(\n    wireframe: wireframeDiv,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const _id = _isPositiveInteger(wireframe.id) ? wireframe.id : context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: asStyleString([makeStylesString(wireframe), 'overflow:hidden', 'white-space:nowrap']),\n                'data-rrweb-id': _id,\n            },\n            id: _id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction makeTextElement(\n    wireframe: wireframeText,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (wireframe.type !== 'text') {\n        console.error('Passed incorrect wireframe type to makeTextElement')\n        return null\n    }\n\n    // because we might have to style the text, we always wrap it in a div\n    // and apply styles to that\n    const id = context.idSequence.next().value\n\n    const childNodes = [...children]\n    if (!_isNullish(wireframe.text)) {\n        childNodes.unshift({\n            type: NodeType.Text,\n            textContent: wireframe.text,\n            // since the text node is wrapped, we assign it a synthetic id\n            id,\n        })\n    }\n\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: asStyleString([makeStylesString(wireframe), 'overflow:hidden', 'white-space:normal']),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes,\n        },\n        context,\n    }\n}\n\nfunction makeWebViewElement(\n    wireframe: wireframe,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const labelledWireframe: wireframePlaceholder = { ...wireframe } as wireframePlaceholder\n    if ('url' in wireframe) {\n        labelledWireframe.label = wireframe.url\n    }\n\n    return makePlaceholderElement(labelledWireframe, children, context)\n}\n\nexport function makePlaceholderElement(\n    wireframe: wireframe,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const txt = 'label' in wireframe && wireframe.label ? wireframe.label : wireframe.type || 'PLACEHOLDER'\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe, {\n                    verticalAlign: 'center',\n                    horizontalAlign: 'center',\n                    backgroundColor: wireframe.style?.backgroundColor || BACKGROUND,\n                    color: wireframe.style?.color || FOREGROUND,\n                    backgroundImage: PLACEHOLDER_SVG_DATA_IMAGE_URL,\n                    backgroundSize: 'auto',\n                    backgroundRepeat: 'unset',\n                    ...context.styleOverride,\n                }),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: [\n                {\n                    type: NodeType.Text,\n                    // since the text node is wrapped, we assign it a synthetic id\n                    id: context.idSequence.next().value,\n                    textContent: txt,\n                },\n                ...children,\n            ],\n        },\n        context,\n    }\n}\n\nexport function dataURIOrPNG(src: string): string {\n    // replace all new lines in src\n    src = src.replace(/\\r?\\n|\\r/g, '')\n    if (!src.startsWith('data:image/')) {\n        return 'data:image/png;base64,' + src\n    }\n    return src\n}\n\nfunction makeImageElement(\n    wireframe: wireframeImage | wireframeScreenshot,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (!wireframe.base64) {\n        return makePlaceholderElement(wireframe, children, context)\n    }\n\n    const src = dataURIOrPNG(wireframe.base64)\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'img',\n            attributes: {\n                src: src,\n                width: wireframe.width,\n                height: wireframe.height,\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction inputAttributes<T extends wireframeInputComponent>(wireframe: T): attributes {\n    const attributes = {\n        style: makeStylesString(wireframe),\n        type: wireframe.inputType,\n        ...(wireframe.disabled ? { disabled: wireframe.disabled } : {}),\n        'data-rrweb-id': wireframe.id,\n    }\n\n    switch (wireframe.inputType) {\n        case 'checkbox':\n            return {\n                ...attributes,\n                style: null, // checkboxes are styled by being combined with a label\n                ...(wireframe.checked ? { checked: wireframe.checked } : {}),\n            }\n        case 'toggle':\n            return {\n                ...attributes,\n                style: null, // toggle are styled by being combined with a label\n                ...(wireframe.checked ? { checked: wireframe.checked } : {}),\n            }\n        case 'radio':\n            return {\n                ...attributes,\n                style: null, // radio buttons are styled by being combined with a label\n                ...(wireframe.checked ? { checked: wireframe.checked } : {}),\n                // radio value defaults to the string \"on\" if not specified\n                // we're not really submitting the form, so it doesn't matter \n                // radio name is used to correctly uncheck values when one is checked\n                // mobile doesn't really have it, and we will be checking based on snapshots,\n                // so we can ignore it for now\n            }\n        case 'button':\n            return {\n                ...attributes,\n            }\n        case 'text_area':\n            return {\n                ...attributes,\n                value: wireframe.value || '',\n            }\n        case 'progress':\n            return {\n                ...attributes,\n                // indeterminate when omitted\n                value: wireframe.value || null,\n                // defaults to 1 when omitted\n                max: wireframe.max || null,\n                type: null, // progress has no type attribute\n            }\n        default:\n            return {\n                ...attributes,\n                value: wireframe.value || '',\n            }\n    }\n}\n\nfunction makeButtonElement(\n    wireframe: wireframeButton,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const buttonText: textNode | null = wireframe.value\n        ? {\n              type: NodeType.Text,\n              textContent: wireframe.value,\n          }\n        : null\n\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'button',\n            attributes: inputAttributes(wireframe),\n            id: wireframe.id,\n            childNodes: buttonText ? [{ ...buttonText, id: context.idSequence.next().value }, ...children] : children,\n        },\n        context,\n    }\n}\n\nfunction makeSelectOptionElement(\n    option: string,\n    selected: boolean,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> {\n    const optionId = context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'option',\n            attributes: {\n                ...(selected ? { selected: selected } : {}),\n                'data-rrweb-id': optionId,\n            },\n            id: optionId,\n            childNodes: [\n                {\n                    type: NodeType.Text,\n                    textContent: option,\n                    id: context.idSequence.next().value,\n                },\n            ],\n        },\n        context,\n    }\n}\n\nfunction makeSelectElement(\n    wireframe: wireframeSelect,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const selectOptions: serializedNodeWithId[] = []\n    if (wireframe.options) {\n        let optionContext = context\n        for (let i = 0; i < wireframe.options.length; i++) {\n            const option = wireframe.options[i]\n            const conversion = makeSelectOptionElement(option, wireframe.value === option, optionContext)\n            selectOptions.push(conversion.result)\n            optionContext = conversion.context\n        }\n    }\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'select',\n            attributes: inputAttributes(wireframe),\n            id: wireframe.id,\n            childNodes: [...selectOptions, ...children],\n        },\n        context,\n    }\n}\n\nfunction groupRadioButtons(children: serializedNodeWithId[], radioGroupName: string): serializedNodeWithId[] {\n    return children.map((child) => {\n        if (child.type === NodeType.Element && child.tagName === 'input' && child.attributes.type === 'radio') {\n            return {\n                ...child,\n                attributes: {\n                    ...child.attributes,\n                    name: radioGroupName,\n                    'data-rrweb-id': child.id,\n                },\n            }\n        }\n        return child\n    })\n}\n\nfunction makeRadioGroupElement(\n    wireframe: wireframeRadioGroup,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const radioGroupName = 'radio_group_' + wireframe.id\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: groupRadioButtons(children, radioGroupName),\n        },\n        context,\n    }\n}\n\nfunction makeStar(title: string, path: string, context: ConversionContext): serializedNodeWithId {\n    const svgId = context.idSequence.next().value\n    const titleId = context.idSequence.next().value\n    const pathId = context.idSequence.next().value\n    return {\n        type: NodeType.Element,\n        tagName: 'svg',\n        isSVG: true,\n        attributes: {\n            style: asStyleString(['height: 100%', 'overflow-clip-margin: content-box', 'overflow:hidden']),\n            viewBox: '0 0 24 24',\n            fill: 'currentColor',\n            'data-rrweb-id': svgId,\n        },\n        id: svgId,\n        childNodes: [\n            {\n                type: NodeType.Element,\n                tagName: 'title',\n                isSVG: true,\n                attributes: {\n                    'data-rrweb-id': titleId,\n                },\n                id: titleId,\n                childNodes: [\n                    {\n                        type: NodeType.Text,\n                        textContent: title,\n                        id: context.idSequence.next().value,\n                    },\n                ],\n            },\n            {\n                type: NodeType.Element,\n                tagName: 'path',\n                isSVG: true,\n                attributes: {\n                    d: path,\n                    'data-rrweb-id': pathId,\n                },\n                id: pathId,\n                childNodes: [],\n            },\n        ],\n    }\n}\n\nfunction filledStar(context: ConversionContext): serializedNodeWithId {\n    return makeStar(\n        'filled star',\n        'M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z',\n        context\n    )\n}\n\nfunction halfStar(context: ConversionContext): serializedNodeWithId {\n    return makeStar(\n        'half-filled star',\n        'M12,15.4V6.1L13.71,10.13L18.09,10.5L14.77,13.39L15.76,17.67M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z',\n        context\n    )\n}\n\nfunction emptyStar(context: ConversionContext): serializedNodeWithId {\n    return makeStar(\n        'empty star',\n        'M12,15.39L8.24,17.66L9.23,13.38L5.91,10.5L10.29,10.13L12,6.09L13.71,10.13L18.09,10.5L14.77,13.38L15.76,17.66M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z',\n        context\n    )\n}\n\nfunction makeRatingBar(\n    wireframe: wireframeProgress,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    // max is the number of stars... and value is the number of stars to fill\n\n    // deliberate double equals, because we want to allow null and undefined\n    if (wireframe.value == null || wireframe.max == null) {\n        return makePlaceholderElement(wireframe, children, context)\n    }\n\n    const numberOfFilledStars = Math.floor(wireframe.value)\n    const numberOfHalfStars = wireframe.value - numberOfFilledStars > 0 ? 1 : 0\n    const numberOfEmptyStars = wireframe.max - numberOfFilledStars - numberOfHalfStars\n\n    const filledStars = Array(numberOfFilledStars)\n        .fill(undefined)\n        .map(() => filledStar(context))\n    const halfStars = Array(numberOfHalfStars)\n        .fill(undefined)\n        .map(() => halfStar(context))\n    const emptyStars = Array(numberOfEmptyStars)\n        .fill(undefined)\n        .map(() => emptyStar(context))\n\n    const ratingBarId = context.idSequence.next().value\n    const ratingBar = {\n        type: NodeType.Element,\n        tagName: 'div',\n        id: ratingBarId,\n        attributes: {\n            style: asStyleString([\n                makeColorStyles(wireframe),\n                'position: relative',\n                'display: flex',\n                'flex-direction: row',\n                'padding: 2px 4px',\n            ]),\n            'data-rrweb-id': ratingBarId,\n        },\n        childNodes: [...filledStars, ...halfStars, ...emptyStars],\n    } as serializedNodeWithId\n\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: [ratingBar, ...children],\n        },\n        context,\n    }\n}\n\nfunction makeProgressElement(\n    wireframe: wireframeProgress,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (wireframe.style?.bar === 'circular') {\n        // value needs to be expressed as a number between 0 and 100\n        const max = wireframe.max || 1\n        let value = wireframe.value || null\n        if (_isPositiveInteger(value) && value <= max) {\n            value = (value / max) * 100\n        } else {\n            value = null\n        }\n\n        const styleOverride = {\n            color: wireframe.style?.color || FOREGROUND,\n            backgroundColor: wireframe.style?.backgroundColor || BACKGROUND,\n        }\n\n        // if not _isPositiveInteger(value) then we render a spinner,\n        // so we need to add a style element with the spin keyframe\n        const stylingChildren: serializedNodeWithId[] = _isPositiveInteger(value)\n            ? []\n            : [\n                  {\n                      type: NodeType.Element,\n                      tagName: 'style',\n                      attributes: {\n                          type: 'text/css',\n                      },\n                      id: context.idSequence.next().value,\n                      childNodes: [\n                          {\n                              type: NodeType.Text,\n                              textContent: `@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`,\n                              id: context.idSequence.next().value,\n                          },\n                      ],\n                  },\n              ]\n\n        const wrappingDivId = context.idSequence.next().value\n        return {\n            result: {\n                type: NodeType.Element,\n                tagName: 'div',\n                attributes: {\n                    style: makeMinimalStyles(wireframe),\n                    'data-rrweb-id': wireframe.id,\n                },\n                id: wireframe.id,\n                childNodes: [\n                    {\n                        type: NodeType.Element,\n                        tagName: 'div',\n                        attributes: {\n                            // with no provided value we render a spinner\n                            style: _isPositiveInteger(value)\n                                ? makeDeterminateProgressStyles(wireframe, styleOverride)\n                                : makeIndeterminateProgressStyles(wireframe, styleOverride),\n                            'data-rrweb-id': wrappingDivId,\n                        },\n                        id: wrappingDivId,\n                        childNodes: stylingChildren,\n                    },\n                    ...children,\n                ],\n            },\n            context,\n        }\n    } else if (wireframe.style?.bar === 'rating') {\n        return makeRatingBar(wireframe, children, context)\n    }\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'progress',\n            attributes: inputAttributes(wireframe),\n            id: wireframe.id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction makeToggleParts(wireframe: wireframeToggle, context: ConversionContext): serializedNodeWithId[] {\n    const togglePosition = wireframe.checked ? 'right' : 'left'\n    const defaultColor = wireframe.checked ? '#1d4aff' : BACKGROUND\n    const sliderPartId = context.idSequence.next().value\n    const handlePartId = context.idSequence.next().value\n    return [\n        {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                'data-toggle-part': 'slider',\n                style: asStyleString([\n                    'position:absolute',\n                    'top:33%',\n                    'left:5%',\n                    'display:inline-block',\n                    'width:75%',\n                    'height:33%',\n                    'opacity: 0.2',\n                    'border-radius:7.5%',\n                    `background-color:${wireframe.style?.color || defaultColor}`,\n                ]),\n                'data-rrweb-id': sliderPartId,\n            },\n            id: sliderPartId,\n            childNodes: [],\n        },\n        {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                'data-toggle-part': 'handle',\n                style: asStyleString([\n                    'position:absolute',\n                    'top:1.5%',\n                    `${togglePosition}:5%`,\n                    'display:flex',\n                    'align-items:center',\n                    'justify-content:center',\n                    'width:40%',\n                    'height:75%',\n                    'cursor:inherit',\n                    'border-radius:50%',\n                    `background-color:${wireframe.style?.color || defaultColor}`,\n                    `border:2px solid ${wireframe.style?.borderColor || wireframe.style?.color || defaultColor}`,\n                ]),\n                'data-rrweb-id': handlePartId,\n            },\n            id: handlePartId,\n            childNodes: [],\n        },\n    ]\n}\n\nfunction makeToggleElement(\n    wireframe: wireframeToggle,\n    context: ConversionContext\n): ConversionResult<\n    elementNode & {\n        id: number\n    }\n> | null {\n    const isLabelled = 'label' in wireframe\n    const wrappingDivId = context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                // if labelled take up available space, otherwise use provided positioning\n                style: isLabelled ? asStyleString(['height:100%', 'flex:1']) : makePositionStyles(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: [\n                {\n                    type: NodeType.Element,\n                    tagName: 'div',\n                    attributes: {\n                        // relative position, fills parent\n                        style: asStyleString(['position:relative', 'width:100%', 'height:100%']),\n                        'data-rrweb-id': wrappingDivId,\n                    },\n                    id: wrappingDivId,\n                    childNodes: makeToggleParts(wireframe, context),\n                },\n            ],\n        },\n        context,\n    }\n}\n\nfunction makeLabelledInput(\n    wireframe: wireframeCheckBox | wireframeRadio | wireframeToggle,\n    theInputElement: serializedNodeWithId,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> {\n    const theLabel: serializedNodeWithId = {\n        type: NodeType.Text,\n        textContent: wireframe.label || '',\n        id: context.idSequence.next().value,\n    }\n\n    const orderedChildren = wireframe.inputType === 'toggle' ? [theLabel, theInputElement] : [theInputElement, theLabel]\n\n    const labelId = context.idSequence.next().value\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'label',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': labelId,\n            },\n            id: labelId,\n            childNodes: orderedChildren,\n        },\n        context,\n    }\n}\n\nfunction makeInputElement(\n    wireframe: wireframeInputComponent,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    if (!wireframe.inputType) {\n        return null\n    }\n\n    if (wireframe.inputType === 'button') {\n        return makeButtonElement(wireframe, children, context)\n    }\n\n    if (wireframe.inputType === 'select') {\n        return makeSelectElement(wireframe, children, context)\n    }\n\n    if (wireframe.inputType === 'progress') {\n        return makeProgressElement(wireframe, children, context)\n    }\n\n    const theInputElement: ConversionResult<serializedNodeWithId> | null =\n        wireframe.inputType === 'toggle'\n            ? makeToggleElement(wireframe, context)\n            : {\n                  result: {\n                      type: NodeType.Element,\n                      tagName: 'input',\n                      attributes: inputAttributes(wireframe),\n                      id: wireframe.id,\n                      childNodes: children,\n                  },\n                  context,\n              }\n\n    if (!theInputElement) {\n        return null\n    }\n\n    if ('label' in wireframe) {\n        return makeLabelledInput(wireframe, theInputElement.result, theInputElement.context)\n    }\n    // when labelled no styles are needed, when un-labelled as here - we add the styling in.\n    ;(theInputElement.result as elementNode).attributes.style = makeStylesString(wireframe)\n    return theInputElement\n}\n\nfunction makeRectangleElement(\n    wireframe: wireframeRectangle,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    return {\n        result: {\n            type: NodeType.Element,\n            tagName: 'div',\n            attributes: {\n                style: makeStylesString(wireframe),\n                'data-rrweb-id': wireframe.id,\n            },\n            id: wireframe.id,\n            childNodes: children,\n        },\n        context,\n    }\n}\n\nfunction chooseConverter<T extends wireframe>(\n    wireframe: T\n): (\n    wireframe: T,\n    children: serializedNodeWithId[],\n    context: ConversionContext\n) => ConversionResult<serializedNodeWithId> | null {\n    // in theory type is always present\n    // but since this is coming over the wire we can't really be sure,\n    // and so we default to div\n    const converterType: MobileNodeType = wireframe.type || 'div'\n    const converterMapping: Record<\n        MobileNodeType,\n        (wireframe: T, children: serializedNodeWithId[]) => ConversionResult<serializedNodeWithId> | null\n    > = {\n        // KLUDGE: TS can't tell that the wireframe type of each function is safe based on the converter type\n        text: makeTextElement as any,\n        image: makeImageElement as any,\n        rectangle: makeRectangleElement as any,\n        div: makeDivElement as any,\n        input: makeInputElement as any,\n        radio_group: makeRadioGroupElement as any,\n        web_view: makeWebViewElement as any,\n        placeholder: makePlaceholderElement as any,\n        status_bar: makeStatusBar as any,\n        navigation_bar: makeNavigationBar as any,\n        screenshot: makeImageElement as any,\n    }\n    return converterMapping[converterType]\n}\n\nfunction convertWireframe(\n    wireframe: wireframe,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId> | null {\n    const children = convertWireframesFor(wireframe.childWireframes, context)\n    const converted = chooseConverter(wireframe)?.(wireframe, children.result, children.context)\n    return converted || null\n}\n\nfunction convertWireframesFor(\n    wireframes: wireframe[] | undefined,\n    context: ConversionContext\n): ConversionResult<serializedNodeWithId[]> {\n    if (!wireframes) {\n        return { result: [], context }\n    }\n\n    const result: serializedNodeWithId[] = []\n    for (const wireframe of wireframes) {\n        const converted = convertWireframe(wireframe, context)\n        if (converted) {\n            result.push(converted.result)\n            context = converted.context\n        }\n    }\n    return { result, context }\n}\n\nfunction isMobileIncrementalSnapshotEvent(x: unknown): x is MobileIncrementalSnapshotEvent {\n    const isIncrementalSnapshot = isObject(x) && 'type' in x && x.type === EventType.IncrementalSnapshot\n    if (!isIncrementalSnapshot) {\n        return false\n    }\n    const hasData = isObject(x) && 'data' in x\n    const data = hasData ? x.data : null\n\n    const hasMutationSource = isObject(data) && 'source' in data && data.source === IncrementalSource.Mutation\n\n    const adds = isObject(data) && 'adds' in data && Array.isArray(data.adds) ? data.adds : null\n    const updates = isObject(data) && 'updates' in data && Array.isArray(data.updates) ? data.updates : null\n\n    const hasUpdatedWireframe = !!updates && updates.length > 0 && isObject(updates[0]) && 'wireframe' in updates[0]\n    const hasAddedWireframe = !!adds && adds.length > 0 && isObject(adds[0]) && 'wireframe' in adds[0]\n\n    return hasMutationSource && (hasAddedWireframe || hasUpdatedWireframe)\n}\n\nfunction chooseParentId(nodeType: MobileNodeType, providedParentId: number): number {\n    return nodeType === 'screenshot' ? BODY_ID : providedParentId\n}\n\nfunction makeIncrementalAdd(add: MobileNodeMutation, context: ConversionContext): addedNodeMutation[] | null {\n    const converted = convertWireframe(add.wireframe, context)\n\n    if (!converted) {\n        return null\n    }\n\n    const addition: addedNodeMutation = {\n        parentId: chooseParentId(add.wireframe.type, add.parentId),\n        nextId: null,\n        node: converted.result,\n    }\n    const adds: addedNodeMutation[] = []\n    if (addition) {\n        const flattened = flattenMutationAdds(addition)\n        flattened.forEach((x) => adds.push(x))\n        return adds\n    }\n    return null\n}\n\n/**\n * When processing an update we remove the entire item, and then add it back in.\n */\nfunction makeIncrementalRemoveForUpdate(update: MobileNodeMutation): removedNodeMutation {\n    return {\n        parentId: chooseParentId(update.wireframe.type, update.parentId),\n        id: update.wireframe.id,\n    }\n}\n\nfunction isNode(x: unknown): x is serializedNodeWithId {\n    // KLUDGE: really we should check that x.type is valid, but we're safe enough already\n    return isObject(x) && 'type' in x && 'id' in x\n}\n\nfunction isNodeWithChildren(x: unknown): x is elementNode | documentNode {\n    return isNode(x) && 'childNodes' in x && Array.isArray(x.childNodes)\n}\n\n/**\n * when creating incremental adds we have to flatten the node tree structure\n * there's no point, then keeping those child nodes in place\n */\nfunction cloneWithoutChildren(converted: addedNodeMutation): addedNodeMutation {\n    const cloned = { ...converted }\n    const clonedNode: serializedNodeWithId = { ...converted.node }\n    if (isNodeWithChildren(clonedNode)) {\n        clonedNode.childNodes = []\n    }\n    cloned.node = clonedNode\n    return cloned\n}\n\nfunction flattenMutationAdds(converted: addedNodeMutation): addedNodeMutation[] {\n    const flattened: addedNodeMutation[] = []\n\n    flattened.push(cloneWithoutChildren(converted))\n\n    const node: unknown = converted.node\n    const newParentId = converted.node.id\n    if (isNodeWithChildren(node)) {\n        node.childNodes.forEach((child) => {\n            flattened.push(\n                cloneWithoutChildren({\n                    parentId: newParentId,\n                    nextId: null,\n                    node: child,\n                })\n            )\n            if (isNodeWithChildren(child)) {\n                flattened.push(...flattenMutationAdds({ parentId: newParentId, nextId: null, node: child }))\n            }\n        })\n    }\n    return flattened\n}\n\n/**\n * each update wireframe carries the entire tree because we don't want to diff on the client\n * that means that we might create multiple mutations for the same node\n * we only want to add it once, so we dedupe the mutations\n * the app guarantees that for a given ID that is present more than once in a single snapshot\n * every instance of that ID is identical\n * it might change in the next snapshot but for a single incremental snapshot there is one\n * and only one version of any given ID\n */\nfunction dedupeMutations<T extends addedNodeMutation | removedNodeMutation>(mutations: T[]): T[] {\n    // KLUDGE: it's slightly yucky to stringify everything but since synthetic nodes\n    // introduce a new id, we can't just compare the id\n    const seen = new Set<string>()\n\n    // in case later mutations are the ones we want to keep, we reverse the array\n    // this does help with the deduping, so, it's likely that the view for a single ID\n    // is not consistent over a snapshot, but it's cheap to reverse so :YOLO:\n    return mutations\n        .reverse()\n        .filter((mutation: addedNodeMutation | removedNodeMutation) => {\n            let toCompare: string\n            if (isRemovedNodeMutation(mutation)) {\n                toCompare = JSON.stringify(mutation)\n            } else {\n                // if this is a synthetic addition, then we need to ignore the id,\n                // since duplicates won't have duplicate ids\n                toCompare = JSON.stringify({\n                    ...mutation.node,\n                    id: 0,\n                })\n            }\n\n            if (seen.has(toCompare)) {\n                return false\n            }\n            seen.add(toCompare)\n            return true\n        })\n        .reverse()\n}\n\n/**\n * We want to ensure that any events don't use id = 0.\n * They must always represent a valid ID from the dom, so we swap in the body id when the id = 0.\n *\n * For \"removes\", we don't need to do anything, the id of the element to be removed remains valid. We won't try and remove other elements that we added during transformation in order to show that element.\n *\n * \"adds\" are converted from wireframes to nodes and converted to `incrementalSnapshotEvent.adds`\n *\n * \"updates\" are converted to a remove and an add.\n *\n */\nexport const makeIncrementalEvent = (\n    mobileEvent: (MobileIncrementalSnapshotEvent | incrementalSnapshotEvent) & {\n        timestamp: number\n        delay?: number\n    }\n): incrementalSnapshotEvent & {\n    timestamp: number\n    delay?: number\n} => {\n    const converted = mobileEvent as unknown as incrementalSnapshotEvent & {\n        timestamp: number\n        delay?: number\n    }\n    if ('id' in converted.data && converted.data.id === 0) {\n        converted.data.id = BODY_ID\n    }\n\n    if (isMobileIncrementalSnapshotEvent(mobileEvent)) {\n        const adds: addedNodeMutation[] = []\n        const removes: removedNodeMutation[] = mobileEvent.data.removes || []\n        if ('adds' in mobileEvent.data && Array.isArray(mobileEvent.data.adds)) {\n            const addsContext = {\n                timestamp: mobileEvent.timestamp,\n                idSequence: globalIdSequence,\n            }\n\n            mobileEvent.data.adds.forEach((add) => {\n                makeIncrementalAdd(add, addsContext)?.forEach((x) => adds.push(x))\n            })\n        }\n        if ('updates' in mobileEvent.data && Array.isArray(mobileEvent.data.updates)) {\n            const updatesContext = {\n                timestamp: mobileEvent.timestamp,\n                idSequence: globalIdSequence,\n            }\n            const updateAdditions: addedNodeMutation[] = []\n            mobileEvent.data.updates.forEach((update) => {\n                const removal = makeIncrementalRemoveForUpdate(update)\n                if (removal) {\n                    removes.push(removal)\n                }\n                makeIncrementalAdd(update, updatesContext)?.forEach((x) => updateAdditions.push(x))\n            })\n            dedupeMutations(updateAdditions).forEach((x) => adds.push(x))\n        }\n\n        converted.data = {\n            source: IncrementalSource.Mutation,\n            attributes: [],\n            texts: [],\n            adds: dedupeMutations(adds),\n            // TODO: this assumes that removes are processed before adds \n            removes: dedupeMutations(removes),\n        }\n    }\n\n    return converted\n}\n\nfunction makeKeyboardParent(): serializedNodeWithId {\n    return {\n        type: NodeType.Element,\n        tagName: 'div',\n        attributes: {\n            'data-render-reason': 'a fixed placeholder to contain the keyboard in the correct stacking position',\n            'data-rrweb-id': KEYBOARD_PARENT_ID,\n        },\n        id: KEYBOARD_PARENT_ID,\n        childNodes: [],\n    }\n}\n\nfunction makeStatusBarNode(\n    statusBar: wireframeStatusBar | undefined,\n    context: ConversionContext\n): serializedNodeWithId {\n    const childNodes = statusBar ? convertWireframesFor([statusBar], context).result : []\n    return {\n        type: NodeType.Element,\n        tagName: 'div',\n        attributes: {\n            'data-rrweb-id': STATUS_BAR_PARENT_ID,\n        },\n        id: STATUS_BAR_PARENT_ID,\n        childNodes,\n    }\n}\n\nfunction makeNavBarNode(\n    navigationBar: wireframeNavigationBar | undefined,\n    context: ConversionContext\n): serializedNodeWithId {\n    const childNodes = navigationBar ? convertWireframesFor([navigationBar], context).result : []\n    return {\n        type: NodeType.Element,\n        tagName: 'div',\n        attributes: {\n            'data-rrweb-id': NAVIGATION_BAR_PARENT_ID,\n        },\n        id: NAVIGATION_BAR_PARENT_ID,\n        childNodes,\n    }\n}\n\nfunction stripBarsFromWireframe(wireframe: wireframe): {\n    wireframe: wireframe | undefined\n    statusBar: wireframeStatusBar | undefined\n    navBar: wireframeNavigationBar | undefined\n} {\n    if (wireframe.type === 'status_bar') {\n        return { wireframe: undefined, statusBar: wireframe, navBar: undefined }\n    } else if (wireframe.type === 'navigation_bar') {\n        return { wireframe: undefined, statusBar: undefined, navBar: wireframe }\n    }\n    let statusBar: wireframeStatusBar | undefined\n    let navBar: wireframeNavigationBar | undefined\n    const wireframeToReturn: wireframe | undefined = { ...wireframe }\n    wireframeToReturn.childWireframes = []\n    for (const child of wireframe.childWireframes || []) {\n        const {\n            wireframe: childWireframe,\n            statusBar: childStatusBar,\n            navBar: childNavBar,\n        } = stripBarsFromWireframe(child)\n        statusBar = statusBar || childStatusBar\n        navBar = navBar || childNavBar\n        if (childWireframe) {\n            wireframeToReturn.childWireframes.push(childWireframe)\n        }\n    }\n    return { wireframe: wireframeToReturn, statusBar, navBar }\n}\n\n/**\n * We want to be able to place the status bar and navigation bar in the correct stacking order.\n * So, we lift them out of the tree, and return them separately.\n */\nexport function stripBarsFromWireframes(wireframes: wireframe[]): {\n    statusBar: wireframeStatusBar | undefined\n    navigationBar: wireframeNavigationBar | undefined\n    appNodes: wireframe[]\n} {\n    let statusBar: wireframeStatusBar | undefined\n    let navigationBar: wireframeNavigationBar | undefined\n    const copiedNodes: wireframe[] = []\n\n    wireframes.forEach((w) => {\n        const matches = stripBarsFromWireframe(w)\n        if (matches.statusBar) {\n            statusBar = matches.statusBar\n        }\n        if (matches.navBar) {\n            navigationBar = matches.navBar\n        }\n        if (matches.wireframe) {\n            copiedNodes.push(matches.wireframe)\n        }\n    })\n    return { statusBar, navigationBar, appNodes: copiedNodes }\n}\n\nexport const makeFullEvent = (\n    mobileEvent: MobileFullSnapshotEvent & {\n        timestamp: number\n        delay?: number\n    }\n): fullSnapshotEvent & {\n    timestamp: number\n    delay?: number\n} => {\n    // we can restart the id sequence on each full snapshot\n    globalIdSequence = ids()\n\n    if (!(isObject(mobileEvent.data) && 'wireframes' in mobileEvent.data)) {\n        return mobileEvent as unknown as fullSnapshotEvent & {\n            timestamp: number\n            delay?: number\n        }\n    }\n\n    const conversionContext = {\n        timestamp: mobileEvent.timestamp,\n        idSequence: globalIdSequence,\n    }\n\n    const { statusBar, navigationBar, appNodes } = stripBarsFromWireframes(mobileEvent.data.wireframes)\n\n    const nodeGroups = {\n        appNodes: convertWireframesFor(appNodes, conversionContext).result || [],\n        statusBarNode: makeStatusBarNode(statusBar, conversionContext),\n        navBarNode: makeNavBarNode(navigationBar, conversionContext),\n    }\n\n    return {\n        type: EventType.FullSnapshot,\n        timestamp: mobileEvent.timestamp,\n        data: {\n            node: {\n                type: NodeType.Document,\n                childNodes: [\n                    {\n                        type: NodeType.DocumentType,\n                        name: 'html',\n                        publicId: '',\n                        systemId: '',\n                        id: HTML_DOC_TYPE_ID,\n                    },\n                    {\n                        type: NodeType.Element,\n                        tagName: 'html',\n                        attributes: { style: makeHTMLStyles(), 'data-rrweb-id': HTML_ELEMENT_ID },\n                        id: HTML_ELEMENT_ID,\n                        childNodes: [\n                            {\n                                type: NodeType.Element,\n                                tagName: 'head',\n                                attributes: { 'data-rrweb-id': HEAD_ID },\n                                id: HEAD_ID,\n                                childNodes: [makeCSSReset(conversionContext)],\n                            },\n                            {\n                                type: NodeType.Element,\n                                tagName: 'body',\n                                attributes: { style: makeBodyStyles(), 'data-rrweb-id': BODY_ID },\n                                id: BODY_ID,\n                                childNodes: [\n                                    // in the order they should stack if they ever clash\n                                    // lower is higher in the stacking context\n                                    ...nodeGroups.appNodes,\n                                    makeKeyboardParent(),\n                                    nodeGroups.navBarNode,\n                                    nodeGroups.statusBarNode,\n                                ],\n                            },\n                        ],\n                    },\n                ],\n                id: DOCUMENT_ID,\n            },\n            initialOffset: {\n                top: 0,\n                left: 0,\n            },\n        },\n    }\n}\n\nfunction makeCSSReset(context: ConversionContext): serializedNodeWithId {\n    // we need to normalize CSS so browsers don't do unexpected things\n    return {\n        type: NodeType.Element,\n        tagName: 'style',\n        attributes: {\n            type: 'text/css',\n        },\n        id: context.idSequence.next().value,\n        childNodes: [\n            {\n                type: NodeType.Text,\n                textContent: `\n                    body {\n                      margin: unset;\n                    }\n                    input, button, select, textarea {\n                        font: inherit;\n                        margin: 0;\n                        padding: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        padding-block: 0 !important;\n                    }\n                    .input:focus {\n                        outline: none;\n                    }\n                    img {\n                      border-style: none;\n                    }\n                `,\n                id: context.idSequence.next().value,\n            },\n        ],\n    }\n}\n","import posthogEE from '@posthog/ee/exports'\nimport { customEvent, EventType, eventWithTime, fullSnapshotEvent, IncrementalSource } from '@posthog/rrweb-types'\nimport { captureException } from '@sentry/react'\nimport { gunzipSync, strFromU8, strToU8 } from 'fflate'\nimport {\n    actions,\n    afterMount,\n    beforeUnmount,\n    connect,\n    defaults,\n    kea,\n    key,\n    listeners,\n    path,\n    props,\n    reducers,\n    selectors,\n} from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { subscriptions } from 'kea-subscriptions'\nimport api from 'lib/api'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { Dayjs, dayjs } from 'lib/dayjs'\nimport { featureFlagLogic, FeatureFlagsSet } from 'lib/logic/featureFlagLogic'\nimport { isObject } from 'lib/utils'\nimport { chainToElements } from 'lib/utils/elements-chain'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport posthog from 'posthog-js'\nimport { compressedEventWithTime } from 'posthog-js/lib/src/extensions/replay/sessionrecording'\nimport { RecordingComment } from 'scenes/session-recordings/player/inspector/playerInspectorLogic'\nimport { teamLogic } from 'scenes/teamLogic'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\nimport {\n    EncodedRecordingSnapshot,\n    RecordingEventsFilters,\n    RecordingEventType,\n    RecordingReportLoadTimes,\n    RecordingSegment,\n    RecordingSnapshot,\n    SessionPlayerData,\n    SessionRecordingId,\n    SessionRecordingSnapshotParams,\n    SessionRecordingSnapshotSource,\n    SessionRecordingSnapshotSourceResponse,\n    SessionRecordingType,\n    SessionRecordingUsageType,\n    SnapshotSourceType,\n} from '~/types'\n\nimport { PostHogEE } from '../../../../@posthog/ee/types'\nimport { ExportedSessionRecordingFileV2 } from '../file-playback/types'\nimport type { sessionRecordingDataLogicType } from './sessionRecordingDataLogicType'\nimport { createSegments, mapSnapshotsToWindowId } from './utils/segmenter'\n\nconst IS_TEST_MODE = process.env.NODE_ENV === 'test'\nconst TWENTY_FOUR_HOURS_IN_MS = 24 * 60 * 60 * 1000 // +- before and after start and end of a recording to query for.\nconst DEFAULT_REALTIME_POLLING_MILLIS = 3000\nconst DEFAULT_V2_POLLING_INTERVAL_MS = 10000\nexport const MUTATION_CHUNK_SIZE = 5000 // Maximum number of mutations per chunk\n\nlet postHogEEModule: PostHogEE\n\nfunction isRecordingSnapshot(x: unknown): x is RecordingSnapshot {\n    return typeof x === 'object' && x !== null && 'type' in x && 'timestamp' in x\n}\n\n/*\n there was a bug in mobile SDK that didn't consistently send a meta event with a full snapshot.\n rrweb player hides itself until it has seen the meta event \n but we can patch a meta event into the recording data to make it work\n*/\nfunction patchMetaEventIntoMobileData(parsedLines: RecordingSnapshot[]): RecordingSnapshot[] {\n    let fullSnapshotIndex: number = -1\n    let metaIndex: number = -1\n    try {\n        fullSnapshotIndex = parsedLines.findIndex((l) => l.type === EventType.FullSnapshot)\n        metaIndex = parsedLines.findIndex((l) => l.type === EventType.Meta)\n\n        // then we need to patch the meta event into the snapshot data\n        if (fullSnapshotIndex > -1 && metaIndex === -1) {\n            const fullSnapshot = parsedLines[fullSnapshotIndex] as RecordingSnapshot & fullSnapshotEvent & eventWithTime\n            // a full snapshot (particularly from the mobile transformer) has a relatively fixed structure,\n            // but the types exposed by rrweb don't quite cover what we need , so...\n            const mainNode = fullSnapshot.data.node as any\n            const targetNode = mainNode.childNodes[1].childNodes[1].childNodes[0]\n            const { width, height } = targetNode.attributes\n            const metaEvent: RecordingSnapshot = {\n                windowId: fullSnapshot.windowId,\n                type: EventType.Meta,\n                timestamp: fullSnapshot.timestamp,\n                data: {\n                    href: getHrefFromSnapshot(fullSnapshot) || '',\n                    width,\n                    height,\n                },\n            }\n            parsedLines.splice(fullSnapshotIndex, 0, metaEvent)\n        }\n    } catch (e) {\n        captureException(e, {\n            tags: { feature: 'session-recording-missing-meta-patching' },\n            extra: { fullSnapshotIndex, metaIndex },\n        })\n    }\n\n    return parsedLines\n}\n\nfunction hasAnyWireframes(snapshotData: Record<string, any>[]): boolean {\n    return snapshotData.some((d) => {\n        return isObject(d.data) && 'wireframes' in d.data\n    })\n}\n\nfunction isCompressedEvent(ev: unknown): ev is compressedEventWithTime {\n    return typeof ev === 'object' && ev !== null && 'cv' in ev\n}\n\nfunction unzip(compressedStr: string | undefined): any {\n    if (!compressedStr) {\n        return undefined\n    }\n    return JSON.parse(strFromU8(gunzipSync(strToU8(compressedStr, true))))\n}\n\n/**\n *\n * takes an event that might be from web, might be from mobile,\n * and might be partially compressed,\n * and decompresses it when possible\n *\n * you can't return a union of `KnownType | unknown`\n * so even though this returns `eventWithTime | unknown`\n * it has to be typed as only unknown\n *\n * KLUDGE: we shouldn't need so many type assertions on ev.data but TS is not smart enough to figure it out\n */\nfunction decompressEvent(ev: unknown): unknown {\n    try {\n        if (isCompressedEvent(ev)) {\n            if (ev.cv === '2024-10') {\n                if (ev.type === EventType.FullSnapshot && typeof ev.data === 'string') {\n                    return {\n                        ...ev,\n                        data: unzip(ev.data),\n                    }\n                } else if (\n                    ev.type === EventType.IncrementalSnapshot &&\n                    typeof ev.data === 'object' &&\n                    'source' in ev.data\n                ) {\n                    if (ev.data.source === IncrementalSource.StyleSheetRule) {\n                        return {\n                            ...ev,\n                            data: {\n                                ...ev.data,\n                                source: IncrementalSource.StyleSheetRule,\n                                adds: unzip(ev.data.adds),\n                                removes: unzip(ev.data.removes),\n                            },\n                        }\n                    } else if (ev.data.source === IncrementalSource.Mutation && 'texts' in ev.data) {\n                        return {\n                            ...ev,\n                            data: {\n                                ...ev.data,\n                                source: IncrementalSource.Mutation,\n                                adds: unzip(ev.data.adds),\n                                removes: unzip(ev.data.removes),\n                                texts: unzip(ev.data.texts),\n                                attributes: unzip(ev.data.attributes),\n                            },\n                        }\n                    }\n                }\n            } else {\n                posthog.captureException(new Error('Unknown compressed event version'), {\n                    feature: 'session-recording-compressed-event-decompression',\n                    compressedEvent: ev,\n                    compressionVersion: ev.cv,\n                })\n                // probably unplayable but we don't know how to decompress it\n                return ev\n            }\n        }\n        return ev\n    } catch (e) {\n        posthog.captureException((e as Error) || new Error('Could not decompress event'), {\n            feature: 'session-recording-compressed-event-decompression',\n            compressedEvent: ev,\n        })\n        return ev\n    }\n}\n\n/**\n * We can receive data in one of multiple formats, so we treat it as unknown\n * And if we can't process it force it into eventWithTime\n *\n * If it can't be case as eventWithTime by this point then it's probably not a valid event anyway\n */\nfunction coerceToEventWithTime(d: unknown, withMobileTransformer: boolean): eventWithTime {\n    // we decompress first so that we could support partial compression on mobile in future\n    const currentEvent = decompressEvent(d)\n    return withMobileTransformer\n        ? postHogEEModule?.mobileReplay?.transformEventToWeb(currentEvent) || (currentEvent as eventWithTime)\n        : (currentEvent as eventWithTime)\n}\n\nexport function chunkMutationSnapshot(snapshot: RecordingSnapshot): RecordingSnapshot[] {\n    if (\n        snapshot.type !== EventType.IncrementalSnapshot ||\n        !('data' in snapshot) ||\n        !snapshot.data ||\n        typeof snapshot.data !== 'object' ||\n        !('source' in snapshot.data) ||\n        snapshot.data.source !== IncrementalSource.Mutation ||\n        !('adds' in snapshot.data) ||\n        !Array.isArray(snapshot.data.adds) ||\n        snapshot.data.adds.length <= MUTATION_CHUNK_SIZE\n    ) {\n        return [snapshot]\n    }\n\n    const chunks: RecordingSnapshot[] = []\n    const { adds, removes, texts, attributes } = snapshot.data\n    const totalAdds = adds.length\n    const chunksCount = Math.ceil(totalAdds / MUTATION_CHUNK_SIZE)\n\n    for (let i = 0; i < chunksCount; i++) {\n        const startIdx = i * MUTATION_CHUNK_SIZE\n        const endIdx = Math.min((i + 1) * MUTATION_CHUNK_SIZE, totalAdds)\n        const isFirstChunk = i === 0\n        const isLastChunk = i === chunksCount - 1\n\n        const chunkSnapshot: RecordingSnapshot = {\n            ...snapshot,\n            timestamp: snapshot.timestamp,\n            data: {\n                ...snapshot.data,\n                adds: adds.slice(startIdx, endIdx),\n                // Keep removes in the first chunk only\n                removes: isFirstChunk ? removes : [],\n                // Keep texts and attributes in the last chunk only\n                texts: isLastChunk ? texts : [],\n                attributes: isLastChunk ? attributes : [],\n            },\n        }\n\n        // If delay was present in the original snapshot, increment it by 1 for each chunk\n        if ('delay' in snapshot) {\n            chunkSnapshot.delay = snapshot.delay || 0\n        }\n\n        chunks.push(chunkSnapshot)\n    }\n\n    return chunks\n}\n\nexport const parseEncodedSnapshots = async (\n    items: (RecordingSnapshot | EncodedRecordingSnapshot | string)[],\n    sessionId: string,\n    withMobileTransformer: boolean = true\n): Promise<RecordingSnapshot[]> => {\n    if (!postHogEEModule) {\n        postHogEEModule = await posthogEE()\n    }\n\n    const lineCount = items.length\n    const unparseableLines: string[] = []\n    let isMobileSnapshots = false\n\n    const parsedLines: RecordingSnapshot[] = items.flatMap((l) => {\n        if (!l) {\n            // blob files have an empty line at the end\n            return []\n        }\n        try {\n            let snapshotLine: { windowId: string } | EncodedRecordingSnapshot\n            if (typeof l === 'string') {\n                // is loaded from blob or realtime storage\n                snapshotLine = JSON.parse(l) as EncodedRecordingSnapshot\n                if (Array.isArray(snapshotLine)) {\n                    snapshotLine = {\n                        windowId: snapshotLine[0],\n                        data: [snapshotLine[1]],\n                    }\n                }\n            } else {\n                // is loaded from file export\n                snapshotLine = l\n            }\n            let snapshotData: ({ windowId: string } | EncodedRecordingSnapshot)[]\n            if (isRecordingSnapshot(snapshotLine)) {\n                // is loaded from file export\n                snapshotData = [snapshotLine]\n            } else {\n                // is loaded from blob or realtime storage\n                snapshotData = snapshotLine['data']\n            }\n\n            if (!isMobileSnapshots) {\n                isMobileSnapshots = hasAnyWireframes(snapshotData)\n            }\n\n            return snapshotData.flatMap((d: unknown) => {\n                const snap = coerceToEventWithTime(d, withMobileTransformer)\n\n                const baseSnapshot: RecordingSnapshot = {\n                    windowId: snapshotLine['window_id'] || snapshotLine['windowId'],\n                    ...snap,\n                }\n\n                // Apply chunking to the snapshot if needed\n                return chunkMutationSnapshot(baseSnapshot)\n            })\n        } catch (e) {\n            if (typeof l === 'string') {\n                unparseableLines.push(l)\n            }\n            return []\n        }\n    })\n\n    if (unparseableLines.length) {\n        const extra = {\n            playbackSessionId: sessionId,\n            totalLineCount: lineCount,\n            unparseableLinesCount: unparseableLines.length,\n            exampleLines: unparseableLines.slice(0, 3),\n        }\n        posthog.capture('session recording had unparseable lines', {\n            ...extra,\n            feature: 'session-recording-snapshot-processing',\n        })\n    }\n\n    return isMobileSnapshots ? patchMetaEventIntoMobileData(parsedLines) : parsedLines\n}\n\nconst getHrefFromSnapshot = (snapshot: unknown): string | undefined => {\n    return isObject(snapshot) && 'data' in snapshot\n        ? (snapshot.data as any)?.href || (snapshot.data as any)?.payload?.href\n        : undefined\n}\n\n/*\n    cyrb53 (c) 2018 bryc (github.com/bryc)\n    License: Public domain. Attribution appreciated.\n    A fast and simple 53-bit string hash function with decent collision resistance.\n    Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.\n*/\nconst cyrb53 = function (str: string, seed = 0): number {\n    let h1 = 0xdeadbeef ^ seed,\n        h2 = 0x41c6ce57 ^ seed\n    for (let i = 0, ch; i < str.length; i++) {\n        ch = str.charCodeAt(i)\n        h1 = Math.imul(h1 ^ ch, 2654435761)\n        h2 = Math.imul(h2 ^ ch, 1597334677)\n    }\n    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507)\n    h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909)\n    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507)\n    h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909)\n    return 4294967296 * (2097151 & h2) + (h1 >>> 0)\n}\n\nexport const deduplicateSnapshots = (snapshots: RecordingSnapshot[] | null): RecordingSnapshot[] => {\n    const seenHashes: Set<string> = new Set()\n\n    return (snapshots ?? [])\n        .filter((snapshot) => {\n            // For a multitude of reasons, there can be duplicate snapshots in the same recording.\n            // we have to stringify the snapshot to compare it to other snapshots.\n            // so we can filter by storing them all in a set\n\n            // we can see duplicates that only differ by delay - these still count as duplicates\n            // even though the delay would hide that\n            const { delay: _delay, ...delayFreeSnapshot } = snapshot\n            // we check each item multiple times as new snapshots come in\n            // so store the computer value on the object to save recalculating it so much\n            const key = (snapshot as any).seen || cyrb53(JSON.stringify(delayFreeSnapshot))\n            ;(snapshot as any).seen = key\n\n            if (seenHashes.has(key)) {\n                return false\n            }\n            seenHashes.add(key)\n            return true\n        })\n        .sort((a, b) => a.timestamp - b.timestamp)\n}\n\nconst generateRecordingReportDurations = (cache: Record<string, any>): RecordingReportLoadTimes => {\n    return {\n        metadata: cache.metadataLoadDuration || Math.round(performance.now() - cache.metaStartTime),\n        snapshots: cache.snapshotsLoadDuration || Math.round(performance.now() - cache.snapshotsStartTime),\n        events: cache.eventsLoadDuration || Math.round(performance.now() - cache.eventsStartTime),\n        firstPaint: cache.firstPaintDuration,\n    }\n}\n\nconst resetTimingsCache = (cache: Record<string, any>): void => {\n    cache.metaStartTime = null\n    cache.metadataLoadDuration = null\n    cache.snapshotsStartTime = null\n    cache.snapshotsLoadDuration = null\n    cache.eventsStartTime = null\n    cache.eventsLoadDuration = null\n    cache.firstPaintDuration = null\n}\n\nexport interface SessionRecordingDataLogicProps {\n    sessionRecordingId: SessionRecordingId\n    realTimePollingIntervalMilliseconds?: number\n}\n\nasync function processEncodedResponse(\n    encodedResponse: (EncodedRecordingSnapshot | string)[],\n    props: SessionRecordingDataLogicProps,\n    featureFlags: FeatureFlagsSet\n): Promise<{ transformed: RecordingSnapshot[]; untransformed: RecordingSnapshot[] | null }> {\n    let untransformed: RecordingSnapshot[] | null = null\n\n    const transformed = await parseEncodedSnapshots(encodedResponse, props.sessionRecordingId)\n\n    if (featureFlags[FEATURE_FLAGS.SESSION_REPLAY_EXPORT_MOBILE_DATA]) {\n        untransformed = await parseEncodedSnapshots(\n            encodedResponse,\n            props.sessionRecordingId,\n            false // don't transform mobile data\n        )\n    }\n\n    return { transformed, untransformed }\n}\n\nconst getSourceKey = (source: SessionRecordingSnapshotSource): string => {\n    // realtime sources vary so blob_key is not always present and is either null or undefined...\n    // we only care about key when not realtime\n    // and we'll always have a key when not realtime\n    return `${source.source}-${source.blob_key || source.source}`\n}\n\nexport const sessionRecordingDataLogic = kea<sessionRecordingDataLogicType>([\n    path((key) => ['scenes', 'session-recordings', 'sessionRecordingDataLogic', key]),\n    props({} as SessionRecordingDataLogicProps),\n    key(({ sessionRecordingId }) => sessionRecordingId || 'no-session-recording-id'),\n    connect({\n        logic: [eventUsageLogic],\n        values: [featureFlagLogic, ['featureFlags'], teamLogic, ['currentTeam']],\n    }),\n    defaults({\n        sessionPlayerMetaData: null as SessionRecordingType | null,\n    }),\n    actions({\n        setFilters: (filters: Partial<RecordingEventsFilters>) => ({ filters }),\n        loadRecordingMeta: true,\n        loadRecordingComments: true,\n        maybeLoadRecordingMeta: true,\n        loadSnapshots: true,\n        loadSnapshotSources: (breakpointLength?: number) => ({ breakpointLength }),\n        loadNextSnapshotSource: true,\n        loadSnapshotsForSource: (source: Pick<SessionRecordingSnapshotSource, 'source' | 'blob_key'>) => ({ source }),\n        loadEvents: true,\n        loadFullEventData: (event: RecordingEventType | RecordingEventType[]) => ({ event }),\n        markViewed: (delay?: number) => ({ delay }),\n        reportUsageIfFullyLoaded: true,\n        persistRecording: true,\n        maybePersistRecording: true,\n        pollRealtimeSnapshots: true,\n        stopRealtimePolling: true,\n        setTrackedWindow: (windowId: string | null) => ({ windowId }),\n        setWasMarkedViewed: (wasMarkedViewed: boolean) => ({ wasMarkedViewed }),\n    }),\n    reducers(() => ({\n        trackedWindow: [\n            null as string | null,\n            {\n                setTrackedWindow: (_, { windowId }) => windowId,\n            },\n        ],\n        filters: [\n            {} as Partial<RecordingEventsFilters>,\n            {\n                setFilters: (state, { filters }) => ({ ...state, ...filters }),\n            },\n        ],\n        isRealtimePolling: [\n            false as boolean,\n            {\n                pollRealtimeSnapshots: () => true,\n                stopRealtimePolling: () => false,\n            },\n        ],\n        isNotFound: [\n            false as boolean,\n            {\n                loadRecordingMeta: () => false,\n                loadRecordingMetaSuccess: () => false,\n                loadRecordingMetaFailure: () => true,\n            },\n        ],\n        snapshotsBySource: [\n            null as Record<string, SessionRecordingSnapshotSourceResponse> | null,\n            {\n                loadSnapshotsForSourceSuccess: (state, { snapshotsForSource }) => {\n                    const sourceKey = getSourceKey(snapshotsForSource.source)\n\n                    return {\n                        ...state,\n                        [sourceKey]: snapshotsForSource,\n                    }\n                },\n            },\n        ],\n        wasMarkedViewed: [\n            false as boolean,\n            {\n                setWasMarkedViewed: (_, { wasMarkedViewed }) => wasMarkedViewed,\n            },\n        ],\n    })),\n    loaders(({ values, props, cache }) => ({\n        sessionComments: {\n            loadRecordingComments: async (_, breakpoint) => {\n                const empty: RecordingComment[] = []\n                if (!props.sessionRecordingId) {\n                    return empty\n                }\n\n                const response = await api.notebooks.recordingComments(props.sessionRecordingId)\n                breakpoint()\n\n                return response.results || empty\n            },\n        },\n        sessionPlayerMetaData: {\n            loadRecordingMeta: async (_, breakpoint) => {\n                if (!props.sessionRecordingId) {\n                    return null\n                }\n\n                cache.metaStartTime = performance.now()\n\n                const response = await api.recordings.get(props.sessionRecordingId)\n                breakpoint()\n\n                return response\n            },\n\n            persistRecording: async (_, breakpoint) => {\n                if (!values.sessionPlayerMetaData) {\n                    return null\n                }\n                await breakpoint(100)\n                await api.recordings.persist(props.sessionRecordingId)\n\n                return {\n                    ...values.sessionPlayerMetaData,\n                    storage: 'object_storage_lts',\n                }\n            },\n        },\n        snapshotSources: [\n            null as SessionRecordingSnapshotSource[] | null,\n            {\n                loadSnapshotSources: async ({ breakpointLength }, breakpoint) => {\n                    if (breakpointLength) {\n                        await breakpoint(breakpointLength)\n                    }\n                    const response = await api.recordings.listSnapshotSources(props.sessionRecordingId)\n                    if (!response.sources) {\n                        return []\n                    }\n                    const anyBlobV2 = response.sources.some((s) => s.source === SnapshotSourceType.blob_v2)\n                    if (values.featureFlags[FEATURE_FLAGS.RECORDINGS_BLOBBY_V2_REPLAY] && anyBlobV2) {\n                        return response.sources.filter((s) => s.source === SnapshotSourceType.blob_v2)\n                    }\n                    return response.sources.filter((s) => s.source !== SnapshotSourceType.blob_v2)\n                },\n            },\n        ],\n        snapshotsForSource: [\n            null as SessionRecordingSnapshotSourceResponse | null,\n            {\n                loadSnapshotsForSource: async ({ source }, breakpoint) => {\n                    let params: SessionRecordingSnapshotParams\n\n                    if (source.source === SnapshotSourceType.blob) {\n                        if (!source.blob_key) {\n                            throw new Error('Missing key')\n                        }\n                        params = { blob_key: source.blob_key, source: 'blob' }\n                    } else if (source.source === SnapshotSourceType.realtime) {\n                        params = { source: 'realtime', version: '2024-04-30' }\n                    } else if (source.source === SnapshotSourceType.blob_v2) {\n                        params = { source: 'blob_v2', blob_key: source.blob_key }\n                    } else {\n                        throw new Error(`Unsupported source: ${source.source}`)\n                    }\n\n                    const snapshotLoadingStartTime = performance.now()\n\n                    if (!cache.snapshotsStartTime) {\n                        cache.snapshotsStartTime = snapshotLoadingStartTime\n                    }\n\n                    await breakpoint(1)\n\n                    const response = await api.recordings.getSnapshots(props.sessionRecordingId, params).catch((e) => {\n                        if (source.source === 'realtime' && e.status === 404) {\n                            // Realtime source is not always available so a 404 is expected\n                            return []\n                        }\n                        throw e\n                    })\n\n                    const { transformed, untransformed } = await processEncodedResponse(\n                        response,\n                        props,\n                        values.featureFlags\n                    )\n\n                    return { snapshots: transformed, untransformed_snapshots: untransformed ?? undefined, source }\n                },\n            },\n        ],\n        sessionEventsData: [\n            null as null | RecordingEventType[],\n            {\n                loadEvents: async () => {\n                    if (!cache.eventsStartTime) {\n                        cache.eventsStartTime = performance.now()\n                    }\n\n                    const { start, end, person } = values.sessionPlayerData\n\n                    if (!person || !start || !end) {\n                        return null\n                    }\n\n                    const sessionEventsQuery = hogql`\n                            SELECT uuid, event, timestamp, elements_chain, properties.$window_id, properties.$current_url, properties.$event_type\n                            FROM events\n                            WHERE timestamp > ${start.subtract(TWENTY_FOUR_HOURS_IN_MS, 'ms')}\n                              AND timestamp < ${end.add(TWENTY_FOUR_HOURS_IN_MS, 'ms')}\n                              AND $session_id = ${props.sessionRecordingId}\n                              ORDER BY timestamp ASC\n                        LIMIT 1000000\n                        `\n\n                    let relatedEventsQuery = hogql`\n                            SELECT uuid, event, timestamp, elements_chain, properties.$window_id, properties.$current_url, properties.$event_type\n                            FROM events\n                            WHERE timestamp > ${start.subtract(TWENTY_FOUR_HOURS_IN_MS, 'ms')}\n                              AND timestamp < ${end.add(TWENTY_FOUR_HOURS_IN_MS, 'ms')}\n                              AND (empty($session_id) OR isNull($session_id)) AND properties.$lib != 'web'\n                        `\n                    if (person?.uuid) {\n                        relatedEventsQuery += `\n                            AND person_id = '${person.uuid}'\n                        `\n                    }\n                    if (!person?.uuid && values.sessionPlayerMetaData?.distinct_id) {\n                        relatedEventsQuery += `\n                            AND distinct_id = ${values.sessionPlayerMetaData.distinct_id}\n                        `\n                    }\n                    relatedEventsQuery += `\n                        ORDER BY timestamp ASC\n                        LIMIT 1000000\n                    `\n\n                    const [sessionEvents, relatedEvents]: any[] = await Promise.all([\n                        // make one query for all events that are part of the session\n                        api.query({\n                            kind: NodeKind.HogQLQuery,\n                            query: sessionEventsQuery,\n                        }),\n                        // make a second for all events from that person,\n                        // not marked as part of the session\n                        // but in the same time range\n                        // these are probably e.g. backend events for the session\n                        // but with no session id\n                        // since posthog-js must always add session id we can also\n                        // take advantage of lib being materialized and further filter\n                        api.query({\n                            kind: NodeKind.HogQLQuery,\n                            query: relatedEventsQuery,\n                        }),\n                    ])\n\n                    return [...sessionEvents.results, ...relatedEvents.results].map(\n                        (event: any): RecordingEventType => {\n                            const currentUrl = event[5]\n                            // We use the pathname to simplify the UI - we build it here instead of fetching it to keep data usage small\n                            let pathname: string | undefined\n                            try {\n                                pathname = event[5] ? new URL(event[5]).pathname : undefined\n                            } catch {\n                                pathname = undefined\n                            }\n\n                            return {\n                                id: event[0],\n                                event: event[1],\n                                timestamp: event[2],\n                                elements: chainToElements(event[3]),\n                                properties: {\n                                    $window_id: event[4],\n                                    $current_url: currentUrl,\n                                    $event_type: event[6],\n                                    $pathname: pathname,\n                                },\n                                playerTime: +dayjs(event[2]) - +start,\n                                fullyLoaded: false,\n                            }\n                        }\n                    )\n                },\n\n                loadFullEventData: async ({ event }) => {\n                    // box so we're always dealing with a list\n                    const events = Array.isArray(event) ? event : [event]\n\n                    let existingEvents = values.sessionEventsData?.filter((x) => events.some((e) => e.id === x.id))\n\n                    const allEventsAreFullyLoaded =\n                        existingEvents?.every((e) => e.fullyLoaded) && existingEvents.length === events.length\n                    if (!existingEvents || allEventsAreFullyLoaded) {\n                        return values.sessionEventsData\n                    }\n\n                    existingEvents = existingEvents.filter((e) => !e.fullyLoaded)\n                    const timestamps = existingEvents.map((ee) => dayjs(ee.timestamp).utc().valueOf())\n                    const eventNames = Array.from(new Set(existingEvents.map((ee) => ee.event)))\n                    const eventIds = existingEvents.map((ee) => ee.id)\n                    const earliestTimestamp = timestamps.reduce((a, b) => Math.min(a, b))\n                    const latestTimestamp = timestamps.reduce((a, b) => Math.max(a, b))\n\n                    try {\n                        const query: HogQLQuery = {\n                            kind: NodeKind.HogQLQuery,\n                            query: hogql`SELECT properties, uuid\n                                         FROM events\n                                        -- the timestamp range here is only to avoid querying too much of the events table\n                                        -- we don't really care about the absolute value,\n                                        -- but we do care about whether timezones have an odd impact\n                                        -- so, we extend the range by a day on each side so that timezones don't cause issues\n                                         WHERE timestamp > ${dayjs(earliestTimestamp).subtract(1, 'day')}\n                                           AND timestamp < ${dayjs(latestTimestamp).add(1, 'day')}\n                                           AND event in ${eventNames}\n                                           AND uuid in ${eventIds}`,\n                        }\n\n                        const response = await api.query(query)\n                        if (response.error) {\n                            throw new Error(response.error)\n                        }\n\n                        for (const event of existingEvents) {\n                            const result = response.results.find((x: any) => {\n                                return x[1] === event.id\n                            })\n\n                            if (result) {\n                                event.properties = JSON.parse(result[0])\n                                event.fullyLoaded = true\n                            }\n                        }\n                    } catch (e) {\n                        // NOTE: This is not ideal but should happen so rarely that it is tolerable.\n                        existingEvents.forEach((e) => (e.fullyLoaded = true))\n                        captureException(e, {\n                            tags: { feature: 'session-recording-load-full-event-data' },\n                        })\n                    }\n\n                    // here we map the events list because we want the result to be a new instance to trigger downstream recalculation\n                    return !values.sessionEventsData\n                        ? values.sessionEventsData\n                        : values.sessionEventsData.map((x) => {\n                              const event = existingEvents?.find((ee) => ee.id === x.id)\n                              return event\n                                  ? ({\n                                        ...x,\n                                        properties: event.properties,\n                                        fullyLoaded: event.fullyLoaded,\n                                    } as RecordingEventType)\n                                  : x\n                          })\n                },\n            },\n        ],\n    })),\n    listeners(({ values, actions, cache, props }) => ({\n        loadSnapshots: () => {\n            // This kicks off the loading chain\n            if (!values.snapshotSourcesLoading) {\n                actions.loadSnapshotSources()\n            }\n        },\n        maybeLoadRecordingMeta: () => {\n            if (!values.sessionPlayerMetaDataLoading) {\n                actions.loadRecordingMeta()\n            }\n            if (!values.sessionCommentsLoading) {\n                actions.loadRecordingComments()\n            }\n        },\n        loadSnapshotSources: () => {\n            // We only load events once we actually start loading the recording\n            actions.loadEvents()\n        },\n        loadRecordingMetaSuccess: () => {\n            cache.metadataLoadDuration = Math.round(performance.now() - cache.metaStartTime)\n            actions.reportUsageIfFullyLoaded()\n        },\n        loadRecordingMetaFailure: () => {\n            cache.metadataLoadDuration = Math.round(performance.now() - cache.metaStartTime)\n        },\n\n        loadSnapshotSourcesSuccess: () => {\n            // When we receive the list of sources we can kick off the loading chain\n            actions.loadNextSnapshotSource()\n        },\n\n        loadSnapshotsForSourceSuccess: ({ snapshotsForSource }) => {\n            const sources = values.snapshotSources\n            const snapshots = snapshotsForSource.snapshots\n\n            // Cache the last response count to detect if we're getting the same data over and over\n            const newSnapshotsCount = snapshots.length\n\n            if ((cache.lastSnapshotsCount ?? newSnapshotsCount) === newSnapshotsCount) {\n                // if we're getting no results from realtime polling we can increment faster\n                // so that we stop polling sooner\n                const increment = newSnapshotsCount === 0 ? 2 : 1\n                cache.lastSnapshotsUnchangedCount = (cache.lastSnapshotsUnchangedCount ?? 0) + increment\n            } else {\n                cache.lastSnapshotsUnchangedCount = 0\n            }\n            cache.lastSnapshotsCount = newSnapshotsCount\n\n            if (!snapshots.length && sources?.length === 1) {\n                // We got only a single source to load, loaded it successfully, but it had no snapshots.\n                posthog.capture('recording_snapshots_v2_empty_response', {\n                    source: sources[0],\n                })\n            } else if (!cache.firstPaintDuration) {\n                cache.firstPaintDuration = Math.round(performance.now() - cache.snapshotsStartTime)\n            }\n            if (!values.wasMarkedViewed) {\n                actions.markViewed()\n            }\n\n            actions.loadNextSnapshotSource()\n        },\n\n        loadNextSnapshotSource: () => {\n            const nextSourceToLoad = values.snapshotSources?.find((s) => {\n                const sourceKey = getSourceKey(s)\n                return !values.snapshotsBySource?.[sourceKey]\n            })\n\n            if (nextSourceToLoad) {\n                return actions.loadSnapshotsForSource(nextSourceToLoad)\n            }\n\n            if (values.snapshotSources?.find((s) => s.source === SnapshotSourceType.blob_v2)) {\n                actions.loadSnapshotSources(DEFAULT_V2_POLLING_INTERVAL_MS)\n            }\n\n            // TODO: Move this to a one time check - only report once per recording\n            cache.snapshotsLoadDuration = Math.round(performance.now() - cache.snapshotsStartTime)\n            actions.reportUsageIfFullyLoaded()\n\n            // If we have a realtime source, start polling it\n            const realTimeSource = values.snapshotSources?.find((s) => s.source === SnapshotSourceType.realtime)\n            if (realTimeSource) {\n                actions.pollRealtimeSnapshots()\n            }\n        },\n        loadSnapshotsForSourceFailure: () => {\n            cache.snapshotsLoadDuration = Math.round(performance.now() - cache.snapshotsStartTime)\n        },\n        pollRealtimeSnapshots: () => {\n            // always make sure we've cleared up the last timeout\n            clearTimeout(cache.realTimePollingTimeoutID)\n            cache.realTimePollingTimeoutID = null\n\n            // ten is an arbitrary limit to try to avoid sending requests to our backend unnecessarily\n            // we could change this or add to it e.g. only poll if browser is visible to user\n            if ((cache.lastSnapshotsUnchangedCount ?? 0) <= 10) {\n                cache.realTimePollingTimeoutID = setTimeout(() => {\n                    actions.loadSnapshotsForSource({ source: SnapshotSourceType.realtime })\n                }, props.realTimePollingIntervalMilliseconds || DEFAULT_REALTIME_POLLING_MILLIS)\n            } else {\n                actions.stopRealtimePolling()\n            }\n        },\n        loadEventsSuccess: () => {\n            cache.eventsLoadDuration = Math.round(performance.now() - cache.eventsStartTime)\n            actions.reportUsageIfFullyLoaded()\n        },\n        loadEventsFailure: () => {\n            cache.eventsLoadDuration = Math.round(performance.now() - cache.eventsStartTime)\n        },\n        reportUsageIfFullyLoaded: (_, breakpoint) => {\n            breakpoint()\n            if (values.fullyLoaded) {\n                eventUsageLogic.actions.reportRecording(\n                    values.sessionPlayerData,\n                    generateRecordingReportDurations(cache),\n                    SessionRecordingUsageType.LOADED,\n                    values.sessionPlayerMetaData,\n                    0\n                )\n                // Reset cache now that final usage report has been sent\n                resetTimingsCache(cache)\n            }\n        },\n        markViewed: async ({ delay }, breakpoint) => {\n            const durations = generateRecordingReportDurations(cache)\n            // Triggered on first paint\n            breakpoint()\n            if (values.wasMarkedViewed) {\n                return\n            }\n            actions.setWasMarkedViewed(true) // this prevents us from calling the function multiple times\n\n            await breakpoint(IS_TEST_MODE ? 1 : delay ?? 3000)\n            await api.recordings.update(props.sessionRecordingId, {\n                viewed: true,\n                player_metadata: values.sessionPlayerMetaData,\n                durations,\n            })\n            await breakpoint(IS_TEST_MODE ? 1 : 10000)\n            await api.recordings.update(props.sessionRecordingId, {\n                analyzed: true,\n                player_metadata: values.sessionPlayerMetaData,\n                durations,\n            })\n        },\n\n        maybePersistRecording: () => {\n            if (values.sessionPlayerMetaDataLoading) {\n                return\n            }\n\n            if (values.sessionPlayerMetaData?.storage === 'object_storage') {\n                actions.persistRecording()\n            }\n        },\n    })),\n    selectors(({ cache }) => ({\n        webVitalsEvents: [\n            (s) => [s.sessionEventsData],\n            (sessionEventsData): RecordingEventType[] =>\n                (sessionEventsData || []).filter((e) => e.event === '$web_vitals'),\n        ],\n        AIEvents: [\n            (s) => [s.sessionEventsData],\n            (sessionEventsData): RecordingEventType[] =>\n                // see if event start with $ai_\n                (sessionEventsData || []).filter((e) => e.event.startsWith('$ai_')),\n        ],\n        windowIdForTimestamp: [\n            (s) => [s.segments],\n            (segments) =>\n                (timestamp: number): string | undefined => {\n                    return segments.find(\n                        (segment) => segment.startTimestamp <= timestamp && segment.endTimestamp >= timestamp\n                    )?.windowId\n                },\n        ],\n\n        sessionPlayerData: [\n            (s, p) => [\n                s.sessionPlayerMetaData,\n                s.snapshotsByWindowId,\n                s.segments,\n                s.bufferedToTime,\n                s.start,\n                s.end,\n                s.durationMs,\n                s.fullyLoaded,\n                p.sessionRecordingId,\n            ],\n            (\n                meta,\n                snapshotsByWindowId,\n                segments,\n                bufferedToTime,\n                start,\n                end,\n                durationMs,\n                fullyLoaded,\n                sessionRecordingId\n            ): SessionPlayerData => ({\n                person: meta?.person ?? null,\n                start,\n                end,\n                durationMs,\n                snapshotsByWindowId,\n                segments,\n                bufferedToTime,\n                fullyLoaded,\n                sessionRecordingId,\n            }),\n        ],\n\n        snapshotsLoading: [\n            (s) => [s.snapshotSourcesLoading, s.snapshotsForSourceLoading, s.snapshots, s.featureFlags],\n            (\n                snapshotSourcesLoading: boolean,\n                snapshotsForSourceLoading: boolean,\n                snapshots: RecordingSnapshot[],\n                featureFlags: FeatureFlagsSet\n            ): boolean => {\n                // For v2 recordings, only show loading if we have no snapshots yet\n                if (featureFlags[FEATURE_FLAGS.RECORDINGS_BLOBBY_V2_REPLAY]) {\n                    return snapshots.length === 0\n                }\n\n                // Default behavior for non-v2 recordings\n                // if there's a realTimePollingTimeoutID, don't signal that we're loading\n                // we don't want the UI to flip to \"loading\" every time we poll\n                return !cache.realTimePollingTimeoutID && (snapshotSourcesLoading || snapshotsForSourceLoading)\n            },\n        ],\n\n        snapshotsLoaded: [(s) => [s.snapshotSources], (snapshotSources): boolean => !!snapshotSources],\n\n        fullyLoaded: [\n            (s) => [s.snapshots, s.sessionPlayerMetaDataLoading, s.snapshotsLoading, s.sessionEventsDataLoading],\n            (snapshots, sessionPlayerMetaDataLoading, snapshotsLoading, sessionEventsDataLoading): boolean => {\n                // TODO: Do a proper check for all sources having been loaded\n                return (\n                    !!snapshots.length &&\n                    !sessionPlayerMetaDataLoading &&\n                    !snapshotsLoading &&\n                    !sessionEventsDataLoading\n                )\n            },\n        ],\n\n        firstSnapshot: [\n            (s) => [s.snapshots],\n            (snapshots): RecordingSnapshot | null => {\n                return snapshots[0] || null\n            },\n        ],\n\n        lastSnapshot: [\n            (s) => [s.snapshots],\n            (snapshots): RecordingSnapshot | null => {\n                return snapshots[snapshots.length - 1] || null\n            },\n        ],\n\n        start: [\n            (s) => [s.firstSnapshot, s.sessionPlayerMetaData],\n            (firstSnapshot, meta): Dayjs | null => {\n                const eventStart = meta?.start_time ? dayjs(meta.start_time) : null\n                const snapshotStart = firstSnapshot ? dayjs(firstSnapshot.timestamp) : null\n\n                // whichever is earliest\n                if (eventStart && snapshotStart) {\n                    return eventStart.isBefore(snapshotStart) ? eventStart : snapshotStart\n                }\n                return eventStart || snapshotStart\n            },\n        ],\n\n        end: [\n            (s) => [s.lastSnapshot, s.sessionPlayerMetaData],\n            (lastSnapshot, meta): Dayjs | null => {\n                const eventEnd = meta?.end_time ? dayjs(meta.end_time) : null\n                const snapshotEnd = lastSnapshot ? dayjs(lastSnapshot.timestamp) : null\n\n                // whichever is latest\n                if (eventEnd && snapshotEnd) {\n                    return eventEnd.isAfter(snapshotEnd) ? eventEnd : snapshotEnd\n                }\n                return eventEnd || snapshotEnd\n            },\n        ],\n\n        durationMs: [\n            (s) => [s.start, s.end],\n            (start, end): number => {\n                return !!start && !!end ? end.diff(start) : 0\n            },\n        ],\n\n        segments: [\n            (s) => [s.snapshots, s.start, s.end, s.trackedWindow],\n            (snapshots, start, end, trackedWindow): RecordingSegment[] => {\n                return createSegments(snapshots || [], start, end, trackedWindow)\n            },\n        ],\n\n        urls: [\n            (s) => [s.snapshots],\n            (snapshots): { url: string; timestamp: number }[] => {\n                return (\n                    snapshots\n                        .filter((snapshot) => getHrefFromSnapshot(snapshot))\n                        .map((snapshot) => {\n                            return {\n                                url: getHrefFromSnapshot(snapshot) as string,\n                                timestamp: snapshot.timestamp,\n                            }\n                        }) ?? []\n                )\n            },\n        ],\n\n        snapshots: [\n            (s) => [s.snapshotSources, s.snapshotsBySource],\n            (sources, snapshotsBySource): RecordingSnapshot[] => {\n                const allSnapshots =\n                    sources?.flatMap((source) => {\n                        const sourceKey = getSourceKey(source)\n                        return snapshotsBySource?.[sourceKey]?.snapshots || []\n                    }) ?? []\n\n                return deduplicateSnapshots(allSnapshots)\n            },\n        ],\n\n        untransformedSnapshots: [\n            (s) => [s.snapshotSources, s.snapshotsBySource],\n            (sources, snapshotsBySource): RecordingSnapshot[] => {\n                const allSnapshots =\n                    sources?.flatMap((source) => {\n                        const sourceKey = getSourceKey(source)\n                        return snapshotsBySource?.[sourceKey]?.untransformed_snapshots || []\n                    }) ?? []\n\n                return deduplicateSnapshots(allSnapshots)\n            },\n        ],\n\n        snapshotsByWindowId: [\n            (s) => [s.snapshots],\n            (snapshots): Record<string, eventWithTime[]> => {\n                return mapSnapshotsToWindowId(snapshots || [])\n            },\n        ],\n\n        snapshotsInvalid: [\n            (s, p) => [s.snapshotsByWindowId, s.fullyLoaded, s.start, p.sessionRecordingId, s.currentTeam],\n            (snapshotsByWindowId, fullyLoaded, start, sessionRecordingId, currentTeam): boolean => {\n                if (!fullyLoaded || !start) {\n                    return false\n                }\n\n                const windowsHaveFullSnapshot = Object.entries(snapshotsByWindowId).reduce(\n                    (acc, [windowId, events]) => {\n                        acc[`window-id-${windowId}-has-full-snapshot`] = events.some(\n                            (event) => event.type === EventType.FullSnapshot\n                        )\n                        return acc\n                    },\n                    {}\n                )\n                const anyWindowMissingFullSnapshot = !Object.values(windowsHaveFullSnapshot).some((x) => x)\n                const everyWindowMissingFullSnapshot = !Object.values(windowsHaveFullSnapshot).every((x) => x)\n\n                if (everyWindowMissingFullSnapshot) {\n                    // video is definitely unplayable\n                    posthog.capture('recording_has_no_full_snapshot', {\n                        watchedSession: sessionRecordingId,\n                        teamId: currentTeam?.id,\n                        teamName: currentTeam?.name,\n                    })\n                } else if (anyWindowMissingFullSnapshot) {\n                    posthog.capture('recording_window_missing_full_snapshot', {\n                        watchedSession: sessionRecordingId,\n                        teamID: currentTeam?.id,\n                        teamName: currentTeam?.name,\n                    })\n                }\n\n                return everyWindowMissingFullSnapshot\n            },\n        ],\n\n        isRecentAndInvalid: [\n            (s) => [s.start, s.snapshotsInvalid],\n            (start, snapshotsInvalid) => {\n                const lessThanFiveMinutesOld = dayjs().diff(start, 'minute') <= 5\n                return snapshotsInvalid && lessThanFiveMinutesOld\n            },\n        ],\n\n        bufferedToTime: [\n            (s) => [s.segments],\n            (segments): number | null => {\n                if (!segments.length) {\n                    return null\n                }\n\n                const startTime = segments[0].startTimestamp\n                const lastSegment = segments[segments.length - 1]\n\n                if (lastSegment.kind === 'buffer') {\n                    return lastSegment.startTimestamp - startTime\n                }\n\n                return lastSegment.endTimestamp - startTime\n            },\n        ],\n\n        windowIds: [\n            (s) => [s.snapshotsByWindowId],\n            (snapshotsByWindowId) => {\n                return Object.keys(snapshotsByWindowId)\n            },\n        ],\n\n        createExportJSON: [\n            (s) => [s.sessionPlayerMetaData, s.snapshots, s.untransformedSnapshots],\n            (\n                sessionPlayerMetaData,\n                snapshots,\n                untransformedSnapshots\n            ): ((exportUntransformedMobileSnapshotData: boolean) => ExportedSessionRecordingFileV2) => {\n                return (exportUntransformedMobileSnapshotData: boolean) => ({\n                    version: '2023-04-28',\n                    data: {\n                        id: sessionPlayerMetaData?.id ?? '',\n                        person: sessionPlayerMetaData?.person,\n                        snapshots: exportUntransformedMobileSnapshotData ? untransformedSnapshots : snapshots,\n                    },\n                })\n            },\n        ],\n\n        customRRWebEvents: [\n            (s) => [s.snapshots],\n            (snapshots): customEvent[] => {\n                return snapshots.filter((snapshot) => snapshot.type === EventType.Custom).map((x) => x as customEvent)\n            },\n        ],\n    })),\n    subscriptions(({ actions, values }) => ({\n        webVitalsEvents: (value: RecordingEventType[]) => {\n            // we preload all web vitals data, so it can be used before user interaction\n            if (!values.sessionEventsDataLoading) {\n                actions.loadFullEventData(value)\n            }\n        },\n        AIEvents: (value: RecordingEventType[]) => {\n            // we preload all AI  data, so it can be used before user interaction\n            if (value.length > 0) {\n                actions.loadFullEventData(value)\n            }\n        },\n        isRecentAndInvalid: (prev: boolean, next: boolean) => {\n            if (!prev && next) {\n                posthog.capture('recording cannot playback yet', {\n                    watchedSession: values.sessionPlayerData.sessionRecordingId,\n                })\n            }\n        },\n    })),\n    afterMount(({ cache }) => {\n        resetTimingsCache(cache)\n    }),\n    beforeUnmount(({ cache }) => {\n        resetTimingsCache(cache)\n    }),\n])\n","import { kea, key, path, props, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { combineUrl } from 'kea-router'\nimport { colonDelimitedDuration, reverseColonDelimitedDuration } from 'lib/utils'\nimport { urls } from 'scenes/urls'\n\nimport type { playerShareLogicType } from './playerShareLogicType'\n\nexport interface FormWithTime {\n    includeTime: boolean\n    time: string | null\n}\n\nfunction makePrivateLinkQueryParams(formWithTime: FormWithTime): Record<string, string | undefined> {\n    return {\n        t: formWithTime.includeTime ? `${reverseColonDelimitedDuration(formWithTime.time) || 0}` : undefined,\n    }\n}\n\nfunction makePrivateLink(id: string, formWithTime: FormWithTime): string {\n    return combineUrl(\n        urls.absolute(urls.currentProject(urls.replaySingle(id))),\n        makePrivateLinkQueryParams(formWithTime)\n    ).url\n}\n\nexport type PlayerShareLogicProps = {\n    seconds: number | null\n    id: string\n    shareType?: 'private' | 'public' | 'linear'\n}\n\nexport const playerShareLogic = kea<playerShareLogicType>([\n    path(() => ['scenes', 'session-recordings', 'player', 'playerShareLogic']),\n    props({} as PlayerShareLogicProps),\n    key((props: PlayerShareLogicProps) => `${props.id}-${props.seconds}`),\n\n    forms(({ props }) => ({\n        privateLinkForm: {\n            defaults: { includeTime: true, time: colonDelimitedDuration(props.seconds, null) } as FormWithTime,\n            errors: ({ time, includeTime }) => ({\n                time:\n                    time && includeTime && reverseColonDelimitedDuration(time || undefined) === null\n                        ? 'Set a valid time like 02:30 (minutes:seconds)'\n                        : undefined,\n            }),\n            options: {\n                // whether we show errors after touch (true) or submit (false)\n                showErrorsOnTouch: true,\n\n                // show errors even without submitting first\n                alwaysShowErrors: true,\n            },\n        },\n        linearLinkForm: {\n            defaults: {\n                includeTime: true,\n                time: colonDelimitedDuration(props.seconds, null),\n                issueTitle: '',\n                issueDescription: '',\n            } as FormWithTime & {\n                issueTitle: string\n                issueDescription: string\n            },\n            errors: ({ time, includeTime }) => ({\n                time:\n                    time && includeTime && reverseColonDelimitedDuration(time || undefined) === null\n                        ? 'Set a valid time like 02:30 (minutes:seconds)'\n                        : undefined,\n            }),\n            options: {\n                // whether we show errors after touch (true) or submit (false)\n                showErrorsOnTouch: true,\n\n                // show errors even without submitting first\n                alwaysShowErrors: true,\n            },\n        },\n    })),\n\n    selectors(({ props }) => ({\n        privateLinkUrlQueryParams: [\n            (s) => [s.privateLinkForm],\n            (privateLinkForm) => {\n                return makePrivateLinkQueryParams(privateLinkForm)\n            },\n        ],\n        privateLinkUrl: [\n            (s) => [s.privateLinkForm],\n            (privateLinkForm) => {\n                return makePrivateLink(props.id, privateLinkForm)\n            },\n        ],\n        linearQueryParams: [\n            (s) => [s.linearLinkForm],\n            (linearLinkForm) => {\n                return {\n                    title: linearLinkForm.issueTitle,\n                    description:\n                        linearLinkForm.issueDescription +\n                        `\\n\\nPostHog recording: ${makePrivateLink(props.id, linearLinkForm)}`,\n                }\n            },\n        ],\n        linearUrl: [\n            (s) => [s.linearQueryParams],\n            (linearQueryParams) => {\n                return combineUrl('https://linear.app/new', linearQueryParams).url\n            },\n        ],\n    })),\n])\n","import { actions, connect, kea, listeners, path, reducers } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { CORE_FILTER_DEFINITIONS_BY_GROUP } from 'lib/taxonomy'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\nimport { SessionRecordingPropertiesType, SessionRecordingType } from '~/types'\n\nimport type { sessionRecordingsListPropertiesLogicType } from './sessionRecordingsListPropertiesLogicType'\n\n// This logic is used to fetch properties for a list of recordings\n// It is used in a global way as the cached values can be re-used\nexport const sessionRecordingsListPropertiesLogic = kea<sessionRecordingsListPropertiesLogicType>([\n    path(() => ['scenes', 'session-recordings', 'playlist', 'sessionRecordingsListPropertiesLogic']),\n    connect(() => ({\n        actions: [eventUsageLogic, ['reportRecordingsListPropertiesFetched']],\n    })),\n\n    actions({\n        loadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n        maybeLoadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n    }),\n\n    loaders(({ actions }) => ({\n        recordingProperties: [\n            [] as SessionRecordingPropertiesType[],\n            {\n                loadPropertiesForSessions: async ({ sessions }, breakpoint) => {\n                    await breakpoint(100)\n\n                    const startTime = performance.now()\n                    const sessionIds = sessions.map((x) => x.id)\n\n                    const oldestTimestamp = sessions.map((x) => x.start_time).sort()[0]\n                    const newestTimestamp = sessions.map((x) => x.end_time).sort()[sessions.length - 1]\n\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT \n                                    $session_id as session_id, \n                                    any(properties.$geoip_country_code) as $geoip_country_code, \n                                    any(properties.$browser) as $browser, \n                                    any(properties.$device_type) as $device_type, \n                                    any(properties.$os) as $os, \n                                    any(properties.$os_name) as $os_name,\n                                    any(session.$entry_referring_domain) as $entry_referring_domain,\n                                    any(properties.$geoip_subdivision_1_name) as $geoip_subdivision_1_name,\n                                    any(properties.$geoip_city_name) as $geoip_city_name,\n                                    any(session.$entry_current_url) as $entry_current_url\n                                FROM events\n                                WHERE event IN ${Object.keys(CORE_FILTER_DEFINITIONS_BY_GROUP['events'])}\n                                AND session_id IN ${sessionIds}\n                                -- the timestamp range here is only to avoid querying too much of the events table\n                                -- we don't really care about the absolute value, \n                                -- but we do care about whether timezones have an odd impact\n                                -- so, we extend the range by a day on each side so that timezones don't cause issues\n                                AND timestamp >= ${dayjs(oldestTimestamp).subtract(1, 'day')}\n                                AND timestamp <= ${dayjs(newestTimestamp).add(1, 'day')}\n                                GROUP BY session_id`,\n                    }\n\n                    const response = await api.query(query)\n                    const loadTimeMs = performance.now() - startTime\n\n                    actions.reportRecordingsListPropertiesFetched(loadTimeMs)\n\n                    breakpoint()\n                    return (response.results || []).map((x: any): SessionRecordingPropertiesType => {\n                        return {\n                            id: x[0],\n                            properties: {\n                                $geoip_country_code: x[1],\n                                $browser: x[2],\n                                $device_type: x[3],\n                                $os: x[4],\n                                $os_name: x[5],\n                                $entry_referring_domain: x[6],\n                                $geoip_subdivision_1_name: x[7],\n                                $geoip_city_name: x[8],\n                                $entry_current_url: x[9],\n                            },\n                        }\n                    })\n                },\n            },\n        ],\n    })),\n\n    listeners(({ actions, values }) => ({\n        maybeLoadPropertiesForSessions: ({ sessions }) => {\n            const newSessions = sessions.filter((session) => !values.recordingPropertiesById[session.id])\n\n            if (newSessions.length > 0) {\n                actions.loadPropertiesForSessions(newSessions)\n            }\n        },\n    })),\n\n    reducers({\n        recordingPropertiesById: [\n            {} as Record<string, SessionRecordingPropertiesType['properties']>,\n            {\n                loadPropertiesForSessionsSuccess: (\n                    state,\n                    { recordingProperties }\n                ): Record<string, SessionRecordingPropertiesType['properties']> => {\n                    const newState = { ...state }\n                    recordingProperties.forEach((properties) => {\n                        if (properties.properties) {\n                            newState[properties.id] = properties.properties\n                        }\n                    })\n\n                    return newState\n                },\n            },\n        ],\n    }),\n])\n","import { IconEllipsis, IconInfo } from '@posthog/icons'\nimport {\n    LemonBanner,\n    LemonButton,\n    LemonDialog,\n    LemonInput,\n    LemonMenu,\n    LemonTable,\n    LemonTableColumns,\n    LemonTabs,\n    Spinner,\n    Tooltip,\n} from '@posthog/lemon-ui'\nimport clsx from 'clsx'\nimport { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { PayGateMini } from 'lib/components/PayGateMini/PayGateMini'\nimport { payGateMiniLogic } from 'lib/components/PayGateMini/payGateMiniLogic'\nimport { RestrictionScope, useRestrictedArea } from 'lib/components/RestrictedArea'\nimport { OrganizationMembershipLevel } from 'lib/constants'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonMarkdown } from 'lib/lemon-ui/LemonMarkdown'\n\nimport { AvailableFeature } from '~/types'\n\nimport { proxyLogic, ProxyRecord } from './proxyLogic'\n\nconst statusText = {\n    valid: 'live',\n    timed_out: 'timed out',\n}\n\nexport function ManagedReverseProxy(): JSX.Element {\n    const { formState, proxyRecords, proxyRecordsLoading } = useValues(proxyLogic)\n    const { showForm, deleteRecord } = useActions(proxyLogic)\n\n    const restrictionReason = useRestrictedArea({\n        minimumAccessLevel: OrganizationMembershipLevel.Admin,\n        scope: RestrictionScope.Organization,\n    })\n\n    const { featureAvailableOnOrg } = useValues(payGateMiniLogic({ feature: AvailableFeature.MANAGED_REVERSE_PROXY }))\n\n    const maxRecordsReached = proxyRecords.length >= (featureAvailableOnOrg?.limit || 0)\n\n    const recordsWithMessages = proxyRecords.filter((record) => !!record.message)\n\n    const columns: LemonTableColumns<ProxyRecord> = [\n        {\n            title: 'Domain',\n            dataIndex: 'domain',\n        },\n        {\n            title: 'Status',\n            dataIndex: 'status',\n            render: function RenderStatus(status) {\n                if (!status) {\n                    return <span>Unknown</span>\n                }\n\n                return (\n                    <div\n                        className={clsx(\n                            'deprecated-space-x-1',\n                            status === 'valid'\n                                ? 'text-success'\n                                : status == 'erroring'\n                                ? 'text-danger'\n                                : 'text-warning-dark'\n                        )}\n                    >\n                        {status === 'issuing' && <Spinner />}\n                        <span className=\"capitalize\">{statusText[status] || status}</span>\n                        {status === 'waiting' && (\n                            <Tooltip title=\"Waiting for DNS records to be created\">\n                                <IconInfo className=\"cursor-pointer\" />\n                            </Tooltip>\n                        )}\n                        {status === 'timed_out' && (\n                            <Tooltip title=\"Timed out waiting for DNS records to be created. Please delete the record and try again\">\n                                <IconInfo className=\"cursor-pointer\" />\n                            </Tooltip>\n                        )}\n                    </div>\n                )\n            },\n        },\n        {\n            title: <span className=\"h-5\" />,\n            width: 20,\n            className: 'flex justify-center',\n            render: function Render(_, { id, status }) {\n                return (\n                    status != 'deleting' &&\n                    !restrictionReason && (\n                        <LemonMenu\n                            items={[\n                                {\n                                    label: 'Delete',\n                                    status: 'danger',\n                                    onClick: () => {\n                                        LemonDialog.open({\n                                            title: 'Delete managed proxy',\n                                            width: '20rem',\n                                            content:\n                                                'Are you sure you want to delete this managed proxy? This cannot be undone and if it is in use then events sent to the domain will not be processed.',\n                                            primaryButton: {\n                                                status: 'danger',\n                                                onClick: () => deleteRecord(id),\n                                                children: 'Delete',\n                                            },\n                                            secondaryButton: {\n                                                children: 'Cancel',\n                                            },\n                                        })\n                                    },\n                                },\n                            ]}\n                        >\n                            <LemonButton size=\"small\" icon={<IconEllipsis className=\"text-secondary\" />} />\n                        </LemonMenu>\n                    )\n                )\n            },\n        },\n    ]\n\n    return (\n        <PayGateMini feature={AvailableFeature.MANAGED_REVERSE_PROXY}>\n            <div className=\"deprecated-space-y-2\">\n                {recordsWithMessages.map((r) => (\n                    <LemonBanner type=\"warning\" key={r.id}>\n                        <LemonMarkdown>{`**${r.domain}**\\n ${r.message}`}</LemonMarkdown>\n                    </LemonBanner>\n                ))}\n                <LemonTable\n                    loading={proxyRecords.length === 0 && proxyRecordsLoading}\n                    columns={columns}\n                    dataSource={proxyRecords}\n                    expandable={{\n                        expandedRowRender: (record) => <ExpandedRow record={record} />,\n                    }}\n                />\n                {formState === 'collapsed' ? (\n                    maxRecordsReached ? (\n                        <LemonBanner type=\"info\">\n                            There is a maximum of {featureAvailableOnOrg?.limit || 0} records allowed per organization.\n                        </LemonBanner>\n                    ) : (\n                        <div className=\"flex\">\n                            <LemonButton onClick={showForm} type=\"primary\" disabledReason={restrictionReason}>\n                                Add managed proxy\n                            </LemonButton>\n                        </div>\n                    )\n                ) : (\n                    <CreateRecordForm />\n                )}\n            </div>\n        </PayGateMini>\n    )\n}\n\nconst ExpandedRow = ({ record }: { record: ProxyRecord }): JSX.Element => {\n    return (\n        <div className=\"pb-4 pr-4\">\n            <LemonTabs\n                size=\"small\"\n                activeKey=\"cname\"\n                tabs={[\n                    {\n                        label: 'CNAME',\n                        key: 'cname',\n                        content: (\n                            <CodeSnippet key={record.id} language={Language.HTTP}>\n                                {record.target_cname}\n                            </CodeSnippet>\n                        ),\n                    },\n                ]}\n            />\n        </div>\n    )\n}\n\nfunction CreateRecordForm(): JSX.Element {\n    const { formState, proxyRecordsLoading, proxyRecords } = useValues(proxyLogic)\n    const { collapseForm } = useActions(proxyLogic)\n\n    const waitingRecords = proxyRecords.filter((r) => r.status === 'waiting')\n\n    return (\n        <div className=\"bg-surface-primary rounded border px-5 py-4 deprecated-space-y-2\">\n            {formState == 'active' ? (\n                <Form\n                    logic={proxyLogic}\n                    formKey=\"createRecord\"\n                    enableFormOnSubmit\n                    className=\"w-full deprecated-space-y-2\"\n                >\n                    <LemonField name=\"domain\">\n                        <LemonInput\n                            autoFocus\n                            placeholder=\"Enter a domain (e.g. ph.mydomain.com)\"\n                            data-attr=\"domain-input\"\n                        />\n                    </LemonField>\n                    <div className=\"flex justify-end gap-2\">\n                        <LemonButton\n                            type=\"secondary\"\n                            onClick={collapseForm}\n                            disabledReason={proxyRecordsLoading ? 'Saving' : undefined}\n                        >\n                            Cancel\n                        </LemonButton>\n                        <LemonButton\n                            htmlType=\"submit\"\n                            type=\"primary\"\n                            data-attr=\"domain-save\"\n                            loading={proxyRecordsLoading}\n                        >\n                            Add\n                        </LemonButton>\n                    </div>\n                </Form>\n            ) : (\n                <>\n                    <div className=\"text-xl font-semibold leading-tight\">Almost there</div>\n                    <div>\n                        You need to set the following <b>CNAME</b> records in your DNS provider:\n                    </div>\n                    {waitingRecords.map((r) => (\n                        <div key={r.id} className=\"deprecated-space-y-1\">\n                            <span className=\"font-semibold\">{r.domain}</span>\n                            <CodeSnippet key={r.id} language={Language.HTTP}>\n                                {r.target_cname}\n                            </CodeSnippet>\n                        </div>\n                    ))}\n                    <div className=\"flex justify-end\">\n                        <LemonButton onClick={collapseForm} type=\"primary\">\n                            Done\n                        </LemonButton>\n                    </div>\n                </>\n            )}\n        </div>\n    )\n}\n","import { Link } from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { Form } from 'kea-forms'\nimport { CopyToClipboardInline } from 'lib/components/CopyToClipboard'\nimport { LemonBanner } from 'lib/lemon-ui/LemonBanner'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { LemonInput } from 'lib/lemon-ui/LemonInput/LemonInput'\nimport { LemonModal } from 'lib/lemon-ui/LemonModal'\nimport { LemonTextArea } from 'lib/lemon-ui/LemonTextArea/LemonTextArea'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\n\nimport { verifiedDomainsLogic } from './verifiedDomainsLogic'\n\nexport function ConfigureSAMLModal(): JSX.Element {\n    const { configureSAMLModalId, isSamlConfigSubmitting, samlConfig } = useValues(verifiedDomainsLogic)\n    const { setConfigureSAMLModalId } = useActions(verifiedDomainsLogic)\n    const { preflight } = useValues(preflightLogic)\n    const siteUrl = preflight?.site_url ?? window.location.origin\n\n    const samlReady = samlConfig.saml_acs_url && samlConfig.saml_entity_id && samlConfig.saml_x509_cert\n\n    const handleClose = (): void => {\n        setConfigureSAMLModalId(null)\n        // clean()\n    }\n\n    return (\n        <LemonModal onClose={handleClose} isOpen={!!configureSAMLModalId} title=\"\" simple>\n            <Form logic={verifiedDomainsLogic} formKey=\"samlConfig\" enableFormOnSubmit className=\"LemonModal__layout \">\n                <LemonModal.Header>\n                    <h3>Configure SAML authentication and provisioning</h3>\n                </LemonModal.Header>\n                <LemonModal.Content className=\"deprecated-space-y-2\">\n                    <p>\n                        <Link to=\"https://posthog.com/docs/data/sso#setting-up-saml\" target=\"_blank\" targetBlankIcon>\n                            Read the docs\n                        </Link>\n                    </p>\n                    <LemonField label=\"ACS Consumer URL\" name=\"_ACSConsumerUrl\">\n                        <CopyToClipboardInline>{`${siteUrl}/complete/saml/`}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField label=\"RelayState\" name=\"_RelayState\">\n                        <CopyToClipboardInline>{configureSAMLModalId || 'unknown'}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField label=\"Audience / Entity ID\" name=\"_Audience\">\n                        <CopyToClipboardInline>{siteUrl}</CopyToClipboardInline>\n                    </LemonField>\n                    <LemonField name=\"saml_acs_url\" label=\"SAML ACS URL\">\n                        <LemonInput className=\"ph-ignore-input\" placeholder=\"Your IdP's ACS or single sign-on URL.\" />\n                    </LemonField>\n                    <LemonField name=\"saml_entity_id\" label=\"SAML Entity ID\">\n                        <LemonInput className=\"ph-ignore-input\" placeholder=\"Entity ID provided by your IdP.\" />\n                    </LemonField>\n                    <LemonField name=\"saml_x509_cert\" label=\"SAML X.509 Certificate\">\n                        <LemonTextArea\n                            className=\"ph-ignore-input\"\n                            minRows={10}\n                            placeholder={`Enter the public certificate of your IdP. Keep all line breaks.\\n-----BEGIN CERTIFICATE-----\\nMIICVjCCAb+gAwIBAgIBADANBgkqhkiG9w0BAQ0FADBIMQswCQYDVQQGEwJ1czEL\\n-----END CERTIFICATE-----`}\n                        />\n                    </LemonField>\n                    {!samlReady && (\n                        <LemonBanner type=\"info\">\n                            SAML will not be enabled unless you enter all attributes above. However you can still\n                            settings as draft.\n                        </LemonBanner>\n                    )}\n                </LemonModal.Content>\n                <LemonModal.Footer>\n                    <LemonButton loading={isSamlConfigSubmitting} type=\"primary\" htmlType=\"submit\">\n                        Save settings\n                    </LemonButton>\n                </LemonModal.Footer>\n            </Form>\n        </LemonModal>\n    )\n}\n","import { LemonButton, LemonDivider, LemonModal } from '@posthog/lemon-ui'\nimport { useValues } from 'kea'\nimport { router } from 'kea-router'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport { IconOpenInNew } from 'lib/lemon-ui/icons'\nimport { surveyLogic } from 'scenes/surveys/surveyLogic'\nimport { urls } from 'scenes/urls'\n\nimport { NodeKind } from '~/queries/schema/schema-general'\nimport { Survey, SurveyQuestion } from '~/types'\n\nimport { createAnswerFilterHogQLExpression, getResponseFieldCondition } from './utils'\n\ninterface SurveySQLHelperProps {\n    isOpen: boolean\n    onClose: () => void\n}\n\nexport function SurveySQLHelper({ isOpen, onClose }: SurveySQLHelperProps): JSX.Element {\n    const { survey, answerFilters } = useValues(surveyLogic)\n\n    const filterConditions = createAnswerFilterHogQLExpression(answerFilters, survey as Survey)\n\n    const generateSingleQuestionQuery = (question: SurveyQuestion, index: number): string => {\n        return `SELECT\n    distinct_id,\n    ${getResponseFieldCondition(index, question.id)} AS \"${question.question}\",\n    timestamp\nFROM\n    events\nWHERE\n    event = 'survey sent'\n    AND properties.$survey_id = '${survey.id}' ${filterConditions ? '\\n' + filterConditions : ''}\nORDER BY\n    timestamp DESC\nLIMIT\n    100`\n    }\n\n    const generateFullSurveyQuery = (): string => {\n        const questionSelects = survey.questions\n            .map((question: SurveyQuestion, index: number) => {\n                return `    ${getResponseFieldCondition(index, question.id)} AS \"${question.question}\"`\n            })\n            .join(',\\n')\n\n        return `SELECT\n    distinct_id,\n${questionSelects},\n    timestamp\nFROM\n    events\nWHERE\n    event = 'survey sent'\n    AND properties.$survey_id = '${survey.id}' ${filterConditions ? '\\n' + filterConditions : ''}\nORDER BY\n    timestamp DESC\nLIMIT\n    100`\n    }\n\n    // Function to open query in a new insight\n    const openInInsight = (query: string): void => {\n        const insightQuery = {\n            kind: NodeKind.DataTableNode,\n            full: true,\n            source: {\n                kind: NodeKind.HogQLQuery,\n                query: query,\n            },\n        }\n        router.actions.push(urls.insightNew({ query: insightQuery }))\n    }\n\n    return (\n        <LemonModal\n            isOpen={isOpen}\n            onClose={onClose}\n            title=\"SQL Query Helper\"\n            description={\n                <div className=\"flex flex-col gap-1 text-sm text-muted\">\n                    <p>\n                        <b>Important:</b> Since March 7, 2024, survey responses are stored using question IDs\n                        ([UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)) instead of indexes. The\n                        queries below handle both formats using the <code>coalesce</code> function.\n                    </p>\n                    <p>\n                        <b>Note:</b> These queries only include response filters set on the table. Additional property\n                        filters like cohorts, user properties, etc. are not included.\n                    </p>\n                </div>\n            }\n            width={800}\n        >\n            <div className=\"flex flex-col gap-2\">\n                <div className=\"flex flex-col gap-1\">\n                    <h4>Full Survey Query</h4>\n                    <p className=\"text-sm text-muted\">Returns all questions for this survey.</p>\n                    <CodeSnippet\n                        language={Language.SQL}\n                        compact\n                        actions={\n                            <LemonButton\n                                icon={<IconOpenInNew />}\n                                size=\"small\"\n                                onClick={() => openInInsight(generateFullSurveyQuery())}\n                                tooltip=\"Open as new insight\"\n                                noPadding\n                            />\n                        }\n                    >\n                        {generateFullSurveyQuery()}\n                    </CodeSnippet>\n                </div>\n\n                <LemonDivider />\n\n                <div className=\"flex flex-col gap-2\">\n                    <h4>Individual Question Queries</h4>\n                    <p className=\"text-sm text-muted\">Returns responses for individual questions.</p>\n\n                    <div className=\"flex flex-col gap-1\">\n                        {survey.questions.map((question: SurveyQuestion, index: number) => (\n                            <div key={question.id || index} className=\"flex flex-col gap-2\">\n                                <h5>{question.question}</h5>\n                                <CodeSnippet\n                                    language={Language.SQL}\n                                    compact\n                                    actions={\n                                        <LemonButton\n                                            icon={<IconOpenInNew />}\n                                            size=\"small\"\n                                            onClick={() => openInInsight(generateSingleQuestionQuery(question, index))}\n                                            tooltip=\"Open as new insight\"\n                                            noPadding\n                                        />\n                                    }\n                                >\n                                    {generateSingleQuestionQuery(question, index)}\n                                </CodeSnippet>\n                            </div>\n                        ))}\n                    </div>\n                </div>\n            </div>\n        </LemonModal>\n    )\n}\n","import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, afterMount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl, router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { featureFlagLogic as enabledFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { allOperatorsMapping, debounce, hasFormErrors, isObject } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { Scene } from 'scenes/sceneTypes'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { activationLogic, ActivationTask } from '~/layout/navigation-3000/sidepanel/panels/activation/activationLogic'\nimport { CompareFilter, DataTableNode, HogQLQuery, InsightVizNode, NodeKind } from '~/queries/schema/schema-general'\nimport {\n    AnyPropertyFilter,\n    BaseMathType,\n    Breadcrumb,\n    EventPropertyFilter,\n    FeatureFlagFilters,\n    IntervalType,\n    MultipleSurveyQuestion,\n    PropertyFilterType,\n    PropertyOperator,\n    RatingSurveyQuestion,\n    Survey,\n    SurveyMatchType,\n    SurveyQuestionBase,\n    SurveyQuestionBranchingType,\n    SurveyQuestionType,\n    SurveySchedule,\n} from '~/types'\n\nimport { defaultSurveyAppearance, defaultSurveyFieldValues, NEW_SURVEY, NewSurvey } from './constants'\nimport type { surveyLogicType } from './surveyLogicType'\nimport { surveysLogic } from './surveysLogic'\nimport {\n    calculateNpsBreakdown,\n    calculateNpsScore,\n    createAnswerFilterHogQLExpression,\n    getResponseFieldWithId,\n    sanitizeHTML,\n    sanitizeSurveyAppearance,\n    validateColor,\n} from './utils'\n\nconst DEFAULT_OPERATORS: Record<SurveyQuestionType, { label: string; value: PropertyOperator }> = {\n    [SurveyQuestionType.Open]: {\n        label: allOperatorsMapping[PropertyOperator.IContains],\n        value: PropertyOperator.IContains,\n    },\n    [SurveyQuestionType.Rating]: {\n        label: allOperatorsMapping[PropertyOperator.Exact],\n        value: PropertyOperator.Exact,\n    },\n    [SurveyQuestionType.SingleChoice]: {\n        label: allOperatorsMapping[PropertyOperator.Exact],\n        value: PropertyOperator.Exact,\n    },\n    [SurveyQuestionType.MultipleChoice]: {\n        label: allOperatorsMapping[PropertyOperator.IContains],\n        value: PropertyOperator.IContains,\n    },\n    [SurveyQuestionType.Link]: {\n        label: allOperatorsMapping[PropertyOperator.Exact],\n        value: PropertyOperator.Exact,\n    },\n}\n\nexport enum SurveyEditSection {\n    Steps = 'steps',\n    Widget = 'widget',\n    Presentation = 'presentation',\n    Appearance = 'appearance',\n    Customization = 'customization',\n    DisplayConditions = 'DisplayConditions',\n    Scheduling = 'scheduling',\n    CompletionConditions = 'CompletionConditions',\n}\nexport interface SurveyLogicProps {\n    /** Either a UUID or 'new'. */\n    id: string\n}\n\nexport interface SurveyMetricsQueries {\n    surveysShown: DataTableNode\n    surveysDismissed: DataTableNode\n}\n\nexport interface SurveyUserStats {\n    seen: number\n    dismissed: number\n    sent: number\n}\n\nexport interface SurveyRatingResults {\n    [key: number]: {\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveyRecurringNPSResults {\n    [key: number]: {\n        data: number[]\n        total: number\n    }\n}\n\ntype SurveyNPSResult = {\n    Promoters: number\n    Detractors: number\n    Passives: number\n}\n\nexport interface SurveySingleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveyMultipleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n    }\n}\n\nexport interface SurveyOpenTextResults {\n    [key: number]: {\n        events: { distinct_id: string; properties: Record<string, any>; personProperties: Record<string, any> }[]\n    }\n}\n\nexport interface QuestionResultsReady {\n    [key: string]: boolean\n}\n\nexport type DataCollectionType = 'until_stopped' | 'until_limit' | 'until_adaptive_limit'\n\nexport interface SurveyDateRange {\n    date_from: string | null\n    date_to: string | null\n}\n\n// Helper function to generate the HogQL condition for checking survey responses in both formats\nconst getResponseFieldCondition = (questionIndex: number, questionId?: string): string => {\n    const ids = getResponseFieldWithId(questionIndex, questionId)\n\n    if (!ids.idBasedKey) {\n        return `JSONExtractString(properties, '${ids.indexBasedKey}')`\n    }\n\n    // For ClickHouse, we need to use coalesce to check both fields\n    // This will return the first non-null value, prioritizing the ID-based format if available\n    return `coalesce(\n        nullIf(JSONExtractString(properties, '${ids.idBasedKey}'), ''),\n        nullIf(JSONExtractString(properties, '${ids.indexBasedKey}'), '')\n    )`\n}\n\n// Helper function to generate the HogQL condition for checking multiple choice survey responses in both formats\nconst getMultipleChoiceResponseFieldCondition = (questionIndex: number, questionId?: string): string => {\n    const ids = getResponseFieldWithId(questionIndex, questionId)\n\n    if (!ids.idBasedKey) {\n        return `JSONExtractArrayRaw(properties, '${ids.indexBasedKey}')`\n    }\n\n    // For multiple choice, we need to check if either field has a value and use that one\n    return `if(\n        JSONHas(properties, '${ids.idBasedKey}') AND length(JSONExtractArrayRaw(properties, '${ids.idBasedKey}')) > 0,\n        JSONExtractArrayRaw(properties, '${ids.idBasedKey}'),\n        JSONExtractArrayRaw(properties, '${ids.indexBasedKey}')\n    )`\n}\n\nfunction duplicateExistingSurvey(survey: Survey | NewSurvey): Partial<Survey> {\n    return {\n        ...survey,\n        questions: survey.questions.map((question) => ({\n            ...question,\n            id: undefined,\n        })),\n        id: NEW_SURVEY.id,\n        name: `${survey.name} (copy)`,\n        archived: false,\n        start_date: null,\n        end_date: null,\n        targeting_flag_filters: survey.targeting_flag?.filters ?? NEW_SURVEY.targeting_flag_filters,\n        linked_flag_id: survey.linked_flag?.id ?? NEW_SURVEY.linked_flag_id,\n    }\n}\n\nconst DATE_FORMAT = 'YYYY-MM-DDTHH:mm:ss'\n\nfunction getSurveyStartDateForQuery(survey: Survey): string {\n    return survey.start_date\n        ? dayjs(survey.start_date).startOf('day').format(DATE_FORMAT)\n        : dayjs(survey.created_at).startOf('day').format(DATE_FORMAT)\n}\n\nfunction getSurveyEndDateForQuery(survey: Survey): string {\n    return survey.end_date\n        ? dayjs(survey.end_date).endOf('day').format(DATE_FORMAT)\n        : dayjs().endOf('day').format(DATE_FORMAT)\n}\n\nexport const surveyLogic = kea<surveyLogicType>([\n    props({} as SurveyLogicProps),\n    key(({ id }) => id),\n    path((key) => ['scenes', 'surveys', 'surveyLogic', key]),\n    connect(() => ({\n        actions: [\n            surveysLogic,\n            ['loadSurveys'],\n            eventUsageLogic,\n            [\n                'reportSurveyCreated',\n                'reportSurveyEdited',\n                'reportSurveyArchived',\n                'reportSurveyViewed',\n                'reportSurveyCycleDetected',\n            ],\n        ],\n        values: [enabledFlagLogic, ['featureFlags as enabledFlags'], surveysLogic, ['data']],\n    })),\n    actions({\n        setSurveyMissing: true,\n        editingSurvey: (editing: boolean) => ({ editing }),\n        setDefaultForQuestionType: (\n            idx: number,\n            type: SurveyQuestionType,\n            isEditingQuestion: boolean,\n            isEditingDescription: boolean,\n            isEditingThankYouMessage: boolean\n        ) => ({\n            idx,\n            type,\n            isEditingQuestion,\n            isEditingDescription,\n            isEditingThankYouMessage,\n        }),\n        setQuestionBranchingType: (questionIndex, type, specificQuestionIndex) => ({\n            questionIndex,\n            type,\n            specificQuestionIndex,\n        }),\n        setResponseBasedBranchingForQuestion: (questionIndex, responseValue, nextStep, specificQuestionIndex) => ({\n            questionIndex,\n            responseValue,\n            nextStep,\n            specificQuestionIndex,\n        }),\n        setDataCollectionType: (dataCollectionType: DataCollectionType) => ({\n            dataCollectionType,\n        }),\n        resetBranchingForQuestion: (questionIndex) => ({ questionIndex }),\n        deleteBranchingLogic: true,\n        archiveSurvey: true,\n        setWritingHTMLDescription: (writingHTML: boolean) => ({ writingHTML }),\n        setSurveyTemplateValues: (template: Partial<NewSurvey>) => ({ template }),\n        setSelectedPageIndex: (idx: number | null) => ({ idx }),\n        setSelectedSection: (section: SurveyEditSection | null) => ({ section }),\n        resetTargeting: true,\n        resetSurveyAdaptiveSampling: true,\n        resetSurveyResponseLimits: true,\n        setFlagPropertyErrors: (errors: any) => ({ errors }),\n        setPropertyFilters: (propertyFilters: AnyPropertyFilter[]) => ({ propertyFilters }),\n        setAnswerFilters: (filters: EventPropertyFilter[], reloadResults: boolean = true) => ({\n            filters,\n            reloadResults,\n        }),\n        setDateRange: (dateRange: SurveyDateRange) => ({ dateRange }),\n        setInterval: (interval: IntervalType) => ({ interval }),\n        setCompareFilter: (compareFilter: CompareFilter | null) => ({ compareFilter }),\n    }),\n    loaders(({ props, actions, values }) => ({\n        responseSummary: {\n            summarize: async ({ questionIndex }: { questionIndex?: number }) => {\n                return api.surveys.summarize_responses(props.id, questionIndex)\n            },\n        },\n        survey: {\n            loadSurvey: async () => {\n                if (props.id && props.id !== 'new') {\n                    try {\n                        const survey = await api.surveys.get(props.id)\n                        actions.reportSurveyViewed(survey)\n                        // Initialize answer filters for all questions - first for index-based, then for id-based\n                        actions.setAnswerFilters(\n                            survey.questions.map((question, index) => ({\n                                key: getResponseFieldWithId(index, question?.id).indexBasedKey,\n                                operator: DEFAULT_OPERATORS[question.type].value,\n                                type: PropertyFilterType.Event as const,\n                                value: [],\n                            })),\n                            false\n                        )\n                        return survey\n                    } catch (error: any) {\n                        if (error.status === 404) {\n                            actions.setSurveyMissing()\n                            return { ...NEW_SURVEY }\n                        }\n                        throw error\n                    }\n                }\n                if (props.id === 'new' && router.values.hashParams.fromTemplate) {\n                    const templatedSurvey = values.survey\n                    templatedSurvey.appearance = {\n                        ...defaultSurveyAppearance,\n                        ...teamLogic.values.currentTeam?.survey_config?.appearance,\n                        ...templatedSurvey.appearance,\n                    }\n                    return templatedSurvey\n                }\n\n                const newSurvey = NEW_SURVEY\n                newSurvey.appearance = {\n                    ...defaultSurveyAppearance,\n                    ...teamLogic.values.currentTeam?.survey_config?.appearance,\n                    ...newSurvey.appearance,\n                }\n\n                return newSurvey\n            },\n            createSurvey: async (surveyPayload: Partial<Survey>) => {\n                return await api.surveys.create(sanitizeQuestions(surveyPayload))\n            },\n            updateSurvey: async (surveyPayload: Partial<Survey>) => {\n                return await api.surveys.update(props.id, sanitizeQuestions(surveyPayload))\n            },\n            launchSurvey: async () => {\n                const startDate = dayjs()\n                return await api.surveys.update(props.id, { start_date: startDate.toISOString() })\n            },\n            stopSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: dayjs().toISOString() })\n            },\n            resumeSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: null })\n            },\n        },\n        duplicatedSurvey: {\n            duplicateSurvey: async () => {\n                const { survey } = values\n                const payload = duplicateExistingSurvey(survey)\n                const createdSurvey = await api.surveys.create(sanitizeQuestions(payload))\n\n                lemonToast.success('Survey duplicated.', {\n                    toastId: `survey-duplicated-${createdSurvey.id}`,\n                    button: {\n                        label: 'View Survey',\n                        action: () => {\n                            router.actions.push(urls.survey(createdSurvey.id))\n                        },\n                    },\n                })\n\n                actions.reportSurveyCreated(createdSurvey, true)\n                return survey\n            },\n        },\n        surveyUserStats: {\n            loadSurveyUserStats: async (): Promise<SurveyUserStats> => {\n                const survey: Survey = values.survey as Survey\n                const startDate = getSurveyStartDateForQuery(survey)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                const answerFilter = createAnswerFilterHogQLExpression(values.answerFilters, survey)\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        -- QUERYING SURVEY USER STATS\n                        SELECT\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey shown'\n                                    AND properties.$survey_id = '${props.id}'\n                                    AND timestamp >= '${startDate}'\n                                    AND timestamp <= '${endDate}'\n                                    ${answerFilter !== '' ? answerFilter : ''}\n                                    AND {filters}),\n                                    (SELECT COUNT(DISTINCT person_id)\n                                    FROM events\n                                    WHERE event = 'survey dismissed'\n                                    AND properties.$survey_id = '${props.id}'\n                                    AND timestamp >= '${startDate}'\n                                    AND timestamp <= '${endDate}'\n                                    ${answerFilter !== '' ? answerFilter : ''}\n                                    AND {filters}),\n                                    (SELECT COUNT(DISTINCT person_id)\n                                    FROM events\n                                    WHERE event = 'survey sent'\n                                    AND properties.$survey_id = '${props.id}'\n                                    AND timestamp >= '${startDate}'\n                                    AND timestamp <= '${endDate}'\n                                    ${answerFilter !== '' ? answerFilter : ''}\n                                    AND {filters})\n                    `,\n                    filters: {\n                        properties: values.propertyFilters,\n                    },\n                }\n\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n                if (results && results[0]) {\n                    const [totalSeen, dismissed, sent] = results[0]\n                    const onlySeen = totalSeen - dismissed - sent\n                    return { seen: onlySeen < 0 ? 0 : onlySeen, dismissed, sent }\n                }\n                return { seen: 0, dismissed: 0, sent: 0 }\n            },\n        },\n        surveyRatingResults: {\n            loadSurveyRatingResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyRatingResults> => {\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.Rating) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.Rating}`)\n                }\n\n                const survey: Survey = values.survey as Survey\n                const startDate = getSurveyStartDateForQuery(survey)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        -- QUERYING NPS RESPONSES\n                        SELECT\n                            ${getResponseFieldCondition(questionIndex, question?.id)} AS survey_response,\n                            COUNT(survey_response)\n                        FROM events\n                        WHERE event = 'survey sent'\n                            AND properties.$survey_id = '${props.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                            ${createAnswerFilterHogQLExpression(values.answerFilters, survey)}\n                            AND {filters}\n                        GROUP BY survey_response\n                    `,\n                    filters: {\n                        properties: values.propertyFilters,\n                    },\n                }\n\n                const responseJSON = await api.query(query)\n                // TODO:Dylan - I don't like how we lose our types here\n                // would be cool if we could parse this in a more type-safe way\n                const { results } = responseJSON\n\n                let total = 0\n                const dataSize = question.scale === 10 ? 11 : question.scale\n                const data = new Array(dataSize).fill(0)\n                results?.forEach(([value, count]) => {\n                    total += count\n\n                    const index = question.scale === 10 ? value : value - 1\n                    data[index] = count\n                })\n\n                return { ...values.surveyRatingResults, [questionIndex]: { total, data } }\n            },\n        },\n        surveyRecurringNPSResults: {\n            loadSurveyRecurringNPSResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyRecurringNPSResults> => {\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.Rating) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.Rating}`)\n                }\n\n                const survey: Survey = values.survey as Survey\n                const startDate = getSurveyStartDateForQuery(survey)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        -- QUERYING NPS RECURRING RESPONSES\n                        SELECT\n                            JSONExtractString(properties, '$survey_iteration') AS survey_iteration,\n                            ${getResponseFieldCondition(questionIndex, question?.id)} AS survey_response,\n                            COUNT(survey_response)\n                        FROM events\n                        WHERE event = 'survey sent'\n                            AND properties.$survey_id = '${survey.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                            ${createAnswerFilterHogQLExpression(values.answerFilters, survey)}\n                            AND {filters}\n                        GROUP BY survey_response, survey_iteration\n                    `,\n                    filters: {\n                        properties: values.propertyFilters,\n                    },\n                }\n\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n                let total = 100\n                const data = new Array(survey.iteration_count).fill(0)\n\n                const iterations = new Map<string, SurveyNPSResult>()\n\n                results?.forEach(([iteration, response, count]) => {\n                    let promoters = 0\n                    let passives = 0\n                    let detractors = 0\n\n                    if (parseInt(response) >= 9) {\n                        // a Promoter is someone who gives a survey response of 9 or 10\n                        promoters += parseInt(count)\n                    } else if (parseInt(response) > 6) {\n                        // a Passive is someone who gives a survey response of 7 or 8\n                        passives += parseInt(count)\n                    } else {\n                        // a Detractor is someone who gives a survey response of 0 - 6\n                        detractors += parseInt(count)\n                    }\n\n                    if (iterations.has(iteration)) {\n                        const currentValue = iterations.get(iteration)\n                        if (currentValue !== undefined) {\n                            currentValue.Detractors += detractors\n                            currentValue.Promoters += promoters\n                            currentValue.Passives += passives\n                        }\n                    } else {\n                        iterations.set(iteration, {\n                            Detractors: detractors,\n                            Passives: passives,\n                            Promoters: promoters,\n                        })\n                    }\n                })\n\n                iterations.forEach((value: SurveyNPSResult, key: string) => {\n                    // NPS score is calculated with this formula\n                    // (Promoters / (Promoters + Passives + Detractors) * 100) - (Detractors / (Promoters + Passives + Detractors)* 100)\n                    const totalResponses = value.Promoters + value.Passives + value.Detractors\n                    const npsScore =\n                        (value.Promoters / totalResponses) * 100 - (value.Detractors / totalResponses) * 100\n                    data[parseInt(key) - 1] = npsScore\n                    total += 100\n                })\n\n                return { ...values.surveyRecurringNPSResults, [questionIndex]: { total, data } }\n            },\n        },\n        surveySingleChoiceResults: {\n            loadSurveySingleChoiceResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveySingleChoiceResults> => {\n                const question = values.survey.questions[questionIndex]\n                const survey: Survey = values.survey as Survey\n                const startDate = getSurveyStartDateForQuery(survey)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        -- QUERYING SINGLE CHOICE RESPONSES\n                        SELECT\n                            ${getResponseFieldCondition(questionIndex, question?.id)} AS survey_response,\n                            COUNT(survey_response)\n                        FROM events\n                        WHERE event = 'survey sent'\n                            AND properties.$survey_id = '${props.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                            ${createAnswerFilterHogQLExpression(values.answerFilters, survey)}\n                            AND {filters}\n                        GROUP BY survey_response\n                    `,\n                    filters: {\n                        properties: values.propertyFilters,\n                    },\n                }\n\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                const labels = results?.map((r) => r[0])\n                const data = results?.map((r) => r[1])\n                const total = data?.reduce((a, b) => a + b, 0)\n\n                return { ...values.surveySingleChoiceResults, [questionIndex]: { labels, data, total } }\n            },\n        },\n        surveyMultipleChoiceResults: {\n            loadSurveyMultipleChoiceResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyMultipleChoiceResults> => {\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.MultipleChoice) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.MultipleChoice}`)\n                }\n\n                const survey: Survey = values.survey as Survey\n                const startDate = getSurveyStartDateForQuery(survey)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                // Use a WITH clause to ensure we're only counting each response once\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        -- QUERYING MULTIPLE CHOICE RESPONSES\n                        SELECT\n                            count(),\n                            arrayJoin(${getMultipleChoiceResponseFieldCondition(questionIndex, question?.id)}) AS choice\n                        FROM events\n                        WHERE event == 'survey sent'\n                            AND properties.$survey_id == '${survey.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                            ${createAnswerFilterHogQLExpression(values.answerFilters, survey)}\n                            AND {filters}\n                        GROUP BY choice\n                        ORDER BY count() DESC\n                    `,\n                    filters: {\n                        properties: values.propertyFilters,\n                    },\n                }\n\n                const responseJSON = await api.query(query)\n                let { results } = responseJSON\n\n                // Remove outside quotes\n                results = results?.map((r) => {\n                    return [r[0], r[1].slice(1, r[1].length - 1)]\n                })\n\n                // Zero-fill choices that are not open-ended\n                question.choices.forEach((choice, idx) => {\n                    const isOpenChoice = idx == question.choices.length - 1 && question?.hasOpenChoice\n                    if (results?.length && !isOpenChoice && !results.some((r) => r[1] === choice)) {\n                        results.push([0, choice])\n                    }\n                })\n\n                const data = results?.map((r) => r[0])\n                const labels = results?.map((r) => r[1])\n\n                return { ...values.surveyMultipleChoiceResults, [questionIndex]: { labels, data } }\n            },\n        },\n        surveyOpenTextResults: {\n            loadSurveyOpenTextResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyOpenTextResults> => {\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.Open) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.Open}`)\n                }\n\n                const survey: Survey = values.survey as Survey\n                const startDate = getSurveyStartDateForQuery(survey)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                // For open text responses, we need to check both formats in the WHERE clause\n                const ids = getResponseFieldWithId(questionIndex, question?.id)\n\n                // Build the condition to check for non-empty responses in either format\n                const responseCondition = ids.idBasedKey\n                    ? `(\n                        (JSONHas(properties, '${ids.indexBasedKey}') AND length(trim(JSONExtractString(properties, '${ids.indexBasedKey}'))) > 0) OR\n                        (JSONHas(properties, '${ids.idBasedKey}') AND length(trim(JSONExtractString(properties, '${ids.idBasedKey}'))) > 0)\n                      )`\n                    : `(JSONHas(properties, '${ids.indexBasedKey}') AND length(trim(JSONExtractString(properties, '${ids.indexBasedKey}'))) > 0)`\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        -- QUERYING OPEN TEXT RESPONSES\n                        SELECT distinct_id, properties, person.properties\n                        FROM events\n                        WHERE event == 'survey sent'\n                            AND properties.$survey_id == '${survey.id}'\n                            AND ${responseCondition}\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                            ${createAnswerFilterHogQLExpression(values.answerFilters, survey)}\n                            AND {filters}\n                        LIMIT 20\n                    `,\n                    filters: {\n                        properties: values.propertyFilters,\n                    },\n                }\n\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                const events =\n                    results?.map((r) => {\n                        const distinct_id = r[0]\n                        const properties = JSON.parse(r[1])\n\n                        // Safely handle personProperties which might be null for non-identified users\n                        let personProperties = {}\n                        try {\n                            if (r[2] && r[2] !== 'null') {\n                                personProperties = JSON.parse(r[2])\n                            }\n                        } catch (e) {\n                            // If parsing fails, use an empty object\n                        }\n\n                        return { distinct_id, properties, personProperties }\n                    }) || []\n\n                return { ...values.surveyOpenTextResults, [questionIndex]: { events } }\n            },\n        },\n    })),\n    listeners(({ actions, values }) => {\n        const reloadAllSurveyResults = debounce((): void => {\n            // Load survey user stats\n            actions.loadSurveyUserStats()\n\n            // Load results for each question\n            values.survey.questions.forEach((question, index) => {\n                switch (question.type) {\n                    case SurveyQuestionType.Rating:\n                        actions.loadSurveyRatingResults({\n                            questionIndex: index,\n                        })\n                        if (values.survey.iteration_count && values.survey.iteration_count > 0) {\n                            actions.loadSurveyRecurringNPSResults({ questionIndex: index })\n                        }\n                        break\n                    case SurveyQuestionType.SingleChoice:\n                        actions.loadSurveySingleChoiceResults({ questionIndex: index })\n                        break\n                    case SurveyQuestionType.MultipleChoice:\n                        actions.loadSurveyMultipleChoiceResults({ questionIndex: index })\n                        break\n                    case SurveyQuestionType.Open:\n                        actions.loadSurveyOpenTextResults({ questionIndex: index })\n                        break\n                }\n            })\n        }, 1000)\n\n        return {\n            createSurveySuccess: ({ survey }) => {\n                lemonToast.success(<>Survey {survey.name} created</>)\n                actions.loadSurveys()\n                router.actions.replace(urls.survey(survey.id))\n                actions.reportSurveyCreated(survey)\n            },\n            updateSurveySuccess: ({ survey }) => {\n                lemonToast.success(<>Survey {survey.name} updated</>)\n                actions.editingSurvey(false)\n                actions.reportSurveyEdited(survey)\n                actions.loadSurveys()\n            },\n            duplicateSurveySuccess: () => {\n                actions.loadSurveys()\n            },\n            launchSurveySuccess: ({ survey }) => {\n                lemonToast.success(<>Survey {survey.name} launched</>)\n                actions.loadSurveys()\n            },\n            stopSurveySuccess: () => {\n                actions.loadSurveys()\n            },\n            resumeSurveySuccess: () => {\n                actions.loadSurveys()\n            },\n            archiveSurvey: () => {\n                actions.updateSurvey({ archived: true })\n            },\n            loadSurveySuccess: () => {\n                actions.loadSurveyUserStats()\n\n                if (values.survey.start_date) {\n                    activationLogic.findMounted()?.actions.markTaskAsCompleted(ActivationTask.LaunchSurvey)\n                }\n\n                const dateRange = {\n                    date_from: getSurveyStartDateForQuery(values.survey as Survey),\n                    date_to: getSurveyEndDateForQuery(values.survey as Survey),\n                }\n                actions.setDateRange(dateRange)\n            },\n            resetSurveyResponseLimits: () => {\n                actions.setSurveyValue('responses_limit', null)\n            },\n\n            resetSurveyAdaptiveSampling: () => {\n                actions.setSurveyValues({\n                    response_sampling_interval: null,\n                    response_sampling_interval_type: null,\n                    response_sampling_limit: null,\n                    response_sampling_start_date: null,\n                    response_sampling_daily_limits: null,\n                })\n            },\n            resetTargeting: () => {\n                actions.setSurveyValue('linked_flag_id', NEW_SURVEY.linked_flag_id)\n                actions.setSurveyValue('targeting_flag_filters', NEW_SURVEY.targeting_flag_filters)\n                actions.setSurveyValue('linked_flag', NEW_SURVEY.linked_flag)\n                actions.setSurveyValue('targeting_flag', NEW_SURVEY.targeting_flag)\n                actions.setSurveyValue('conditions', NEW_SURVEY.conditions)\n                actions.setSurveyValue('remove_targeting_flag', true)\n                actions.setSurveyValue('responses_limit', NEW_SURVEY.responses_limit)\n                actions.setSurveyValues({\n                    iteration_count: NEW_SURVEY.iteration_count,\n                    iteration_frequency_days: NEW_SURVEY.iteration_frequency_days,\n                })\n                actions.setFlagPropertyErrors(null)\n            },\n            submitSurveyFailure: async () => {\n                // When errors occur, scroll to the error, but wait for errors to be set in the DOM first\n                if (hasFormErrors(values.flagPropertyErrors) || values.urlMatchTypeValidationError) {\n                    actions.setSelectedSection(SurveyEditSection.DisplayConditions)\n                } else if (hasFormErrors(values.survey.appearance)) {\n                    actions.setSelectedSection(SurveyEditSection.Customization)\n                } else {\n                    actions.setSelectedSection(SurveyEditSection.Steps)\n                }\n                setTimeout(\n                    () =>\n                        document\n                            .querySelector(`.Field--error`)\n                            ?.scrollIntoView({ block: 'center', behavior: 'smooth' }),\n                    5\n                )\n            },\n            setPropertyFilters: () => {\n                reloadAllSurveyResults()\n            },\n            setAnswerFilters: ({ reloadResults }) => {\n                if (reloadResults) {\n                    reloadAllSurveyResults()\n                }\n            },\n        }\n    }),\n    reducers({\n        isEditingSurvey: [\n            false,\n            {\n                editingSurvey: (_, { editing }) => editing,\n            },\n        ],\n        surveyMissing: [\n            false,\n            {\n                setSurveyMissing: () => true,\n            },\n        ],\n        dataCollectionType: [\n            'until_stopped' as DataCollectionType,\n            {\n                setDataCollectionType: (_, { dataCollectionType }) => dataCollectionType,\n            },\n        ],\n        propertyFilters: [\n            [] as AnyPropertyFilter[],\n            {\n                setPropertyFilters: (_, { propertyFilters }) => propertyFilters,\n            },\n        ],\n        survey: [\n            { ...NEW_SURVEY } as NewSurvey | Survey,\n            {\n                setDefaultForQuestionType: (\n                    state,\n                    { idx, type, isEditingQuestion, isEditingDescription, isEditingThankYouMessage }\n                ) => {\n                    const question = isEditingQuestion\n                        ? state.questions[idx].question\n                        : defaultSurveyFieldValues[type].questions[0].question\n                    const description = isEditingDescription\n                        ? state.questions[idx].description\n                        : defaultSurveyFieldValues[type].questions[0].description\n                    const thankYouMessageHeader = isEditingThankYouMessage\n                        ? state.appearance?.thankYouMessageHeader\n                        : defaultSurveyFieldValues[type].appearance.thankYouMessageHeader\n                    const newQuestions = [...state.questions]\n                    newQuestions[idx] = {\n                        ...state.questions[idx],\n                        ...(defaultSurveyFieldValues[type].questions[0] as SurveyQuestionBase),\n                        question,\n                        description,\n                    }\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                        appearance: {\n                            ...state.appearance,\n                            ...defaultSurveyFieldValues[type].appearance,\n                            thankYouMessageHeader,\n                        },\n                    }\n                },\n                setSurveyTemplateValues: (_, { template }) => {\n                    const newTemplateSurvey = { ...NEW_SURVEY, ...template }\n                    return newTemplateSurvey\n                },\n                setQuestionBranchingType: (state, { questionIndex, type, specificQuestionIndex }) => {\n                    const newQuestions = [...state.questions]\n                    const question = newQuestions[questionIndex]\n\n                    if (type === SurveyQuestionBranchingType.NextQuestion) {\n                        delete question.branching\n                    } else if (type === SurveyQuestionBranchingType.End) {\n                        question.branching = {\n                            type: SurveyQuestionBranchingType.End,\n                        }\n                    } else if (type === SurveyQuestionBranchingType.ResponseBased) {\n                        if (\n                            question.type !== SurveyQuestionType.Rating &&\n                            question.type !== SurveyQuestionType.SingleChoice\n                        ) {\n                            throw new Error(\n                                `Survey question type must be ${SurveyQuestionType.Rating} or ${SurveyQuestionType.SingleChoice}`\n                            )\n                        }\n\n                        question.branching = {\n                            type: SurveyQuestionBranchingType.ResponseBased,\n                            responseValues: {},\n                        }\n                    } else if (type === SurveyQuestionBranchingType.SpecificQuestion) {\n                        question.branching = {\n                            type: SurveyQuestionBranchingType.SpecificQuestion,\n                            index: specificQuestionIndex,\n                        }\n                    }\n\n                    newQuestions[questionIndex] = question\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n                setResponseBasedBranchingForQuestion: (\n                    state,\n                    { questionIndex, responseValue, nextStep, specificQuestionIndex }\n                ) => {\n                    const newQuestions = [...state.questions]\n                    const question = newQuestions[questionIndex]\n\n                    if (\n                        question.type !== SurveyQuestionType.Rating &&\n                        question.type !== SurveyQuestionType.SingleChoice\n                    ) {\n                        throw new Error(\n                            `Survey question type must be ${SurveyQuestionType.Rating} or ${SurveyQuestionType.SingleChoice}`\n                        )\n                    }\n\n                    if (question.branching?.type !== SurveyQuestionBranchingType.ResponseBased) {\n                        throw new Error(\n                            `Survey question branching type must be ${SurveyQuestionBranchingType.ResponseBased}`\n                        )\n                    }\n\n                    if ('responseValues' in question.branching) {\n                        if (nextStep === SurveyQuestionBranchingType.NextQuestion) {\n                            delete question.branching.responseValues[responseValue]\n                        } else if (nextStep === SurveyQuestionBranchingType.End) {\n                            question.branching.responseValues[responseValue] = SurveyQuestionBranchingType.End\n                        } else if (nextStep === SurveyQuestionBranchingType.SpecificQuestion) {\n                            question.branching.responseValues[responseValue] = specificQuestionIndex\n                        }\n                    }\n\n                    newQuestions[questionIndex] = question\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n                resetBranchingForQuestion: (state, { questionIndex }) => {\n                    const newQuestions = [...state.questions]\n                    const question = newQuestions[questionIndex]\n                    delete question.branching\n\n                    newQuestions[questionIndex] = question\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n                deleteBranchingLogic: (state) => {\n                    const newQuestions = [...state.questions]\n                    newQuestions.forEach((question) => {\n                        delete question.branching\n                    })\n\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n            },\n        ],\n        selectedPageIndex: [\n            0 as number | null,\n            {\n                setSelectedPageIndex: (_, { idx }) => idx,\n            },\n        ],\n        selectedSection: [\n            SurveyEditSection.Steps as SurveyEditSection | null,\n            {\n                setSelectedSection: (_, { section }) => section,\n            },\n        ],\n        surveyRatingResultsReady: [\n            {},\n            {\n                loadSurveyRatingResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveyRecurringNPSResultsReady: [\n            {},\n            {\n                loadSurveyRecurringNPSResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveySingleChoiceResultsReady: [\n            {},\n            {\n                loadSurveySingleChoiceResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveyMultipleChoiceResultsReady: [\n            {},\n            {\n                loadSurveyMultipleChoiceResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveyOpenTextResultsReady: [\n            {},\n            {\n                loadSurveyOpenTextResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        writingHTMLDescription: [\n            false,\n            {\n                setWritingHTMLDescription: (_, { writingHTML }) => writingHTML,\n            },\n        ],\n        flagPropertyErrors: [\n            null as any,\n            {\n                setFlagPropertyErrors: (_, { errors }) => errors,\n            },\n        ],\n        answerFilters: [\n            [] as EventPropertyFilter[],\n            {\n                setAnswerFilters: (_, { filters }) => filters,\n            },\n        ],\n        dateRange: [\n            null as SurveyDateRange | null,\n            {\n                setDateRange: (_, { dateRange }) => dateRange,\n            },\n        ],\n        interval: [\n            null as IntervalType | null,\n            {\n                setInterval: (_, { interval }) => interval,\n            },\n        ],\n        compareFilter: [\n            null as CompareFilter | null,\n            {\n                setCompareFilter: (_, { compareFilter }) => compareFilter,\n            },\n        ],\n    }),\n    selectors({\n        isAnyResultsLoading: [\n            (s) => [\n                s.surveyUserStatsLoading,\n                s.surveyRatingResultsReady,\n                s.surveySingleChoiceResultsReady,\n                s.surveyMultipleChoiceResultsReady,\n                s.surveyOpenTextResultsReady,\n                s.surveyRecurringNPSResultsReady,\n            ],\n            (\n                surveyUserStatsLoading: boolean,\n                surveyRatingResultsReady: boolean,\n                surveySingleChoiceResultsReady: boolean,\n                surveyMultipleChoiceResultsReady: boolean,\n                surveyOpenTextResultsReady: boolean,\n                surveyRecurringNPSResultsReady: boolean\n            ) => {\n                return (\n                    surveyUserStatsLoading ||\n                    !surveyRatingResultsReady ||\n                    !surveySingleChoiceResultsReady ||\n                    !surveyMultipleChoiceResultsReady ||\n                    !surveyOpenTextResultsReady ||\n                    !surveyRecurringNPSResultsReady\n                )\n            },\n        ],\n        isSurveyRunning: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(survey.start_date && !survey.end_date)\n            },\n        ],\n        surveyUsesLimit: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(survey.responses_limit && survey.responses_limit > 0)\n            },\n        ],\n        surveyUsesAdaptiveLimit: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(\n                    survey.response_sampling_interval &&\n                    survey.response_sampling_interval > 0 &&\n                    survey.response_sampling_interval_type !== '' &&\n                    survey.response_sampling_limit &&\n                    survey.response_sampling_limit > 0\n                )\n            },\n        ],\n        surveyShufflingQuestionsAvailable: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return survey.questions.length > 1\n            },\n        ],\n        showSurveyRepeatSchedule: [(s) => [s.survey], (survey: Survey) => survey.schedule === SurveySchedule.Recurring],\n        descriptionContentType: [\n            (s) => [s.survey],\n            (survey: Survey) => (questionIndex: number) => {\n                return survey.questions[questionIndex].descriptionContentType\n            },\n        ],\n        surveyRepeatedActivationAvailable: [\n            (s) => [s.survey],\n            (survey: Survey): boolean =>\n                survey.conditions?.events?.values != undefined && survey.conditions?.events?.values?.length > 0,\n        ],\n        hasTargetingSet: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                const hasLinkedFlag =\n                    !!survey.linked_flag_id || (survey.linked_flag && Object.keys(survey.linked_flag).length > 0)\n                const hasTargetingFlag =\n                    (survey.targeting_flag && Object.keys(survey.targeting_flag).length > 0) ||\n                    (survey.targeting_flag_filters && Object.keys(survey.targeting_flag_filters).length > 0)\n                const hasOtherConditions = survey.conditions && Object.keys(survey.conditions).length > 0\n                return !!hasLinkedFlag || !!hasTargetingFlag || !!hasOtherConditions\n            },\n        ],\n        breadcrumbs: [\n            (s) => [s.survey],\n            (survey: Survey): Breadcrumb[] => [\n                {\n                    key: Scene.Surveys,\n                    name: 'Surveys',\n                    path: urls.surveys(),\n                },\n                { key: [Scene.Survey, survey?.id || 'new'], name: survey.name },\n            ],\n        ],\n        dataTableQuery: [\n            (s) => [s.survey, s.propertyFilters, s.answerFilters],\n            (\n                survey: Survey,\n                propertyFilters: AnyPropertyFilter[],\n                answerFilters: EventPropertyFilter[]\n            ): DataTableNode | null => {\n                if (survey.id === 'new') {\n                    return null\n                }\n                const surveyWithResults = survey\n\n                const where = [`event == 'survey sent'`]\n                const answerFilter = createAnswerFilterHogQLExpression(answerFilters, survey)\n\n                if (answerFilter !== '') {\n                    // skip the 'AND ' prefix\n                    where.push(answerFilter.slice(4))\n                }\n\n                return {\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.EventsQuery,\n                        select: [\n                            '*',\n                            ...survey.questions.map((q, i) => {\n                                if (q.type === SurveyQuestionType.MultipleChoice) {\n                                    const ids = getResponseFieldWithId(i, q.id)\n                                    if (!ids.idBasedKey) {\n                                        // If we only have index-based key, just use that\n                                        return `coalesce(arrayStringConcat(JSONExtractArrayRaw(properties, '${ids.indexBasedKey}'), ', ')) -- ${q.question}`\n                                    }\n                                    // Handle both formats for multiple choice questions\n                                    return `coalesce(\n                                        if(\n                                            JSONHas(properties, '${ids.idBasedKey}') AND length(JSONExtractArrayRaw(properties, '${ids.idBasedKey}')) > 0,\n                                            arrayStringConcat(JSONExtractArrayRaw(properties, '${ids.idBasedKey}'), ', '),\n                                            arrayStringConcat(JSONExtractArrayRaw(properties, '${ids.indexBasedKey}'), ', ')\n                                        )\n                                    ) -- ${q.question}`\n                                }\n                                // Use the new condition that checks both formats\n                                return `coalesce(${getResponseFieldCondition(i, q.id)}) -- ${q.question}`\n                            }),\n                            'timestamp',\n                            'person',\n                            `coalesce(JSONExtractString(properties, '$lib_version')) -- Library Version`,\n                            `coalesce(JSONExtractString(properties, '$lib')) -- Library`,\n                            `coalesce(JSONExtractString(properties, '$current_url')) -- URL`,\n                        ],\n                        orderBy: ['timestamp DESC'],\n                        where,\n                        after: getSurveyStartDateForQuery(surveyWithResults),\n                        properties: [\n                            {\n                                type: PropertyFilterType.Event,\n                                key: '$survey_id',\n                                operator: PropertyOperator.Exact,\n                                value: survey.id,\n                            },\n                            ...propertyFilters,\n                        ],\n                    },\n                    propertiesViaUrl: true,\n                    showExport: true,\n                    showReload: true,\n                    showEventFilter: false,\n                    showPropertyFilter: false,\n                    showTimings: false,\n                }\n            },\n        ],\n        targetingFlagFilters: [\n            (s) => [s.survey],\n            (survey): FeatureFlagFilters | undefined => {\n                if (survey.targeting_flag_filters) {\n                    return {\n                        ...survey.targeting_flag_filters,\n                        groups: survey.targeting_flag_filters.groups,\n                        multivariate: null,\n                        payloads: {},\n                        super_groups: undefined,\n                    }\n                }\n                return survey.targeting_flag?.filters || undefined\n            },\n        ],\n        urlMatchTypeValidationError: [\n            (s) => [s.survey],\n            (survey): string | null => {\n                if (\n                    survey.conditions?.url &&\n                    [SurveyMatchType.Regex, SurveyMatchType.NotRegex].includes(\n                        survey.conditions?.urlMatchType || SurveyMatchType.Exact\n                    )\n                ) {\n                    try {\n                        new RegExp(survey.conditions.url)\n                    } catch (e: any) {\n                        return e.message\n                    }\n                }\n                return null\n            },\n        ],\n        deviceTypesMatchTypeValidationError: [\n            (s) => [s.survey],\n            (survey: Survey): string | null => {\n                if (\n                    survey.conditions?.deviceTypes &&\n                    [SurveyMatchType.Regex, SurveyMatchType.NotRegex].includes(\n                        survey.conditions?.deviceTypesMatchType || SurveyMatchType.Exact\n                    )\n                ) {\n                    try {\n                        new RegExp(survey.conditions.deviceTypes?.at(0) || '')\n                    } catch (e: any) {\n                        return e.message\n                    }\n                }\n                return null\n            },\n        ],\n        surveyNPSScore: [\n            (s) => [s.surveyRatingResults],\n            (surveyRatingResults) => {\n                if (surveyRatingResults) {\n                    const questionIdx = Object.keys(surveyRatingResults)[0]\n                    const questionResults = surveyRatingResults[questionIdx]\n\n                    // If we don't have any results, return 'No data available' instead of NaN.\n                    if (!questionResults || questionResults.total === 0) {\n                        return 'No data available'\n                    }\n\n                    const npsBreakdown = calculateNpsBreakdown(questionResults)\n                    if (!npsBreakdown) {\n                        return null\n                    }\n\n                    return calculateNpsScore(npsBreakdown).toFixed(1)\n                }\n            },\n        ],\n        npsBreakdown: [\n            (s) => [s.surveyRatingResults],\n            (surveyRatingResults) => {\n                const surveyRatingKeys = Object.keys(surveyRatingResults ?? {})\n                if (surveyRatingKeys.length === 0) {\n                    return null\n                }\n                const questionIdx = surveyRatingKeys[0]\n                const questionResults = surveyRatingResults[questionIdx]\n                if (!questionResults) {\n                    return null\n                }\n\n                return calculateNpsBreakdown(questionResults)\n            },\n        ],\n        getBranchingDropdownValue: [\n            (s) => [s.survey],\n            (survey) => (questionIndex: number, question: RatingSurveyQuestion | MultipleSurveyQuestion) => {\n                if (question.branching?.type) {\n                    const { type } = question.branching\n\n                    if (type === SurveyQuestionBranchingType.SpecificQuestion) {\n                        const nextQuestionIndex = question.branching.index\n                        return `${SurveyQuestionBranchingType.SpecificQuestion}:${nextQuestionIndex}`\n                    }\n\n                    return type\n                }\n\n                // No branching specified, default to Next question / Confirmation message\n                if (questionIndex < survey.questions.length - 1) {\n                    return SurveyQuestionBranchingType.NextQuestion\n                }\n\n                return SurveyQuestionBranchingType.End\n            },\n        ],\n        getResponseBasedBranchingDropdownValue: [\n            (s) => [s.survey],\n            (survey) => (questionIndex: number, question: RatingSurveyQuestion | MultipleSurveyQuestion, response) => {\n                if (!question.branching || !('responseValues' in question.branching)) {\n                    return SurveyQuestionBranchingType.NextQuestion\n                }\n\n                // If a value is mapped onto an integer, we're redirecting to a specific question\n                if (Number.isInteger(question.branching.responseValues[response])) {\n                    const nextQuestionIndex = question.branching.responseValues[response]\n                    return `${SurveyQuestionBranchingType.SpecificQuestion}:${nextQuestionIndex}`\n                }\n\n                // If any other value is present (practically only Confirmation message), return that value\n                if (question.branching?.responseValues?.[response]) {\n                    return question.branching.responseValues[response]\n                }\n\n                // No branching specified, default to Next question / Confirmation message\n                if (questionIndex < survey.questions.length - 1) {\n                    return SurveyQuestionBranchingType.NextQuestion\n                }\n\n                return SurveyQuestionBranchingType.End\n            },\n        ],\n        hasCycle: [\n            (s) => [s.survey],\n            (survey) => {\n                const graph = new Map()\n                survey.questions.forEach((question, fromIndex: number) => {\n                    if (!graph.has(fromIndex)) {\n                        graph.set(fromIndex, new Set())\n                    }\n\n                    if (question.branching?.type === SurveyQuestionBranchingType.End) {\n                        return\n                    } else if (\n                        question.branching?.type === SurveyQuestionBranchingType.SpecificQuestion &&\n                        Number.isInteger(question.branching.index)\n                    ) {\n                        const toIndex = question.branching.index\n                        graph.get(fromIndex).add(toIndex)\n                        return\n                    } else if (\n                        question.branching?.type === SurveyQuestionBranchingType.ResponseBased &&\n                        isObject(question.branching?.responseValues)\n                    ) {\n                        for (const [_, toIndex] of Object.entries(question.branching?.responseValues)) {\n                            if (Number.isInteger(toIndex)) {\n                                graph.get(fromIndex).add(toIndex)\n                            }\n                        }\n                    }\n\n                    // No branching - still need to connect the next question\n                    if (fromIndex < survey.questions.length - 1) {\n                        const toIndex = fromIndex + 1\n                        graph.get(fromIndex).add(toIndex)\n                    }\n                })\n\n                let cycleDetected = false\n                function dfs(node: number, seen: number[]): void {\n                    if (cycleDetected) {\n                        return\n                    }\n\n                    for (const neighbor of graph.get(node) || []) {\n                        if (seen.includes(neighbor)) {\n                            cycleDetected = true\n                            return\n                        }\n                        dfs(neighbor, seen.concat(neighbor))\n                    }\n                }\n                dfs(0, [0])\n\n                return cycleDetected\n            },\n        ],\n        hasBranchingLogic: [\n            (s) => [s.survey],\n            (survey) =>\n                survey.questions.some((question) => question.branching && Object.keys(question.branching).length > 0),\n        ],\n        surveyAsInsightURL: [\n            (s) => [s.survey],\n            (survey) => {\n                const query: InsightVizNode = {\n                    kind: NodeKind.InsightVizNode,\n                    source: {\n                        kind: NodeKind.TrendsQuery,\n                        properties: [\n                            {\n                                key: '$survey_id',\n                                value: survey.id,\n                                operator: PropertyOperator.Exact,\n                                type: PropertyFilterType.Event,\n                            },\n                        ],\n                        series: [\n                            {\n                                kind: NodeKind.EventsNode,\n                                event: 'survey sent',\n                                name: 'survey sent',\n                                math: BaseMathType.TotalCount,\n                            },\n                            {\n                                kind: NodeKind.EventsNode,\n                                event: 'survey shown',\n                                name: 'survey shown',\n                                math: BaseMathType.TotalCount,\n                            },\n                            {\n                                kind: NodeKind.EventsNode,\n                                event: 'survey dismissed',\n                                name: 'survey dismissed',\n                                math: BaseMathType.TotalCount,\n                            },\n                        ],\n                    },\n                }\n\n                return urls.insightNew({ query })\n            },\n        ],\n        defaultInterval: [\n            (s) => [s.survey],\n            (survey: Survey): IntervalType => {\n                const start = getSurveyStartDateForQuery(survey)\n                const end = getSurveyEndDateForQuery(survey)\n                const diffInDays = dayjs(end).diff(dayjs(start), 'days')\n                const diffInWeeks = dayjs(end).diff(dayjs(start), 'weeks')\n\n                if (diffInDays < 2) {\n                    return 'hour'\n                }\n                if (diffInWeeks <= 4) {\n                    return 'day'\n                }\n                if (diffInWeeks <= 12) {\n                    return 'week'\n                }\n                return 'month'\n            },\n        ],\n    }),\n    forms(({ actions, props, values }) => ({\n        survey: {\n            defaults: { ...NEW_SURVEY } as NewSurvey | Survey,\n            errors: ({ name, questions, appearance, type }) => {\n                const sanitizedAppearance = sanitizeSurveyAppearance(appearance)\n                return {\n                    name: !name && 'Please enter a name.',\n                    questions: questions.map((question) => {\n                        const questionErrors = {\n                            question: !question.question && 'Please enter a question label.',\n                        }\n\n                        if (question.type === SurveyQuestionType.Link) {\n                            if (question.link) {\n                                if (question.link.startsWith('mailto:')) {\n                                    const emailRegex = /^mailto:[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\n                                    if (!emailRegex.test(question.link)) {\n                                        return {\n                                            ...questionErrors,\n                                            link: 'Please enter a valid mailto link (e.g., mailto:example@domain.com).',\n                                        }\n                                    }\n                                } else {\n                                    try {\n                                        const url = new URL(question.link)\n                                        if (url.protocol !== 'https:') {\n                                            return {\n                                                ...questionErrors,\n                                                link: 'Only HTTPS links are supported for security reasons.',\n                                            }\n                                        }\n                                    } catch {\n                                        return {\n                                            ...questionErrors,\n                                            link: 'Please enter a valid HTTPS URL.',\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        if (question.type === SurveyQuestionType.Rating) {\n                            return {\n                                ...questionErrors,\n                                display: !question.display && 'Please choose a display type.',\n                                scale: !question.scale && 'Please choose a scale.',\n                                lowerBoundLabel: !question.lowerBoundLabel && 'Please enter a lower bound label.',\n                                upperBoundLabel: !question.upperBoundLabel && 'Please enter an upper bound label.',\n                            }\n                        } else if (\n                            question.type === SurveyQuestionType.SingleChoice ||\n                            question.type === SurveyQuestionType.MultipleChoice\n                        ) {\n                            return {\n                                ...questionErrors,\n                                choices: question.choices.some((choice) => !choice.trim())\n                                    ? 'Please ensure all choices are non-empty.'\n                                    : undefined,\n                            }\n                        }\n\n                        return questionErrors\n                    }),\n                    // release conditions controlled using a PureField in the form\n                    targeting_flag_filters: values.flagPropertyErrors,\n                    // controlled using a PureField in the form\n                    urlMatchType: values.urlMatchTypeValidationError,\n                    appearance: sanitizedAppearance && {\n                        backgroundColor: validateColor(sanitizedAppearance.backgroundColor, 'background color'),\n                        borderColor: validateColor(sanitizedAppearance.borderColor, 'border color'),\n                        ratingButtonActiveColor: validateColor(\n                            sanitizedAppearance.ratingButtonActiveColor,\n                            'rating button active color'\n                        ),\n                        ratingButtonColor: validateColor(sanitizedAppearance.ratingButtonColor, 'rating button color'),\n                        submitButtonColor: validateColor(sanitizedAppearance.submitButtonColor, 'button color'),\n                        submitButtonTextColor: validateColor(\n                            sanitizedAppearance.submitButtonTextColor,\n                            'button text color'\n                        ),\n                        widgetSelector:\n                            type === 'widget' &&\n                            appearance?.widgetType === 'selector' &&\n                            !sanitizedAppearance.widgetSelector\n                                ? 'Please enter a CSS selector.'\n                                : undefined,\n                    },\n                }\n            },\n            submit: (surveyPayload) => {\n                if (values.hasCycle) {\n                    actions.reportSurveyCycleDetected(values.survey)\n\n                    return lemonToast.error(\n                        'Your survey contains an endless cycle. Please revisit your branching rules.'\n                    )\n                }\n\n                const payload = {\n                    ...surveyPayload,\n                    appearance: sanitizeSurveyAppearance(surveyPayload.appearance),\n                }\n\n                // when the survey is being submitted, we should turn off editing mode\n                actions.editingSurvey(false)\n                if (props.id && props.id !== 'new') {\n                    actions.updateSurvey(payload)\n                } else {\n                    actions.createSurvey(payload)\n                }\n            },\n        },\n    })),\n    urlToAction(({ actions, props }) => ({\n        [urls.survey(props.id ?? 'new')]: (_, { edit }, __, { method }) => {\n            // We always set the editingSurvey to true when we create a new survey\n            if (props.id === 'new') {\n                actions.editingSurvey(true)\n            }\n            // If the URL was pushed (user clicked on a link), reset the scene's data.\n            // This avoids resetting form fields if you click back/forward.\n            if (method === 'PUSH') {\n                if (props.id) {\n                    actions.loadSurvey()\n                } else {\n                    actions.resetSurvey()\n                }\n            }\n\n            if (edit) {\n                actions.editingSurvey(true)\n            }\n        },\n    })),\n    actionToUrl(({ values }) => ({\n        setSurveyTemplateValues: () => {\n            const hashParams = router.values.hashParams\n            hashParams['fromTemplate'] = true\n\n            return [urls.survey(values.survey.id), router.values.searchParams, hashParams]\n        },\n        editingSurvey: ({ editing }) => {\n            const searchParams = router.values.searchParams\n            if (editing) {\n                searchParams['edit'] = true\n            } else {\n                delete searchParams['edit']\n            }\n\n            return [router.values.location.pathname, router.values.searchParams, router.values.hashParams]\n        },\n    })),\n    afterMount(({ props, actions }) => {\n        if (props.id !== 'new') {\n            actions.loadSurvey()\n        }\n        if (props.id === 'new') {\n            actions.resetSurvey()\n        }\n    }),\n])\n\nfunction sanitizeQuestions(surveyPayload: Partial<Survey>): Partial<Survey> {\n    if (!surveyPayload.questions) {\n        return surveyPayload\n    }\n\n    const sanitizedThankYouHeader = sanitizeHTML(surveyPayload.appearance?.thankYouMessageHeader || '')\n    const sanitizedThankYouDescription = sanitizeHTML(surveyPayload.appearance?.thankYouMessageDescription || '')\n\n    const appearance = {\n        ...surveyPayload.appearance,\n        ...(sanitizedThankYouHeader && { thankYouMessageHeader: sanitizedThankYouHeader }),\n        ...(sanitizedThankYouDescription && { thankYouMessageDescription: sanitizedThankYouDescription }),\n    }\n\n    // Remove widget-specific fields if survey type is not Widget\n    if (surveyPayload.type !== 'widget') {\n        delete appearance.widgetType\n        delete appearance.widgetLabel\n        delete appearance.widgetColor\n    }\n\n    return {\n        ...surveyPayload,\n        questions: surveyPayload.questions?.map((rawQuestion) => {\n            return {\n                ...rawQuestion,\n                description: sanitizeHTML(rawQuestion.description || ''),\n                question: sanitizeHTML(rawQuestion.question || ''),\n            }\n        }),\n        appearance,\n    }\n}\n","import DOMPurify from 'dompurify'\nimport { SURVEY_RESPONSE_PROPERTY } from 'scenes/surveys/constants'\nimport { SurveyRatingResults } from 'scenes/surveys/surveyLogic'\n\nimport { EventPropertyFilter, Survey, SurveyAppearance } from '~/types'\n\nconst sanitizeConfig = { ADD_ATTR: ['target'] }\n\nexport function sanitizeHTML(html: string): string {\n    return DOMPurify.sanitize(html, sanitizeConfig)\n}\n\nexport function sanitizeColor(color: string | undefined): string | undefined {\n    if (!color) {\n        return undefined\n    }\n\n    // test if the color is valid by adding a # to the beginning of the string\n    if (!validateColor(`#${color}`, 'color')) {\n        return `#${color}`\n    }\n\n    return color\n}\n\nexport function validateColor(color: string | undefined, fieldName: string): string | undefined {\n    if (!color) {\n        return undefined\n    }\n    // Test if the color value is valid using CSS.supports\n    const isValidColor = CSS.supports('color', color)\n    return !isValidColor ? `Invalid color value for ${fieldName}. Please use a valid CSS color.` : undefined\n}\n\nexport function getSurveyResponseKey(questionIndex: number): string {\n    return questionIndex === 0 ? SURVEY_RESPONSE_PROPERTY : `${SURVEY_RESPONSE_PROPERTY}_${questionIndex}`\n}\n\n// Helper function to generate the response field keys with proper typing\nexport const getResponseFieldWithId = (\n    questionIndex: number,\n    questionId?: string\n): { indexBasedKey: string; idBasedKey: string | undefined } => {\n    return {\n        indexBasedKey: getSurveyResponseKey(questionIndex),\n        idBasedKey: questionId ? `${SURVEY_RESPONSE_PROPERTY}_${questionId}` : undefined,\n    }\n}\n\n// Helper function to generate the HogQL condition for checking survey responses in both formats\nexport const getResponseFieldCondition = (questionIndex: number, questionId?: string): string => {\n    const ids = getResponseFieldWithId(questionIndex, questionId)\n\n    if (!ids.idBasedKey) {\n        return `JSONExtractString(properties, '${ids.indexBasedKey}')`\n    }\n\n    // For ClickHouse, we need to use coalesce to check both fields\n    // This will return the first non-null value, prioritizing the ID-based format if available\n    return `coalesce(\n        nullIf(JSONExtractString(properties, '${ids.idBasedKey}'), ''),\n        nullIf(JSONExtractString(properties, '${ids.indexBasedKey}'), '')\n    )`\n}\n\n// Helper function to generate the HogQL condition for checking multiple choice survey responses in both formats\nexport const getMultipleChoiceResponseFieldCondition = (questionIndex: number, questionId?: string): string => {\n    const ids = getResponseFieldWithId(questionIndex, questionId)\n\n    if (!ids.idBasedKey) {\n        return `JSONExtractArrayRaw(properties, '${ids.indexBasedKey}')`\n    }\n\n    // For multiple choice, we need to check if either field has a value and use that one\n    return `if(\n        JSONHas(properties, '${ids.idBasedKey}') AND length(JSONExtractArrayRaw(properties, '${ids.idBasedKey}')) > 0,\n        JSONExtractArrayRaw(properties, '${ids.idBasedKey}'),\n        JSONExtractArrayRaw(properties, '${ids.indexBasedKey}')\n    )`\n}\n\nexport function sanitizeSurveyAppearance(appearance: SurveyAppearance | null): SurveyAppearance | null {\n    if (!appearance) {\n        return null\n    }\n\n    return {\n        ...appearance,\n        backgroundColor: sanitizeColor(appearance.backgroundColor),\n        borderColor: sanitizeColor(appearance.borderColor),\n        ratingButtonActiveColor: sanitizeColor(appearance.ratingButtonActiveColor),\n        ratingButtonColor: sanitizeColor(appearance.ratingButtonColor),\n        submitButtonColor: sanitizeColor(appearance.submitButtonColor),\n        submitButtonTextColor: sanitizeColor(appearance.submitButtonTextColor),\n    }\n}\n\nexport type NPSBreakdown = {\n    total: number\n    promoters: number\n    passives: number\n    detractors: number\n}\n\nexport function calculateNpsBreakdown(surveyRatingResults: SurveyRatingResults[number]): NPSBreakdown | null {\n    // Validate input structure\n    if (!surveyRatingResults.data || surveyRatingResults.data.length !== 11) {\n        return null\n    }\n\n    if (surveyRatingResults.total === 0) {\n        return { total: 0, promoters: 0, passives: 0, detractors: 0 }\n    }\n\n    const PROMOTER_MIN = 9\n    const PASSIVE_MIN = 7\n\n    const promoters = surveyRatingResults.data.slice(PROMOTER_MIN, 11).reduce((a, b) => a + b, 0)\n    const passives = surveyRatingResults.data.slice(PASSIVE_MIN, PROMOTER_MIN).reduce((a, b) => a + b, 0)\n    const detractors = surveyRatingResults.data.slice(0, PASSIVE_MIN).reduce((a, b) => a + b, 0)\n    return { total: surveyRatingResults.total, promoters, passives, detractors }\n}\n\nexport function calculateNpsScore(npsBreakdown: NPSBreakdown): number {\n    if (npsBreakdown.total === 0) {\n        return 0\n    }\n    return ((npsBreakdown.promoters - npsBreakdown.detractors) / npsBreakdown.total) * 100\n}\n\n// Helper to escape special characters in SQL strings\nfunction escapeSqlString(value: string): string {\n    return value.replace(/['\\\\]/g, '\\\\$&')\n}\n\n/**\n * Creates a HogQL expression for survey answer filters that handles both index-based and ID-based property keys\n * using OR logic between the alternative formats for each question.\n *\n * @param filters - The answer filters to convert to HogQL expressions\n * @param survey - The survey object (needed to access question IDs)\n * @returns A HogQL expression string that can be used in queries\n *\n * TODO: Consider leveraging the backend query builder instead of duplicating this logic in the frontend.\n * ClickHouse has powerful functions like match(), multiIf(), etc. that could be used more effectively.\n */\nexport function createAnswerFilterHogQLExpression(filters: EventPropertyFilter[], survey: Survey): string {\n    if (!filters || !filters.length) {\n        return ''\n    }\n\n    // Build the filter expression as a string\n    let filterExpression = ''\n    let hasValidFilter = false\n\n    // Process each filter\n    for (const filter of filters) {\n        // Skip filters with empty or undefined values\n        if (filter.value === undefined || filter.value === null || filter.value === '') {\n            continue\n        }\n\n        // Skip empty arrays\n        if (Array.isArray(filter.value) && filter.value.length === 0) {\n            continue\n        }\n\n        // Skip ILIKE filters with empty search patterns\n        if (\n            filter.operator === 'icontains' &&\n            (filter.value === '%' ||\n                filter.value === '%%' ||\n                (typeof filter.value === 'string' && filter.value.trim() === ''))\n        ) {\n            continue\n        }\n\n        // Extract question index from the filter key (assuming format like \"$survey_response_X\" or \"$survey_response\")\n        let questionIndex = 0\n        if (filter.key === '$survey_response') {\n            // If the key is exactly \"$survey_response\", it's for question index 0\n            questionIndex = 0\n        } else {\n            const questionIndexMatch = filter.key.match(/\\$survey_response_(\\d+)/)\n            if (!questionIndexMatch) {\n                continue // Skip if we can't determine the question index\n            }\n            questionIndex = parseInt(questionIndexMatch[1])\n        }\n\n        // Check if question index is valid before accessing\n        if (questionIndex >= survey.questions.length) {\n            continue // Skip if question index is out of bounds\n        }\n        const questionId = survey.questions[questionIndex]?.id\n\n        // Get both key formats\n        const { indexBasedKey, idBasedKey } = getResponseFieldWithId(questionIndex, questionId)\n\n        // Create the condition for this filter\n        let condition = ''\n        let escapedValue: string\n        let valueList: string\n\n        // Handle different operators\n        switch (filter.operator) {\n            case 'exact':\n                if (Array.isArray(filter.value)) {\n                    valueList = filter.value.map((v) => `'${escapeSqlString(String(v))}'`).join(', ')\n                    condition = `(properties['${indexBasedKey}'] IN (${valueList})`\n                    if (idBasedKey) {\n                        condition += ` OR properties['${idBasedKey}'] IN (${valueList})`\n                    }\n                } else {\n                    escapedValue = escapeSqlString(String(filter.value))\n                    condition = `(properties['${indexBasedKey}'] = '${escapedValue}'`\n                    if (idBasedKey) {\n                        condition += ` OR properties['${idBasedKey}'] = '${escapedValue}'`\n                    }\n                }\n                condition += ')'\n                break\n            case 'is_not':\n                if (Array.isArray(filter.value)) {\n                    valueList = filter.value.map((v) => `'${escapeSqlString(String(v))}'`).join(', ')\n                    condition = `(properties['${indexBasedKey}'] NOT IN (${valueList})`\n                    if (idBasedKey) {\n                        condition += ` OR properties['${idBasedKey}'] NOT IN (${valueList})`\n                    }\n                } else {\n                    escapedValue = escapeSqlString(String(filter.value))\n                    condition = `(properties['${indexBasedKey}'] != '${escapedValue}'`\n                    if (idBasedKey) {\n                        condition += ` OR properties['${idBasedKey}'] != '${escapedValue}'`\n                    }\n                }\n                condition += ')'\n                break\n            case 'icontains':\n                escapedValue = escapeSqlString(String(filter.value))\n                condition = `(properties['${indexBasedKey}'] ILIKE '%${escapedValue}%'`\n                if (idBasedKey) {\n                    condition += ` OR properties['${idBasedKey}'] ILIKE '%${escapedValue}%'`\n                }\n                condition += ')'\n                break\n            case 'regex':\n                escapedValue = escapeSqlString(String(filter.value))\n                condition = `(match(properties['${indexBasedKey}'], '${escapedValue}')`\n                if (idBasedKey) {\n                    condition += ` OR match(properties['${idBasedKey}'], '${escapedValue}')`\n                }\n                condition += ')'\n                break\n            case 'not_regex':\n                escapedValue = escapeSqlString(String(filter.value))\n                condition = `(NOT match(properties['${indexBasedKey}'], '${escapedValue}')`\n                if (idBasedKey) {\n                    condition += ` OR NOT match(properties['${idBasedKey}'], '${escapedValue}')`\n                }\n                condition += ')'\n                break\n            // Add more operators as needed\n            default:\n                continue // Skip unsupported operators\n        }\n\n        // Add this condition to the overall expression\n        if (condition) {\n            if (hasValidFilter) {\n                filterExpression += ' AND '\n            }\n            filterExpression += condition\n            hasValidFilter = true\n        }\n    }\n\n    return hasValidFilter ? `AND ${filterExpression}` : ''\n}\n","import { LemonCollapse, LemonModal, Link } from '@posthog/lemon-ui'\nimport { useValues } from 'kea'\nimport { CodeSnippet, Language } from 'lib/components/CodeSnippet'\nimport EarlyAccessFeatureImage from 'public/early-access-feature-demo.png'\nimport { preflightLogic } from 'scenes/PreflightCheck/preflightLogic'\nimport { urls } from 'scenes/urls'\n\nimport { FeatureFlagType, PipelineStage, Region } from '~/types'\n\ninterface InstructionsModalProps {\n    flag: FeatureFlagType['key']\n    visible: boolean\n    onClose: () => void\n}\n\nexport function InstructionsModal({ onClose, visible, flag }: InstructionsModalProps): JSX.Element {\n    const { preflight } = useValues(preflightLogic)\n\n    const getCloudPanels = (): JSX.Element => (\n        <LemonCollapse\n            className=\"mt-2 bg-surface-primary\"\n            defaultActiveKey=\"1\"\n            panels={[\n                {\n                    key: '1',\n                    header: 'Option 1: Widget Site App',\n                    content: (\n                        <div>\n                            Give your users a{' '}\n                            <Link\n                                to={urls.pipelineNodeNew(\n                                    PipelineStage.SiteApp,\n                                    preflight?.region === Region.EU ? 332 : 574\n                                )}\n                            >\n                                prebuilt widget\n                            </Link>{' '}\n                            to opt-in to features\n                            <img className=\"max-h-full max-w-full mt-2.5\" src={EarlyAccessFeatureImage} />\n                        </div>\n                    ),\n                },\n                {\n                    key: '2',\n                    header: 'Option 2: Custom implementation',\n                    content: (\n                        <div>\n                            <b>Opt user in</b>\n                            <div>\n                                <FeatureEnrollInstructions flag={flag} />\n                            </div>\n\n                            <b>Opt user out</b>\n                            <div>\n                                <FeatureUnenrollInstructions flag={flag} />\n                            </div>\n\n                            <b>Retrieve Previews</b>\n                            <div>\n                                <RetrievePreviewsInstructions />\n                            </div>\n                        </div>\n                    ),\n                },\n            ]}\n        />\n    )\n\n    const getSelfHostedPanels = (): JSX.Element => (\n        <div>\n            <b>Opt user in</b>\n            <div>\n                <FeatureEnrollInstructions flag={flag} />\n            </div>\n\n            <b>Opt user out</b>\n            <div>\n                <FeatureUnenrollInstructions flag={flag} />\n            </div>\n\n            <b>Retrieve Previews</b>\n            <div>\n                <RetrievePreviewsInstructions />\n            </div>\n        </div>\n    )\n\n    const panels: JSX.Element = preflight?.cloud ? getCloudPanels() : getSelfHostedPanels()\n\n    return (\n        <LemonModal title=\"How to implement opt-in feature flags\" isOpen={visible} onClose={onClose} width={640}>\n            <div>\n                <div className=\"mb-2\">\n                    Implement manual release condition toggles to give your users the ability choose which features they\n                    want to try\n                </div>\n                {panels}\n            </div>\n        </LemonModal>\n    )\n}\n\nfunction FeatureEnrollInstructions({ flag }: { flag: string }): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.updateEarlyAccessFeatureEnrollment(\"${flag}\", true)\n`}\n        </CodeSnippet>\n    )\n}\n\nfunction FeatureUnenrollInstructions({ flag }: { flag: string }): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.updateEarlyAccessFeatureEnrollment(\"${flag}\", false)\n`}\n        </CodeSnippet>\n    )\n}\n\nfunction RetrievePreviewsInstructions(): JSX.Element {\n    return (\n        <CodeSnippet language={Language.JavaScript} wrap>\n            {`posthog.getEarlyAccessFeatures((previewItemData) => {\n    // do something with early access feature\n})\n`}\n        </CodeSnippet>\n    )\n}\n"],"names":[],"sourceRoot":""}