{"version":3,"file":"65048.d1eefeb0.iframe.bundle.js","mappings":";AA0RA;AACA;AACA","sources":["webpack://@posthog/storybook/../../frontend/src/scenes/data-model/NodeCanvas.tsx"],"sourcesContent":["import { clsx } from 'clsx'\nimport { useEffect, useRef, useState } from 'react'\n\nimport { Edge, Node, NodePosition, NodePositionWithBounds, NodeWithDepth } from './types'\n\nconst VERTICAL_SPACING = 300\nconst HORIZONTAL_SPACING = 400\n\n// Core graph layout calculation functions\nconst assignDepths = (nodes: Node[]): NodeWithDepth[] => {\n    const nodeMap: { [id: string]: NodeWithDepth } = {}\n\n    nodes.forEach((node) => {\n        nodeMap[node.nodeId] = { ...node, depth: -1 }\n    })\n\n    const assignDepthRecursive = (nodeId: string, currentDepth: number): void => {\n        const node = nodeMap[nodeId]\n        if (!node) {\n            return\n        }\n        node.depth = currentDepth\n\n        node.leaf.forEach((leafId) => {\n            if (nodeMap[leafId]) {\n                assignDepthRecursive(leafId, currentDepth + 1)\n            }\n        })\n    }\n\n    nodes.forEach((node) => {\n        if (nodeMap[node.nodeId].depth === -1) {\n            assignDepthRecursive(node.nodeId, 0)\n        }\n    })\n\n    return Object.values(nodeMap)\n}\n\nconst calculateNodePositions = (nodesWithDepth: NodeWithDepth[]): NodePosition[] => {\n    const padding = 50\n    nodesWithDepth.sort((a, b) => a.depth - b.depth)\n\n    const nodePositions: NodePosition[] = []\n    const visited: string[] = []\n\n    const dfs = (nodeId: string, row: number = 0): number => {\n        if (visited.includes(nodeId)) {\n            return row\n        }\n        visited.push(nodeId)\n\n        const node = nodesWithDepth.find((n) => n.nodeId === nodeId)\n        if (!node) {\n            return row\n        }\n\n        const nodePosition = {\n            ...node,\n            position: {\n                x: padding + node.depth * HORIZONTAL_SPACING,\n                y: padding + row * VERTICAL_SPACING,\n            },\n        }\n\n        nodePositions.push(nodePosition)\n\n        let maxRow = row\n        node.leaf\n            .filter((leafId) => !leafId.includes('_joined'))\n            .forEach((leafId, index) => {\n                dfs(leafId, row + index)\n                maxRow = Math.max(maxRow, row + index)\n            })\n\n        return maxRow\n    }\n\n    let maxRow = 0\n    nodesWithDepth.forEach((node) => {\n        if (node.depth === 0) {\n            maxRow = dfs(node.nodeId, maxRow) + 1\n        }\n    })\n\n    return nodePositions\n}\n\nconst calculateBound = (node: NodePosition, ref: HTMLDivElement | null): NodePositionWithBounds => {\n    if (!ref) {\n        return {\n            ...node,\n            left: null,\n            right: null,\n        }\n    }\n\n    const { x, y } = node.position\n    const { width, height } = ref.getBoundingClientRect()\n    return {\n        ...node,\n        left: { x, y: y + height / 2 },\n        right: { x: x + width, y: y + height / 2 },\n    }\n}\n\nconst calculateEdgesFromTo = (from: NodePositionWithBounds, to: NodePositionWithBounds): Edge[] => {\n    if (!from.right || !to.left) {\n        return []\n    }\n\n    const edges = []\n    edges.push({\n        from: from.right,\n        to: to.left,\n    })\n\n    return edges\n}\n\nconst calculateEdges = (nodeRefs: (HTMLDivElement | null)[], nodes: NodePosition[]): Edge[] => {\n    const nodes_map = nodes.reduce((acc: Record<string, NodePosition>, node) => {\n        acc[node.nodeId] = node\n        return acc\n    }, {})\n\n    const dfs = (nodeId: string, visited: Set<string> = new Set()): Edge[] => {\n        if (visited.has(nodeId)) {\n            return []\n        }\n        visited.add(nodeId)\n\n        const node = nodes_map[nodeId]\n        if (!node) {\n            return []\n        }\n\n        const nodeRef = nodeRefs.find((ref) => ref?.id === nodeId)\n        if (!nodeRef) {\n            return []\n        }\n\n        const edges: Edge[] = []\n        const fromWithBounds = calculateBound(node, nodeRef)\n\n        for (const leafId of node.leaf) {\n            const toNode = nodes_map[leafId]\n            const toRef = nodeRefs.find((ref) => ref?.id === leafId)\n            if (toNode && toRef) {\n                const toWithBounds = calculateBound(toNode, toRef)\n                edges.push(...calculateEdgesFromTo(fromWithBounds, toWithBounds))\n            }\n\n            edges.push(...dfs(leafId, visited))\n        }\n\n        return edges\n    }\n\n    const edges: Edge[] = []\n    const visited = new Set<string>()\n\n    for (const node of nodes) {\n        if (!visited.has(node.nodeId)) {\n            edges.push(...dfs(node.nodeId, visited))\n        }\n    }\n\n    return edges\n}\n\ninterface NodeCanvasProps<T extends Node> {\n    nodes: T[]\n    renderNode: (node: T & NodePosition, ref: (el: HTMLDivElement | null) => void) => JSX.Element\n}\n\nexport function NodeCanvas<T extends Node>({ nodes, renderNode }: NodeCanvasProps<T>): JSX.Element {\n    const canvasRef = useRef<HTMLCanvasElement | null>(null)\n    const [isDragging, setIsDragging] = useState(false)\n    const [offset, setOffset] = useState({ x: 0, y: 0 })\n    const [dragStart, setDragStart] = useState({ x: 0, y: 0 })\n    const nodeRefs = useRef<(HTMLDivElement | null)[]>(Array(nodes.length).fill(null))\n    const [nodePositions, setNodePositions] = useState<NodePosition[]>([])\n    const [edges, setEdges] = useState<Edge[]>([])\n\n    useEffect(() => {\n        const nodesWithDepth = assignDepths(nodes)\n        const positions = calculateNodePositions(nodesWithDepth)\n        setNodePositions(positions)\n    }, [nodes, offset])\n\n    useEffect(() => {\n        const allNodes = [...nodePositions]\n        const calculatedEdges = calculateEdges([...nodeRefs.current], allNodes)\n        setEdges(calculatedEdges)\n    }, [nodePositions])\n\n    const drawGrid = (ctx: CanvasRenderingContext2D, canvasWidth: number, canvasHeight: number): void => {\n        ctx.fillStyle = '#000000'\n        ctx.imageSmoothingEnabled = true\n        const dotSize = 0.5\n        const spacing = 10\n\n        for (let x = offset.x % spacing; x < canvasWidth; x += spacing) {\n            for (let y = offset.y % spacing; y < canvasHeight; y += spacing) {\n                ctx.fillRect(x, y, dotSize, dotSize)\n            }\n        }\n    }\n\n    useEffect(() => {\n        const canvas = canvasRef.current\n        if (!canvas) {\n            return\n        }\n\n        const ctx = canvas.getContext('2d')\n        if (!ctx) {\n            return\n        }\n\n        const { width, height } = canvas.getBoundingClientRect()\n        canvas.width = width\n        canvas.height = height\n        drawGrid(ctx, width, height)\n\n        const handleResize = (): void => {\n            if (canvas) {\n                const { width, height } = canvas.getBoundingClientRect()\n                canvas.width = width\n                canvas.height = height\n                const ctx = canvas.getContext('2d')\n                if (ctx) {\n                    drawGrid(ctx, width, height)\n                }\n            }\n        }\n\n        window.addEventListener('resize', handleResize)\n        return () => window.removeEventListener('resize', handleResize)\n    }, [offset, nodePositions])\n\n    const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>): void => {\n        setIsDragging(true)\n        setDragStart({ x: e.clientX - offset.x, y: e.clientY - offset.y })\n    }\n\n    const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>): void => {\n        if (!isDragging) {\n            return\n        }\n        const newOffset = {\n            x: e.clientX - dragStart.x,\n            y: e.clientY - dragStart.y,\n        }\n        setOffset(newOffset)\n    }\n\n    const handleMouseUp = (): void => {\n        setIsDragging(false)\n    }\n\n    return (\n        <div className=\"w-full h-full relative\">\n            <canvas\n                ref={canvasRef}\n                onMouseDown={handleMouseDown}\n                onMouseMove={handleMouseMove}\n                onMouseUp={handleMouseUp}\n                onMouseLeave={handleMouseUp}\n                className={clsx('w-full h-full absolute inset-0', isDragging ? 'cursor-grabbing' : 'cursor-grab')}\n            />\n            <svg className=\"absolute inset-0 w-full h-full pointer-events-none\">\n                {edges.map((edge, index) => {\n                    const controlPoint1X = edge.from.x + offset.x + (edge.to.x - edge.from.x) / 3\n                    const controlPoint1Y = edge.from.y + offset.y\n                    const controlPoint2X = edge.to.x + offset.x - (edge.to.x - edge.from.x) / 3\n                    const controlPoint2Y = edge.to.y + offset.y\n                    return (\n                        <path\n                            key={index}\n                            d={`M ${edge.from.x + offset.x} ${edge.from.y + offset.y} \n                               C ${controlPoint1X} ${controlPoint1Y}, \n                                 ${controlPoint2X} ${controlPoint2Y}, \n                                 ${edge.to.x + offset.x} ${edge.to.y + offset.y}`}\n                            stroke=\"var(--text-3000)\"\n                            strokeWidth=\"2\"\n                            fill=\"none\"\n                        />\n                    )\n                })}\n            </svg>\n            {nodePositions.map((nodePosition, idx) => (\n                <div\n                    key={nodePosition.nodeId}\n                    className=\"absolute\"\n                    // eslint-disable-next-line react/forbid-dom-props\n                    style={{\n                        left: `${nodePosition.position.x + offset.x}px`,\n                        top: `${nodePosition.position.y + offset.y}px`,\n                    }}\n                >\n                    {renderNode(nodePosition as T & NodePosition, (el) => {\n                        nodeRefs.current[idx] = el\n                        nodeRefs.current[idx]?.setAttribute('id', nodePosition.nodeId)\n                    })}\n                </div>\n            ))}\n        </div>\n    )\n}\n"],"names":[],"sourceRoot":""}