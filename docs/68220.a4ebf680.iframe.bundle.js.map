{"version":3,"file":"68220.a4ebf680.iframe.bundle.js","mappings":";AAoFA;AAAA;;;;AChFA","sources":["webpack://posthog/./frontend/src/scenes/llm-observability/utils.ts","webpack://posthog/./node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js"],"sourcesContent":["import { LLMGeneration, LLMTrace } from '~/queries/schema'\n\nexport function formatLLMUsage(trace: LLMTrace | LLMGeneration): string | null {\n    if (typeof trace.inputTokens === 'number') {\n        return `${trace.inputTokens} → ${trace.outputTokens || 0} (∑ ${trace.inputTokens + (trace.outputTokens || 0)})`\n    }\n\n    return null\n}\n\nexport function formatLLMLatency(latency: number): string {\n    return `${Math.round(latency * 100) / 100} s`\n}\n\nconst usdFormatter = new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD',\n    maximumFractionDigits: 4,\n})\n\nexport function formatLLMCost(cost: number): string {\n    return usdFormatter.format(cost)\n}\n\nexport interface RoleBasedMessage {\n    role: string\n    content: string\n    additional_kwargs?: any\n    tool_calls?: any\n}\n\nexport function isRoleBasedMessage(input: any): input is RoleBasedMessage {\n    return (\n        typeof input === 'object' &&\n        'role' in input &&\n        'content' in input &&\n        typeof input.role === 'string' &&\n        typeof input.content === 'string'\n    )\n}\n\nexport interface ChoicesOutput {\n    choices: RoleBasedMessage[]\n}\n\nexport function isChoicesOutput(input: any): input is ChoicesOutput {\n    return typeof input === 'object' && 'choices' in input && Array.isArray(input.choices)\n}\n\nexport interface ToolCall {\n    type: string\n    id?: string\n    function: {\n        name: string\n        arguments: string\n    }\n}\n\nexport function isToolCall(input: any): input is ToolCall {\n    return typeof input === 'object' && 'type' in input && 'function' in input && input.type === 'function'\n}\n\nexport type ToolCalls = ToolCall[]\n\nexport function isToolCallsArray(input: any): input is ToolCalls {\n    return Array.isArray(input) && input.every(isToolCall)\n}\n\nexport function formatToolCalls(toolCalls: ToolCalls): string {\n    const toolsWithParsedArguments = toolCalls.map((toolCall) => ({\n        ...toolCall,\n        function: {\n            ...toolCall.function,\n            arguments:\n                typeof toolCall.function.arguments === 'string'\n                    ? JSON.parse(toolCall.function.arguments)\n                    : toolCall.function.arguments,\n        },\n    }))\n\n    return JSON.stringify(toolsWithParsedArguments, null, 2)\n}\n\nexport function formatAsMarkdownJSONBlock(output: string): string {\n    return `\\`\\`\\`json\\n${output}\\n\\`\\`\\``\n}\n","/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (arg) {\n\t\t\t\tclasses = appendClass(classes, parseValue(arg));\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction parseValue (arg) {\n\t\tif (typeof arg === 'string' || typeof arg === 'number') {\n\t\t\treturn arg;\n\t\t}\n\n\t\tif (typeof arg !== 'object') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (Array.isArray(arg)) {\n\t\t\treturn classNames.apply(null, arg);\n\t\t}\n\n\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\treturn arg.toString();\n\t\t}\n\n\t\tvar classes = '';\n\n\t\tfor (var key in arg) {\n\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\tclasses = appendClass(classes, key);\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction appendClass (value, newClass) {\n\t\tif (!newClass) {\n\t\t\treturn value;\n\t\t}\n\t\n\t\tif (value) {\n\t\t\treturn value + ' ' + newClass;\n\t\t}\n\t\n\t\treturn value + newClass;\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n"],"names":[],"sourceRoot":""}