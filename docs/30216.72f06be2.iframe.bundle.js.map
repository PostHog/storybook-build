{"version":3,"file":"30216.72f06be2.iframe.bundle.js","mappings":";AAsVA;AACA;AACA","sources":["webpack://posthog/./frontend/src/scenes/data-model/NodeCanvasWithTable.tsx"],"sourcesContent":["import clsx from 'clsx'\nimport { useEffect, useRef, useState } from 'react'\n\nimport GenericNode from './Node'\nimport { FixedField, JoinedField, TableFields } from './TableFields'\nimport { Edge, Node, NodePosition, NodePositionWithBounds, NodeWithDepth, Position } from './types'\n\nconst VERTICAL_SPACING = 150\nconst HORIZONTAL_SPACING = 250\n\n// TODO: Refactor this to be done in the backend\nconst assignDepths = (nodes: Node[]): NodeWithDepth[] => {\n    const nodeMap: { [id: string]: NodeWithDepth } = {}\n\n    // Initialize all nodes with depth -1\n    nodes.forEach((node) => {\n        nodeMap[node.nodeId] = { ...node, depth: -1 }\n    })\n\n    const assignDepthRecursive = (nodeId: string, currentDepth: number): void => {\n        const node = nodeMap[nodeId]\n        if (!node) {\n            return\n        } // Skip if node doesn't exist or already processed\n\n        node.depth = currentDepth\n\n        // Process leaf nodes\n        node.leaf.forEach((leafId) => {\n            if (nodeMap[leafId]) {\n                assignDepthRecursive(leafId, currentDepth + 1)\n            }\n        })\n    }\n\n    // Start assigning depths from each unprocessed node\n    nodes.forEach((node) => {\n        if (nodeMap[node.nodeId].depth === -1) {\n            assignDepthRecursive(node.nodeId, 0)\n        }\n    })\n\n    return Object.values(nodeMap)\n}\n\nconst calculateNodePositions = (nodesWithDepth: NodeWithDepth[]): NodePosition[] => {\n    const padding = 50\n    // Order nodes by depth\n    nodesWithDepth.sort((a, b) => a.depth - b.depth)\n\n    const nodePositions: NodePosition[] = []\n    const visited: string[] = []\n\n    const dfs = (nodeId: string, row: number = 0): number => {\n        if (visited.includes(nodeId)) {\n            return row\n        }\n        visited.push(nodeId)\n\n        const node = nodesWithDepth.find((n) => n.nodeId === nodeId)\n        if (!node) {\n            return row\n        }\n\n        const nodePosition = {\n            ...node,\n            position: {\n                x: padding + node.depth * HORIZONTAL_SPACING,\n                y: padding + row * VERTICAL_SPACING,\n            },\n        }\n\n        nodePositions.push(nodePosition)\n\n        let maxRow = row\n        node.leaf\n            .filter((leafId) => !leafId.includes('_joined'))\n            .forEach((leafId, index) => {\n                dfs(leafId, row + index)\n                maxRow = Math.max(maxRow, row + index)\n            })\n\n        return maxRow\n    }\n\n    let maxRow = 0\n\n    nodesWithDepth.forEach((node) => {\n        if (node.depth === 0) {\n            maxRow = dfs(node.nodeId, maxRow) + 1\n        }\n    })\n\n    return nodePositions\n}\n\nconst calculateTablePosition = (nodePositions: NodePosition[]): Position => {\n    // Find the node with the maximum x position\n    const farthestNode = nodePositions.reduce((max, node) => (node.position.x > max.position.x ? node : max))\n\n    // Calculate the table position to be slightly to the right of the farthest node\n    const tablePosition: Position = {\n        x: farthestNode.position.x + 300, // Add some padding\n        y: 100, // Fixed y position for the table\n    }\n\n    return tablePosition\n}\n\nconst calculateEdges = (nodeRefs: (HTMLDivElement | null)[], nodes: NodePosition[]): Edge[] => {\n    const nodes_map = nodes.reduce((acc: Record<string, NodePosition>, node) => {\n        acc[node.nodeId] = node\n        return acc\n    }, {})\n\n    const dfs = (nodeId: string, visited: Set<string> = new Set(), depth: number = 0): Edge[] => {\n        if (visited.has(nodeId)) {\n            return []\n        }\n        visited.add(nodeId)\n\n        const node = nodes_map[nodeId]\n        if (!node) {\n            return []\n        }\n\n        const nodeRef = nodeRefs.find((ref) => ref?.id === nodeId)\n        if (!nodeRef) {\n            return []\n        }\n\n        const edges: Edge[] = []\n        const fromWithBounds = calculateBound(node, nodeRef)\n\n        for (let i = 0; i < node.leaf.length; i++) {\n            const leafId = node.leaf[i]\n            const toNode = nodes_map[leafId]\n            const toRef = nodeRefs.find((ref) => ref?.id === leafId)\n\n            if (toNode && toRef) {\n                const toWithBounds = calculateBound(toNode, toRef)\n                const newEdges = calculateEdgesFromTo(fromWithBounds, toWithBounds)\n                edges.push(...newEdges)\n            }\n\n            depth = i > 0 ? depth + 1 : depth\n            edges.push(...dfs(leafId, visited, depth))\n        }\n\n        return edges\n    }\n\n    const edges: Edge[] = []\n\n    const visited = new Set<string>()\n    for (const node of nodes) {\n        if (!visited.has(node.nodeId)) {\n            edges.push(...dfs(node.nodeId, visited))\n        }\n    }\n\n    return edges\n}\n\nconst calculateBound = (node: NodePosition, ref: HTMLDivElement | null): NodePositionWithBounds => {\n    if (!ref) {\n        return {\n            ...node,\n            left: null,\n            right: null,\n        }\n    }\n\n    const { x, y } = node.position\n    const { width, height } = ref.getBoundingClientRect()\n    return {\n        ...node,\n        left: { x, y: y + height / 2 },\n        right: { x: x + width, y: y + height / 2 },\n    }\n}\n\nconst calculateEdgesFromTo = (from: NodePositionWithBounds, to: NodePositionWithBounds): Edge[] => {\n    if (!from.right || !to.left) {\n        return []\n    }\n\n    const edges = []\n    edges.push({\n        from: from.right,\n        to: to.left,\n    })\n\n    return edges\n}\n\ninterface ScrollableDraggableCanvasProps {\n    nodes: Node[]\n    fixedFields: FixedField[]\n    joinedFields: JoinedField[]\n    tableName: string\n}\n\nconst NodeCanvasWithTable = ({\n    nodes,\n    fixedFields,\n    joinedFields,\n    tableName,\n}: ScrollableDraggableCanvasProps): JSX.Element => {\n    const canvasRef = useRef<HTMLCanvasElement | null>(null)\n    const [isDragging, setIsDragging] = useState(false)\n    const [offset, setOffset] = useState({ x: 0, y: 0 })\n    const [dragStart, setDragStart] = useState({ x: 0, y: 0 })\n    const rowsRefs = useRef<(HTMLDivElement | null)[]>(Array(joinedFields.length).fill(null))\n    const nodeRefs = useRef<(HTMLDivElement | null)[]>(Array(nodes.length).fill(null))\n    const tableNodeRef = useRef<HTMLDivElement | null>(null)\n    const [nodePositions, setNodePositions] = useState<NodePosition[]>([])\n    const [tablePosition, setTablePosition] = useState<Position>({ x: 0, y: 0 })\n    const [edges, setEdges] = useState<Edge[]>([])\n\n    useEffect(() => {\n        const nodesWithDepth = assignDepths(nodes)\n        const nodePositions = calculateNodePositions(nodesWithDepth)\n        setNodePositions(nodePositions)\n        const tablePosition = calculateTablePosition(nodePositions)\n        setTablePosition(tablePosition)\n    }, [nodes, fixedFields, joinedFields])\n\n    useEffect(() => {\n        const allNodes = [...nodePositions]\n        // calculated table row positions\n        rowsRefs.current.forEach((ref) => {\n            const rect = ref?.getBoundingClientRect()\n            const nodeRect = tableNodeRef.current?.getBoundingClientRect()\n\n            if (!rect) {\n                return\n            }\n\n            if (nodeRect && ref) {\n                allNodes.push({\n                    nodeId: ref.id,\n                    name: 'Table',\n                    position: { x: tablePosition.x, y: tablePosition.y + (rect.y - nodeRect.y) },\n                    leaf: [],\n                    depth: -1,\n                })\n            }\n        })\n\n        const calculatedEdges = calculateEdges([...nodeRefs.current, ...rowsRefs.current], allNodes)\n        setEdges(calculatedEdges)\n    }, [nodePositions, tablePosition])\n\n    const drawGrid = (ctx: CanvasRenderingContext2D, canvasWidth: number, canvasHeight: number): void => {\n        ctx.fillStyle = '#000000'\n        ctx.imageSmoothingEnabled = true\n        const dotSize = 0.5\n        const spacing = 10\n\n        for (let x = offset.x % spacing; x < canvasWidth; x += spacing) {\n            for (let y = offset.y % spacing; y < canvasHeight; y += spacing) {\n                ctx.fillRect(x, y, dotSize, dotSize)\n            }\n        }\n    }\n\n    useEffect(() => {\n        const canvas = canvasRef.current\n\n        if (canvas) {\n            const ctx = canvas.getContext('2d')\n            if (!ctx) {\n                return\n            }\n            const { width, height } = canvas.getBoundingClientRect()\n\n            canvas.width = width\n            canvas.height = height\n\n            drawGrid(ctx, width, height)\n        }\n\n        const handleResize = (): void => {\n            if (canvas) {\n                const { width, height } = canvas.getBoundingClientRect()\n                canvas.width = width\n                canvas.height = height\n                const ctx = canvas.getContext('2d')\n                if (ctx) {\n                    drawGrid(ctx, width, height)\n                }\n            }\n        }\n\n        window.addEventListener('resize', handleResize)\n\n        return () => {\n            window.removeEventListener('resize', handleResize)\n        }\n    }, [offset, nodePositions])\n\n    const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>): void => {\n        setIsDragging(true)\n        setDragStart({ x: e.clientX - offset.x, y: e.clientY - offset.y })\n    }\n\n    const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>): void => {\n        if (!isDragging) {\n            return\n        }\n        const newOffset = {\n            x: e.clientX - dragStart.x,\n            y: e.clientY - dragStart.y,\n        }\n        setOffset(newOffset)\n    }\n\n    const handleMouseUp = (): void => {\n        setIsDragging(false)\n    }\n\n    return (\n        <div className=\"w-full h-[100vh]\">\n            <canvas\n                ref={canvasRef}\n                onMouseDown={handleMouseDown}\n                onMouseMove={handleMouseMove}\n                onMouseUp={handleMouseUp}\n                onMouseLeave={handleMouseUp}\n                className={clsx('w-full h-full', isDragging ? 'cursor-grabbing' : 'cursor-grab')}\n            />\n            <svg className=\"absolute top-0 left-0 w-full h-full pointer-events-none\">\n                {edges.map((edge, index) => {\n                    const controlPoint1X = edge.from.x + offset.x + (edge.to.x - edge.from.x) / 3\n                    const controlPoint1Y = edge.from.y + offset.y\n                    const controlPoint2X = edge.to.x + offset.x - (edge.to.x - edge.from.x) / 3\n                    const controlPoint2Y = edge.to.y + offset.y\n                    return (\n                        <path\n                            key={index}\n                            d={`M ${edge.from.x + offset.x} ${edge.from.y + offset.y} \n                               C ${controlPoint1X} ${controlPoint1Y}, \n                                 ${controlPoint2X} ${controlPoint2Y}, \n                                 ${edge.to.x + offset.x} ${edge.to.y + offset.y}`}\n                            stroke=\"var(--text-3000)\"\n                            strokeWidth=\"2\"\n                            fill=\"none\"\n                        />\n                    )\n                })}\n            </svg>\n            {nodePositions.map(({ name, position, nodeId }, idx) => {\n                return (\n                    <div\n                        key={nodeId}\n                        className=\"absolute\"\n                        // eslint-disable-next-line react/forbid-dom-props\n                        style={{\n                            left: `${position.x + offset.x}px`,\n                            top: `${position.y + offset.y}px`,\n                        }}\n                    >\n                        <GenericNode\n                            pref={(el: HTMLDivElement | null) => {\n                                nodeRefs.current[idx] = el\n                                nodeRefs.current[idx]?.setAttribute('id', nodeId)\n                            }}\n                        >\n                            {name}\n                        </GenericNode>\n                    </div>\n                )\n            })}\n\n            <div\n                className=\"absolute\"\n                // eslint-disable-next-line react/forbid-dom-props\n                style={{\n                    left: `${tablePosition.x + offset.x}px`,\n                    top: `${tablePosition.y + offset.y}px`,\n                }}\n            >\n                <TableFieldNode\n                    fixedFields={fixedFields}\n                    joinedFields={joinedFields}\n                    nodeRef={tableNodeRef}\n                    rowsRefs={rowsRefs}\n                    tableName={tableName}\n                />\n            </div>\n        </div>\n    )\n}\n\nexport default NodeCanvasWithTable\n\ninterface TableFieldNodeProps {\n    fixedFields: FixedField[]\n    joinedFields: JoinedField[]\n    rowsRefs: React.MutableRefObject<(HTMLDivElement | null)[]>\n    nodeRef: React.MutableRefObject<HTMLDivElement | null>\n    tableName: string\n}\n\nfunction TableFieldNode({ nodeRef, rowsRefs, fixedFields, joinedFields, tableName }: TableFieldNodeProps): JSX.Element {\n    return (\n        <div ref={nodeRef} className=\"w-[500px] bg-bg-3000 border border-black border-2 rounded-lg\">\n            <TableFields\n                fixedFields={fixedFields}\n                joinedFields={joinedFields}\n                rowsRefs={rowsRefs}\n                tableName={tableName}\n            />\n        </div>\n    )\n}\n"],"names":[],"sourceRoot":""}