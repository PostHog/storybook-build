{"version":3,"file":"main.2015f44c.iframe.bundle.js","mappings":";;;;AAyCA;;;;;AAKA;AACA;AAIA","sources":["webpack://posthog/./frontend/src/scenes/session-recordings/playlist/sessionRecordingsListPropertiesLogic.ts"],"sourcesContent":["import { connect, kea, path, reducers, actions, listeners } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { SessionRecordingPropertiesType, SessionRecordingType } from '~/types'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport type { sessionRecordingsListPropertiesLogicType } from './sessionRecordingsListPropertiesLogicType'\nimport { HogQLQuery, NodeKind } from '~/queries/schema'\nimport { dayjs } from 'lib/dayjs'\nimport { hogql } from '~/queries/utils'\n\n// This logic is used to fetch properties for a list of recordings\n// It is used in a global way as the cached values can be re-used\nexport const sessionRecordingsListPropertiesLogic = kea<sessionRecordingsListPropertiesLogicType>([\n    path(() => ['scenes', 'session-recordings', 'playlist', 'sessionRecordingsListPropertiesLogic']),\n    connect(() => ({\n        actions: [eventUsageLogic, ['reportRecordingsListPropertiesFetched']],\n    })),\n\n    actions({\n        loadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n        maybeLoadPropertiesForSessions: (sessions: SessionRecordingType[]) => ({ sessions }),\n    }),\n\n    loaders(({ actions }) => ({\n        recordingProperties: [\n            [] as SessionRecordingPropertiesType[],\n            {\n                loadPropertiesForSessions: async ({ sessions }, breakpoint) => {\n                    await breakpoint(100)\n\n                    const startTime = performance.now()\n                    const sessionIds = sessions.map((x) => x.id)\n\n                    const oldestTimestamp = sessions.map((x) => x.start_time).sort()[0]\n                    const newestTimestamp = sessions.map((x) => x.end_time).sort()[sessions.length - 1]\n\n                    const query: HogQLQuery = {\n                        kind: NodeKind.HogQLQuery,\n                        query: hogql`SELECT properties.$session_id as session_id, any(properties) as properties\n                                FROM events\n                                WHERE event IN ['$pageview', '$autocapture']\n                                AND session_id IN ${sessionIds}\n                                -- the timestamp range here is only to avoid querying too much of the events table\n                                -- we don't really care about the absolute value, \n                                -- but we do care about whether timezones have an odd impact\n                                -- so, we extend the range by a day on each side so that timezones don't cause issues\n                                AND timestamp >= ${dayjs(oldestTimestamp).subtract(1, 'day')}\n                                AND timestamp <= ${dayjs(newestTimestamp).add(1, 'day')}\n                                GROUP BY session_id`,\n                    }\n\n                    const response = await api.query(query)\n                    const loadTimeMs = performance.now() - startTime\n\n                    actions.reportRecordingsListPropertiesFetched(loadTimeMs)\n\n                    breakpoint()\n                    return (response.results || []).map(\n                        (x: any): SessionRecordingPropertiesType => ({\n                            id: x[0],\n                            properties: JSON.parse(x[1] || '{}'),\n                        })\n                    )\n                },\n            },\n        ],\n    })),\n\n    listeners(({ actions, values }) => ({\n        maybeLoadPropertiesForSessions: ({ sessions }) => {\n            const newSessions = sessions.filter((session) => !values.recordingPropertiesById[session.id])\n\n            if (newSessions.length > 0) {\n                actions.loadPropertiesForSessions(newSessions)\n            }\n        },\n    })),\n\n    reducers({\n        recordingPropertiesById: [\n            {} as Record<string, SessionRecordingPropertiesType['properties']>,\n            {\n                loadPropertiesForSessionsSuccess: (\n                    state,\n                    { recordingProperties }\n                ): Record<string, SessionRecordingPropertiesType['properties']> => {\n                    const newState = { ...state }\n                    recordingProperties.forEach((properties) => {\n                        newState[properties.id] = properties.properties\n                    })\n\n                    return newState\n                },\n            },\n        ],\n    }),\n])\n"],"names":[],"sourceRoot":""}